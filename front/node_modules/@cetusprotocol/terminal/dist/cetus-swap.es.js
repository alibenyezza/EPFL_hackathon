var zT = Object.defineProperty;
var WT = (e, t, r) => t in e ? zT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Pt = (e, t, r) => (WT(e, typeof t != "symbol" ? t + "" : t, r), r);
import * as R from "react";
import Fr, { useState as Mt, useEffect as Bt, useMemo as Ft, useCallback as Ii, useLayoutEffect as Vw, useRef as Ar, forwardRef as qT, createElement as Ph, PureComponent as HT, memo as GT } from "react";
import * as zw from "react-dom";
import Ww, { createPortal as KT } from "react-dom";
import { useSwitchAccount as YT, useAccounts as XT, useCurrentAccount as wd, useDisconnectWallet as JT, useCurrentWallet as qw, useWallets as ZT, ConnectModal as QT, useSignTransaction as eC, useSignAndExecuteTransaction as tC, useConnectWallet as rC } from "@mysten/dapp-kit";
function nC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Hw = { exports: {} }, Mr = Hw.exports = {}, Gi, Ki;
function Qp() {
  throw new Error("setTimeout has not been defined");
}
function e0() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Gi = setTimeout : Gi = Qp;
  } catch {
    Gi = Qp;
  }
  try {
    typeof clearTimeout == "function" ? Ki = clearTimeout : Ki = e0;
  } catch {
    Ki = e0;
  }
})();
function Gw(e) {
  if (Gi === setTimeout)
    return setTimeout(e, 0);
  if ((Gi === Qp || !Gi) && setTimeout)
    return Gi = setTimeout, setTimeout(e, 0);
  try {
    return Gi(e, 0);
  } catch {
    try {
      return Gi.call(null, e, 0);
    } catch {
      return Gi.call(this, e, 0);
    }
  }
}
function iC(e) {
  if (Ki === clearTimeout)
    return clearTimeout(e);
  if ((Ki === e0 || !Ki) && clearTimeout)
    return Ki = clearTimeout, clearTimeout(e);
  try {
    return Ki(e);
  } catch {
    try {
      return Ki.call(null, e);
    } catch {
      return Ki.call(this, e);
    }
  }
}
var js = [], sc = !1, ia, Gl = -1;
function sC() {
  !sc || !ia || (sc = !1, ia.length ? js = ia.concat(js) : Gl = -1, js.length && Kw());
}
function Kw() {
  if (!sc) {
    var e = Gw(sC);
    sc = !0;
    for (var t = js.length; t; ) {
      for (ia = js, js = []; ++Gl < t; )
        ia && ia[Gl].run();
      Gl = -1, t = js.length;
    }
    ia = null, sc = !1, iC(e);
  }
}
Mr.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  js.push(new Yw(e, t)), js.length === 1 && !sc && Gw(Kw);
};
function Yw(e, t) {
  this.fun = e, this.array = t;
}
Yw.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Mr.title = "browser";
Mr.browser = !0;
Mr.env = {};
Mr.argv = [];
Mr.version = "";
Mr.versions = {};
function Xs() {
}
Mr.on = Xs;
Mr.addListener = Xs;
Mr.once = Xs;
Mr.off = Xs;
Mr.removeListener = Xs;
Mr.removeAllListeners = Xs;
Mr.emit = Xs;
Mr.prependListener = Xs;
Mr.prependOnceListener = Xs;
Mr.listeners = function(e) {
  return [];
};
Mr.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Mr.cwd = function() {
  return "/";
};
Mr.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Mr.umask = function() {
  return 0;
};
var oC = Hw.exports;
const Rn = /* @__PURE__ */ nC(oC);
var Yr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Ec(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var t0 = { exports: {} }, zc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uy;
function aC() {
  if (uy)
    return zc;
  uy = 1;
  var e = Fr, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, c, u) {
    var l, f = {}, h = null, v = null;
    u !== void 0 && (h = "" + u), c.key !== void 0 && (h = "" + c.key), c.ref !== void 0 && (v = c.ref);
    for (l in c)
      n.call(c, l) && !s.hasOwnProperty(l) && (f[l] = c[l]);
    if (a && a.defaultProps)
      for (l in c = a.defaultProps, c)
        f[l] === void 0 && (f[l] = c[l]);
    return { $$typeof: t, type: a, key: h, ref: v, props: f, _owner: i.current };
  }
  return zc.Fragment = r, zc.jsx = o, zc.jsxs = o, zc;
}
var Wc = {}, ly;
function cC() {
  return ly || (ly = 1, Rn.env.NODE_ENV !== "production" && function() {
    var e = Fr, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), l = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), b = Symbol.iterator, y = "@@iterator";
    function S(Q) {
      if (Q === null || typeof Q != "object")
        return null;
      var Se = b && Q[b] || Q[y];
      return typeof Se == "function" ? Se : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function O(Q) {
      {
        for (var Se = arguments.length, Ie = new Array(Se > 1 ? Se - 1 : 0), Je = 1; Je < Se; Je++)
          Ie[Je - 1] = arguments[Je];
        I("error", Q, Ie);
      }
    }
    function I(Q, Se, Ie) {
      {
        var Je = C.ReactDebugCurrentFrame, lt = Je.getStackAddendum();
        lt !== "" && (Se += "%s", Ie = Ie.concat([lt]));
        var Ze = Ie.map(function(ot) {
          return String(ot);
        });
        Ze.unshift("Warning: " + Se), Function.prototype.apply.call(console[Q], console, Ze);
      }
    }
    var U = !1, D = !1, H = !1, z = !1, ne = !1, le;
    le = Symbol.for("react.module.reference");
    function te(Q) {
      return !!(typeof Q == "string" || typeof Q == "function" || Q === n || Q === s || ne || Q === i || Q === u || Q === l || z || Q === v || U || D || H || typeof Q == "object" && Q !== null && (Q.$$typeof === h || Q.$$typeof === f || Q.$$typeof === o || Q.$$typeof === a || Q.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Q.$$typeof === le || Q.getModuleId !== void 0));
    }
    function ce(Q, Se, Ie) {
      var Je = Q.displayName;
      if (Je)
        return Je;
      var lt = Se.displayName || Se.name || "";
      return lt !== "" ? Ie + "(" + lt + ")" : Ie;
    }
    function V(Q) {
      return Q.displayName || "Context";
    }
    function L(Q) {
      if (Q == null)
        return null;
      if (typeof Q.tag == "number" && O("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Q == "function")
        return Q.displayName || Q.name || null;
      if (typeof Q == "string")
        return Q;
      switch (Q) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case l:
          return "SuspenseList";
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case a:
            var Se = Q;
            return V(Se) + ".Consumer";
          case o:
            var Ie = Q;
            return V(Ie._context) + ".Provider";
          case c:
            return ce(Q, Q.render, "ForwardRef");
          case f:
            var Je = Q.displayName || null;
            return Je !== null ? Je : L(Q.type) || "Memo";
          case h: {
            var lt = Q, Ze = lt._payload, ot = lt._init;
            try {
              return L(ot(Ze));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var p = Object.assign, d = 0, m, x, E, A, j, k, g;
    function w() {
    }
    w.__reactDisabledLog = !0;
    function P() {
      {
        if (d === 0) {
          m = console.log, x = console.info, E = console.warn, A = console.error, j = console.group, k = console.groupCollapsed, g = console.groupEnd;
          var Q = {
            configurable: !0,
            enumerable: !0,
            value: w,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Q,
            log: Q,
            warn: Q,
            error: Q,
            group: Q,
            groupCollapsed: Q,
            groupEnd: Q
          });
        }
        d++;
      }
    }
    function ue() {
      {
        if (d--, d === 0) {
          var Q = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: p({}, Q, {
              value: m
            }),
            info: p({}, Q, {
              value: x
            }),
            warn: p({}, Q, {
              value: E
            }),
            error: p({}, Q, {
              value: A
            }),
            group: p({}, Q, {
              value: j
            }),
            groupCollapsed: p({}, Q, {
              value: k
            }),
            groupEnd: p({}, Q, {
              value: g
            })
          });
        }
        d < 0 && O("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ie = C.ReactCurrentDispatcher, fe;
    function ye(Q, Se, Ie) {
      {
        if (fe === void 0)
          try {
            throw Error();
          } catch (lt) {
            var Je = lt.stack.trim().match(/\n( *(at )?)/);
            fe = Je && Je[1] || "";
          }
        return `
` + fe + Q;
      }
    }
    var Te = !1, N;
    {
      var F = typeof WeakMap == "function" ? WeakMap : Map;
      N = new F();
    }
    function G(Q, Se) {
      if (!Q || Te)
        return "";
      {
        var Ie = N.get(Q);
        if (Ie !== void 0)
          return Ie;
      }
      var Je;
      Te = !0;
      var lt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ze;
      Ze = ie.current, ie.current = null, P();
      try {
        if (Se) {
          var ot = function() {
            throw Error();
          };
          if (Object.defineProperty(ot.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ot, []);
            } catch (ur) {
              Je = ur;
            }
            Reflect.construct(Q, [], ot);
          } else {
            try {
              ot.call();
            } catch (ur) {
              Je = ur;
            }
            Q.call(ot.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (ur) {
            Je = ur;
          }
          Q();
        }
      } catch (ur) {
        if (ur && Je && typeof ur.stack == "string") {
          for (var Et = ur.stack.split(`
`), cr = Je.stack.split(`
`), Kt = Et.length - 1, Jt = cr.length - 1; Kt >= 1 && Jt >= 0 && Et[Kt] !== cr[Jt]; )
            Jt--;
          for (; Kt >= 1 && Jt >= 0; Kt--, Jt--)
            if (Et[Kt] !== cr[Jt]) {
              if (Kt !== 1 || Jt !== 1)
                do
                  if (Kt--, Jt--, Jt < 0 || Et[Kt] !== cr[Jt]) {
                    var _r = `
` + Et[Kt].replace(" at new ", " at ");
                    return Q.displayName && _r.includes("<anonymous>") && (_r = _r.replace("<anonymous>", Q.displayName)), typeof Q == "function" && N.set(Q, _r), _r;
                  }
                while (Kt >= 1 && Jt >= 0);
              break;
            }
        }
      } finally {
        Te = !1, ie.current = Ze, ue(), Error.prepareStackTrace = lt;
      }
      var Jr = Q ? Q.displayName || Q.name : "", Sr = Jr ? ye(Jr) : "";
      return typeof Q == "function" && N.set(Q, Sr), Sr;
    }
    function ee(Q, Se, Ie) {
      return G(Q, !1);
    }
    function Z(Q) {
      var Se = Q.prototype;
      return !!(Se && Se.isReactComponent);
    }
    function q(Q, Se, Ie) {
      if (Q == null)
        return "";
      if (typeof Q == "function")
        return G(Q, Z(Q));
      if (typeof Q == "string")
        return ye(Q);
      switch (Q) {
        case u:
          return ye("Suspense");
        case l:
          return ye("SuspenseList");
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case c:
            return ee(Q.render);
          case f:
            return q(Q.type, Se, Ie);
          case h: {
            var Je = Q, lt = Je._payload, Ze = Je._init;
            try {
              return q(Ze(lt), Se, Ie);
            } catch {
            }
          }
        }
      return "";
    }
    var he = Object.prototype.hasOwnProperty, Y = {}, X = C.ReactDebugCurrentFrame;
    function B(Q) {
      if (Q) {
        var Se = Q._owner, Ie = q(Q.type, Q._source, Se ? Se.type : null);
        X.setExtraStackFrame(Ie);
      } else
        X.setExtraStackFrame(null);
    }
    function se(Q, Se, Ie, Je, lt) {
      {
        var Ze = Function.call.bind(he);
        for (var ot in Q)
          if (Ze(Q, ot)) {
            var Et = void 0;
            try {
              if (typeof Q[ot] != "function") {
                var cr = Error((Je || "React class") + ": " + Ie + " type `" + ot + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Q[ot] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw cr.name = "Invariant Violation", cr;
              }
              Et = Q[ot](Se, ot, Je, Ie, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Kt) {
              Et = Kt;
            }
            Et && !(Et instanceof Error) && (B(lt), O("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Je || "React class", Ie, ot, typeof Et), B(null)), Et instanceof Error && !(Et.message in Y) && (Y[Et.message] = !0, B(lt), O("Failed %s type: %s", Ie, Et.message), B(null));
          }
      }
    }
    var me = Array.isArray;
    function de(Q) {
      return me(Q);
    }
    function xe(Q) {
      {
        var Se = typeof Symbol == "function" && Symbol.toStringTag, Ie = Se && Q[Symbol.toStringTag] || Q.constructor.name || "Object";
        return Ie;
      }
    }
    function Oe(Q) {
      try {
        return Be(Q), !1;
      } catch {
        return !0;
      }
    }
    function Be(Q) {
      return "" + Q;
    }
    function Xe(Q) {
      if (Oe(Q))
        return O("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xe(Q)), Be(Q);
    }
    var Re = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, rt, Qe, Ot;
    Ot = {};
    function $t(Q) {
      if (he.call(Q, "ref")) {
        var Se = Object.getOwnPropertyDescriptor(Q, "ref").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return Q.ref !== void 0;
    }
    function Ge(Q) {
      if (he.call(Q, "key")) {
        var Se = Object.getOwnPropertyDescriptor(Q, "key").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return Q.key !== void 0;
    }
    function ht(Q, Se) {
      if (typeof Q.ref == "string" && Re.current && Se && Re.current.stateNode !== Se) {
        var Ie = L(Re.current.type);
        Ot[Ie] || (O('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(Re.current.type), Q.ref), Ot[Ie] = !0);
      }
    }
    function ct(Q, Se) {
      {
        var Ie = function() {
          rt || (rt = !0, O("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        Ie.isReactWarning = !0, Object.defineProperty(Q, "key", {
          get: Ie,
          configurable: !0
        });
      }
    }
    function et(Q, Se) {
      {
        var Ie = function() {
          Qe || (Qe = !0, O("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        Ie.isReactWarning = !0, Object.defineProperty(Q, "ref", {
          get: Ie,
          configurable: !0
        });
      }
    }
    var st = function(Q, Se, Ie, Je, lt, Ze, ot) {
      var Et = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: Q,
        key: Se,
        ref: Ie,
        props: ot,
        // Record the component responsible for creating this element.
        _owner: Ze
      };
      return Et._store = {}, Object.defineProperty(Et._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Et, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Je
      }), Object.defineProperty(Et, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lt
      }), Object.freeze && (Object.freeze(Et.props), Object.freeze(Et)), Et;
    };
    function yt(Q, Se, Ie, Je, lt) {
      {
        var Ze, ot = {}, Et = null, cr = null;
        Ie !== void 0 && (Xe(Ie), Et = "" + Ie), Ge(Se) && (Xe(Se.key), Et = "" + Se.key), $t(Se) && (cr = Se.ref, ht(Se, lt));
        for (Ze in Se)
          he.call(Se, Ze) && !He.hasOwnProperty(Ze) && (ot[Ze] = Se[Ze]);
        if (Q && Q.defaultProps) {
          var Kt = Q.defaultProps;
          for (Ze in Kt)
            ot[Ze] === void 0 && (ot[Ze] = Kt[Ze]);
        }
        if (Et || cr) {
          var Jt = typeof Q == "function" ? Q.displayName || Q.name || "Unknown" : Q;
          Et && ct(ot, Jt), cr && et(ot, Jt);
        }
        return st(Q, Et, cr, lt, Je, Re.current, ot);
      }
    }
    var it = C.ReactCurrentOwner, vt = C.ReactDebugCurrentFrame;
    function Dt(Q) {
      if (Q) {
        var Se = Q._owner, Ie = q(Q.type, Q._source, Se ? Se.type : null);
        vt.setExtraStackFrame(Ie);
      } else
        vt.setExtraStackFrame(null);
    }
    var pt;
    pt = !1;
    function It(Q) {
      return typeof Q == "object" && Q !== null && Q.$$typeof === t;
    }
    function Vt() {
      {
        if (it.current) {
          var Q = L(it.current.type);
          if (Q)
            return `

Check the render method of \`` + Q + "`.";
        }
        return "";
      }
    }
    function Ke(Q) {
      {
        if (Q !== void 0) {
          var Se = Q.fileName.replace(/^.*[\\\/]/, ""), Ie = Q.lineNumber;
          return `

Check your code at ` + Se + ":" + Ie + ".";
        }
        return "";
      }
    }
    var Rt = {};
    function zt(Q) {
      {
        var Se = Vt();
        if (!Se) {
          var Ie = typeof Q == "string" ? Q : Q.displayName || Q.name;
          Ie && (Se = `

Check the top-level render call using <` + Ie + ">.");
        }
        return Se;
      }
    }
    function $(Q, Se) {
      {
        if (!Q._store || Q._store.validated || Q.key != null)
          return;
        Q._store.validated = !0;
        var Ie = zt(Se);
        if (Rt[Ie])
          return;
        Rt[Ie] = !0;
        var Je = "";
        Q && Q._owner && Q._owner !== it.current && (Je = " It was passed a child from " + L(Q._owner.type) + "."), Dt(Q), O('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ie, Je), Dt(null);
      }
    }
    function T(Q, Se) {
      {
        if (typeof Q != "object")
          return;
        if (de(Q))
          for (var Ie = 0; Ie < Q.length; Ie++) {
            var Je = Q[Ie];
            It(Je) && $(Je, Se);
          }
        else if (It(Q))
          Q._store && (Q._store.validated = !0);
        else if (Q) {
          var lt = S(Q);
          if (typeof lt == "function" && lt !== Q.entries)
            for (var Ze = lt.call(Q), ot; !(ot = Ze.next()).done; )
              It(ot.value) && $(ot.value, Se);
        }
      }
    }
    function M(Q) {
      {
        var Se = Q.type;
        if (Se == null || typeof Se == "string")
          return;
        var Ie;
        if (typeof Se == "function")
          Ie = Se.propTypes;
        else if (typeof Se == "object" && (Se.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Se.$$typeof === f))
          Ie = Se.propTypes;
        else
          return;
        if (Ie) {
          var Je = L(Se);
          se(Ie, Q.props, "prop", Je, Q);
        } else if (Se.PropTypes !== void 0 && !pt) {
          pt = !0;
          var lt = L(Se);
          O("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", lt || "Unknown");
        }
        typeof Se.getDefaultProps == "function" && !Se.getDefaultProps.isReactClassApproved && O("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function K(Q) {
      {
        for (var Se = Object.keys(Q.props), Ie = 0; Ie < Se.length; Ie++) {
          var Je = Se[Ie];
          if (Je !== "children" && Je !== "key") {
            Dt(Q), O("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Je), Dt(null);
            break;
          }
        }
        Q.ref !== null && (Dt(Q), O("Invalid attribute `ref` supplied to `React.Fragment`."), Dt(null));
      }
    }
    var ae = {};
    function ve(Q, Se, Ie, Je, lt, Ze) {
      {
        var ot = te(Q);
        if (!ot) {
          var Et = "";
          (Q === void 0 || typeof Q == "object" && Q !== null && Object.keys(Q).length === 0) && (Et += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var cr = Ke(lt);
          cr ? Et += cr : Et += Vt();
          var Kt;
          Q === null ? Kt = "null" : de(Q) ? Kt = "array" : Q !== void 0 && Q.$$typeof === t ? (Kt = "<" + (L(Q.type) || "Unknown") + " />", Et = " Did you accidentally export a JSX literal instead of a component?") : Kt = typeof Q, O("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Kt, Et);
        }
        var Jt = yt(Q, Se, Ie, lt, Ze);
        if (Jt == null)
          return Jt;
        if (ot) {
          var _r = Se.children;
          if (_r !== void 0)
            if (Je)
              if (de(_r)) {
                for (var Jr = 0; Jr < _r.length; Jr++)
                  T(_r[Jr], Q);
                Object.freeze && Object.freeze(_r);
              } else
                O("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              T(_r, Q);
        }
        if (he.call(Se, "key")) {
          var Sr = L(Q), ur = Object.keys(Se).filter(function(Cn) {
            return Cn !== "key";
          }), Kr = ur.length > 0 ? "{key: someKey, " + ur.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ae[Sr + Kr]) {
            var li = ur.length > 0 ? "{" + ur.join(": ..., ") + ": ...}" : "{}";
            O(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Kr, Sr, li, Sr), ae[Sr + Kr] = !0;
          }
        }
        return Q === n ? K(Jt) : M(Jt), Jt;
      }
    }
    function we(Q, Se, Ie) {
      return ve(Q, Se, Ie, !0);
    }
    function nt(Q, Se, Ie) {
      return ve(Q, Se, Ie, !1);
    }
    var _t = nt, tt = we;
    Wc.Fragment = n, Wc.jsx = _t, Wc.jsxs = tt;
  }()), Wc;
}
Rn.env.NODE_ENV === "production" ? t0.exports = aC() : t0.exports = cC();
var _ = t0.exports;
window._iconfont_svg_string_4776227 = '<svg><symbol id="icon-icon_mev" viewBox="0 0 1024 1024"><path d="M651.1616 95.488c53.4016 56.4224 131.84 113.8176 235.2128 171.6736a38.4 38.4 0 0 1 19.456 29.9008c12.032 129.024-12.544 251.7504-73.6256 367.1552-60.2112 113.8176-158.976 226.4576-295.936 338.3296a38.4 38.4 0 0 1-48.5888 0c-131.072-107.1104-228.352-220.3648-291.6352-339.8656-64.1024-121.1904-90.2656-243.4048-77.824-365.8752a38.4 38.4 0 0 1 20.5312-30.2592c101.1712-52.224 181.0944-109.568 239.872-171.6224 104.96-110.9504 169.3696-108.4416 272.5376 0.512z m126.464 196.5056l-1.1776 0.8192a41.9328 41.9328 0 0 1-10.0352 3.84c-4.2496 1.024-5.4272 1.28-14.6944 3.328a122.368 122.368 0 0 0-16.896 4.4032c-43.8784 16.384-71.168 47.4112-83.0976 96.6656-2.304 9.6256-3.328 20.8384-3.6864 38.4l-0.2048 13.5168v15.872l0.0512 9.728v2.048l0.0512 3.4816c0.256 35.328 0.1536 51.2-1.024 71.424-4.5056 79.36-42.2912 140.3904-108.9536 178.4832-29.5424 16.896-61.9008 23.9616-99.328 23.9104h-8.704a9243.136 9243.136 0 0 0-29.2864-0.1536h-17.4592l-10.0352-0.0512H350.208c40.448 50.8416 88.3712 100.7104 143.7696 149.504l17.9712 15.5136 17.5104-14.8992c101.0176-88.064 176.0768-175.5136 225.28-262.144l9.5232-17.408c50.8928-96.2048 73.0624-197.2736 66.56-303.9744l-3.584-2.4064c-17.2544-9.9328-33.792-19.9168-49.664-29.9008z m-171.52 5.12h-1.1264c-15.1552 0.1024-30.0544 3.584-45.1072 10.5984-46.2848 21.504-77.056 71.3728-76.3904 128.0512 0.3072 25.7024 0.256 51.3536 0 87.6032l-0.1024 10.4448c-0.1024 14.4896-0.512 24.3712-1.7408 34.816-4.864 42.8032-19.6608 79.7696-43.6736 110.2848l-1.792 2.1504 1.3312 0.0512h1.3312c24.832 0 44.288-4.1984 61.0304-13.824 44.032-25.1904 67.3792-62.72 70.4-116.1216 1.024-18.0224 1.1264-32.768 0.8704-66.56V479.1296l-0.0512-5.2224v-21.504c0-5.12 0.0512-9.728 0.1536-14.4896 0.512-22.6816 1.8944-38.6048 5.8368-54.9376a225.0752 225.0752 0 0 1 35.6864-79.5136l4.7104-6.2464h-11.3664z m1.4848-136.2944l-12.2368-12.544c-73.728-77.9264-87.2448-78.4384-160.9728-0.5632C373.9136 211.6096 294.7072 269.824 196.9152 322.6624l-3.9424 2.048-0.768 17.5616c-2.4064 88.064 18.176 176.384 61.952 265.4208l9.7792 19.0464c9.2672 17.5104 19.3536 34.9184 30.2592 52.224l-0.8704 0.1536c2.4064-0.512 2.4064-0.512 6.144-0.9728 15.104-1.536 29.5936-6.8608 43.776-15.9744 36.4544-23.552 56.8832-56.576 62.1056-102.2464 0.8192-7.168 1.1264-14.848 1.2288-26.7264l0.1024-10.3424c0.256-35.84 0.3072-61.1328 0-86.2208-1.024-86.5792 46.8992-164.1984 120.7808-198.5536a183.552 183.552 0 0 1 77.312-17.7664h1.536l53.0432 0.256h16.0768a775.1168 775.1168 0 0 1-67.84-59.7504z"  ></path></symbol><symbol id="icon-icon_mode" viewBox="0 0 1024 1024"><path d="M854.8352 357.80266667v203.6736H921.6a38.4 38.4 0 0 1 33.7408 56.832l-2.9696 4.608-222.8736 298.1376c-22.1184 29.5424-69.1712 13.9264-69.1712-23.04v-185.0368h-75.6736c-37.7344-21.1968-40.0896-22.528-38.4-40.0384l0.3584-3.7376c1.7408-7.68 1.7408-7.68 2.9184-10.24l2.2016-4.2496 1.1776-1.8944 1.536-2.304 2.048-2.9696 10.9568-15.2576c9.5744-13.2608 24.064-33.1264 43.4176-59.5968 38.656-52.7872 96.8704-132.0448 174.592-237.6704 22.016-29.8496 69.376-14.336 69.376 22.784zM485.2736 93.86666667c97.792 0 190.6176 33.4848 265.0624 93.7984a38.4 38.4 0 1 1-48.3328 59.6992 344.4736 344.4736 0 1 0-216.6784 612.3008 38.4 38.4 0 1 1 0 76.8 421.2736 421.2736 0 0 1 0-842.5984z m292.7104 380.8768l-5.632 7.7312a73697.1776 73697.1776 0 0 0-106.496 145.152l-6.3488 8.5504h39.2192a38.4 38.4 0 0 1 38.0416 33.1776l0.3584 5.2224V782.50666667l107.776-144.2304h-28.4672a38.4 38.4 0 0 1-38.0416-33.1776l-0.3584-5.1712V474.74346667z m-422.912-144.0768l92.9792 92.8768A98.816 98.816 0 1 1 393.728 477.86666667L300.7488 384.98986667a38.4 38.4 0 1 1 54.272-54.272z"  ></path></symbol><symbol id="icon-icon_flash" viewBox="0 0 1024 1024"><path d="M776.448 0L192 579.456h222.016L242.048 1024 832 439.104H617.472L776.448 0z"  ></path></symbol><symbol id="icon-token_nor" viewBox="0 0 1024 1024"><path d="M512 0c282.784 0 512 229.216 512 512s-229.216 512-512 512S0 794.784 0 512 229.216 0 512 0z m0 64C264.608 64 64 264.544 64 512s200.608 448 448 448 448-200.544 448-448S759.392 64 512 64z m51.808 596.256v107.872H446.72v-107.84h117.088z m-26.304-414.72c98.816 4.736 152.16 48.416 160.096 131.296 3.136 47.808-22.944 91.328-78.24 130.56l-7.712 5.312c-44.672 29.696-64.576 58.56-59.776 86.688v18.784h-95.68v-25.792c-1.6-48.384 19.2-87.488 62.144-117.184 39.744-31.2 58.944-59.392 57.408-84.384-3.168-32.768-21.536-50.784-54.976-53.888-44.672 0-72.512 28.896-83.616 86.72l-107.584-23.424c19.168-106.176 88.416-157.76 207.936-154.656z"  ></path></symbol><symbol id="icon-icon_resrt" viewBox="0 0 1024 1024"><path d="M700.16 173.2608l150.5792 150.528a140.8 140.8 0 0 1 0 199.168l-250.0096 249.9072H844.8a38.4 38.4 0 0 1 0 76.8h-409.6a38.4 38.4 0 0 1-11.7248-1.792 246.528 246.528 0 0 1-174.9504-72.3968l-75.264-75.264a140.8 140.8 0 0 1 0-199.168l327.7824-327.7824a140.8 140.8 0 0 1 199.168 0z m-438.272 347.6992l-34.304 34.4064a64 64 0 0 0 0 90.5216l75.264 75.264a170.496 170.496 0 0 0 193.024 33.792l-233.984-233.984z m293.4784-293.376l-239.2064 239.104 241.152 241.152 239.104-239.2064a64 64 0 0 0 0-90.5216l-150.528-150.528a64 64 0 0 0-90.5216 0zM667.136 305.664l102.4 102.4a38.4 38.4 0 0 1-54.272 54.272l-102.4-102.4a38.4 38.4 0 1 1 54.272-54.272z"  ></path></symbol><symbol id="icon-icon_link" viewBox="0 0 1024 1024"><path d="M436.992 281.6a38.4 38.4 0 0 1 0 76.8 217.6 217.6 0 1 0 217.6 217.6 38.4 38.4 0 1 1 76.8 0 294.4 294.4 0 1 1-294.4-294.4z m385.28-102.4l3.8912 0.2048 0.6144 0.0512-4.5056-0.256a38.2464 38.2464 0 0 1 28.416 12.544l0.8704 1.024a38.5536 38.5536 0 0 1 2.0992 2.7136l-2.9696-3.7376a38.656 38.656 0 0 1 9.984 25.5488V473.6a38.4 38.4 0 1 1-76.8 0V304.4864l-399.616 364.1344a38.4 38.4 0 0 1-51.712-56.832L723.0464 256H566.272a38.4 38.4 0 0 1-38.0416-33.1776l-0.3584-5.2224a38.4 38.4 0 0 1 38.4-38.4h256z"  ></path></symbol><symbol id="icon-icon_disconnect" viewBox="0 0 1024 1024"><path d="M580.7104 694.6304a38.4 38.4 0 0 1 0 54.272l-60.3136 60.416a209.0496 209.0496 0 0 1-295.68-295.68l60.3648-60.3648a38.4 38.4 0 1 1 54.272 54.272l-60.3136 60.416a132.2496 132.2496 0 0 0 187.0336 187.0336l60.3648-60.3648a38.4 38.4 0 0 1 54.272 0z m-125.5424-113.664a38.4 38.4 0 0 1-0.7168 54.272L399.36 689.0496a38.4 38.4 0 0 1-53.6064-55.04l55.1424-53.7088a38.4 38.4 0 0 1 54.272 0.7168z m276.4288 83.456a38.4 38.4 0 1 1-54.3232 54.3744L315.2384 356.7104a38.4 38.4 0 0 1 54.272-54.272l362.0864 361.984z m90.4704-452.5056a209.0496 209.0496 0 0 1 0 295.68l-60.3136 60.3136a38.4 38.4 0 1 1-54.272-54.272l60.3136-60.3648A132.2496 132.2496 0 0 0 580.7104 266.24l-60.3136 60.3136a38.4 38.4 0 0 1-54.272-54.272l60.3136-60.3648a209.0496 209.0496 0 0 1 295.6288 0z m-122.368 119.04l3.584 3.7376a38.4 38.4 0 0 1-3.9424 54.1184l-63.1296 54.4768a38.4 38.4 0 0 1-50.176-58.1632l63.1296-54.4768a38.4 38.4 0 0 1 46.4384-2.816l4.096 3.1232z"  ></path></symbol><symbol id="icon-icon_del1" viewBox="0 0 1024 1024"><path d="M705.024 294.4a140.8 140.8 0 0 1 139.9808 156.0576l-39.1168 358.4a140.8 140.8 0 0 1-139.9808 125.5424H358.0928a140.8 140.8 0 0 1-139.9808-125.5424l-39.1168-358.4A140.8 140.8 0 0 1 318.976 294.4h386.048z m0 76.8H318.976a64 64 0 0 0-63.6416 70.9632l39.1168 358.4a64 64 0 0 0 63.6416 57.0368h307.8144a64 64 0 0 0 63.6416-57.0368l39.1168-358.4A64 64 0 0 0 705.024 371.2z m-102.5024 126.464a38.4 38.4 0 0 1 38.4 38.4v184.32a38.4 38.4 0 1 1-76.8 0v-184.32a38.4 38.4 0 0 1 38.4-38.4z m-184.32 0a38.4 38.4 0 0 1 38.4 38.4v184.32a38.4 38.4 0 1 1-76.8 0v-184.32a38.4 38.4 0 0 1 38.4-38.4z m276.1728-377.344a38.4 38.4 0 1 1 0 76.8H327.3728a38.4 38.4 0 1 1 0-76.8h367.0016z"  ></path></symbol><symbol id="icon-icon_copy" viewBox="0 0 1024 1024"><path d="M742.4 373.76a140.8 140.8 0 0 1 140.8 140.8v227.84a140.8 140.8 0 0 1-140.8 140.8h-227.84A140.8 140.8 0 0 1 373.76 742.4v-227.84a140.8 140.8 0 0 1 140.8-140.8h227.84z m0 76.8h-227.84c-35.328 0-64 28.672-64 64v227.84c0 35.328 28.672 64 64 64h227.84c35.328 0 64-28.672 64-64v-227.84c0-35.328-28.672-64-64-64z m-197.12-309.76A104.96 104.96 0 0 1 650.24 245.76v33.28a38.4 38.4 0 0 1-76.8 0V245.76a28.16 28.16 0 0 0-28.16-28.16H245.76a28.16 28.16 0 0 0-28.16 28.16v299.52c0 15.5648 12.5952 28.16 28.16 28.16h33.28a38.4 38.4 0 0 1 0 76.8H245.76a104.96 104.96 0 0 1-104.96-104.96V245.76A104.96 104.96 0 0 1 245.76 140.8h299.52z"  ></path></symbol><symbol id="icon-link2" viewBox="0 0 1024 1024"><path d="M642.7648 217.6a166.5024 166.5024 0 0 1 166.5024 166.5024v256.256a166.5024 166.5024 0 0 1-166.5024 166.5024H386.5088a92.16 92.16 0 0 1-64.9728-157.5936L506.88 465.2032H429.2096a38.4 38.4 0 0 1-38.0416-33.1776l-0.3584-5.2224a38.4 38.4 0 0 1 38.4-38.4h170.8544l1.4336 0.0512c0.8704 0 1.6896 0.1024 2.56 0.1536l-3.9936-0.2048a38.656 38.656 0 0 1 27.2384 11.3664l1.792 1.9456 1.536 1.8944-3.328-3.84a38.6048 38.6048 0 0 1 11.1616 27.0336v170.8544a38.4 38.4 0 0 1-76.8 0l-0.0512-78.592-185.9584 184.6784a15.36 15.36 0 0 0 7.3216 25.9072l3.584 0.4096h256.2048c49.5616 0 89.7024-40.1408 89.7024-89.7024V384.1024c0-49.5104-40.1408-89.7024-89.7024-89.7024H386.5088c-49.5616 0-89.7024 40.192-89.7024 89.7024V563.2a38.4 38.4 0 0 1-76.8 0V384.1024A166.5024 166.5024 0 0 1 386.5088 217.6h256.256z"  ></path></symbol><symbol id="icon-more" viewBox="0 0 1024 1024"><path d="M499.2 217.6m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path><path d="M499.2 524.8m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path><path d="M499.2 832m0-64a64 64 0 1 0 0 128 64 64 0 1 0 0-128Z"  ></path></symbol><symbol id="icon-docs" viewBox="0 0 1024 1024"><path d="M665.6 41.728c65.9456 0 121.2928 45.312 136.6016 106.496 5.0688-2.6624 10.8544-4.096 16.9984-4.096a140.8 140.8 0 0 1 140.8 140.8v563.2a140.8 140.8 0 0 1-140.8 140.8H358.4a140.8512 140.8512 0 0 1-135.4752-102.4H204.8a140.8 140.8 0 0 1-140.8-140.8v-563.2A140.8 140.8 0 0 1 204.8 41.728h460.8z m140.8 177.0496v526.9504a140.8 140.8 0 0 1-140.8 140.8l-358.4 0.1024c11.7248 15.5136 30.3104 25.4976 51.2 25.4976h460.8c35.328 0 64-28.672 64-64v-563.2c0-35.328-28.672-64-64-64a38.3488 38.3488 0 0 1-12.8-2.1504zM665.6 118.528H204.8c-35.328 0-64 28.672-64 64v563.2c0 35.328 28.672 64 64 64h460.8c35.328 0 64-28.672 64-64v-563.2c0-35.328-28.672-64-64-64z m-153.6 281.6a38.4 38.4 0 1 1 0 76.8H256a38.4 38.4 0 1 1 0-76.8h256z m102.4-153.6a38.4 38.4 0 1 1 0 76.8H256a38.4 38.4 0 1 1 0-76.8h358.4z"  ></path></symbol><symbol id="icon-link1" viewBox="0 0 1024 1024"><path d="M719.872 268.8l3.738 0.205 0.768 0.051-4.506-0.256a38.502 38.502 0 0 1 28.416 12.544l0.973 1.126a38.554 38.554 0 0 1 1.74 2.253l-2.713-3.379a38.605 38.605 0 0 1 9.984 25.549V563.2a38.4 38.4 0 1 1-76.8 0V394.086L281.856 758.221a38.4 38.4 0 0 1-51.712-56.832L620.646 345.6H463.872a38.4 38.4 0 0 1-38.042-33.178l-0.358-5.222a38.4 38.4 0 0 1 38.4-38.4h256z"  ></path></symbol><symbol id="icon-icon-kfckfc" viewBox="0 0 1024 1024"><path d="M53.504 102.912c-0.41 0.563 30.208 42.086 67.84 92.006L299.008 430.9 408.32 576l-7.014 7.885c-3.943 4.352-84.327 90.521-178.432 191.488C128.717 876.595 51.354 960 51.2 960.87c-0.358 0.922 16.077 1.69 39.731 1.536l40.243-0.204 13.21-14.49A217385.626 217385.626 0 0 0 440.32 629.914l4.71-5.479 37.837 50.33L610.048 843.93l89.6 118.63H836.71c114.023 0 136.858-0.358 136.141-2.458-0.563-1.484-35.328-48.025-77.312-103.782-41.984-55.603-90.01-119.398-106.65-141.568-16.793-22.17-66.15-88.064-110.028-146.074-43.879-58.163-79.821-106.598-79.821-107.366 0-1.331 231.782-251.187 310.58-334.746l22.527-23.808h-41.42l-41.217 0.154-48.179 51.814a48197.632 48197.632 0 0 1-144.23 154.88l-95.847 102.912L445.03 258.202 328.55 103.68l-137.062-0.922c-75.418-0.563-137.626-0.41-137.984 0.154z m324.762 166.4c44.8 59.7 113.97 151.5 153.65 204.288 39.732 52.531 127.796 169.677 195.892 259.994 68.045 90.47 124.365 165.376 125.286 166.707 1.178 1.69-12.288 2.253-61.235 2.253h-62.566L605.286 737.69c-286.208-379.802-430.592-571.7-432.332-574.516-1.127-1.69 11.724-2.252 61.081-2.252h62.567l81.664 108.39z"  ></path></symbol><symbol id="icon-icon_telegram" viewBox="0 0 1024 1024"><path d="M824.87808 503.6032c55.8592 0 100.096 12.544 133.4272 37.5296 34.2016 26.7264 55.9104 66.7136 64.2048 120.9344h-94.208c-5.8368-27.4944-17.5104-47.5136-34.2016-60.8768-17.5104-13.312-40.8576-19.968-69.2224-19.968-35.0208 0-62.5664 12.4928-82.5856 39.168-19.968 25.856-30.0032 62.5152-30.0032 109.2608 0 47.5136 9.216 85.0432 29.184 111.7184 18.3296 25.856 45.8752 39.2192 82.5856 39.2192 63.3856 0 98.4064-31.6928 105.8816-94.208H1024.19968c-9.984 58.368-32.512 101.7344-66.7136 130.048-33.3824 27.5456-78.3872 41.728-134.2976 41.728-66.7136 0-118.4256-21.7088-155.136-65.024-35.84-41.728-53.3504-95.9488-53.3504-162.6624 0-65.024 17.5104-118.4256 52.5312-159.2832 37.5296-45.056 90.112-67.584 157.6448-67.584z m75.7248-333.6704l-53.76 245.4528a353.792 353.792 0 0 0-12.6464-0.256c-164.096 0-316.3648 113.7664-357.0176 266.752L381.63968 771.9424c-11.6224 10.9056-20.7872 20.1216-41.5744 20.1216l14.1824-205.2608 385.1776-336.7424c16.896-14.5408-3.6352-21.6576-26.112-8.3968L237.76768 532.2752 32.35328 470.1696c-44.288-13.1584-44.544-42.7008 10.0352-64l800.3072-298.9568c36.5568-15.9744 71.8336 8.5504 57.856 62.72z"  ></path></symbol><symbol id="icon-icon_medium" viewBox="0 0 1024 1024"><path d="M576.819712 497.6128c-0.7168 169.6768-139.5712 294.7584-293.376 292.3008C127.795712 787.4048-0.357888 656.1792 0.000512 495.2064 0.358912 334.9504 130.611712 204.032 288.819712 204.8c159.9488 0.768 288.2048 131.1744 288 292.8128m27.904-1.536c0.9216-72.9088 12.3904-143.3088 50.1248-207.0528 7.168-12.1856 15.872-23.8592 25.6512-33.9968 44.4928-46.08 99.4816-44.0832 141.312 4.5056 28.8768 33.5872 45.8752 73.216 56.064 115.8656 24.576 102.5536 21.2992 203.5712-19.968 301.6704-11.9808 28.416-28.5184 54.2208-52.9408 73.728-36.2496 29.1328-76.8 29.3888-112.5376-0.3072-39.2704-32.6656-59.4944-77.5168-70.7584-125.696-9.8304-41.984-14.2848-85.248-21.0944-128l4.1472-0.7168M1024.000512 470.5792c-3.1744 93.952-4.9152 159.8976-22.1696 224.0512-3.0208 11.264-6.656 22.7328-12.4928 32.6656-3.8912 6.656-11.776 14.3872-18.3296 14.8992-5.3248 0.4096-14.08-8.192-16.6912-14.6944-7.5776-18.7392-14.848-38.0928-18.6368-57.9584-16.384-86.3744-18.4832-173.7216-10.496-261.0176 3.584-39.424 11.9296-78.4896 19.1488-117.5552 1.792-9.728 6.7584-19.2512 11.776-27.9552 9.728-16.4864 22.3744-16.896 30.9248 0 7.68 15.2576 15.0528 31.744 17.408 48.4864 8.8064 62.0544 15.4112 124.416 19.5584 159.0784"  ></path></symbol><symbol id="icon-icon_discord" viewBox="0 0 1024 1024"><path d="M831.8976 213.6064A748.032 748.032 0 0 0 641.7408 153.6c-8.192 14.848-17.7664 34.8672-24.3712 50.7904a694.8864 694.8864 0 0 0-210.688 0c-6.6048-15.872-16.384-35.8912-24.6272-50.7904a745.5744 745.5744 0 0 0-190.3104 60.16C71.424 396.4928 38.8096 574.6176 55.0912 750.2848a758.784 758.784 0 0 0 233.216 120.064c18.7904-26.0096 35.5328-53.6064 49.92-82.688a490.0864 490.0864 0 0 1-78.6432-38.4c6.656-4.9664 13.056-10.0864 19.3024-15.36 151.6544 71.2704 316.416 71.2704 466.2272 0 6.2976 5.2736 12.8 10.3936 19.3024 15.36a488.8576 488.8576 0 0 1-78.848 38.5024c14.4384 28.9792 31.1296 56.6784 49.9712 82.6368a757.2992 757.2992 0 0 0 233.3184-120.1152c19.1488-203.6224-32.6656-380.16-136.96-536.6784zM358.912 642.2528c-45.568 0-82.8416-42.7008-82.8416-94.72 0-51.968 36.5056-94.72 82.8416-94.72 46.336 0 83.6608 42.6496 82.8416 94.72 0.1024 52.0192-36.5056 94.72-82.8416 94.72z m306.176 0c-45.5168 0-82.8416-42.7008-82.8416-94.72 0-51.968 36.5056-94.72 82.8416-94.72 46.336 0 83.6608 42.6496 82.8416 94.72 0 52.0192-36.5056 94.72-82.8416 94.72z"  ></path></symbol><symbol id="icon-plorer" viewBox="0 0 1024 1024"><path d="M608 62.31l245.453 141.67a192 192 0 0 1 96 166.298v283.444a192 192 0 0 1-96 166.297L608 961.69a192 192 0 0 1-192 0L170.547 820.02a192 192 0 0 1-96-166.297V370.278a192 192 0 0 1 95.949-166.297L415.949 62.31a192 192 0 0 1 192 0z m-153.6 66.51L208.947 270.49a115.2 115.2 0 0 0-57.6 99.84v283.392a115.2 115.2 0 0 0 57.6 99.788L454.4 895.18a115.2 115.2 0 0 0 115.2 0l245.453-141.67a115.2 115.2 0 0 0 57.6-99.84V370.33a115.2 115.2 0 0 0-57.6-99.79L569.6 128.87a115.2 115.2 0 0 0-115.2 0zM726.886 324.3L577.741 764.11c-11.776 34.713-60.826 34.816-72.704 0.051L440.73 575.59l-197.94-71.987c-31.744-11.622-33.536-54.63-5.427-69.785l5.632-2.458 434.586-155.546a38.4 38.4 0 0 1 49.305 48.487z m-98.252 50.586L369.05 467.763l115.2 41.984a38.4 38.4 0 0 1 20.992 18.381l2.252 5.325 33.792 98.97 87.348-257.537z"  ></path></symbol><symbol id="icon-unfold" viewBox="0 0 2048 1024"><path d="M565.248 78.131a76.8 76.8 0 0 1 108.544 0l362.086 361.984a25.6 25.6 0 0 0 36.25 0l361.984-361.984a76.8 76.8 0 0 1 108.544 108.544l-361.984 362.189a179.2 179.2 0 0 1-253.44 0L565.248 186.675a76.8 76.8 0 0 1 0-108.544z"  ></path></symbol><symbol id="icon-rpc" viewBox="0 0 1024 1024"><path d="M204.8 678.4a140.8 140.8 0 1 1 0 281.6 140.8 140.8 0 0 1 0-281.6z m168.96-573.44a268.8 268.8 0 0 1 207.872 439.245l38.144 38.144a192 192 0 1 1-55.603 53.094l-39.27-39.373A268.8 268.8 0 1 1 373.76 104.96zM204.8 755.2a64 64 0 1 0 0 128 64 64 0 0 0 0-128z m517.12-125.44a115.2 115.2 0 1 0 0 230.4 115.2 115.2 0 0 0 0-230.4z m-348.16-448a192 192 0 1 0 0 384 192 192 0 0 0 0-384zM819.2 64a140.8 140.8 0 1 1 0 281.6 140.8 140.8 0 0 1 0-281.6z m0 76.8a64 64 0 1 0 0 128 64 64 0 0 0 0-128z"  ></path></symbol><symbol id="icon-mev" viewBox="0 0 1024 1024"><path d="M651.162 95.488c53.401 56.422 131.84 113.818 235.212 171.674a38.4 38.4 0 0 1 19.456 29.9c12.032 129.024-12.544 251.75-73.625 367.156-60.211 113.817-158.976 226.457-295.936 338.33a38.4 38.4 0 0 1-48.589 0C356.608 895.436 259.328 782.181 196.045 662.681c-64.103-121.19-90.266-243.405-77.824-365.876a38.4 38.4 0 0 1 20.531-30.259C239.923 214.323 319.846 156.98 378.624 94.925c104.96-110.95 169.37-108.442 272.538 0.512z m126.464 196.506l-1.178 0.819a41.933 41.933 0 0 1-10.035 3.84c-4.25 1.024-5.427 1.28-14.695 3.328a122.368 122.368 0 0 0-16.896 4.403c-43.878 16.384-71.168 47.411-83.097 96.666-2.304 9.625-3.328 20.838-3.687 38.4l-0.204 13.516v15.872l0.05 9.728v2.048l0.052 3.482c0.256 35.328 0.154 51.2-1.024 71.424-4.506 79.36-42.291 140.39-108.954 178.483-29.542 16.896-61.9 23.962-99.328 23.91h-8.704a9243.136 9243.136 0 0 0-29.286-0.153h-17.46l-10.034-0.051h-22.938c40.448 50.841 88.371 100.71 143.77 149.504l17.97 15.513 17.511-14.899c101.018-88.064 176.077-175.513 225.28-262.144l9.523-17.408c50.893-96.205 73.063-197.273 66.56-303.974l-3.584-2.407a1479.786 1479.786 0 0 1-49.664-29.9z m-171.52 5.12h-1.127c-15.155 0.102-30.054 3.584-45.107 10.598-46.285 21.504-77.056 71.373-76.39 128.051 0.307 25.703 0.256 51.354 0 87.603l-0.103 10.445c-0.102 14.49-0.512 24.371-1.74 34.816-4.865 42.803-19.661 79.77-43.674 110.285l-1.792 2.15 1.331 0.052h1.331c24.832 0 44.288-4.199 61.03-13.824 44.033-25.19 67.38-62.72 70.4-116.122 1.025-18.022 1.127-32.768 0.871-66.56v-5.478l-0.051-5.223v-21.504c0-5.12 0.051-9.728 0.153-14.49 0.512-22.681 1.895-38.604 5.837-54.937a225.075 225.075 0 0 1 35.687-79.514l4.71-6.246h-11.366z m1.484-136.295l-12.236-12.544c-73.728-77.926-87.245-78.438-160.973-0.563-60.467 63.898-139.674 122.112-237.466 174.95l-3.942 2.048-0.768 17.562c-2.407 88.064 18.176 176.384 61.952 265.42l9.779 19.047c9.267 17.51 19.354 34.919 30.26 52.224l-0.871 0.154c2.406-0.512 2.406-0.512 6.144-0.973 15.104-1.536 29.593-6.86 43.776-15.974 36.454-23.552 56.883-56.576 62.105-102.247 0.82-7.168 1.127-14.848 1.23-26.726l0.102-10.343c0.256-35.84 0.307-61.132 0-86.22-1.024-86.58 46.899-164.199 120.78-198.554a183.552 183.552 0 0 1 77.312-17.766h1.536l53.044 0.256h16.076a775.117 775.117 0 0 1-67.84-59.75z"  ></path></symbol><symbol id="icon-caution" viewBox="0 0 1024 1024"><path d="M512 682.666667c-47.146667 0-85.333333-42.112-85.333333-94.037334V94.037333C426.666667 42.112 464.853333 0 512 0s85.333333 42.112 85.333333 94.037333v494.592C597.333333 640.554667 559.146667 682.666667 512 682.666667zM512 1024c-47.146667 0-85.333333-35.2-85.333333-78.592v-98.816C426.666667 803.2 464.853333 768 512 768s85.333333 35.2 85.333333 78.592v98.816C597.333333 988.8 559.146667 1024 512 1024z"  ></path></symbol><symbol id="icon-settings" viewBox="0 0 1024 1024"><path d="M608 62.31l245.453 141.67a192 192 0 0 1 96 166.298v283.444a192 192 0 0 1-96 166.297L608 961.69a192 192 0 0 1-192 0L170.547 820.02a192 192 0 0 1-96-166.297V370.278a192 192 0 0 1 95.949-166.297L415.949 62.31a192 192 0 0 1 192 0z m-153.6 66.51L208.947 270.49a115.2 115.2 0 0 0-57.6 99.84v283.392a115.2 115.2 0 0 0 57.6 99.788L454.4 895.18a115.2 115.2 0 0 0 115.2 0l245.453-141.67a115.2 115.2 0 0 0 57.6-99.84V370.33a115.2 115.2 0 0 0-57.6-99.79L569.6 128.87a115.2 115.2 0 0 0-115.2 0z m104.858 211.762a89.6 89.6 0 0 1 77.568 44.8l47.257 81.818a89.6 89.6 0 0 1 0 89.6l-47.257 81.818a89.6 89.6 0 0 1-77.568 44.8h-94.516a89.6 89.6 0 0 1-77.568-44.8L339.917 556.8a89.6 89.6 0 0 1 0-89.6l47.257-81.818a89.6 89.6 0 0 1 77.568-44.8h94.516z m0 76.8h-94.516a12.8 12.8 0 0 0-11.059 6.4L406.426 505.6a12.8 12.8 0 0 0 0 12.8l47.257 81.818a12.8 12.8 0 0 0 11.06 6.4h94.515a12.8 12.8 0 0 0 11.059-6.4l47.257-81.818a12.8 12.8 0 0 0 0-12.8l-47.257-81.818a12.8 12.8 0 0 0-11.06-6.4z"  ></path></symbol><symbol id="icon-back" viewBox="0 0 1024 1024"><path d="M67.738 495.616l36.3 32.358 220.468 194.868c13.926 12.236 14.438 33.792 1.024 46.796l-0.41 0.41a31.898 31.898 0 0 1-44.288 0L20.736 518.554a31.744 31.744 0 0 1 0-45.773l260.096-251.597a31.898 31.898 0 0 1 44.288 0l0.46 0.41a31.846 31.846 0 0 1-1.023 46.848l-220.57 194.816-36.352 32.358z"  ></path></symbol><symbol id="icon-wallet" viewBox="0 0 1024 1024"><path d="M825.6 115.2A134.4 134.4 0 0 1 960 249.6v384c0 60.877-40.448 112.282-95.949 128.82L864 785.868a140.8 140.8 0 0 1-179.456 135.373l-467.2-133.479A140.8 140.8 0 0 1 115.2 652.288V249.6a134.4 134.4 0 0 1 134.4-134.4h576zM256 225.331c-35.328 0-64 28.672-64 64V652.34c0 28.57 18.944 53.709 46.438 61.543l467.2 133.478a64 64 0 0 0 81.562-61.491v-47.616a38.502 38.502 0 0 1 0-17.306V422.861a64 64 0 0 0-46.438-61.543l-467.2-133.478A64 64 0 0 0 256 225.28zM825.6 192H427.827l334.029 95.437A140.8 140.8 0 0 1 864 422.86v253.645c11.776-10.548 19.2-25.856 19.2-42.906v-384c0-31.795-25.805-57.6-57.6-57.6z m-192 259.226a38.4 38.4 0 0 1 38.4 38.4V633.6a38.4 38.4 0 1 1-76.8 0V489.574a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-star" viewBox="0 0 1024 1024"><path d="M474.778 72.653a84.992 84.992 0 0 1 113.1 37.683l90.727 179.712c1.024 2.15 3.277 3.686 5.939 4.096l202.906 29.082c18.278 2.56 35.174 11.059 48.128 24.064a83.302 83.302 0 0 1-1.23 119.09l-148.12 142.542a6.605 6.605 0 0 0-2.049 5.939l34.765 195.584c3.277 18.483 0.154 37.58-8.806 54.17a85.043 85.043 0 0 1-114.176 34.457L515.84 804.659a8.55 8.55 0 0 0-7.885 0l-179.968 94.31c-16.589 8.705-35.635 11.674-54.118 8.5a83.968 83.968 0 0 1-68.813-97.28l34.97-195.328a6.605 6.605 0 0 0-2.048-5.94L89.702 466.484a83.61 83.61 0 0 1-24.832-48.128 83.968 83.968 0 0 1 71.732-95.078l204.339-29.184a7.834 7.834 0 0 0 5.939-4.096l89.395-179.251c8.192-16.59 21.76-29.952 38.503-38.093z m36.198 68.25l-2.56 0.767a7.475 7.475 0 0 0-3.43 3.328l-89.344 179.303c-12.39 24.832-36.301 41.933-63.847 45.875l-204.339 29.133c-4.352 0.614-7.168 4.198-6.605 7.885a6.81 6.81 0 0 0 2.048 3.89l148.275 142.49c20.173 19.354 29.338 47.36 24.423 74.804l-34.919 195.379c-0.665 3.584 1.946 7.27 6.247 8.038 1.894 0.307 3.789 0 5.427-0.819l179.968-94.31a85.35 85.35 0 0 1 79.155 0l180.173 94.361c3.994 2.1 9.011 0.615 10.957-3.02a6.4 6.4 0 0 0 0.717-4.199l-34.714-195.533a83.354 83.354 0 0 1 24.371-74.65l148.122-142.591a6.502 6.502 0 0 0 0.102-9.524 8.14 8.14 0 0 0-4.608-2.252l-202.957-29.082c-27.392-3.942-51.2-20.89-63.59-45.517l-90.726-179.712c-1.844-3.635-6.81-5.273-10.906-3.277l2.56-0.768z"  ></path></symbol><symbol id="icon-trade" viewBox="0 0 1024 1024"><path d="M1002.93153 563.627l-433.237 432.64a67.243 67.243 0 0 1-29.696 21.93c-0.853 0.171-1.45 0.342-1.963 0.342a61.27 61.27 0 0 1-22.442 4.608c-1.11 0-2.304 0.853-3.414 0.853-2.048 0-3.84-1.365-5.973-1.365a54.87 54.87 0 0 1-13.653-2.987 77.312 77.312 0 0 1-15.275-6.144c-2.987-1.621-5.803-3.67-8.533-5.803-2.56-1.962-5.718-2.816-7.936-5.461L21.34153 563.627a71.68 71.68 0 0 1 0-102.059 72.704 72.704 0 0 1 102.57 0l316.16 315.477V73.472C440.07353 33.109 472.92753 0 513.29053 0a73.387 73.387 0 0 1 73.216 73.472v701.355L900.53153 461.653a72.363 72.363 0 0 1 102.4 102.059z"  ></path></symbol><symbol id="icon-verticalslider" viewBox="0 0 1024 1024"><path d="M310.426 441.6a166.4 166.4 0 0 1 38.4 328.346V870.4a38.4 38.4 0 1 1-76.8 0V769.946a166.451 166.451 0 0 1 38.4-328.346z m0 76.8a89.6 89.6 0 1 0 0 179.2 89.6 89.6 0 0 0 0-179.2z m403.2-403.2a38.4 38.4 0 0 1 38.4 38.4v55.654a166.451 166.451 0 0 1-38.4 328.346 166.4 166.4 0 0 1-38.4-328.346V153.6a38.4 38.4 0 0 1 38.4-38.4z m0 166.4a89.6 89.6 0 1 0 0 179.2 89.6 89.6 0 0 0 0-179.2zM310.323 115.2a38.4 38.4 0 0 1 38.4 38.4v146.534a38.4 38.4 0 0 1-76.8 0V153.6a38.4 38.4 0 0 1 38.4-38.4z m403.2 525.26a38.4 38.4 0 0 1 38.4 38.4V870.4a38.4 38.4 0 1 1-76.8 0V678.86a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-swap" viewBox="0 0 1024 1024"><path d="M321.434 116.224a51.2 51.2 0 0 1 69.888 74.752c-47.77 44.646-87.04 81.818-117.658 111.462l-1.997 1.844h289.229a51.2 51.2 0 0 1 50.842 45.26l0.358 5.94a51.2 51.2 0 0 1-51.2 51.2H154.47a51.763 51.763 0 0 1-52.07-52.839c0.205-11.52 3.123-19.097 7.782-27.136 3.226-5.53 7.22-10.752 12.8-17.203 8.192-9.626 20.992-23.04 38.656-40.704a7171.584 7171.584 0 0 1 159.744-152.576z m509.593 188.058a51.2 51.2 0 0 1 0 102.4h-93.593a51.2 51.2 0 0 1 0-102.4h93.593zM663.194 853.709a51.2 51.2 0 0 1-69.888-74.803c47.77-44.647 87.04-81.818 117.657-111.412l2.048-1.894H153.6a51.2 51.2 0 0 1-50.842-45.21l-0.358-5.99a51.2 51.2 0 0 1 51.2-51.2h676.557c27.904 0 52.582 22.272 52.07 52.838a51.456 51.456 0 0 1-7.782 27.136c-3.226 5.53-7.22 10.752-12.8 17.204-8.192 9.625-20.992 23.04-38.656 40.704a7171.584 7171.584 0 0 1-159.744 152.627z"  ></path></symbol><symbol id="icon-star_sel" viewBox="0 0 1024 1024"><path d="M470.63 127.846L381.286 307.2a46.182 46.182 0 0 1-34.918 24.986l-204.34 29.184a45.568 45.568 0 0 0-39.167 51.456 45.344 45.344 0 0 0 13.465 26.01l148.276 142.438c10.905 10.496 15.872 25.6 13.21 40.448l-34.97 195.328a45.568 45.568 0 0 0 37.58 52.633 46.95 46.95 0 0 0 29.748-4.659l179.968-94.31a46.95 46.95 0 0 1 43.52 0l180.121 94.361c22.528 11.827 50.586 3.43 62.618-18.688a44.8 44.8 0 0 0 4.71-29.184L746.394 621.62a45.005 45.005 0 0 1 13.21-40.294l148.12-142.592a44.902 44.902 0 0 0 0.666-64.256 46.54 46.54 0 0 0-26.368-13.21l-202.956-29.081a46.182 46.182 0 0 1-34.765-24.781l-90.727-179.712a46.592 46.592 0 0 0-82.944 0.205z"  ></path></symbol><symbol id="icon-tips" viewBox="0 0 1024 1024"><path d="M512 166.4a345.6 345.6 0 1 1 0 691.2 345.6 345.6 0 0 1 0-691.2z m0 76.8a268.8 268.8 0 1 0 0 537.6 268.8 268.8 0 0 0 0-537.6z m0 196.3a38.4 38.4 0 0 1 38.4 38.4v219.29a38.4 38.4 0 1 1-76.8 0V477.9a38.4 38.4 0 0 1 38.4-38.4z m0-153.087a38.4 38.4 0 0 1 38.4 38.4v45.414a38.4 38.4 0 1 1-76.8 0v-45.363a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-sel" viewBox="0 0 1024 1024"><path d="M783.36 281.2416a51.2 51.2 0 0 1 71.68 73.0624l-407.9616 400.384a51.2 51.2 0 0 1-67.8912 3.4304l-206.3872-165.376a51.2 51.2 0 1 1 64-79.9232l170.9568 137.0112 375.6032-368.64z"  ></path></symbol><symbol id="icon-spread" viewBox="0 0 1024 1024"><path d="M143.36 678.4a38.4 38.4 0 0 1 38.4 38.4v112.64c0 7.066 5.734 12.8 12.8 12.8H307.2a38.4 38.4 0 1 1 0 76.8H194.56a89.6 89.6 0 0 1-89.6-89.6V716.8a38.4 38.4 0 0 1 38.4-38.4z m327.68-573.44a38.4 38.4 0 0 1 0 76.8H234.342L842.24 790.477v-242.33a38.4 38.4 0 1 1 76.8 0V829.44a89.6 89.6 0 0 1-89.6 89.6H552.96a38.4 38.4 0 1 1 0-76.8l232.346-0.051L181.76 237.773V471.04a38.4 38.4 0 0 1-76.8 0V194.56c0-49.46 40.14-89.6 89.6-89.6h276.48z m358.4 0c49.46 0 89.6 40.14 89.6 89.6V307.2a38.4 38.4 0 1 1-76.8 0V194.56a12.8 12.8 0 0 0-12.8-12.8H716.8a38.4 38.4 0 1 1 0-76.8h112.64z"  ></path></symbol><symbol id="icon-refresh" viewBox="0 0 1024 1024"><path d="M601.446 178.176a344.576 344.576 0 0 1 124.621 62.413 38.4 38.4 0 0 1 5.12 55.45l-94.566 107.878a38.4 38.4 0 1 1-57.754-50.586l65.741-75.11-4.915-2.816a268.646 268.646 0 0 0-43.008-18.535l-15.104-4.505A268.8 268.8 0 1 0 771.635 581.58a38.4 38.4 0 1 1 74.189 19.865 345.6 345.6 0 1 1-244.378-423.27z"  ></path></symbol><symbol id="icon-close" viewBox="0 0 1024 1024"><path d="M763.392 256.512a51.2 51.2 0 0 1 0 72.3968L582.2464 509.952l183.1424 183.1424a51.2 51.2 0 0 1-72.3968 72.3968l-183.1424-183.1424-180.992 181.0432a51.2 51.2 0 0 1-72.3968-72.3968L437.504 509.952 258.56 330.9568A51.2 51.2 0 0 1 330.9568 258.56L509.952 437.504l181.0432-180.992a51.2 51.2 0 0 1 72.3968 0z"  ></path></symbol><symbol id="icon-alert" viewBox="0 0 1024 1024"><path d="M558.08 125.0816c12.6464 7.5776 23.1936 18.1248 30.72 30.72L959.232 773.12a89.6 89.6 0 0 1-76.8 135.68H141.6192a89.6 89.6 0 0 1-76.8-135.68L435.1488 155.8016a89.6 89.6 0 0 1 122.9312-30.72zM501.0432 195.328L130.6624 812.5952a12.8 12.8 0 0 0 10.9568 19.4048h740.7616a12.8 12.8 0 0 0 10.9568-19.4048L522.9568 195.328a12.8 12.8 0 0 0-21.9136 0zM512 524.8a38.4 38.4 0 0 1 38.4 38.4v153.6a38.4 38.4 0 1 1-76.8 0v-153.6a38.4 38.4 0 0 1 38.4-38.4z m0-204.8a38.4 38.4 0 0 1 38.4 38.4v51.2a38.4 38.4 0 1 1-76.8 0V358.4a38.4 38.4 0 0 1 38.4-38.4z"  ></path></symbol><symbol id="icon-arrow" viewBox="0 0 1024 1024"><path d="M572.33 707.67l220.673-220.673a85.333 85.333 0 0 0-60.331-145.664H291.328a85.333 85.333 0 0 0-60.33 145.664L451.668 707.67a85.333 85.333 0 0 0 120.662 0z"  ></path></symbol></svg>', ((e) => {
  var t = (r = (r = document.getElementsByTagName("script"))[r.length - 1]).getAttribute("data-injectcss"), r = r.getAttribute("data-disable-injectsvg");
  if (!r) {
    var n, i, s, o, a, c = function(f, h) {
      h.parentNode.insertBefore(f, h);
    };
    if (t && !e.__iconfont__svg__cssinject__) {
      e.__iconfont__svg__cssinject__ = !0;
      try {
        document.write("<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>");
      } catch {
      }
    }
    n = function() {
      var f, h = document.createElement("div");
      h.innerHTML = e._iconfont_svg_string_4776227, (h = h.getElementsByTagName("svg")[0]) && (h.setAttribute("aria-hidden", "true"), h.style.position = "absolute", h.style.width = 0, h.style.height = 0, h.style.overflow = "hidden", h = h, (f = document.body).firstChild ? c(h, f.firstChild) : f.appendChild(h));
    }, document.addEventListener ? ~["complete", "loaded", "interactive"].indexOf(document.readyState) ? setTimeout(n, 0) : (i = function() {
      document.removeEventListener("DOMContentLoaded", i, !1), n();
    }, document.addEventListener("DOMContentLoaded", i, !1)) : document.attachEvent && (s = n, o = e.document, a = !1, l(), o.onreadystatechange = function() {
      o.readyState == "complete" && (o.onreadystatechange = null, u());
    });
  }
  function u() {
    a || (a = !0, s());
  }
  function l() {
    try {
      o.documentElement.doScroll("left");
    } catch {
      return void setTimeout(l, 50);
    }
    u();
  }
})(window);
function Yi(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function uC(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function Xw(e, t) {
  return Array.isArray(t) ? t.length === 0 ? !0 : e ? t.every((r) => typeof r == "string") : t.every((r) => Number.isSafeInteger(r)) : !1;
}
function r0(e, t) {
  if (typeof t != "string")
    throw new Error(`${e}: string expected`);
  return !0;
}
function Jw(e) {
  if (!Number.isSafeInteger(e))
    throw new Error(`invalid integer: ${e}`);
}
function n0(e) {
  if (!Array.isArray(e))
    throw new Error("array expected");
}
function Zw(e, t) {
  if (!Xw(!0, t))
    throw new Error(`${e}: array of strings expected`);
}
function lC(e, t) {
  if (!Xw(!1, t))
    throw new Error(`${e}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function fC(...e) {
  const t = (s) => s, r = (s, o) => (a) => s(o(a)), n = e.map((s) => s.encode).reduceRight(r, t), i = e.map((s) => s.decode).reduce(r, t);
  return { encode: n, decode: i };
}
// @__NO_SIDE_EFFECTS__
function dC(e) {
  const t = typeof e == "string" ? e.split("") : e, r = t.length;
  Zw("alphabet", t);
  const n = new Map(t.map((i, s) => [i, s]));
  return {
    encode: (i) => (n0(i), i.map((s) => {
      if (!Number.isSafeInteger(s) || s < 0 || s >= r)
        throw new Error(`alphabet.encode: digit index outside alphabet "${s}". Allowed: ${e}`);
      return t[s];
    })),
    decode: (i) => (n0(i), i.map((s) => {
      r0("alphabet.decode", s);
      const o = n.get(s);
      if (o === void 0)
        throw new Error(`Unknown letter: "${s}". Allowed: ${e}`);
      return o;
    }))
  };
}
// @__NO_SIDE_EFFECTS__
function hC(e = "") {
  return r0("join", e), {
    encode: (t) => (Zw("join.decode", t), t.join(e)),
    decode: (t) => (r0("join.decode", t), t.split(e))
  };
}
function fy(e, t, r) {
  if (t < 2)
    throw new Error(`convertRadix: invalid from=${t}, base cannot be less than 2`);
  if (r < 2)
    throw new Error(`convertRadix: invalid to=${r}, base cannot be less than 2`);
  if (n0(e), !e.length)
    return [];
  let n = 0;
  const i = [], s = Array.from(e, (a) => {
    if (Jw(a), a < 0 || a >= t)
      throw new Error(`invalid integer: ${a}`);
    return a;
  }), o = s.length;
  for (; ; ) {
    let a = 0, c = !0;
    for (let u = n; u < o; u++) {
      const l = s[u], f = t * a, h = f + l;
      if (!Number.isSafeInteger(h) || f / t !== a || h - l !== f)
        throw new Error("convertRadix: carry overflow");
      const v = h / r;
      a = h % r;
      const b = Math.floor(v);
      if (s[u] = b, !Number.isSafeInteger(b) || b * r + a !== h)
        throw new Error("convertRadix: carry overflow");
      if (c)
        b ? c = !1 : n = u;
      else
        continue;
    }
    if (i.push(a), c)
      break;
  }
  for (let a = 0; a < e.length - 1 && e[a] === 0; a++)
    i.push(0);
  return i.reverse();
}
// @__NO_SIDE_EFFECTS__
function pC(e) {
  Jw(e);
  const t = 2 ** 8;
  return {
    encode: (r) => {
      if (!uC(r))
        throw new Error("radix.encode input should be Uint8Array");
      return fy(Array.from(r), t, e);
    },
    decode: (r) => (lC("radix.decode", r), Uint8Array.from(fy(r, e, t)))
  };
}
const mC = /* @__NO_SIDE_EFFECTS__ */ (e) => /* @__PURE__ */ fC(/* @__PURE__ */ pC(58), /* @__PURE__ */ dC(e), /* @__PURE__ */ hC("")), _d = /* @__PURE__ */ mC("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Ca = (e) => _d.encode(e), Fs = (e) => _d.decode(e);
function Hr(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
const Nh = 8192;
function Wr(e) {
  if (e.length < Nh)
    return btoa(String.fromCharCode(...e));
  let t = "";
  for (var r = 0; r < e.length; r += Nh) {
    const n = e.slice(r, r + Nh);
    t += String.fromCharCode(...n);
  }
  return btoa(t);
}
function Tc(e) {
  var i;
  const t = e.startsWith("0x") ? e.slice(2) : e, r = t.length % 2 === 0 ? t : `0${t}`, n = ((i = r.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : i.map((s) => parseInt(s, 16))) ?? [];
  if (n.length !== r.length / 2)
    throw new Error(`Invalid hex string ${e}`);
  return Uint8Array.from(n);
}
function Vs(e) {
  return e.reduce((t, r) => t + r.toString(16).padStart(2, "0"), "");
}
function If(e) {
  const t = [];
  let r = 0;
  if (e === 0)
    return [0];
  for (; e > 0; )
    t[r] = e & 127, (e >>= 7) && (t[r] |= 128), r += 1;
  return t;
}
function gC(e) {
  let t = 0, r = 0, n = 0;
  for (; ; ) {
    const i = e[n];
    if (n += 1, t |= (i & 127) << r, !(i & 128))
      break;
    r += 7;
  }
  return {
    value: t,
    length: n
  };
}
class Qw {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(t) {
    this.bytePosition = 0, this.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(t) {
    return this.bytePosition += t, this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    const t = this.dataView.getUint8(this.bytePosition);
    return this.shift(1), t;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    const t = this.dataView.getUint16(this.bytePosition, !0);
    return this.shift(2), t;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    const t = this.dataView.getUint32(this.bytePosition, !0);
    return this.shift(4), t;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    const t = this.read32(), n = this.read32().toString(16) + t.toString(16).padStart(8, "0");
    return BigInt("0x" + n).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    const t = BigInt(this.read64()), n = BigInt(this.read64()).toString(16) + t.toString(16).padStart(16, "0");
    return BigInt("0x" + n).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    const t = BigInt(this.read128()), n = BigInt(this.read128()).toString(16) + t.toString(16).padStart(32, "0");
    return BigInt("0x" + n).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(t) {
    const r = this.bytePosition + this.dataView.byteOffset, n = new Uint8Array(this.dataView.buffer, r, t);
    return this.shift(t), n;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    const t = this.bytePosition + this.dataView.byteOffset, r = new Uint8Array(this.dataView.buffer, t), { value: n, length: i } = gC(r);
    return this.shift(i), n;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(t) {
    const r = this.readULEB(), n = [];
    for (let i = 0; i < r; i++)
      n.push(t(this, i, r));
    return n;
  }
}
function e2(e, t) {
  switch (t) {
    case "base58":
      return Ca(e);
    case "base64":
      return Wr(e);
    case "hex":
      return Vs(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function yC(e, t) {
  switch (t) {
    case "base58":
      return Fs(e);
    case "base64":
      return Hr(e);
    case "hex":
      return Tc(e);
    default:
      throw new Error("Unsupported encoding, supported values are: base64, hex");
  }
}
function Em(e, t = ["<", ">"]) {
  const [r, n] = t, i = [];
  let s = "", o = 0;
  for (let a = 0; a < e.length; a++) {
    const c = e[a];
    if (c === r && o++, c === n && o--, o === 0 && c === ",") {
      i.push(s.trim()), s = "";
      continue;
    }
    s += c;
  }
  return i.push(s.trim()), i;
}
class t2 {
  constructor({
    initialSize: t = 1024,
    maxSize: r = 1 / 0,
    allocateSize: n = 1024
  } = {}) {
    this.bytePosition = 0, this.size = t, this.maxSize = r, this.allocateSize = n, this.dataView = new DataView(new ArrayBuffer(t));
  }
  ensureSizeOrGrow(t) {
    const r = this.bytePosition + t;
    if (r > this.size) {
      const n = Math.min(this.maxSize, this.size + this.allocateSize);
      if (r > n)
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${r}`
        );
      this.size = n;
      const i = new ArrayBuffer(this.size);
      new Uint8Array(i).set(new Uint8Array(this.dataView.buffer)), this.dataView = new DataView(i);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(t) {
    return this.bytePosition += t, this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(t) {
    return this.ensureSizeOrGrow(1), this.dataView.setUint8(this.bytePosition, Number(t)), this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(t) {
    return this.ensureSizeOrGrow(2), this.dataView.setUint16(this.bytePosition, Number(t), !0), this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(t) {
    return this.ensureSizeOrGrow(4), this.dataView.setUint32(this.bytePosition, Number(t), !0), this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(t) {
    return $h(BigInt(t), 8).forEach((r) => this.write8(r)), this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(t) {
    return $h(BigInt(t), 16).forEach((r) => this.write8(r)), this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(t) {
    return $h(BigInt(t), 32).forEach((r) => this.write8(r)), this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(t) {
    return If(t).forEach((r) => this.write8(r)), this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(t, r) {
    return this.writeULEB(t.length), Array.from(t).forEach((n, i) => r(this, n, i, t.length)), this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let t = 0; t < this.bytePosition; t++)
      yield this.dataView.getUint8(t);
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(t) {
    return e2(this.toBytes(), t);
  }
}
function $h(e, t) {
  const r = new Uint8Array(t);
  let n = 0;
  for (; e > 0; )
    r[n] = Number(e % BigInt(256)), e = e / BigInt(256), n += 1;
  return r;
}
var r2 = (e) => {
  throw TypeError(e);
}, n2 = (e, t, r) => t.has(e) || r2("Cannot " + r), vi = (e, t, r) => (n2(e, t, "read from private field"), r ? r.call(e) : t.get(e)), kf = (e, t, r) => t.has(e) ? r2("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), jf = (e, t, r, n) => (n2(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Ka, su, Kl, oo;
const vC = class i2 {
  constructor(t) {
    kf(this, Ka), kf(this, su), this.name = t.name, this.read = t.read, this.serializedSize = t.serializedSize ?? (() => null), jf(this, Ka, t.write), jf(this, su, t.serialize ?? ((r, n) => {
      const i = new t2({
        initialSize: this.serializedSize(r) ?? void 0,
        ...n
      });
      return vi(this, Ka).call(this, r, i), i.toBytes();
    })), this.validate = t.validate ?? (() => {
    });
  }
  write(t, r) {
    this.validate(t), vi(this, Ka).call(this, t, r);
  }
  serialize(t, r) {
    return this.validate(t), new o2(this, vi(this, su).call(this, t, r));
  }
  parse(t) {
    const r = new Qw(t);
    return this.read(r);
  }
  fromHex(t) {
    return this.parse(Tc(t));
  }
  fromBase58(t) {
    return this.parse(Fs(t));
  }
  fromBase64(t) {
    return this.parse(Hr(t));
  }
  transform({
    name: t,
    input: r,
    output: n,
    validate: i
  }) {
    return new i2({
      name: t ?? this.name,
      read: (s) => n ? n(this.read(s)) : this.read(s),
      write: (s, o) => vi(this, Ka).call(this, r ? r(s) : s, o),
      serializedSize: (s) => this.serializedSize(r ? r(s) : s),
      serialize: (s, o) => vi(this, su).call(this, r ? r(s) : s, o),
      validate: (s) => {
        i == null || i(s), this.validate(r ? r(s) : s);
      }
    });
  }
};
Ka = /* @__PURE__ */ new WeakMap();
su = /* @__PURE__ */ new WeakMap();
let bi = vC;
const s2 = Symbol.for("@mysten/serialized-bcs");
function xd(e) {
  return !!e && typeof e == "object" && e[s2] === !0;
}
class o2 {
  constructor(t, r) {
    kf(this, Kl), kf(this, oo), jf(this, Kl, t), jf(this, oo, r);
  }
  // Used to brand SerializedBcs so that they can be identified, even between multiple copies
  // of the @mysten/bcs package are installed
  get [s2]() {
    return !0;
  }
  toBytes() {
    return vi(this, oo);
  }
  toHex() {
    return Vs(vi(this, oo));
  }
  toBase64() {
    return Wr(vi(this, oo));
  }
  toBase58() {
    return Ca(vi(this, oo));
  }
  parse() {
    return vi(this, Kl).parse(vi(this, oo));
  }
}
Kl = /* @__PURE__ */ new WeakMap();
oo = /* @__PURE__ */ new WeakMap();
function Rf({
  size: e,
  ...t
}) {
  return new bi({
    ...t,
    serializedSize: () => e
  });
}
function Dh({
  readMethod: e,
  writeMethod: t,
  ...r
}) {
  return Rf({
    ...r,
    read: (n) => n[e](),
    write: (n, i) => i[t](n),
    validate: (n) => {
      var i;
      if (n < 0 || n > r.maxValue)
        throw new TypeError(
          `Invalid ${r.name} value: ${n}. Expected value in range 0-${r.maxValue}`
        );
      (i = r.validate) == null || i.call(r, n);
    }
  });
}
function Lh({
  readMethod: e,
  writeMethod: t,
  ...r
}) {
  return Rf({
    ...r,
    read: (n) => n[e](),
    write: (n, i) => i[t](BigInt(n)),
    validate: (n) => {
      var s;
      const i = BigInt(n);
      if (i < 0 || i > r.maxValue)
        throw new TypeError(
          `Invalid ${r.name} value: ${i}. Expected value in range 0-${r.maxValue}`
        );
      (s = r.validate) == null || s.call(r, i);
    }
  });
}
function bC({
  serialize: e,
  ...t
}) {
  const r = new bi({
    ...t,
    serialize: e,
    write: (n, i) => {
      for (const s of r.serialize(n).toBytes())
        i.write8(s);
    }
  });
  return r;
}
function wC({
  toBytes: e,
  fromBytes: t,
  ...r
}) {
  return new bi({
    ...r,
    read: (n) => {
      const i = n.readULEB(), s = n.readBytes(i);
      return t(s);
    },
    write: (n, i) => {
      const s = e(n);
      i.writeULEB(s.length);
      for (let o = 0; o < s.length; o++)
        i.write8(s[o]);
    },
    serialize: (n) => {
      const i = e(n), s = If(i.length), o = new Uint8Array(s.length + i.length);
      return o.set(s, 0), o.set(i, s.length), o;
    },
    validate: (n) => {
      var i;
      if (typeof n != "string")
        throw new TypeError(`Invalid ${r.name} value: ${n}. Expected string`);
      (i = r.validate) == null || i.call(r, n);
    }
  });
}
function _C(e) {
  let t = null;
  function r() {
    return t || (t = e()), t;
  }
  return new bi({
    name: "lazy",
    read: (n) => r().read(n),
    serializedSize: (n) => r().serializedSize(n),
    write: (n, i) => r().write(n, i),
    serialize: (n, i) => r().serialize(n, i).toBytes()
  });
}
const re = {
  /**
   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
   * @example
   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
   */
  u8(e) {
    return Dh({
      name: "u8",
      readMethod: "read8",
      writeMethod: "write8",
      size: 1,
      maxValue: 2 ** 8 - 1,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
   * @example
   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
   */
  u16(e) {
    return Dh({
      name: "u16",
      readMethod: "read16",
      writeMethod: "write16",
      size: 2,
      maxValue: 2 ** 16 - 1,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
   * @example
   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
   */
  u32(e) {
    return Dh({
      name: "u32",
      readMethod: "read32",
      writeMethod: "write32",
      size: 4,
      maxValue: 2 ** 32 - 1,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
   * @example
   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
   */
  u64(e) {
    return Lh({
      name: "u64",
      readMethod: "read64",
      writeMethod: "write64",
      size: 8,
      maxValue: 2n ** 64n - 1n,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
   * @example
   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u128(e) {
    return Lh({
      name: "u128",
      readMethod: "read128",
      writeMethod: "write128",
      size: 16,
      maxValue: 2n ** 128n - 1n,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
   * @example
   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
   */
  u256(e) {
    return Lh({
      name: "u256",
      readMethod: "read256",
      writeMethod: "write256",
      size: 32,
      maxValue: 2n ** 256n - 1n,
      ...e
    });
  },
  /**
   * Creates a BcsType that can be used to read and write boolean values.
   * @example
   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
   */
  bool(e) {
    return Rf({
      name: "bool",
      size: 1,
      read: (t) => t.read8() === 1,
      write: (t, r) => r.write8(t ? 1 : 0),
      ...e,
      validate: (t) => {
        var r;
        if ((r = e == null ? void 0 : e.validate) == null || r.call(e, t), typeof t != "boolean")
          throw new TypeError(`Expected boolean, found ${typeof t}`);
      }
    });
  },
  /**
   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
   * @example
   *
   */
  uleb128(e) {
    return bC({
      name: "uleb128",
      read: (t) => t.readULEB(),
      serialize: (t) => Uint8Array.from(If(t)),
      ...e
    });
  },
  /**
   * Creates a BcsType representing a fixed length byte array
   * @param size The number of bytes this types represents
   * @example
   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
   */
  bytes(e, t) {
    return Rf({
      name: `bytes[${e}]`,
      size: e,
      read: (r) => r.readBytes(e),
      write: (r, n) => {
        const i = new Uint8Array(r);
        for (let s = 0; s < e; s++)
          n.write8(i[s] ?? 0);
      },
      ...t,
      validate: (r) => {
        var n;
        if ((n = t == null ? void 0 : t.validate) == null || n.call(t, r), !r || typeof r != "object" || !("length" in r))
          throw new TypeError(`Expected array, found ${typeof r}`);
        if (r.length !== e)
          throw new TypeError(`Expected array of length ${e}, found ${r.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a variable length byte array
   *
   * @example
   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]
   */
  byteVector(e) {
    return new bi({
      name: "bytesVector",
      read: (t) => {
        const r = t.readULEB();
        return t.readBytes(r);
      },
      write: (t, r) => {
        const n = new Uint8Array(t);
        r.writeULEB(n.length);
        for (let i = 0; i < n.length; i++)
          r.write8(n[i] ?? 0);
      },
      ...e,
      serializedSize: (t) => {
        const r = "length" in t ? t.length : null;
        return r == null ? null : If(r).length + r;
      },
      validate: (t) => {
        var r;
        if ((r = e == null ? void 0 : e.validate) == null || r.call(e, t), !t || typeof t != "object" || !("length" in t))
          throw new TypeError(`Expected array, found ${typeof t}`);
      }
    });
  },
  /**
   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
   * @example
   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
   */
  string(e) {
    return wC({
      name: "string",
      toBytes: (t) => new TextEncoder().encode(t),
      fromBytes: (t) => new TextDecoder().decode(t),
      ...e
    });
  },
  /**
   * Creates a BcsType that represents a fixed length array of a given type
   * @param size The number of elements in the array
   * @param type The BcsType of each element in the array
   * @example
   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
   */
  fixedArray(e, t, r) {
    return new bi({
      name: `${t.name}[${e}]`,
      read: (n) => {
        const i = new Array(e);
        for (let s = 0; s < e; s++)
          i[s] = t.read(n);
        return i;
      },
      write: (n, i) => {
        for (const s of n)
          t.write(s, i);
      },
      ...r,
      validate: (n) => {
        var i;
        if ((i = r == null ? void 0 : r.validate) == null || i.call(r, n), !n || typeof n != "object" || !("length" in n))
          throw new TypeError(`Expected array, found ${typeof n}`);
        if (n.length !== e)
          throw new TypeError(`Expected array of length ${e}, found ${n.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing an optional value
   * @param type The BcsType of the optional value
   * @example
   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
   */
  option(e) {
    return re.enum(`Option<${e.name}>`, {
      None: null,
      Some: e
    }).transform({
      input: (t) => t == null ? { None: !0 } : { Some: t },
      output: (t) => t.$kind === "Some" ? t.Some : null
    });
  },
  /**
   * Creates a BcsType representing a variable length vector of a given type
   * @param type The BcsType of each element in the vector
   *
   * @example
   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
   */
  vector(e, t) {
    return new bi({
      name: `vector<${e.name}>`,
      read: (r) => {
        const n = r.readULEB(), i = new Array(n);
        for (let s = 0; s < n; s++)
          i[s] = e.read(r);
        return i;
      },
      write: (r, n) => {
        n.writeULEB(r.length);
        for (const i of r)
          e.write(i, n);
      },
      ...t,
      validate: (r) => {
        var n;
        if ((n = t == null ? void 0 : t.validate) == null || n.call(t, r), !r || typeof r != "object" || !("length" in r))
          throw new TypeError(`Expected array, found ${typeof r}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a tuple of a given set of types
   * @param types The BcsTypes for each element in the tuple
   *
   * @example
   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
   */
  tuple(e, t) {
    return new bi({
      name: `(${e.map((r) => r.name).join(", ")})`,
      serializedSize: (r) => {
        let n = 0;
        for (let i = 0; i < e.length; i++) {
          const s = e[i].serializedSize(r[i]);
          if (s == null)
            return null;
          n += s;
        }
        return n;
      },
      read: (r) => {
        const n = [];
        for (const i of e)
          n.push(i.read(r));
        return n;
      },
      write: (r, n) => {
        for (let i = 0; i < e.length; i++)
          e[i].write(r[i], n);
      },
      ...t,
      validate: (r) => {
        var n;
        if ((n = t == null ? void 0 : t.validate) == null || n.call(t, r), !Array.isArray(r))
          throw new TypeError(`Expected array, found ${typeof r}`);
        if (r.length !== e.length)
          throw new TypeError(`Expected array of length ${e.length}, found ${r.length}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a struct of a given set of fields
   * @param name The name of the struct
   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
   *
   * @example
   * const struct = bcs.struct('MyStruct', {
   *  a: bcs.u8(),
   *  b: bcs.string(),
   * })
   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   */
  struct(e, t, r) {
    const n = Object.entries(t);
    return new bi({
      name: e,
      serializedSize: (i) => {
        let s = 0;
        for (const [o, a] of n) {
          const c = a.serializedSize(i[o]);
          if (c == null)
            return null;
          s += c;
        }
        return s;
      },
      read: (i) => {
        const s = {};
        for (const [o, a] of n)
          s[o] = a.read(i);
        return s;
      },
      write: (i, s) => {
        for (const [o, a] of n)
          a.write(i[o], s);
      },
      ...r,
      validate: (i) => {
        var s;
        if ((s = r == null ? void 0 : r.validate) == null || s.call(r, i), typeof i != "object" || i == null)
          throw new TypeError(`Expected object, found ${typeof i}`);
      }
    });
  },
  /**
   * Creates a BcsType representing an enum of a given set of options
   * @param name The name of the enum
   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
   * null can be used to represent a variant with no data.
   *
   * @example
   * const enum = bcs.enum('MyEnum', {
   *   A: bcs.u8(),
   *   B: bcs.string(),
   *   C: null,
   * })
   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
   */
  enum(e, t, r) {
    const n = Object.entries(t);
    return new bi({
      name: e,
      read: (i) => {
        const s = i.readULEB(), o = n[s];
        if (!o)
          throw new TypeError(`Unknown value ${s} for enum ${e}`);
        const [a, c] = o;
        return {
          [a]: (c == null ? void 0 : c.read(i)) ?? !0,
          $kind: a
        };
      },
      write: (i, s) => {
        const [o, a] = Object.entries(i).filter(
          ([c]) => Object.hasOwn(t, c)
        )[0];
        for (let c = 0; c < n.length; c++) {
          const [u, l] = n[c];
          if (u === o) {
            s.writeULEB(c), l == null || l.write(a, s);
            return;
          }
        }
      },
      ...r,
      validate: (i) => {
        var a;
        if ((a = r == null ? void 0 : r.validate) == null || a.call(r, i), typeof i != "object" || i == null)
          throw new TypeError(`Expected object, found ${typeof i}`);
        const s = Object.keys(i).filter(
          (c) => i[c] !== void 0 && Object.hasOwn(t, c)
        );
        if (s.length !== 1)
          throw new TypeError(
            `Expected object with one key, but found ${s.length} for type ${e}}`
          );
        const [o] = s;
        if (!Object.hasOwn(t, o))
          throw new TypeError(`Invalid enum variant ${o}`);
      }
    });
  },
  /**
   * Creates a BcsType representing a map of a given key and value type
   * @param keyType The BcsType of the key
   * @param valueType The BcsType of the value
   * @example
   * const map = bcs.map(bcs.u8(), bcs.string())
   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
   */
  map(e, t) {
    return re.vector(re.tuple([e, t])).transform({
      name: `Map<${e.name}, ${t.name}>`,
      input: (r) => [...r.entries()],
      output: (r) => {
        const n = /* @__PURE__ */ new Map();
        for (const [i, s] of r)
          n.set(i, s);
        return n;
      }
    });
  },
  /**
   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
   * @param cb A callback that returns the BcsType
   */
  lazy(e) {
    return _C(e);
  }
}, xC = Ca, SC = Fs, a2 = Wr, c2 = Hr, u2 = Vs, l2 = Tc, EC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BcsReader: Qw,
  BcsType: bi,
  BcsWriter: t2,
  SerializedBcs: o2,
  bcs: re,
  decodeStr: yC,
  encodeStr: e2,
  fromB58: SC,
  fromB64: c2,
  fromBase58: Fs,
  fromBase64: Hr,
  fromHEX: l2,
  fromHex: Tc,
  isSerializedBcs: xd,
  splitGenericParameters: Em,
  toB58: xC,
  toB64: a2,
  toBase58: Ca,
  toBase64: Wr,
  toHEX: u2,
  toHex: Vs
}, Symbol.toStringTag, { value: "Module" })), on = /* @__PURE__ */ Ec(EC);
var Tm = Object.defineProperty, TC = Object.getOwnPropertyDescriptor, CC = Object.getOwnPropertyNames, AC = Object.prototype.hasOwnProperty, MC = (e, t) => {
  for (var r in t)
    Tm(e, r, { get: t[r], enumerable: !0 });
}, OC = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of CC(t))
      !AC.call(e, i) && i !== r && Tm(e, i, { get: () => t[i], enumerable: !(n = TC(t, i)) || n.enumerable });
  return e;
}, IC = (e) => OC(Tm({}, "__esModule", { value: !0 }), e), f2 = {};
MC(f2, {
  isValidSuiNSName: () => jC,
  normalizeSuiNSName: () => RC
});
var d2 = IC(f2);
const h2 = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i, p2 = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i, kC = 235;
function jC(e) {
  return e.length > kC ? !1 : e.includes("@") ? h2.test(e) : p2.test(e);
}
function RC(e, t = "at") {
  const r = e.toLowerCase();
  let n;
  if (r.includes("@")) {
    if (!h2.test(r))
      throw new Error(`Invalid SuiNS name ${e}`);
    const [i, s] = r.split("@");
    n = [...i ? i.split(".") : [], s];
  } else {
    if (!p2.test(r))
      throw new Error(`Invalid SuiNS name ${e}`);
    n = r.split(".").slice(0, -1);
  }
  return t === "dot" ? `${n.join(".")}.sui` : `${n.slice(0, -1).join(".")}@${n[n.length - 1]}`;
}
var Cm = Object.defineProperty, PC = Object.getOwnPropertyDescriptor, NC = Object.getOwnPropertyNames, $C = Object.prototype.hasOwnProperty, DC = (e, t) => {
  for (var r in t)
    Cm(e, r, { get: t[r], enumerable: !0 });
}, LC = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of NC(t))
      !$C.call(e, i) && i !== r && Cm(e, i, { get: () => t[i], enumerable: !(n = PC(t, i)) || n.enumerable });
  return e;
}, BC = (e) => LC(Cm({}, "__esModule", { value: !0 }), e), m2 = {};
DC(m2, {
  isValidNamedPackage: () => y2,
  isValidNamedType: () => WC
});
var Am = BC(m2), UC = d2;
const FC = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/, VC = /^\d+$/, zC = 64, g2 = "/", y2 = (e) => {
  const t = e.split(g2);
  if (t.length < 2 || t.length > 3)
    return !1;
  const [r, n, i] = t;
  return i !== void 0 && !VC.test(i) || !(0, UC.isValidSuiNSName)(r) ? !1 : FC.test(n) && n.length < zC;
}, WC = (e) => {
  const t = e.split(/::|<|>|,/);
  for (const r of t)
    if (r.includes(g2) && !y2(r))
      return !1;
  return !0;
};
var Mm = Object.defineProperty, qC = Object.getOwnPropertyDescriptor, HC = Object.getOwnPropertyNames, GC = Object.prototype.hasOwnProperty, KC = (e, t) => {
  for (var r in t)
    Mm(e, r, { get: t[r], enumerable: !0 });
}, YC = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of HC(t))
      !GC.call(e, i) && i !== r && Mm(e, i, { get: () => t[i], enumerable: !(n = qC(t, i)) || n.enumerable });
  return e;
}, XC = (e) => YC(Mm({}, "__esModule", { value: !0 }), e), v2 = {};
KC(v2, {
  SUI_ADDRESS_LENGTH: () => Om,
  isValidSuiAddress: () => w2,
  isValidSuiObjectId: () => eA,
  isValidTransactionDigest: () => QC,
  normalizeStructTag: () => _2,
  normalizeSuiAddress: () => km,
  normalizeSuiObjectId: () => rA,
  parseStructTag: () => Im
});
var Bn = XC(v2), b2 = on, JC = Am;
const ZC = 32;
function QC(e) {
  try {
    return (0, b2.fromBase58)(e).length === ZC;
  } catch {
    return !1;
  }
}
const Om = 32;
function w2(e) {
  return nA(e) && iA(e) === Om;
}
function eA(e) {
  return w2(e);
}
function tA(e) {
  return e.includes("::") ? Im(e) : e;
}
function Im(e) {
  const [t, r] = e.split("::"), n = (0, JC.isValidNamedPackage)(t), i = e.slice(t.length + r.length + 4), s = i.includes("<") ? i.slice(0, i.indexOf("<")) : i, o = i.includes("<") ? (0, b2.splitGenericParameters)(i.slice(i.indexOf("<") + 1, i.lastIndexOf(">"))).map(
    (a) => tA(a.trim())
  ) : [];
  return {
    address: n ? t : km(t),
    module: r,
    name: s,
    typeParams: o
  };
}
function _2(e) {
  const { address: t, module: r, name: n, typeParams: i } = typeof e == "string" ? Im(e) : e, s = (i == null ? void 0 : i.length) > 0 ? `<${i.map(
    (o) => typeof o == "string" ? o : _2(o)
  ).join(",")}>` : "";
  return `${t}::${r}::${n}${s}`;
}
function km(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(Om * 2, "0")}`;
}
function rA(e, t = !1) {
  return km(e, t);
}
function nA(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function iA(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
var jm = Object.defineProperty, sA = Object.getOwnPropertyDescriptor, oA = Object.getOwnPropertyNames, aA = Object.prototype.hasOwnProperty, cA = (e, t) => {
  for (var r in t)
    jm(e, r, { get: t[r], enumerable: !0 });
}, uA = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of oA(t))
      !aA.call(e, i) && i !== r && jm(e, i, { get: () => t[i], enumerable: !(n = sA(t, i)) || n.enumerable });
  return e;
}, lA = (e) => uA(jm({}, "__esModule", { value: !0 }), e), x2 = {};
cA(x2, {
  TypeTagSerializer: () => mA
});
var S2 = lA(x2), fA = on, dA = Bn;
const hA = /^vector<(.+)>$/, pA = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
let mA = class Ya {
  static parseFromStr(t, r = !1) {
    if (t === "address")
      return { address: null };
    if (t === "bool")
      return { bool: null };
    if (t === "u8")
      return { u8: null };
    if (t === "u16")
      return { u16: null };
    if (t === "u32")
      return { u32: null };
    if (t === "u64")
      return { u64: null };
    if (t === "u128")
      return { u128: null };
    if (t === "u256")
      return { u256: null };
    if (t === "signer")
      return { signer: null };
    const n = t.match(hA);
    if (n)
      return {
        vector: Ya.parseFromStr(n[1], r)
      };
    const i = t.match(pA);
    if (i)
      return {
        struct: {
          address: r ? (0, dA.normalizeSuiAddress)(i[1]) : i[1],
          module: i[2],
          name: i[3],
          typeParams: i[5] === void 0 ? [] : Ya.parseStructTypeArgs(i[5], r)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`);
  }
  static parseStructTypeArgs(t, r = !1) {
    return (0, fA.splitGenericParameters)(t).map(
      (n) => Ya.parseFromStr(n, r)
    );
  }
  static tagToString(t) {
    if ("bool" in t)
      return "bool";
    if ("u8" in t)
      return "u8";
    if ("u16" in t)
      return "u16";
    if ("u32" in t)
      return "u32";
    if ("u64" in t)
      return "u64";
    if ("u128" in t)
      return "u128";
    if ("u256" in t)
      return "u256";
    if ("address" in t)
      return "address";
    if ("signer" in t)
      return "signer";
    if ("vector" in t)
      return `vector<${Ya.tagToString(t.vector)}>`;
    if ("struct" in t) {
      const r = t.struct, n = r.typeParams.map(Ya.tagToString).join(", ");
      return `${r.address}::${r.module}::${r.name}${n ? `<${n}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};
var Rm = Object.defineProperty, gA = Object.getOwnPropertyDescriptor, yA = Object.getOwnPropertyNames, vA = Object.prototype.hasOwnProperty, bA = (e, t) => {
  for (var r in t)
    Rm(e, r, { get: t[r], enumerable: !0 });
}, wA = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of yA(t))
      !vA.call(e, i) && i !== r && Rm(e, i, { get: () => t[i], enumerable: !(n = gA(t, i)) || n.enumerable });
  return e;
}, _A = (e) => wA(Rm({}, "__esModule", { value: !0 }), e), E2 = {};
bA(E2, {
  Address: () => Vn,
  AppId: () => U2,
  Argument: () => qi,
  CallArg: () => M2,
  Command: () => I2,
  CompressedSignature: () => z2,
  GasData: () => N2,
  Intent: () => F2,
  IntentMessage: () => V2,
  IntentScope: () => L2,
  IntentVersion: () => B2,
  MultiSig: () => TA,
  MultiSigPkMap: () => q2,
  MultiSigPublicKey: () => H2,
  ObjectArg: () => A2,
  ObjectDigest: () => T2,
  Owner: () => EA,
  PasskeyAuthenticator: () => AA,
  ProgrammableMoveCall: () => O2,
  ProgrammableTransaction: () => k2,
  PublicKey: () => W2,
  SenderSignedData: () => CA,
  SenderSignedTransaction: () => K2,
  SharedObjectRef: () => C2,
  StructTag: () => P2,
  SuiObjectRef: () => Pf,
  TransactionData: () => D2,
  TransactionDataV1: () => $2,
  TransactionExpiration: () => R2,
  TransactionKind: () => j2,
  TypeTag: () => $m,
  base64String: () => G2
});
var Pm = _A(E2), Me = on, qc = Bn, dy = S2;
function xA(e) {
  return Me.bcs.u64({
    name: "unsafe_u64",
    ...e
  }).transform({
    input: (t) => t,
    output: (t) => Number(t)
  });
}
function SA(e) {
  return Me.bcs.enum("Option", {
    None: null,
    Some: e
  });
}
const Vn = Me.bcs.bytes(qc.SUI_ADDRESS_LENGTH).transform({
  validate: (e) => {
    const t = typeof e == "string" ? e : (0, Me.toHex)(e);
    if (!t || !(0, qc.isValidSuiAddress)((0, qc.normalizeSuiAddress)(t)))
      throw new Error(`Invalid Sui address ${t}`);
  },
  input: (e) => typeof e == "string" ? (0, Me.fromHex)((0, qc.normalizeSuiAddress)(e)) : e,
  output: (e) => (0, qc.normalizeSuiAddress)((0, Me.toHex)(e))
}), T2 = Me.bcs.vector(Me.bcs.u8()).transform({
  name: "ObjectDigest",
  input: (e) => (0, Me.fromBase58)(e),
  output: (e) => (0, Me.toBase58)(new Uint8Array(e)),
  validate: (e) => {
    if ((0, Me.fromBase58)(e).length !== 32)
      throw new Error("ObjectDigest must be 32 bytes");
  }
}), Pf = Me.bcs.struct("SuiObjectRef", {
  objectId: Vn,
  version: Me.bcs.u64(),
  digest: T2
}), C2 = Me.bcs.struct("SharedObjectRef", {
  objectId: Vn,
  initialSharedVersion: Me.bcs.u64(),
  mutable: Me.bcs.bool()
}), A2 = Me.bcs.enum("ObjectArg", {
  ImmOrOwnedObject: Pf,
  SharedObject: C2,
  Receiving: Pf
}), EA = Me.bcs.enum("Owner", {
  AddressOwner: Vn,
  ObjectOwner: Vn,
  Shared: Me.bcs.struct("Shared", {
    initialSharedVersion: Me.bcs.u64()
  }),
  Immutable: null,
  ConsensusV2: Me.bcs.struct("ConsensusV2", {
    authenticator: Me.bcs.enum("Authenticator", {
      SingleOwner: Vn
    }),
    startVersion: Me.bcs.u64()
  })
}), M2 = Me.bcs.enum("CallArg", {
  Pure: Me.bcs.struct("Pure", {
    bytes: Me.bcs.vector(Me.bcs.u8()).transform({
      input: (e) => typeof e == "string" ? (0, Me.fromBase64)(e) : e,
      output: (e) => (0, Me.toBase64)(new Uint8Array(e))
    })
  }),
  Object: A2
}), Nm = Me.bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: Me.bcs.lazy(() => Nm),
  struct: Me.bcs.lazy(() => P2),
  u16: null,
  u32: null,
  u256: null
}), $m = Nm.transform({
  input: (e) => typeof e == "string" ? dy.TypeTagSerializer.parseFromStr(e, !0) : e,
  output: (e) => dy.TypeTagSerializer.tagToString(e)
}), qi = Me.bcs.enum("Argument", {
  GasCoin: null,
  Input: Me.bcs.u16(),
  Result: Me.bcs.u16(),
  NestedResult: Me.bcs.tuple([Me.bcs.u16(), Me.bcs.u16()])
}), O2 = Me.bcs.struct("ProgrammableMoveCall", {
  package: Vn,
  module: Me.bcs.string(),
  function: Me.bcs.string(),
  typeArguments: Me.bcs.vector($m),
  arguments: Me.bcs.vector(qi)
}), I2 = Me.bcs.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: O2,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: Me.bcs.struct("TransferObjects", {
    objects: Me.bcs.vector(qi),
    address: qi
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: Me.bcs.struct("SplitCoins", {
    coin: qi,
    amounts: Me.bcs.vector(qi)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: Me.bcs.struct("MergeCoins", {
    destination: qi,
    sources: Me.bcs.vector(qi)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: Me.bcs.struct("Publish", {
    modules: Me.bcs.vector(
      Me.bcs.vector(Me.bcs.u8()).transform({
        input: (e) => typeof e == "string" ? (0, Me.fromBase64)(e) : e,
        output: (e) => (0, Me.toBase64)(new Uint8Array(e))
      })
    ),
    dependencies: Me.bcs.vector(Vn)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: Me.bcs.struct("MakeMoveVec", {
    type: SA($m).transform({
      input: (e) => e === null ? {
        None: !0
      } : {
        Some: e
      },
      output: (e) => e.Some ?? null
    }),
    elements: Me.bcs.vector(qi)
  }),
  Upgrade: Me.bcs.struct("Upgrade", {
    modules: Me.bcs.vector(
      Me.bcs.vector(Me.bcs.u8()).transform({
        input: (e) => typeof e == "string" ? (0, Me.fromBase64)(e) : e,
        output: (e) => (0, Me.toBase64)(new Uint8Array(e))
      })
    ),
    dependencies: Me.bcs.vector(Vn),
    package: Vn,
    ticket: qi
  })
}), k2 = Me.bcs.struct("ProgrammableTransaction", {
  inputs: Me.bcs.vector(M2),
  commands: Me.bcs.vector(I2)
}), j2 = Me.bcs.enum("TransactionKind", {
  ProgrammableTransaction: k2,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
}), R2 = Me.bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: xA()
}), P2 = Me.bcs.struct("StructTag", {
  address: Vn,
  module: Me.bcs.string(),
  name: Me.bcs.string(),
  typeParams: Me.bcs.vector(Nm)
}), N2 = Me.bcs.struct("GasData", {
  payment: Me.bcs.vector(Pf),
  owner: Vn,
  price: Me.bcs.u64(),
  budget: Me.bcs.u64()
}), $2 = Me.bcs.struct("TransactionDataV1", {
  kind: j2,
  sender: Vn,
  gasData: N2,
  expiration: R2
}), D2 = Me.bcs.enum("TransactionData", {
  V1: $2
}), L2 = Me.bcs.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
}), B2 = Me.bcs.enum("IntentVersion", {
  V0: null
}), U2 = Me.bcs.enum("AppId", {
  Sui: null
}), F2 = Me.bcs.struct("Intent", {
  scope: L2,
  version: B2,
  appId: U2
});
function V2(e) {
  return Me.bcs.struct(`IntentMessage<${e.name}>`, {
    intent: F2,
    value: e
  });
}
const z2 = Me.bcs.enum("CompressedSignature", {
  ED25519: Me.bcs.fixedArray(64, Me.bcs.u8()),
  Secp256k1: Me.bcs.fixedArray(64, Me.bcs.u8()),
  Secp256r1: Me.bcs.fixedArray(64, Me.bcs.u8()),
  ZkLogin: Me.bcs.vector(Me.bcs.u8())
}), W2 = Me.bcs.enum("PublicKey", {
  ED25519: Me.bcs.fixedArray(32, Me.bcs.u8()),
  Secp256k1: Me.bcs.fixedArray(33, Me.bcs.u8()),
  Secp256r1: Me.bcs.fixedArray(33, Me.bcs.u8()),
  ZkLogin: Me.bcs.vector(Me.bcs.u8())
}), q2 = Me.bcs.struct("MultiSigPkMap", {
  pubKey: W2,
  weight: Me.bcs.u8()
}), H2 = Me.bcs.struct("MultiSigPublicKey", {
  pk_map: Me.bcs.vector(q2),
  threshold: Me.bcs.u16()
}), TA = Me.bcs.struct("MultiSig", {
  sigs: Me.bcs.vector(z2),
  bitmap: Me.bcs.u16(),
  multisig_pk: H2
}), G2 = Me.bcs.vector(Me.bcs.u8()).transform({
  input: (e) => typeof e == "string" ? (0, Me.fromBase64)(e) : e,
  output: (e) => (0, Me.toBase64)(new Uint8Array(e))
}), K2 = Me.bcs.struct("SenderSignedTransaction", {
  intentMessage: V2(D2),
  txSignatures: Me.bcs.vector(G2)
}), CA = Me.bcs.vector(K2, {
  name: "SenderSignedData"
}), AA = Me.bcs.struct("PasskeyAuthenticator", {
  authenticatorData: Me.bcs.vector(Me.bcs.u8()),
  clientDataJson: Me.bcs.string(),
  userSignature: Me.bcs.vector(Me.bcs.u8())
});
var Dm = Object.defineProperty, MA = Object.getOwnPropertyDescriptor, OA = Object.getOwnPropertyNames, IA = Object.prototype.hasOwnProperty, kA = (e, t) => {
  for (var r in t)
    Dm(e, r, { get: t[r], enumerable: !0 });
}, jA = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of OA(t))
      !IA.call(e, i) && i !== r && Dm(e, i, { get: () => t[i], enumerable: !(n = MA(t, i)) || n.enumerable });
  return e;
}, RA = (e) => jA(Dm({}, "__esModule", { value: !0 }), e), Y2 = {};
kA(Y2, {
  TransactionEffects: () => GA
});
var PA = RA(Y2), je = on, qt = Pm;
const NA = je.bcs.enum("PackageUpgradeError", {
  UnableToFetchPackage: je.bcs.struct("UnableToFetchPackage", { packageId: qt.Address }),
  NotAPackage: je.bcs.struct("NotAPackage", { objectId: qt.Address }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: je.bcs.struct("DigestDoesNotMatch", { digest: je.bcs.vector(je.bcs.u8()) }),
  UnknownUpgradePolicy: je.bcs.struct("UnknownUpgradePolicy", { policy: je.bcs.u8() }),
  PackageIDDoesNotMatch: je.bcs.struct("PackageIDDoesNotMatch", {
    packageId: qt.Address,
    ticketId: qt.Address
  })
}), $A = je.bcs.struct("ModuleId", {
  address: qt.Address,
  name: je.bcs.string()
}), hy = je.bcs.struct("MoveLocation", {
  module: $A,
  function: je.bcs.u16(),
  instruction: je.bcs.u16(),
  functionName: je.bcs.option(je.bcs.string())
}), DA = je.bcs.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: je.bcs.struct("IndexOutOfBounds", { idx: je.bcs.u16() }),
  SecondaryIndexOutOfBounds: je.bcs.struct("SecondaryIndexOutOfBounds", {
    resultIdx: je.bcs.u16(),
    secondaryIdx: je.bcs.u16()
  }),
  InvalidResultArity: je.bcs.struct("InvalidResultArity", { resultIdx: je.bcs.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
}), LA = je.bcs.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
}), BA = je.bcs.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: je.bcs.struct("MoveObjectTooBig", {
    objectSize: je.bcs.u64(),
    maxObjectSize: je.bcs.u64()
  }),
  MovePackageTooBig: je.bcs.struct("MovePackageTooBig", {
    objectSize: je.bcs.u64(),
    maxObjectSize: je.bcs.u64()
  }),
  CircularObjectOwnership: je.bcs.struct("CircularObjectOwnership", { object: qt.Address }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: je.bcs.option(hy),
  MoveAbort: je.bcs.tuple([hy, je.bcs.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: je.bcs.struct("CommandArgumentError", {
    argIdx: je.bcs.u16(),
    kind: DA
  }),
  TypeArgumentError: je.bcs.struct("TypeArgumentError", {
    argumentIdx: je.bcs.u16(),
    kind: LA
  }),
  UnusedValueWithoutDrop: je.bcs.struct("UnusedValueWithoutDrop", {
    resultIdx: je.bcs.u16(),
    secondaryIdx: je.bcs.u16()
  }),
  InvalidPublicFunctionReturnType: je.bcs.struct("InvalidPublicFunctionReturnType", {
    idx: je.bcs.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: je.bcs.struct("EffectsTooLarge", { currentSize: je.bcs.u64(), maxSize: je.bcs.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: je.bcs.struct("PackageUpgradeError", { upgradeError: NA }),
  WrittenObjectsTooLarge: je.bcs.struct("WrittenObjectsTooLarge", {
    currentSize: je.bcs.u64(),
    maxSize: je.bcs.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: je.bcs.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: je.bcs.vector(qt.Address)
    }
  ),
  AddressDeniedForCoin: je.bcs.struct("AddressDeniedForCoin", {
    address: qt.Address,
    coinType: je.bcs.string()
  }),
  CoinTypeGlobalPause: je.bcs.struct("CoinTypeGlobalPause", { coinType: je.bcs.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
}), X2 = je.bcs.enum("ExecutionStatus", {
  Success: null,
  Failed: je.bcs.struct("ExecutionFailed", {
    error: BA,
    command: je.bcs.option(je.bcs.u64())
  })
}), J2 = je.bcs.struct("GasCostSummary", {
  computationCost: je.bcs.u64(),
  storageCost: je.bcs.u64(),
  storageRebate: je.bcs.u64(),
  nonRefundableStorageFee: je.bcs.u64()
}), UA = je.bcs.struct("TransactionEffectsV1", {
  status: X2,
  executedEpoch: je.bcs.u64(),
  gasUsed: J2,
  modifiedAtVersions: je.bcs.vector(je.bcs.tuple([qt.Address, je.bcs.u64()])),
  sharedObjects: je.bcs.vector(qt.SuiObjectRef),
  transactionDigest: qt.ObjectDigest,
  created: je.bcs.vector(je.bcs.tuple([qt.SuiObjectRef, qt.Owner])),
  mutated: je.bcs.vector(je.bcs.tuple([qt.SuiObjectRef, qt.Owner])),
  unwrapped: je.bcs.vector(je.bcs.tuple([qt.SuiObjectRef, qt.Owner])),
  deleted: je.bcs.vector(qt.SuiObjectRef),
  unwrappedThenDeleted: je.bcs.vector(qt.SuiObjectRef),
  wrapped: je.bcs.vector(qt.SuiObjectRef),
  gasObject: je.bcs.tuple([qt.SuiObjectRef, qt.Owner]),
  eventsDigest: je.bcs.option(qt.ObjectDigest),
  dependencies: je.bcs.vector(qt.ObjectDigest)
}), Lm = je.bcs.tuple([je.bcs.u64(), qt.ObjectDigest]), FA = je.bcs.enum("ObjectIn", {
  NotExist: null,
  Exist: je.bcs.tuple([Lm, qt.Owner])
}), VA = je.bcs.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: je.bcs.tuple([qt.ObjectDigest, qt.Owner]),
  PackageWrite: Lm
}), zA = je.bcs.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
}), WA = je.bcs.struct("EffectsObjectChange", {
  inputState: FA,
  outputState: VA,
  idOperation: zA
}), qA = je.bcs.enum("UnchangedSharedKind", {
  ReadOnlyRoot: Lm,
  MutateDeleted: je.bcs.u64(),
  ReadDeleted: je.bcs.u64(),
  Cancelled: je.bcs.u64(),
  PerEpochConfig: null
}), HA = je.bcs.struct("TransactionEffectsV2", {
  status: X2,
  executedEpoch: je.bcs.u64(),
  gasUsed: J2,
  transactionDigest: qt.ObjectDigest,
  gasObjectIndex: je.bcs.option(je.bcs.u32()),
  eventsDigest: je.bcs.option(qt.ObjectDigest),
  dependencies: je.bcs.vector(qt.ObjectDigest),
  lamportVersion: je.bcs.u64(),
  changedObjects: je.bcs.vector(je.bcs.tuple([qt.Address, WA])),
  unchangedSharedObjects: je.bcs.vector(je.bcs.tuple([qt.Address, qA])),
  auxDataDigest: je.bcs.option(qt.ObjectDigest)
}), GA = je.bcs.enum("TransactionEffects", {
  V1: UA,
  V2: HA
});
var Bm = Object.defineProperty, KA = Object.getOwnPropertyDescriptor, YA = Object.getOwnPropertyNames, XA = Object.prototype.hasOwnProperty, JA = (e, t) => {
  for (var r in t)
    Bm(e, r, { get: t[r], enumerable: !0 });
}, ZA = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of YA(t))
      !XA.call(e, i) && i !== r && Bm(e, i, { get: () => t[i], enumerable: !(n = KA(t, i)) || n.enumerable });
  return e;
}, QA = (e) => ZA(Bm({}, "__esModule", { value: !0 }), e), Z2 = {};
JA(Z2, {
  pureBcsSchemaFromTypeName: () => i0
});
var Q2 = QA(Z2), $i = on, eM = Pm;
function i0(e) {
  switch (e) {
    case "u8":
      return $i.bcs.u8();
    case "u16":
      return $i.bcs.u16();
    case "u32":
      return $i.bcs.u32();
    case "u64":
      return $i.bcs.u64();
    case "u128":
      return $i.bcs.u128();
    case "u256":
      return $i.bcs.u256();
    case "bool":
      return $i.bcs.bool();
    case "string":
      return $i.bcs.string();
    case "id":
    case "address":
      return eM.Address;
  }
  const t = e.match(/^(vector|option)<(.+)>$/);
  if (t) {
    const [r, n] = t.slice(1);
    return r === "vector" ? $i.bcs.vector(i0(n)) : $i.bcs.option(i0(n));
  }
  throw new Error(`Invalid Pure type name: ${e}`);
}
var Um = Object.defineProperty, tM = Object.getOwnPropertyDescriptor, rM = Object.getOwnPropertyNames, nM = Object.prototype.hasOwnProperty, iM = (e, t) => {
  for (var r in t)
    Um(e, r, { get: t[r], enumerable: !0 });
}, sM = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of rM(t))
      !nM.call(e, i) && i !== r && Um(e, i, { get: () => t[i], enumerable: !(n = tM(t, i)) || n.enumerable });
  return e;
}, oM = (e) => sM(Um({}, "__esModule", { value: !0 }), e), e4 = {};
iM(e4, {
  BcsType: () => uM.BcsType,
  TypeTagSerializer: () => cM.TypeTagSerializer,
  bcs: () => fM,
  pureBcsSchemaFromTypeName: () => lM.pureBcsSchemaFromTypeName
});
var Ri = oM(e4), Di = on, Yt = Pm, aM = PA, cM = S2, uM = on, lM = Q2;
const fM = {
  ...Di.bcs,
  U8: Di.bcs.u8(),
  U16: Di.bcs.u16(),
  U32: Di.bcs.u32(),
  U64: Di.bcs.u64(),
  U128: Di.bcs.u128(),
  U256: Di.bcs.u256(),
  ULEB128: Di.bcs.uleb128(),
  Bool: Di.bcs.bool(),
  String: Di.bcs.string(),
  Address: Yt.Address,
  AppId: Yt.AppId,
  Argument: Yt.Argument,
  CallArg: Yt.CallArg,
  Command: Yt.Command,
  CompressedSignature: Yt.CompressedSignature,
  GasData: Yt.GasData,
  Intent: Yt.Intent,
  IntentMessage: Yt.IntentMessage,
  IntentScope: Yt.IntentScope,
  IntentVersion: Yt.IntentVersion,
  MultiSig: Yt.MultiSig,
  MultiSigPkMap: Yt.MultiSigPkMap,
  MultiSigPublicKey: Yt.MultiSigPublicKey,
  ObjectArg: Yt.ObjectArg,
  ObjectDigest: Yt.ObjectDigest,
  Owner: Yt.Owner,
  PasskeyAuthenticator: Yt.PasskeyAuthenticator,
  ProgrammableMoveCall: Yt.ProgrammableMoveCall,
  ProgrammableTransaction: Yt.ProgrammableTransaction,
  PublicKey: Yt.PublicKey,
  SenderSignedData: Yt.SenderSignedData,
  SenderSignedTransaction: Yt.SenderSignedTransaction,
  SharedObjectRef: Yt.SharedObjectRef,
  StructTag: Yt.StructTag,
  SuiObjectRef: Yt.SuiObjectRef,
  TransactionData: Yt.TransactionData,
  TransactionDataV1: Yt.TransactionDataV1,
  TransactionEffects: aM.TransactionEffects,
  TransactionExpiration: Yt.TransactionExpiration,
  TransactionKind: Yt.TransactionKind,
  TypeTag: Yt.TypeTag
};
var Fm = Object.defineProperty, dM = Object.getOwnPropertyDescriptor, hM = Object.getOwnPropertyNames, pM = Object.prototype.hasOwnProperty, mM = (e, t) => {
  for (var r in t)
    Fm(e, r, { get: t[r], enumerable: !0 });
}, gM = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of hM(t))
      !pM.call(e, i) && i !== r && Fm(e, i, { get: () => t[i], enumerable: !(n = dM(t, i)) || n.enumerable });
  return e;
}, yM = (e) => gM(Fm({}, "__esModule", { value: !0 }), e), t4 = {};
mM(t4, {
  formatAddress: () => bM,
  formatDigest: () => wM
});
var vM = yM(t4);
const r4 = "";
function bM(e) {
  if (e.length <= 6)
    return e;
  const t = e.startsWith("0x") ? 2 : 0;
  return `0x${e.slice(t, t + 4)}${r4}${e.slice(-4)}`;
}
function wM(e) {
  return `${e.slice(0, 10)}${r4}`;
}
var Vm = Object.defineProperty, _M = Object.getOwnPropertyDescriptor, xM = Object.getOwnPropertyNames, SM = Object.prototype.hasOwnProperty, EM = (e, t) => {
  for (var r in t)
    Vm(e, r, { get: t[r], enumerable: !0 });
}, TM = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of xM(t))
      !SM.call(e, i) && i !== r && Vm(e, i, { get: () => t[i], enumerable: !(n = _M(t, i)) || n.enumerable });
  return e;
}, CM = (e) => TM(Vm({}, "__esModule", { value: !0 }), e), n4 = {};
EM(n4, {
  MIST_PER_SUI: () => OM,
  MOVE_STDLIB_ADDRESS: () => IM,
  SUI_CLOCK_OBJECT_ID: () => jM,
  SUI_DECIMALS: () => MM,
  SUI_FRAMEWORK_ADDRESS: () => s4,
  SUI_SYSTEM_ADDRESS: () => kM,
  SUI_SYSTEM_MODULE_NAME: () => RM,
  SUI_SYSTEM_STATE_OBJECT_ID: () => NM,
  SUI_TYPE_ARG: () => PM
});
var AM = CM(n4), i4 = Bn;
const MM = 9, OM = BigInt(1e9), IM = "0x1", s4 = "0x2", kM = "0x3", jM = (0, i4.normalizeSuiObjectId)("0x6"), RM = "sui_system", PM = `${s4}::sui::SUI`, NM = (0, i4.normalizeSuiObjectId)("0x5");
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function $M(e) {
  return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array";
}
function s0(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error("positive integer expected, got " + e);
}
function zm(e, ...t) {
  if (!$M(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length);
}
function py(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function DM(e, t) {
  zm(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error("digestInto() expects output buffer of length at least " + r);
}
function Nf(e) {
  return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));
}
function o0(...e) {
  for (let t = 0; t < e.length; t++)
    e[t].fill(0);
}
const o4 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function a4(e) {
  return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
}
const Cs = o4 ? (e) => e : (e) => a4(e);
function LM(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = a4(e[t]);
  return e;
}
const $a = o4 ? (e) => e : LM;
function BM(e) {
  if (typeof e != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(e));
}
function fu(e) {
  return typeof e == "string" && (e = BM(e)), zm(e), e;
}
let UM = class {
};
function FM(e) {
  const t = (n, i) => e(i).update(fu(n)).digest(), r = e({});
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = (n) => e(n), t;
}
const VM = /* @__PURE__ */ Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]), Tl = /* @__PURE__ */ BigInt(2 ** 32 - 1), my = /* @__PURE__ */ BigInt(32);
function zM(e, t = !1) {
  return t ? { h: Number(e & Tl), l: Number(e >> my & Tl) } : { h: Number(e >> my & Tl) | 0, l: Number(e & Tl) | 0 };
}
const c4 = (e, t, r) => e >>> r | t << 32 - r, u4 = (e, t, r) => e << 32 - r | t >>> r, WM = (e, t, r) => e << 64 - r | t >>> r - 32, qM = (e, t, r) => e >>> r - 32 | t << 64 - r, HM = (e, t) => t, GM = (e, t) => e;
function l4(e, t, r, n) {
  const i = (t >>> 0) + (n >>> 0);
  return { h: e + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const f4 = (e, t, r) => (e >>> 0) + (t >>> 0) + (r >>> 0), d4 = (e, t, r, n) => t + r + n + (e / 2 ** 32 | 0) | 0, Pr = /* @__PURE__ */ Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]), Ye = /* @__PURE__ */ new Uint32Array(32);
function no(e, t, r, n, i, s) {
  const o = i[s], a = i[s + 1];
  let c = Ye[2 * e], u = Ye[2 * e + 1], l = Ye[2 * t], f = Ye[2 * t + 1], h = Ye[2 * r], v = Ye[2 * r + 1], b = Ye[2 * n], y = Ye[2 * n + 1], S = f4(c, l, o);
  u = d4(S, u, f, a), c = S | 0, { Dh: y, Dl: b } = { Dh: y ^ u, Dl: b ^ c }, { Dh: y, Dl: b } = { Dh: HM(y, b), Dl: GM(y) }, { h: v, l: h } = l4(v, h, y, b), { Bh: f, Bl: l } = { Bh: f ^ v, Bl: l ^ h }, { Bh: f, Bl: l } = { Bh: c4(f, l, 24), Bl: u4(f, l, 24) }, Ye[2 * e] = c, Ye[2 * e + 1] = u, Ye[2 * t] = l, Ye[2 * t + 1] = f, Ye[2 * r] = h, Ye[2 * r + 1] = v, Ye[2 * n] = b, Ye[2 * n + 1] = y;
}
function io(e, t, r, n, i, s) {
  const o = i[s], a = i[s + 1];
  let c = Ye[2 * e], u = Ye[2 * e + 1], l = Ye[2 * t], f = Ye[2 * t + 1], h = Ye[2 * r], v = Ye[2 * r + 1], b = Ye[2 * n], y = Ye[2 * n + 1], S = f4(c, l, o);
  u = d4(S, u, f, a), c = S | 0, { Dh: y, Dl: b } = { Dh: y ^ u, Dl: b ^ c }, { Dh: y, Dl: b } = { Dh: c4(y, b, 16), Dl: u4(y, b, 16) }, { h: v, l: h } = l4(v, h, y, b), { Bh: f, Bl: l } = { Bh: f ^ v, Bl: l ^ h }, { Bh: f, Bl: l } = { Bh: WM(f, l, 63), Bl: qM(f, l, 63) }, Ye[2 * e] = c, Ye[2 * e + 1] = u, Ye[2 * t] = l, Ye[2 * t + 1] = f, Ye[2 * r] = h, Ye[2 * r + 1] = v, Ye[2 * n] = b, Ye[2 * n + 1] = y;
}
function KM(e, t = {}, r, n, i) {
  if (s0(r), e < 0 || e > r)
    throw new Error("outputLen bigger than keyLen");
  const { key: s, salt: o, personalization: a } = t;
  if (s !== void 0 && (s.length < 1 || s.length > r))
    throw new Error("key length must be undefined or 1.." + r);
  if (o !== void 0 && o.length !== n)
    throw new Error("salt must be undefined or " + n);
  if (a !== void 0 && a.length !== i)
    throw new Error("personalization must be undefined or " + i);
}
class YM extends UM {
  constructor(t, r) {
    super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, s0(t), s0(r), this.blockLen = t, this.outputLen = r, this.buffer = new Uint8Array(t), this.buffer32 = Nf(this.buffer);
  }
  update(t) {
    py(this), t = fu(t), zm(t);
    const { blockLen: r, buffer: n, buffer32: i } = this, s = t.length, o = t.byteOffset, a = t.buffer;
    for (let c = 0; c < s; ) {
      this.pos === r && ($a(i), this.compress(i, 0, !1), $a(i), this.pos = 0);
      const u = Math.min(r - this.pos, s - c), l = o + c;
      if (u === r && !(l % 4) && c + u < s) {
        const f = new Uint32Array(a, l, Math.floor((s - c) / 4));
        $a(f);
        for (let h = 0; c + r < s; h += i.length, c += r)
          this.length += r, this.compress(f, h, !1);
        $a(f);
        continue;
      }
      n.set(t.subarray(c, c + u), this.pos), this.pos += u, this.length += u, c += u;
    }
    return this;
  }
  digestInto(t) {
    py(this), DM(t, this);
    const { pos: r, buffer32: n } = this;
    this.finished = !0, o0(this.buffer.subarray(r)), $a(n), this.compress(n, 0, !0), $a(n);
    const i = Nf(t);
    this.get().forEach((s, o) => i[o] = Cs(s));
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    const { buffer: r, length: n, finished: i, destroyed: s, outputLen: o, pos: a } = this;
    return t || (t = new this.constructor({ dkLen: o })), t.set(...this.get()), t.buffer.set(r), t.destroyed = s, t.finished = i, t.length = n, t.pos = a, t.outputLen = o, t;
  }
  clone() {
    return this._cloneInto();
  }
}
let h4 = class extends YM {
  constructor(t = {}) {
    const r = t.dkLen === void 0 ? 64 : t.dkLen;
    super(128, r), this.v0l = Pr[0] | 0, this.v0h = Pr[1] | 0, this.v1l = Pr[2] | 0, this.v1h = Pr[3] | 0, this.v2l = Pr[4] | 0, this.v2h = Pr[5] | 0, this.v3l = Pr[6] | 0, this.v3h = Pr[7] | 0, this.v4l = Pr[8] | 0, this.v4h = Pr[9] | 0, this.v5l = Pr[10] | 0, this.v5h = Pr[11] | 0, this.v6l = Pr[12] | 0, this.v6h = Pr[13] | 0, this.v7l = Pr[14] | 0, this.v7h = Pr[15] | 0, KM(r, t, 64, 16, 16);
    let { key: n, personalization: i, salt: s } = t, o = 0;
    if (n !== void 0 && (n = fu(n), o = n.length), this.v0l ^= this.outputLen | o << 8 | 65536 | 1 << 24, s !== void 0) {
      s = fu(s);
      const a = Nf(s);
      this.v4l ^= Cs(a[0]), this.v4h ^= Cs(a[1]), this.v5l ^= Cs(a[2]), this.v5h ^= Cs(a[3]);
    }
    if (i !== void 0) {
      i = fu(i);
      const a = Nf(i);
      this.v6l ^= Cs(a[0]), this.v6h ^= Cs(a[1]), this.v7l ^= Cs(a[2]), this.v7h ^= Cs(a[3]);
    }
    if (n !== void 0) {
      const a = new Uint8Array(this.blockLen);
      a.set(n), this.update(a);
    }
  }
  // prettier-ignore
  get() {
    let { v0l: t, v0h: r, v1l: n, v1h: i, v2l: s, v2h: o, v3l: a, v3h: c, v4l: u, v4h: l, v5l: f, v5h: h, v6l: v, v6h: b, v7l: y, v7h: S } = this;
    return [t, r, n, i, s, o, a, c, u, l, f, h, v, b, y, S];
  }
  // prettier-ignore
  set(t, r, n, i, s, o, a, c, u, l, f, h, v, b, y, S) {
    this.v0l = t | 0, this.v0h = r | 0, this.v1l = n | 0, this.v1h = i | 0, this.v2l = s | 0, this.v2h = o | 0, this.v3l = a | 0, this.v3h = c | 0, this.v4l = u | 0, this.v4h = l | 0, this.v5l = f | 0, this.v5h = h | 0, this.v6l = v | 0, this.v6h = b | 0, this.v7l = y | 0, this.v7h = S | 0;
  }
  compress(t, r, n) {
    this.get().forEach((c, u) => Ye[u] = c), Ye.set(Pr, 16);
    let { h: i, l: s } = zM(BigInt(this.length));
    Ye[24] = Pr[8] ^ s, Ye[25] = Pr[9] ^ i, n && (Ye[28] = ~Ye[28], Ye[29] = ~Ye[29]);
    let o = 0;
    const a = VM;
    for (let c = 0; c < 12; c++)
      no(0, 4, 8, 12, t, r + 2 * a[o++]), io(0, 4, 8, 12, t, r + 2 * a[o++]), no(1, 5, 9, 13, t, r + 2 * a[o++]), io(1, 5, 9, 13, t, r + 2 * a[o++]), no(2, 6, 10, 14, t, r + 2 * a[o++]), io(2, 6, 10, 14, t, r + 2 * a[o++]), no(3, 7, 11, 15, t, r + 2 * a[o++]), io(3, 7, 11, 15, t, r + 2 * a[o++]), no(0, 5, 10, 15, t, r + 2 * a[o++]), io(0, 5, 10, 15, t, r + 2 * a[o++]), no(1, 6, 11, 12, t, r + 2 * a[o++]), io(1, 6, 11, 12, t, r + 2 * a[o++]), no(2, 7, 8, 13, t, r + 2 * a[o++]), io(2, 7, 8, 13, t, r + 2 * a[o++]), no(3, 4, 9, 14, t, r + 2 * a[o++]), io(3, 4, 9, 14, t, r + 2 * a[o++]);
    this.v0l ^= Ye[0] ^ Ye[16], this.v0h ^= Ye[1] ^ Ye[17], this.v1l ^= Ye[2] ^ Ye[18], this.v1h ^= Ye[3] ^ Ye[19], this.v2l ^= Ye[4] ^ Ye[20], this.v2h ^= Ye[5] ^ Ye[21], this.v3l ^= Ye[6] ^ Ye[22], this.v3h ^= Ye[7] ^ Ye[23], this.v4l ^= Ye[8] ^ Ye[24], this.v4h ^= Ye[9] ^ Ye[25], this.v5l ^= Ye[10] ^ Ye[26], this.v5h ^= Ye[11] ^ Ye[27], this.v6l ^= Ye[12] ^ Ye[28], this.v6h ^= Ye[13] ^ Ye[29], this.v7l ^= Ye[14] ^ Ye[30], this.v7h ^= Ye[15] ^ Ye[31], o0(Ye);
  }
  destroy() {
    this.destroyed = !0, o0(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
const XM = /* @__PURE__ */ FM((e) => new h4(e)), JM = h4, Wm = XM, ZM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BLAKE2b: JM,
  blake2b: Wm
}, Symbol.toStringTag, { value: "Module" })), p4 = /* @__PURE__ */ Ec(ZM);
var qm = Object.defineProperty, QM = Object.getOwnPropertyDescriptor, eO = Object.getOwnPropertyNames, tO = Object.prototype.hasOwnProperty, rO = (e, t) => {
  for (var r in t)
    qm(e, r, { get: t[r], enumerable: !0 });
}, nO = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of eO(t))
      !tO.call(e, i) && i !== r && qm(e, i, { get: () => t[i], enumerable: !(n = QM(t, i)) || n.enumerable });
  return e;
}, iO = (e) => nO(qm({}, "__esModule", { value: !0 }), e), m4 = {};
rO(m4, {
  deriveDynamicFieldID: () => cO
});
var sO = iO(m4), oO = on, aO = p4, Bh = Ri;
function cO(e, t, r) {
  const n = Bh.bcs.Address.serialize(e).toBytes(), i = Bh.bcs.TypeTag.serialize(t).toBytes(), s = Bh.bcs.u64().serialize(r.length).toBytes(), o = aO.blake2b.create({
    dkLen: 32
  });
  return o.update(new Uint8Array([240])), o.update(n), o.update(s), o.update(r), o.update(i), `0x${(0, oO.toHex)(o.digest().slice(0, 32))}`;
}
var Hm = Object.defineProperty, uO = Object.getOwnPropertyDescriptor, lO = Object.getOwnPropertyNames, fO = Object.prototype.hasOwnProperty, dO = (e, t) => {
  for (var r in t)
    Hm(e, r, { get: t[r], enumerable: !0 });
}, hO = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of lO(t))
      !fO.call(e, i) && i !== r && Hm(e, i, { get: () => t[i], enumerable: !(n = uO(t, i)) || n.enumerable });
  return e;
}, pO = (e) => hO(Hm({}, "__esModule", { value: !0 }), e), g4 = {};
dO(g4, {
  MIST_PER_SUI: () => bs.MIST_PER_SUI,
  MOVE_STDLIB_ADDRESS: () => bs.MOVE_STDLIB_ADDRESS,
  SUI_ADDRESS_LENGTH: () => so.SUI_ADDRESS_LENGTH,
  SUI_CLOCK_OBJECT_ID: () => bs.SUI_CLOCK_OBJECT_ID,
  SUI_DECIMALS: () => bs.SUI_DECIMALS,
  SUI_FRAMEWORK_ADDRESS: () => bs.SUI_FRAMEWORK_ADDRESS,
  SUI_SYSTEM_ADDRESS: () => bs.SUI_SYSTEM_ADDRESS,
  SUI_SYSTEM_MODULE_NAME: () => bs.SUI_SYSTEM_MODULE_NAME,
  SUI_SYSTEM_STATE_OBJECT_ID: () => bs.SUI_SYSTEM_STATE_OBJECT_ID,
  SUI_TYPE_ARG: () => bs.SUI_TYPE_ARG,
  deriveDynamicFieldID: () => mO.deriveDynamicFieldID,
  formatAddress: () => gy.formatAddress,
  formatDigest: () => gy.formatDigest,
  fromB64: () => Li.fromB64,
  fromBase58: () => Li.fromBase58,
  fromBase64: () => Li.fromBase64,
  fromHEX: () => Li.fromHEX,
  fromHex: () => Li.fromHex,
  isValidNamedPackage: () => vy.isValidNamedPackage,
  isValidNamedType: () => vy.isValidNamedType,
  isValidSuiAddress: () => so.isValidSuiAddress,
  isValidSuiNSName: () => yy.isValidSuiNSName,
  isValidSuiObjectId: () => so.isValidSuiObjectId,
  isValidTransactionDigest: () => so.isValidTransactionDigest,
  normalizeStructTag: () => so.normalizeStructTag,
  normalizeSuiAddress: () => so.normalizeSuiAddress,
  normalizeSuiNSName: () => yy.normalizeSuiNSName,
  normalizeSuiObjectId: () => so.normalizeSuiObjectId,
  parseStructTag: () => so.parseStructTag,
  toB64: () => Li.toB64,
  toBase58: () => Li.toBase58,
  toBase64: () => Li.toBase64,
  toHEX: () => Li.toHEX,
  toHex: () => Li.toHex
});
var y4 = pO(g4), gy = vM, so = Bn, Li = on, yy = d2, bs = AM, vy = Am, mO = sO, Gm = Object.defineProperty, gO = Object.getOwnPropertyDescriptor, yO = Object.getOwnPropertyNames, vO = Object.prototype.hasOwnProperty, bO = (e, t) => {
  for (var r in t)
    Gm(e, r, { get: t[r], enumerable: !0 });
}, wO = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of yO(t))
      !vO.call(e, i) && i !== r && Gm(e, i, { get: () => t[i], enumerable: !(n = gO(t, i)) || n.enumerable });
  return e;
}, _O = (e) => wO(Gm({}, "__esModule", { value: !0 }), e), v4 = {};
bO(v4, {
  getPureBcsSchema: () => a0,
  isTxContext: () => IO,
  normalizedTypeToMoveTypeSignature: () => kO,
  pureBcsSchemaFromOpenMoveTypeSignatureBody: () => w4
});
var b4 = _O(v4), mr = Ri, by = y4, du = Bn;
const xO = "object", SO = "ID", EO = "ascii", TO = "String", CO = "string", AO = "String", MO = "option", OO = "Option";
function IO(e) {
  const t = typeof e.body == "object" && "datatype" in e.body ? e.body.datatype : null;
  return !!t && (0, du.normalizeSuiAddress)(t.package) === (0, du.normalizeSuiAddress)("0x2") && t.module === "tx_context" && t.type === "TxContext";
}
function a0(e) {
  if (typeof e == "string")
    switch (e) {
      case "address":
        return mr.bcs.Address;
      case "bool":
        return mr.bcs.Bool;
      case "u8":
        return mr.bcs.U8;
      case "u16":
        return mr.bcs.U16;
      case "u32":
        return mr.bcs.U32;
      case "u64":
        return mr.bcs.U64;
      case "u128":
        return mr.bcs.U128;
      case "u256":
        return mr.bcs.U256;
      default:
        throw new Error(`Unknown type signature ${e}`);
    }
  if ("vector" in e) {
    if (e.vector === "u8")
      return mr.bcs.vector(mr.bcs.U8).transform({
        input: (r) => typeof r == "string" ? new TextEncoder().encode(r) : r,
        output: (r) => r
      });
    const t = a0(e.vector);
    return t ? mr.bcs.vector(t) : null;
  }
  if ("datatype" in e) {
    const t = (0, du.normalizeSuiAddress)(e.datatype.package);
    if (t === (0, du.normalizeSuiAddress)(by.MOVE_STDLIB_ADDRESS)) {
      if (e.datatype.module === EO && e.datatype.type === TO || e.datatype.module === CO && e.datatype.type === AO)
        return mr.bcs.String;
      if (e.datatype.module === MO && e.datatype.type === OO) {
        const r = a0(e.datatype.typeParameters[0]);
        return r ? mr.bcs.vector(r) : null;
      }
    }
    if (t === (0, du.normalizeSuiAddress)(by.SUI_FRAMEWORK_ADDRESS) && e.datatype.module === xO && e.datatype.type === SO)
      return mr.bcs.Address;
  }
  return null;
}
function kO(e) {
  return typeof e == "object" && "Reference" in e ? {
    ref: "&",
    body: hu(e.Reference)
  } : typeof e == "object" && "MutableReference" in e ? {
    ref: "&mut",
    body: hu(e.MutableReference)
  } : {
    ref: null,
    body: hu(e)
  };
}
function hu(e) {
  if (typeof e == "string")
    switch (e) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${e}`);
    }
  if ("Vector" in e)
    return { vector: hu(e.Vector) };
  if ("Struct" in e)
    return {
      datatype: {
        package: e.Struct.address,
        module: e.Struct.module,
        type: e.Struct.name,
        typeParameters: e.Struct.typeArguments.map(hu)
      }
    };
  if ("TypeParameter" in e)
    return { typeParameter: e.TypeParameter };
  throw new Error(`Unexpected type ${JSON.stringify(e)}`);
}
function w4(e) {
  if (typeof e == "string")
    switch (e) {
      case "address":
        return mr.bcs.Address;
      case "bool":
        return mr.bcs.Bool;
      case "u8":
        return mr.bcs.U8;
      case "u16":
        return mr.bcs.U16;
      case "u32":
        return mr.bcs.U32;
      case "u64":
        return mr.bcs.U64;
      case "u128":
        return mr.bcs.U128;
      case "u256":
        return mr.bcs.U256;
      default:
        throw new Error(`Unknown type signature ${e}`);
    }
  if ("vector" in e)
    return mr.bcs.vector(w4(e.vector));
  throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(e)}`);
}
var Km = Object.defineProperty, jO = Object.getOwnPropertyDescriptor, RO = Object.getOwnPropertyNames, PO = Object.prototype.hasOwnProperty, NO = (e, t) => {
  for (var r in t)
    Km(e, r, { get: t[r], enumerable: !0 });
}, $O = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of RO(t))
      !PO.call(e, i) && i !== r && Km(e, i, { get: () => t[i], enumerable: !(n = jO(t, i)) || n.enumerable });
  return e;
}, DO = (e) => $O(Km({}, "__esModule", { value: !0 }), e), _4 = {};
NO(_4, {
  Inputs: () => UO
});
var Xu = DO(_4), LO = on, Uh = Bn;
function BO(e) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: e instanceof Uint8Array ? (0, LO.toBase64)(e) : e.toBase64()
    }
  };
}
const UO = {
  Pure: BO,
  ObjectRef({ objectId: e, digest: t, version: r }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest: t,
          version: r,
          objectId: (0, Uh.normalizeSuiAddress)(e)
        }
      }
    };
  },
  SharedObjectRef({
    objectId: e,
    mutable: t,
    initialSharedVersion: r
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable: t,
          initialSharedVersion: r,
          objectId: (0, Uh.normalizeSuiAddress)(e)
        }
      }
    };
  },
  ReceivingRef({ objectId: e, digest: t, version: r }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest: t,
          version: r,
          objectId: (0, Uh.normalizeSuiAddress)(e)
        }
      }
    };
  }
};
function x4() {
  return {
    kind: "transformation",
    type: "await",
    reference: x4,
    async: !0,
    async _run(e) {
      return e.value = await e.value, e;
    }
  };
}
var S4 = /^[A-Z]{6}(?!00)[A-Z\d]{2}(?:[A-Z\d]{3})?$/u, E4 = /^[a-z][\da-z]*$/u, T4 = /^\d+$/u, C4 = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu, A4 = /^[\p{Extended_Pictographic}\p{Emoji_Component}]+$/u, M4 = /^(?:0h|0x)?[\da-f]+$/iu, O4 = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/iu, I4 = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u, k4 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
  /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u
), j4 = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu, R4 = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu, P4 = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u, N4 = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u, $4 = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u, D4 = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u, L4 = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u, B4 = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u, U4 = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu, F4 = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu, V4 = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu, z4 = /^(?:0o)?[0-7]+$/iu, W4 = /^[\da-hjkmnp-tv-z]{26}$/iu, q4 = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu, Kn;
function FO(e) {
  Kn = { ...Kn, ...e };
}
function Ju(e) {
  return {
    lang: (e == null ? void 0 : e.lang) ?? (Kn == null ? void 0 : Kn.lang),
    message: e == null ? void 0 : e.message,
    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (Kn == null ? void 0 : Kn.abortEarly),
    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (Kn == null ? void 0 : Kn.abortPipeEarly)
  };
}
function VO() {
  Kn = void 0;
}
var Ds;
function zO(e, t) {
  Ds || (Ds = /* @__PURE__ */ new Map()), Ds.set(t, e);
}
function H4(e) {
  return Ds == null ? void 0 : Ds.get(e);
}
function WO(e) {
  Ds == null || Ds.delete(e);
}
var Ls;
function qO(e, t) {
  Ls || (Ls = /* @__PURE__ */ new Map()), Ls.set(t, e);
}
function G4(e) {
  return Ls == null ? void 0 : Ls.get(e);
}
function HO(e) {
  Ls == null || Ls.delete(e);
}
var xi;
function GO(e, t, r) {
  xi || (xi = /* @__PURE__ */ new Map()), xi.get(e) || xi.set(e, /* @__PURE__ */ new Map()), xi.get(e).set(r, t);
}
function K4(e, t) {
  var r;
  return (r = xi == null ? void 0 : xi.get(e)) == null ? void 0 : r.get(t);
}
function KO(e, t) {
  var r;
  (r = xi == null ? void 0 : xi.get(e)) == null || r.delete(t);
}
function xn(e) {
  var r, n;
  const t = typeof e;
  return t === "string" ? `"${e}"` : t === "number" || t === "bigint" || t === "boolean" ? `${e}` : t === "object" || t === "function" ? (e && ((n = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : n.name)) ?? "null" : t;
}
function Ae(e, t, r, n, i) {
  const s = i && "input" in i ? i.input : r.value, o = (i == null ? void 0 : i.expected) ?? e.expects ?? null, a = (i == null ? void 0 : i.received) ?? xn(s), c = {
    kind: e.kind,
    type: e.type,
    input: s,
    expected: o,
    received: a,
    message: `Invalid ${t}: ${o ? `Expected ${o} but r` : "R"}eceived ${a}`,
    // @ts-expect-error
    requirement: e.requirement,
    path: i == null ? void 0 : i.path,
    issues: i == null ? void 0 : i.issues,
    lang: n.lang,
    abortEarly: n.abortEarly,
    abortPipeEarly: n.abortPipeEarly
  }, u = e.kind === "schema", l = (i == null ? void 0 : i.message) ?? // @ts-expect-error
  e.message ?? K4(e.reference, c.lang) ?? (u ? G4(c.lang) : null) ?? n.message ?? H4(c.lang);
  l && (c.message = typeof l == "function" ? l(c) : l), u && (r.typed = !1), r.issues ? r.issues.push(c) : r.issues = [c];
}
var YO = /\D/gu;
function Ym(e) {
  const t = e.replace(YO, "");
  let r = t.length, n = 1, i = 0;
  for (; r; ) {
    const s = +t[--r];
    n ^= 1, i += n ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][s] : s;
  }
  return i % 10 === 0;
}
function Aa(e, t) {
  return Object.hasOwn(e, t) && t !== "__proto__" && t !== "prototype" && t !== "constructor";
}
function XO(e, t) {
  const r = {};
  for (const n of e)
    r[n] = t;
  return r;
}
function Y4(e) {
  if (e.path) {
    let t = "";
    for (const r of e.path)
      if (typeof r.key == "string" || typeof r.key == "number")
        t ? t += `.${r.key}` : t += r.key;
      else
        return null;
    return t;
  }
  return null;
}
function JO(e, t) {
  return t.kind === e;
}
function ZO(e, t) {
  return t.type === e;
}
function QO(e) {
  return e instanceof Sd;
}
var Sd = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(t) {
    super(t[0].message);
    /**
     * The error issues.
     */
    Pt(this, "issues");
    this.name = "ValiError", this.issues = t;
  }
};
function X4(e) {
  return {
    kind: "validation",
    type: "bic",
    reference: X4,
    async: !1,
    expects: null,
    requirement: S4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "BIC", t, r), t;
    }
  };
}
function J4(e) {
  return {
    kind: "transformation",
    type: "brand",
    reference: J4,
    async: !1,
    name: e,
    _run(t) {
      return t;
    }
  };
}
function Z4(e, t) {
  return {
    kind: "validation",
    type: "bytes",
    reference: Z4,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      if (r.typed) {
        const i = new TextEncoder().encode(r.value).length;
        i !== this.requirement && Ae(this, "bytes", r, n, {
          received: `${i}`
        });
      }
      return r;
    }
  };
}
function Cc(e, t) {
  return {
    kind: "validation",
    type: "check",
    reference: Cc,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement(r.value) && Ae(this, "input", r, n), r;
    }
  };
}
function Q4(e, t) {
  return {
    kind: "validation",
    type: "check",
    reference: Q4,
    async: !0,
    expects: null,
    requirement: e,
    message: t,
    async _run(r, n) {
      return r.typed && !await this.requirement(r.value) && Ae(this, "input", r, n), r;
    }
  };
}
function e6(e, t) {
  return {
    kind: "validation",
    type: "check_items",
    reference: e6,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      if (r.typed)
        for (let i = 0; i < r.value.length; i++) {
          const s = r.value[i];
          this.requirement(s, i, r.value) || Ae(this, "item", r, n, {
            input: s,
            path: [
              {
                type: "array",
                origin: "value",
                input: r.value,
                key: i,
                value: s
              }
            ]
          });
        }
      return r;
    }
  };
}
var eI = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u, tI = /[- ]/gu, rI = [
  // American Express
  /^3[47]\d{13}$/u,
  // Diners Club
  /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
  // Discover
  /^6(?:011|5\d{2})\d{12,15}$/u,
  // JCB
  /^(?:2131|1800|35\d{3})\d{11}$/u,
  // Mastercard
  /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
  // UnionPay
  /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
  // Visa
  /^4\d{12}(?:\d{3,6})?$/u
];
function t6(e) {
  return {
    kind: "validation",
    type: "credit_card",
    reference: t6,
    async: !1,
    expects: null,
    requirement(t) {
      let r;
      return eI.test(t) && // Remove any hyphens and blanks
      (r = t.replace(tI, "")) && // Check if it matches a provider
      rI.some((n) => n.test(r)) && // Check if passes luhn algorithm
      Ym(r);
    },
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "credit card", t, r), t;
    }
  };
}
function r6(e) {
  return {
    kind: "validation",
    type: "cuid2",
    reference: r6,
    async: !1,
    expects: null,
    requirement: E4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "Cuid2", t, r), t;
    }
  };
}
function n6(e) {
  return {
    kind: "validation",
    type: "decimal",
    reference: n6,
    async: !1,
    expects: null,
    requirement: T4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "decimal", t, r), t;
    }
  };
}
function i6(e) {
  return {
    kind: "validation",
    type: "email",
    reference: i6,
    expects: null,
    async: !1,
    requirement: C4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "email", t, r), t;
    }
  };
}
function s6(e) {
  return {
    kind: "validation",
    type: "emoji",
    reference: s6,
    async: !1,
    expects: null,
    requirement: A4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "emoji", t, r), t;
    }
  };
}
function o6(e) {
  return {
    kind: "validation",
    type: "empty",
    reference: o6,
    async: !1,
    expects: "0",
    message: e,
    _run(t, r) {
      return t.typed && t.value.length > 0 && Ae(this, "length", t, r, {
        received: `${t.value.length}`
      }), t;
    }
  };
}
function a6(e, t) {
  return {
    kind: "validation",
    type: "ends_with",
    reference: a6,
    async: !1,
    expects: `"${e}"`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.endsWith(this.requirement) && Ae(this, "end", r, n, {
        received: `"${r.value.slice(-this.requirement.length)}"`
      }), r;
    }
  };
}
function c6(e, t) {
  return {
    kind: "validation",
    type: "every_item",
    reference: c6,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.every(this.requirement) && Ae(this, "item", r, n), r;
    }
  };
}
function u6(e, t) {
  const r = xn(e);
  return {
    kind: "validation",
    type: "excludes",
    reference: u6,
    async: !1,
    expects: `!${r}`,
    requirement: e,
    message: t,
    _run(n, i) {
      return n.typed && n.value.includes(this.requirement) && Ae(this, "content", n, i, { received: r }), n;
    }
  };
}
function l6(e) {
  return {
    kind: "transformation",
    type: "filter_items",
    reference: l6,
    async: !1,
    operation: e,
    _run(t) {
      return t.value = t.value.filter(this.operation), t;
    }
  };
}
function f6(e) {
  return {
    kind: "transformation",
    type: "find_item",
    reference: f6,
    async: !1,
    operation: e,
    _run(t) {
      return t.value = t.value.find(this.operation), t;
    }
  };
}
function d6(e) {
  return {
    kind: "validation",
    type: "finite",
    reference: d6,
    async: !1,
    expects: null,
    requirement: Number.isFinite,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "finite", t, r), t;
    }
  };
}
var nI = {
  md4: 32,
  md5: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8,
  adler32: 8
};
function h6(e, t) {
  return {
    kind: "validation",
    type: "hash",
    reference: h6,
    expects: null,
    async: !1,
    requirement: RegExp(
      e.map((r) => `^[a-f0-9]{${nI[r]}}$`).join("|"),
      "iu"
    ),
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && Ae(this, "hash", r, n), r;
    }
  };
}
function p6(e) {
  return {
    kind: "validation",
    type: "hexadecimal",
    reference: p6,
    async: !1,
    expects: null,
    requirement: M4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "hexadecimal", t, r), t;
    }
  };
}
function m6(e) {
  return {
    kind: "validation",
    type: "hex_color",
    reference: m6,
    async: !1,
    expects: null,
    requirement: O4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "hex color", t, r), t;
    }
  };
}
function g6(e) {
  return {
    kind: "validation",
    type: "imei",
    reference: g6,
    async: !1,
    expects: null,
    requirement(t) {
      return I4.test(t) && Ym(t);
    },
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "IMEI", t, r), t;
    }
  };
}
function y6(e, t) {
  const r = xn(e);
  return {
    kind: "validation",
    type: "includes",
    reference: y6,
    async: !1,
    expects: r,
    requirement: e,
    message: t,
    _run(n, i) {
      return n.typed && !n.value.includes(this.requirement) && Ae(this, "content", n, i, {
        received: `!${r}`
      }), n;
    }
  };
}
function wr(e) {
  return {
    kind: "validation",
    type: "integer",
    reference: wr,
    async: !1,
    expects: null,
    requirement: Number.isInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "integer", t, r), t;
    }
  };
}
function v6(e) {
  return {
    kind: "validation",
    type: "ip",
    reference: v6,
    async: !1,
    expects: null,
    requirement: R4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "IP", t, r), t;
    }
  };
}
function b6(e) {
  return {
    kind: "validation",
    type: "ipv4",
    reference: b6,
    async: !1,
    expects: null,
    requirement: k4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "IPv4", t, r), t;
    }
  };
}
function w6(e) {
  return {
    kind: "validation",
    type: "ipv6",
    reference: w6,
    async: !1,
    expects: null,
    requirement: j4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "IPv6", t, r), t;
    }
  };
}
function _6(e) {
  return {
    kind: "validation",
    type: "iso_date",
    reference: _6,
    async: !1,
    expects: null,
    requirement: P4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "date", t, r), t;
    }
  };
}
function x6(e) {
  return {
    kind: "validation",
    type: "iso_date_time",
    reference: x6,
    async: !1,
    expects: null,
    requirement: N4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "date-time", t, r), t;
    }
  };
}
function S6(e) {
  return {
    kind: "validation",
    type: "iso_time",
    reference: S6,
    async: !1,
    expects: null,
    requirement: $4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "time", t, r), t;
    }
  };
}
function E6(e) {
  return {
    kind: "validation",
    type: "iso_time_second",
    reference: E6,
    async: !1,
    expects: null,
    requirement: D4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "time-second", t, r), t;
    }
  };
}
function T6(e) {
  return {
    kind: "validation",
    type: "iso_timestamp",
    reference: T6,
    async: !1,
    expects: null,
    requirement: L4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "timestamp", t, r), t;
    }
  };
}
function C6(e) {
  return {
    kind: "validation",
    type: "iso_week",
    reference: C6,
    async: !1,
    expects: null,
    requirement: B4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "week", t, r), t;
    }
  };
}
function A6(e, t) {
  return {
    kind: "validation",
    type: "length",
    reference: A6,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length !== this.requirement && Ae(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function M6(e) {
  return {
    kind: "validation",
    type: "mac",
    reference: M6,
    async: !1,
    expects: null,
    requirement: V4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "MAC", t, r), t;
    }
  };
}
function O6(e) {
  return {
    kind: "validation",
    type: "mac48",
    reference: O6,
    async: !1,
    expects: null,
    requirement: U4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "48-bit MAC", t, r), t;
    }
  };
}
function I6(e) {
  return {
    kind: "validation",
    type: "mac64",
    reference: I6,
    async: !1,
    expects: null,
    requirement: F4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "64-bit MAC", t, r), t;
    }
  };
}
function k6(e) {
  return {
    kind: "transformation",
    type: "map_items",
    reference: k6,
    async: !1,
    operation: e,
    _run(t) {
      return t.value = t.value.map(this.operation), t;
    }
  };
}
function j6(e, t) {
  return {
    kind: "validation",
    type: "max_bytes",
    reference: j6,
    async: !1,
    expects: `<=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      if (r.typed) {
        const i = new TextEncoder().encode(r.value).length;
        i > this.requirement && Ae(this, "bytes", r, n, {
          received: `${i}`
        });
      }
      return r;
    }
  };
}
function R6(e, t) {
  return {
    kind: "validation",
    type: "max_length",
    reference: R6,
    async: !1,
    expects: `<=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length > this.requirement && Ae(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function P6(e, t) {
  return {
    kind: "validation",
    type: "max_size",
    reference: P6,
    async: !1,
    expects: `<=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.size > this.requirement && Ae(this, "size", r, n, {
        received: `${r.value.size}`
      }), r;
    }
  };
}
function N6(e, t) {
  return {
    kind: "validation",
    type: "max_value",
    reference: N6,
    async: !1,
    expects: `<=${e instanceof Date ? e.toJSON() : xn(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value > this.requirement && Ae(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : xn(r.value)
      }), r;
    }
  };
}
function $6(e, t) {
  return {
    kind: "validation",
    type: "mime_type",
    reference: $6,
    async: !1,
    expects: e.map((r) => `"${r}"`).join(" | ") || "never",
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.includes(r.value.type) && Ae(this, "MIME type", r, n, {
        received: `"${r.value.type}"`
      }), r;
    }
  };
}
function D6(e, t) {
  return {
    kind: "validation",
    type: "min_bytes",
    reference: D6,
    async: !1,
    expects: `>=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      if (r.typed) {
        const i = new TextEncoder().encode(r.value).length;
        i < this.requirement && Ae(this, "bytes", r, n, {
          received: `${i}`
        });
      }
      return r;
    }
  };
}
function L6(e, t) {
  return {
    kind: "validation",
    type: "min_length",
    reference: L6,
    async: !1,
    expects: `>=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length < this.requirement && Ae(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function B6(e, t) {
  return {
    kind: "validation",
    type: "min_size",
    reference: B6,
    async: !1,
    expects: `>=${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.size < this.requirement && Ae(this, "size", r, n, {
        received: `${r.value.size}`
      }), r;
    }
  };
}
function U6(e, t) {
  return {
    kind: "validation",
    type: "min_value",
    reference: U6,
    async: !1,
    expects: `>=${e instanceof Date ? e.toJSON() : xn(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value < this.requirement && Ae(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : xn(r.value)
      }), r;
    }
  };
}
function F6(e, t) {
  return {
    kind: "validation",
    type: "multiple_of",
    reference: F6,
    async: !1,
    expects: `%${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value % this.requirement !== 0 && Ae(this, "multiple", r, n), r;
    }
  };
}
function V6(e) {
  return {
    kind: "validation",
    type: "non_empty",
    reference: V6,
    async: !1,
    expects: "!0",
    message: e,
    _run(t, r) {
      return t.typed && t.value.length === 0 && Ae(this, "length", t, r, {
        received: "0"
      }), t;
    }
  };
}
function z6(e) {
  return {
    kind: "transformation",
    type: "normalize",
    reference: z6,
    async: !1,
    form: e,
    _run(t) {
      return t.value = t.value.normalize(this.form), t;
    }
  };
}
function W6(e, t) {
  return {
    kind: "validation",
    type: "not_bytes",
    reference: W6,
    async: !1,
    expects: `!${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      if (r.typed) {
        const i = new TextEncoder().encode(r.value).length;
        i === this.requirement && Ae(this, "bytes", r, n, {
          received: `${i}`
        });
      }
      return r;
    }
  };
}
function q6(e, t) {
  return {
    kind: "validation",
    type: "not_length",
    reference: q6,
    async: !1,
    expects: `!${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.length === this.requirement && Ae(this, "length", r, n, {
        received: `${r.value.length}`
      }), r;
    }
  };
}
function H6(e, t) {
  return {
    kind: "validation",
    type: "not_size",
    reference: H6,
    async: !1,
    expects: `!${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.size === this.requirement && Ae(this, "size", r, n, {
        received: `${r.value.size}`
      }), r;
    }
  };
}
function G6(e, t) {
  return {
    kind: "validation",
    type: "not_value",
    reference: G6,
    async: !1,
    expects: e instanceof Date ? `!${e.toJSON()}` : `!${xn(e)}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && this.requirement <= r.value && this.requirement >= r.value && Ae(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : xn(r.value)
      }), r;
    }
  };
}
function K6(e) {
  return {
    kind: "validation",
    type: "octal",
    reference: K6,
    async: !1,
    expects: null,
    requirement: z4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "octal", t, r), t;
    }
  };
}
function Y6(e, t) {
  var r;
  if (e.issues)
    for (const n of t)
      for (const i of e.issues) {
        let s = !1;
        const o = Math.min(n.length, ((r = i.path) == null ? void 0 : r.length) ?? 0);
        for (let a = 0; a < o; a++)
          if (n[a] !== i.path[a].key) {
            s = !0;
            break;
          }
        if (!s)
          return !1;
      }
  return !0;
}
function X6(e, t, r) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: X6,
    async: !1,
    expects: null,
    requirement: t,
    message: r,
    _run(n, i) {
      return Y6(n, e) && // @ts-expect-error
      !this.requirement(n.value) && Ae(this, "input", n, i), n;
    }
  };
}
function J6(e, t, r) {
  return {
    kind: "validation",
    type: "partial_check",
    reference: J6,
    async: !0,
    expects: null,
    requirement: t,
    message: r,
    async _run(n, i) {
      return Y6(n, e) && // @ts-expect-error
      !await this.requirement(n.value) && Ae(this, "input", n, i), n;
    }
  };
}
function Z6(e) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: Z6,
    async: !1,
    expects: null,
    _run(t, r) {
      return e({
        dataset: t,
        config: r,
        addIssue: (n) => Ae(this, (n == null ? void 0 : n.label) ?? "input", t, r, n)
      }), t;
    }
  };
}
function Q6(e) {
  return {
    kind: "validation",
    type: "raw_check",
    reference: Q6,
    async: !0,
    expects: null,
    async _run(t, r) {
      return await e({
        dataset: t,
        config: r,
        addIssue: (n) => Ae(this, (n == null ? void 0 : n.label) ?? "input", t, r, n)
      }), t;
    }
  };
}
function e8(e) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: e8,
    async: !1,
    _run(t, r) {
      const n = e({
        dataset: t,
        config: r,
        addIssue: (i) => Ae(this, (i == null ? void 0 : i.label) ?? "input", t, r, i),
        NEVER: null
      });
      return t.issues ? t.typed = !1 : t.value = n, t;
    }
  };
}
function t8(e) {
  return {
    kind: "transformation",
    type: "raw_transform",
    reference: t8,
    async: !0,
    async _run(t, r) {
      const n = await e({
        dataset: t,
        config: r,
        addIssue: (i) => Ae(this, (i == null ? void 0 : i.label) ?? "input", t, r, i),
        NEVER: null
      });
      return t.issues ? t.typed = !1 : t.value = n, t;
    }
  };
}
function r8() {
  return {
    kind: "transformation",
    type: "readonly",
    reference: r8,
    async: !1,
    _run(e) {
      return e;
    }
  };
}
function n8(e, t) {
  return {
    kind: "transformation",
    type: "reduce_items",
    reference: n8,
    async: !1,
    operation: e,
    initial: t,
    _run(r) {
      return r.value = r.value.reduce(this.operation, this.initial), r;
    }
  };
}
function i8(e, t) {
  return {
    kind: "validation",
    type: "regex",
    reference: i8,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !this.requirement.test(r.value) && Ae(this, "format", r, n), r;
    }
  };
}
function s8(e) {
  return {
    kind: "validation",
    type: "safe_integer",
    reference: s8,
    async: !1,
    expects: null,
    requirement: Number.isSafeInteger,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "safe integer", t, r), t;
    }
  };
}
function o8(e, t) {
  return {
    kind: "validation",
    type: "size",
    reference: o8,
    async: !1,
    expects: `${e}`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && r.value.size !== this.requirement && Ae(this, "size", r, n, {
        received: `${r.value.size}`
      }), r;
    }
  };
}
function a8(e, t) {
  return {
    kind: "validation",
    type: "some_item",
    reference: a8,
    async: !1,
    expects: null,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.some(this.requirement) && Ae(this, "item", r, n), r;
    }
  };
}
function c8(e) {
  return {
    kind: "transformation",
    type: "sort_items",
    reference: c8,
    async: !1,
    operation: e,
    _run(t) {
      return t.value = t.value.sort(this.operation), t;
    }
  };
}
function u8(e, t) {
  return {
    kind: "validation",
    type: "starts_with",
    reference: u8,
    async: !1,
    expects: `"${e}"`,
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !r.value.startsWith(this.requirement) && Ae(this, "start", r, n, {
        received: `"${r.value.slice(0, this.requirement.length)}"`
      }), r;
    }
  };
}
function l8() {
  return {
    kind: "transformation",
    type: "to_lower_case",
    reference: l8,
    async: !1,
    _run(e) {
      return e.value = e.value.toLowerCase(), e;
    }
  };
}
function f8(e) {
  return {
    kind: "transformation",
    type: "to_max_value",
    reference: f8,
    async: !1,
    requirement: e,
    _run(t) {
      return t.value = t.value > this.requirement ? this.requirement : t.value, t;
    }
  };
}
function d8(e) {
  return {
    kind: "transformation",
    type: "to_min_value",
    reference: d8,
    async: !1,
    requirement: e,
    _run(t) {
      return t.value = t.value < this.requirement ? this.requirement : t.value, t;
    }
  };
}
function h8() {
  return {
    kind: "transformation",
    type: "to_upper_case",
    reference: h8,
    async: !1,
    _run(e) {
      return e.value = e.value.toUpperCase(), e;
    }
  };
}
function Zu(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: Zu,
    async: !1,
    operation: e,
    _run(t) {
      return t.value = this.operation(t.value), t;
    }
  };
}
function p8(e) {
  return {
    kind: "transformation",
    type: "transform",
    reference: p8,
    async: !0,
    operation: e,
    async _run(t) {
      return t.value = await this.operation(t.value), t;
    }
  };
}
function m8() {
  return {
    kind: "transformation",
    type: "trim",
    reference: m8,
    async: !1,
    _run(e) {
      return e.value = e.value.trim(), e;
    }
  };
}
function g8() {
  return {
    kind: "transformation",
    type: "trim_end",
    reference: g8,
    async: !1,
    _run(e) {
      return e.value = e.value.trimEnd(), e;
    }
  };
}
function y8() {
  return {
    kind: "transformation",
    type: "trim_start",
    reference: y8,
    async: !1,
    _run(e) {
      return e.value = e.value.trimStart(), e;
    }
  };
}
function v8(e) {
  return {
    kind: "validation",
    type: "ulid",
    reference: v8,
    async: !1,
    expects: null,
    requirement: W4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "ULID", t, r), t;
    }
  };
}
function b8(e) {
  return {
    kind: "validation",
    type: "url",
    reference: b8,
    async: !1,
    expects: null,
    requirement(t) {
      try {
        return new URL(t), !0;
      } catch {
        return !1;
      }
    },
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement(t.value) && Ae(this, "URL", t, r), t;
    }
  };
}
function w8(e) {
  return {
    kind: "validation",
    type: "uuid",
    reference: w8,
    async: !1,
    expects: null,
    requirement: q4,
    message: e,
    _run(t, r) {
      return t.typed && !this.requirement.test(t.value) && Ae(this, "UUID", t, r), t;
    }
  };
}
function _8(e, t) {
  return {
    kind: "validation",
    type: "value",
    reference: _8,
    async: !1,
    expects: e instanceof Date ? e.toJSON() : xn(e),
    requirement: e,
    message: t,
    _run(r, n) {
      return r.typed && !(this.requirement <= r.value && this.requirement >= r.value) && Ae(this, "value", r, n, {
        received: r.value instanceof Date ? r.value.toJSON() : xn(r.value)
      }), r;
    }
  };
}
function iI(e, t) {
  return {
    ...e,
    _run(r, n) {
      return e._run(r, { ...n, ...t });
    }
  };
}
function Qu(e, t, r) {
  return typeof e.fallback == "function" ? (
    // @ts-expect-error
    e.fallback(t, r)
  ) : (
    // @ts-expect-error
    e.fallback
  );
}
function sI(e, t) {
  return {
    ...e,
    fallback: t,
    _run(r, n) {
      return e._run(r, n), r.issues ? { typed: !0, value: Qu(this, r, n) } : r;
    }
  };
}
function oI(e, t) {
  return {
    ...e,
    fallback: t,
    async: !0,
    async _run(r, n) {
      return e._run(r, n), r.issues ? (
        // @ts-expect-error
        { typed: !0, value: await Qu(this, r, n) }
      ) : r;
    }
  };
}
function aI(e) {
  const t = {};
  for (const r of e)
    if (r.path) {
      const n = Y4(r);
      n ? (t.nested || (t.nested = {}), t.nested[n] ? t.nested[n].push(r.message) : t.nested[n] = [r.message]) : t.other ? t.other.push(r.message) : t.other = [r.message];
    } else
      t.root ? t.root.push(r.message) : t.root = [r.message];
  return t;
}
function cI(e, t) {
  return {
    ...e,
    _run(r, n) {
      const i = r.issues && [...r.issues];
      if (e._run(r, n), r.issues) {
        for (const s of r.issues)
          if (!(i != null && i.includes(s))) {
            let o = r.value;
            for (const a of t) {
              const c = o[a], u = {
                type: "unknown",
                origin: "value",
                input: o,
                key: a,
                value: c
              };
              if (s.path ? s.path.push(u) : s.path = [u], !c)
                break;
              o = c;
            }
          }
      }
      return r;
    }
  };
}
function uI(e, t) {
  return {
    ...e,
    async: !0,
    async _run(r, n) {
      const i = r.issues && [...r.issues];
      if (await e._run(r, n), r.issues) {
        for (const s of r.issues)
          if (!(i != null && i.includes(s))) {
            let o = r.value;
            for (const a of t) {
              const c = o[a], u = {
                type: "unknown",
                origin: "value",
                input: o,
                key: a,
                value: c
              };
              if (s.path ? s.path.push(u) : s.path = [u], !c)
                break;
              o = c;
            }
          }
      }
      return r;
    }
  };
}
function Js(e, t, r) {
  return typeof e.default == "function" ? (
    // @ts-expect-error
    e.default(t, r)
  ) : (
    // @ts-expect-error
    e.default
  );
}
function c0(e) {
  if ("entries" in e) {
    const t = {};
    for (const r in e.entries)
      t[r] = c0(e.entries[r]);
    return t;
  }
  return "items" in e ? e.items.map(c0) : Js(e);
}
async function u0(e) {
  return "entries" in e ? Object.fromEntries(
    await Promise.all(
      Object.entries(e.entries).map(async ([t, r]) => [
        t,
        await u0(r)
      ])
    )
  ) : "items" in e ? Promise.all(e.items.map(u0)) : Js(e);
}
function l0(e) {
  if ("entries" in e) {
    const t = {};
    for (const r in e.entries)
      t[r] = l0(e.entries[r]);
    return t;
  }
  return "items" in e ? e.items.map(l0) : Qu(e);
}
async function f0(e) {
  return "entries" in e ? Object.fromEntries(
    await Promise.all(
      Object.entries(e.entries).map(async ([t, r]) => [
        t,
        await f0(r)
      ])
    )
  ) : "items" in e ? Promise.all(e.items.map(f0)) : Qu(e);
}
function $f(e, t) {
  return !e._run({ typed: !1, value: t }, { abortEarly: !0 }).issues;
}
function x8() {
  return {
    kind: "schema",
    type: "any",
    reference: x8,
    expects: "any",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
function St(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: St,
    expects: "Array",
    async: !1,
    item: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let o = 0; o < i.length; o++) {
          const a = i[o], c = this.item._run({ typed: !1, value: a }, n);
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function S8(e, t) {
  return {
    kind: "schema",
    type: "array",
    reference: S8,
    expects: "Array",
    async: !0,
    item: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        const o = await Promise.all(
          i.map((a) => this.item._run({ typed: !1, value: a }, n))
        );
        for (let a = 0; a < o.length; a++) {
          const c = o[a];
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: a,
              value: i[a]
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function el(e) {
  return {
    kind: "schema",
    type: "bigint",
    reference: el,
    expects: "bigint",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "bigint" ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function E8(e) {
  return {
    kind: "schema",
    type: "blob",
    reference: E8,
    expects: "Blob",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value instanceof Blob ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function tl(e) {
  return {
    kind: "schema",
    type: "boolean",
    reference: tl,
    expects: "boolean",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "boolean" ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function T8(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: T8,
    expects: "unknown",
    async: !1,
    check: e,
    message: t,
    _run(r, n) {
      return this.check(r.value) ? r.typed = !0 : Ae(this, "type", r, n), r;
    }
  };
}
function C8(e, t) {
  return {
    kind: "schema",
    type: "custom",
    reference: C8,
    expects: "unknown",
    async: !0,
    check: e,
    message: t,
    async _run(r, n) {
      return await this.check(r.value) ? r.typed = !0 : Ae(this, "type", r, n), r;
    }
  };
}
function A8(e) {
  return {
    kind: "schema",
    type: "date",
    reference: A8,
    expects: "Date",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value instanceof Date ? isNaN(t.value) ? Ae(this, "type", t, r, {
        received: '"Invalid Date"'
      }) : t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function d0(e, t) {
  const r = Object.entries(e).filter(([n]) => isNaN(+n)).map(([, n]) => n);
  return {
    kind: "schema",
    type: "enum",
    reference: d0,
    expects: r.map(xn).join(" | ") || "never",
    async: !1,
    enum: e,
    options: r,
    message: t,
    _run(n, i) {
      return this.options.includes(n.value) ? n.typed = !0 : Ae(this, "type", n, i), n;
    }
  };
}
function M8(e) {
  return {
    kind: "schema",
    type: "file",
    reference: M8,
    expects: "File",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value instanceof File ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function h0(e) {
  return {
    kind: "schema",
    type: "function",
    reference: h0,
    expects: "Function",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "function" ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function O8(e, t) {
  return {
    kind: "schema",
    type: "instance",
    reference: O8,
    expects: e.name,
    async: !1,
    class: e,
    message: t,
    _run(r, n) {
      return r.value instanceof this.class ? r.typed = !0 : Ae(this, "type", r, n), r;
    }
  };
}
function Df(e, t) {
  if (typeof e == typeof t) {
    if (e === t || e instanceof Date && t instanceof Date && +e == +t)
      return { value: e };
    if (e && t && e.constructor === Object && t.constructor === Object) {
      for (const r in t)
        if (r in e) {
          const n = Df(e[r], t[r]);
          if (n.issue)
            return n;
          e[r] = n.value;
        } else
          e[r] = t[r];
      return { value: e };
    }
    if (Array.isArray(e) && Array.isArray(t) && e.length === t.length) {
      for (let r = 0; r < e.length; r++) {
        const n = Df(e[r], t[r]);
        if (n.issue)
          return n;
        e[r] = n.value;
      }
      return { value: e };
    }
  }
  return { issue: !0 };
}
function I8(e, t) {
  return {
    kind: "schema",
    type: "intersect",
    reference: I8,
    expects: [...new Set(e.map((r) => r.expects))].join(" & ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      if (this.options.length) {
        const i = r.value;
        let s;
        r.typed = !0;
        for (const o of this.options) {
          const a = o._run(
            { typed: !1, value: i },
            n
          );
          if (a.issues && (r.issues ? r.issues.push(...a.issues) : r.issues = a.issues, n.abortEarly)) {
            r.typed = !1;
            break;
          }
          a.typed || (r.typed = !1), r.typed && (s ? s.push(a.value) : s = [a.value]);
        }
        if (r.typed) {
          r.value = s[0];
          for (let o = 1; o < s.length; o++) {
            const a = Df(r.value, s[o]);
            if (a.issue) {
              Ae(this, "type", r, n, {
                received: "unknown"
              });
              break;
            }
            r.value = a.value;
          }
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function k8(e, t) {
  return {
    kind: "schema",
    type: "intersect",
    reference: k8,
    expects: [...new Set(e.map((r) => r.expects))].join(" & ") || "never",
    async: !0,
    options: e,
    message: t,
    async _run(r, n) {
      if (this.options.length) {
        const i = r.value;
        let s;
        r.typed = !0;
        const o = await Promise.all(
          this.options.map(
            (a) => a._run({ typed: !1, value: i }, n)
          )
        );
        for (const a of o) {
          if (a.issues && (r.issues ? r.issues.push(...a.issues) : r.issues = a.issues, n.abortEarly)) {
            r.typed = !1;
            break;
          }
          a.typed || (r.typed = !1), r.typed && (s ? s.push(a.value) : s = [a.value]);
        }
        if (r.typed) {
          r.value = s[0];
          for (let a = 1; a < s.length; a++) {
            const c = Df(r.value, s[a]);
            if (c.issue) {
              Ae(this, "type", r, n, {
                received: "unknown"
              });
              break;
            }
            r.value = c.value;
          }
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function pc(e) {
  return {
    kind: "schema",
    type: "lazy",
    reference: pc,
    expects: "unknown",
    async: !1,
    getter: e,
    _run(t, r) {
      return this.getter(t.value)._run(t, r);
    }
  };
}
function j8(e) {
  return {
    kind: "schema",
    type: "lazy",
    reference: j8,
    expects: "unknown",
    async: !0,
    getter: e,
    async _run(t, r) {
      return (await this.getter(t.value))._run(t, r);
    }
  };
}
function Tt(e, t) {
  return {
    kind: "schema",
    type: "literal",
    reference: Tt,
    expects: xn(e),
    async: !1,
    literal: e,
    message: t,
    _run(r, n) {
      return r.value === this.literal ? r.typed = !0 : Ae(this, "type", r, n), r;
    }
  };
}
function R8(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: R8,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const o in this.entries) {
          const a = i[o], c = this.entries[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || o in i) && (r.value[o] = c.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const o in i)
            Aa(i, o) && !(o in this.entries) && (r.value[o] = i[o]);
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function P8(e, t) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: P8,
    expects: "Object",
    async: !0,
    entries: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        const o = await Promise.all(
          Object.entries(this.entries).map(async ([a, c]) => {
            const u = i[a];
            return [
              a,
              u,
              await c._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || a in i) && (r.value[a] = u.value);
        }
        if (!r.issues || !n.abortEarly)
          for (const a in i)
            Aa(i, a) && !(a in this.entries) && (r.value[a] = i[a]);
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function N8(e, t) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: N8,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let o = 0; o < this.items.length; o++) {
          const a = i[o], c = this.items[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
        if (!r.issues || !n.abortEarly)
          for (let o = this.items.length; o < i.length; o++)
            r.value.push(i[o]);
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function $8(e, t) {
  return {
    kind: "schema",
    type: "loose_tuple",
    reference: $8,
    expects: "Array",
    async: !0,
    items: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        const o = await Promise.all(
          this.items.map(async (a, c) => {
            const u = i[c];
            return [
              c,
              u,
              await a._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
        if (!r.issues || !n.abortEarly)
          for (let a = this.items.length; a < i.length; a++)
            r.value.push(i[a]);
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function D8(e, t, r) {
  return {
    kind: "schema",
    type: "map",
    reference: D8,
    expects: "Map",
    async: !1,
    key: e,
    value: t,
    message: r,
    _run(n, i) {
      var o, a;
      const s = n.value;
      if (s instanceof Map) {
        n.typed = !0, n.value = /* @__PURE__ */ new Map();
        for (const [c, u] of s) {
          const l = this.key._run(
            { typed: !1, value: c },
            i
          );
          if (l.issues) {
            const h = {
              type: "map",
              origin: "key",
              input: s,
              key: c,
              value: u
            };
            for (const v of l.issues)
              v.path ? v.path.unshift(h) : v.path = [h], (o = n.issues) == null || o.push(v);
            if (n.issues || (n.issues = l.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          const f = this.value._run(
            { typed: !1, value: u },
            i
          );
          if (f.issues) {
            const h = {
              type: "map",
              origin: "value",
              input: s,
              key: c,
              value: u
            };
            for (const v of f.issues)
              v.path ? v.path.unshift(h) : v.path = [h], (a = n.issues) == null || a.push(v);
            if (n.issues || (n.issues = f.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          (!l.typed || !f.typed) && (n.typed = !1), n.value.set(l.value, f.value);
        }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function L8(e, t, r) {
  return {
    kind: "schema",
    type: "map",
    reference: L8,
    expects: "Map",
    async: !0,
    key: e,
    value: t,
    message: r,
    async _run(n, i) {
      var o, a;
      const s = n.value;
      if (s instanceof Map) {
        n.typed = !0, n.value = /* @__PURE__ */ new Map();
        const c = await Promise.all(
          [...s].map(
            ([u, l]) => Promise.all([
              u,
              l,
              this.key._run({ typed: !1, value: u }, i),
              this.value._run({ typed: !1, value: l }, i)
            ])
          )
        );
        for (const [
          u,
          l,
          f,
          h
        ] of c) {
          if (f.issues) {
            const v = {
              type: "map",
              origin: "key",
              input: s,
              key: u,
              value: l
            };
            for (const b of f.issues)
              b.path ? b.path.unshift(v) : b.path = [v], (o = n.issues) == null || o.push(b);
            if (n.issues || (n.issues = f.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          if (h.issues) {
            const v = {
              type: "map",
              origin: "value",
              input: s,
              key: u,
              value: l
            };
            for (const b of h.issues)
              b.path ? b.path.unshift(v) : b.path = [v], (a = n.issues) == null || a.push(b);
            if (n.issues || (n.issues = h.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          (!f.typed || !h.typed) && (n.typed = !1), n.value.set(f.value, h.value);
        }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function B8(e) {
  return {
    kind: "schema",
    type: "nan",
    reference: B8,
    expects: "NaN",
    async: !1,
    message: e,
    _run(t, r) {
      return Number.isNaN(t.value) ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function U8(e) {
  return {
    kind: "schema",
    type: "never",
    reference: U8,
    expects: "never",
    async: !1,
    message: e,
    _run(t, r) {
      return Ae(this, "type", t, r), t;
    }
  };
}
function F8(e, t) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: F8,
    expects: "!null",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === null ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function V8(e, t) {
  return {
    kind: "schema",
    type: "non_nullable",
    reference: V8,
    expects: "!null",
    async: !0,
    wrapped: e,
    message: t,
    async _run(r, n) {
      return r.value === null ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function z8(e, t) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: z8,
    expects: "!null & !undefined",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === null || r.value === void 0 ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function W8(e, t) {
  return {
    kind: "schema",
    type: "non_nullish",
    reference: W8,
    expects: "!null & !undefined",
    async: !0,
    wrapped: e,
    message: t,
    async _run(r, n) {
      return r.value === null || r.value === void 0 ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function Xm(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: Xm,
    expects: "!undefined",
    async: !1,
    wrapped: e,
    message: t,
    _run(r, n) {
      return r.value === void 0 ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function Jm(e, t) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: Jm,
    expects: "!undefined",
    async: !0,
    wrapped: e,
    message: t,
    async _run(r, n) {
      return r.value === void 0 ? (Ae(this, "type", r, n), r) : this.wrapped._run(r, n);
    }
  };
}
function p0(e) {
  return {
    kind: "schema",
    type: "null",
    reference: p0,
    expects: "null",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === null ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function Ht(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: Ht,
    expects: `${e.expects} | null`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return n.value === null && ("default" in this && (n.value = Js(
        this,
        n,
        i
      )), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function q8(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullable",
    reference: q8,
    expects: `${e.expects} | null`,
    async: !0,
    wrapped: e,
    async _run(n, i) {
      return n.value === null && ("default" in this && (n.value = await Js(
        this,
        n,
        i
      )), n.value === null) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function va(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: va,
    expects: `${e.expects} | null | undefined`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = Js(
        this,
        n,
        i
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function H8(e, ...t) {
  const r = {
    kind: "schema",
    type: "nullish",
    reference: H8,
    expects: `${e.expects} | null | undefined`,
    async: !0,
    wrapped: e,
    async _run(n, i) {
      return (n.value === null || n.value === void 0) && ("default" in this && (n.value = await Js(
        this,
        n,
        i
      )), n.value === null || n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function vr(e) {
  return {
    kind: "schema",
    type: "number",
    reference: vr,
    expects: "number",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "number" && !isNaN(t.value) ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function We(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: We,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const o in this.entries) {
          const a = i[o], c = this.entries[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || o in i) && (r.value[o] = c.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function G8(e, t) {
  return {
    kind: "schema",
    type: "object",
    reference: G8,
    expects: "Object",
    async: !0,
    entries: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        const o = await Promise.all(
          Object.entries(this.entries).map(async ([a, c]) => {
            const u = i[a];
            return [
              a,
              u,
              await c._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || a in i) && (r.value[a] = u.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function K8(e, t, r) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: K8,
    expects: "Object",
    async: !1,
    entries: e,
    rest: t,
    message: r,
    _run(n, i) {
      var o, a;
      const s = n.value;
      if (s && typeof s == "object") {
        n.typed = !0, n.value = {};
        for (const c in this.entries) {
          const u = s[c], l = this.entries[c]._run(
            { typed: !1, value: u },
            i
          );
          if (l.issues) {
            const f = {
              type: "object",
              origin: "value",
              input: s,
              key: c,
              value: u
            };
            for (const h of l.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (o = n.issues) == null || o.push(h);
            if (n.issues || (n.issues = l.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          l.typed || (n.typed = !1), (l.value !== void 0 || c in s) && (n.value[c] = l.value);
        }
        if (!n.issues || !i.abortEarly) {
          for (const c in s)
            if (Aa(s, c) && !(c in this.entries)) {
              const u = s[c], l = this.rest._run(
                { typed: !1, value: u },
                i
              );
              if (l.issues) {
                const f = {
                  type: "object",
                  origin: "value",
                  input: s,
                  key: c,
                  value: u
                };
                for (const h of l.issues)
                  h.path ? h.path.unshift(f) : h.path = [f], (a = n.issues) == null || a.push(h);
                if (n.issues || (n.issues = l.issues), i.abortEarly) {
                  n.typed = !1;
                  break;
                }
              }
              l.typed || (n.typed = !1), n.value[c] = l.value;
            }
        }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function Y8(e, t, r) {
  return {
    kind: "schema",
    type: "object_with_rest",
    reference: Y8,
    expects: "Object",
    async: !0,
    entries: e,
    rest: t,
    message: r,
    async _run(n, i) {
      var o, a;
      const s = n.value;
      if (s && typeof s == "object") {
        n.typed = !0, n.value = {};
        const [c, u] = await Promise.all([
          // Parse schema of each normal entry
          Promise.all(
            Object.entries(this.entries).map(async ([l, f]) => {
              const h = s[l];
              return [
                l,
                h,
                await f._run({ typed: !1, value: h }, i)
              ];
            })
          ),
          // Parse other entries with rest schema
          Promise.all(
            Object.entries(s).filter(
              ([l]) => Aa(s, l) && !(l in this.entries)
            ).map(
              async ([l, f]) => [
                l,
                f,
                await this.rest._run({ typed: !1, value: f }, i)
              ]
            )
          )
        ]);
        for (const [l, f, h] of c) {
          if (h.issues) {
            const v = {
              type: "object",
              origin: "value",
              input: s,
              key: l,
              value: f
            };
            for (const b of h.issues)
              b.path ? b.path.unshift(v) : b.path = [v], (o = n.issues) == null || o.push(b);
            if (n.issues || (n.issues = h.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          h.typed || (n.typed = !1), (h.value !== void 0 || l in s) && (n.value[l] = h.value);
        }
        if (!n.issues || !i.abortEarly)
          for (const [l, f, h] of u) {
            if (h.issues) {
              const v = {
                type: "object",
                origin: "value",
                input: s,
                key: l,
                value: f
              };
              for (const b of h.issues)
                b.path ? b.path.unshift(v) : b.path = [v], (a = n.issues) == null || a.push(b);
              if (n.issues || (n.issues = h.issues), i.abortEarly) {
                n.typed = !1;
                break;
              }
            }
            h.typed || (n.typed = !1), n.value[l] = h.value;
          }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function qr(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: qr,
    expects: `${e.expects} | undefined`,
    async: !1,
    wrapped: e,
    _run(n, i) {
      return n.value === void 0 && ("default" in this && (n.value = Js(
        this,
        n,
        i
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Zm(e, ...t) {
  const r = {
    kind: "schema",
    type: "optional",
    reference: Zm,
    expects: `${e.expects} | undefined`,
    async: !0,
    wrapped: e,
    async _run(n, i) {
      return n.value === void 0 && ("default" in this && (n.value = await Js(
        this,
        n,
        i
      )), n.value === void 0) ? (n.typed = !0, n) : this.wrapped._run(n, i);
    }
  };
  return 0 in t && (r.default = t[0]), r;
}
function Qm(e, t) {
  return {
    kind: "schema",
    type: "picklist",
    reference: Qm,
    expects: e.map(xn).join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      return this.options.includes(r.value) ? r.typed = !0 : Ae(this, "type", r, n), r;
    }
  };
}
function X8(e) {
  return {
    kind: "schema",
    type: "promise",
    reference: X8,
    expects: "Promise",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value instanceof Promise ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function mc(e, t, r) {
  return {
    kind: "schema",
    type: "record",
    reference: mc,
    expects: "Object",
    async: !1,
    key: e,
    value: t,
    message: r,
    _run(n, i) {
      var o, a;
      const s = n.value;
      if (s && typeof s == "object") {
        n.typed = !0, n.value = {};
        for (const c in s)
          if (Aa(s, c)) {
            const u = s[c], l = this.key._run(
              { typed: !1, value: c },
              i
            );
            if (l.issues) {
              const h = {
                type: "object",
                origin: "key",
                input: s,
                key: c,
                value: u
              };
              for (const v of l.issues)
                v.path = [h], (o = n.issues) == null || o.push(v);
              if (n.issues || (n.issues = l.issues), i.abortEarly) {
                n.typed = !1;
                break;
              }
            }
            const f = this.value._run(
              { typed: !1, value: u },
              i
            );
            if (f.issues) {
              const h = {
                type: "object",
                origin: "value",
                input: s,
                key: c,
                value: u
              };
              for (const v of f.issues)
                v.path ? v.path.unshift(h) : v.path = [h], (a = n.issues) == null || a.push(v);
              if (n.issues || (n.issues = f.issues), i.abortEarly) {
                n.typed = !1;
                break;
              }
            }
            (!l.typed || !f.typed) && (n.typed = !1), l.typed && (n.value[l.value] = f.value);
          }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function J8(e, t, r) {
  return {
    kind: "schema",
    type: "record",
    reference: J8,
    expects: "Object",
    async: !0,
    key: e,
    value: t,
    message: r,
    async _run(n, i) {
      var o, a;
      const s = n.value;
      if (s && typeof s == "object") {
        n.typed = !0, n.value = {};
        const c = await Promise.all(
          Object.entries(s).filter(([u]) => Aa(s, u)).map(
            ([u, l]) => Promise.all([
              u,
              l,
              this.key._run({ typed: !1, value: u }, i),
              this.value._run({ typed: !1, value: l }, i)
            ])
          )
        );
        for (const [
          u,
          l,
          f,
          h
        ] of c) {
          if (f.issues) {
            const v = {
              type: "object",
              origin: "key",
              input: s,
              key: u,
              value: l
            };
            for (const b of f.issues)
              b.path = [v], (o = n.issues) == null || o.push(b);
            if (n.issues || (n.issues = f.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          if (h.issues) {
            const v = {
              type: "object",
              origin: "value",
              input: s,
              key: u,
              value: l
            };
            for (const b of h.issues)
              b.path ? b.path.unshift(v) : b.path = [v], (a = n.issues) == null || a.push(b);
            if (n.issues || (n.issues = h.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          (!f.typed || !h.typed) && (n.typed = !1), f.typed && (n.value[f.value] = h.value);
        }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function Z8(e, t) {
  return {
    kind: "schema",
    type: "set",
    reference: Z8,
    expects: "Set",
    async: !1,
    value: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (i instanceof Set) {
        r.typed = !0, r.value = /* @__PURE__ */ new Set();
        for (const o of i) {
          const a = this.value._run(
            { typed: !1, value: o },
            n
          );
          if (a.issues) {
            const c = {
              type: "set",
              origin: "value",
              input: i,
              key: null,
              value: o
            };
            for (const u of a.issues)
              u.path ? u.path.unshift(c) : u.path = [c], (s = r.issues) == null || s.push(u);
            if (r.issues || (r.issues = a.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          a.typed || (r.typed = !1), r.value.add(a.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function Q8(e, t) {
  return {
    kind: "schema",
    type: "set",
    reference: Q8,
    expects: "Set",
    async: !0,
    value: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (i instanceof Set) {
        r.typed = !0, r.value = /* @__PURE__ */ new Set();
        const o = await Promise.all(
          [...i].map(
            async (a) => [
              a,
              await this.value._run(
                { typed: !1, value: a },
                n
              )
            ]
          )
        );
        for (const [a, c] of o) {
          if (c.issues) {
            const u = {
              type: "set",
              origin: "value",
              input: i,
              key: null,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.add(c.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function e3(e, t) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: e3,
    expects: "Object",
    async: !1,
    entries: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        for (const o in this.entries) {
          const a = i[o], c = this.entries[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "object",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), (c.value !== void 0 || o in i) && (r.value[o] = c.value);
        }
        if (!r.issues || !n.abortEarly) {
          for (const o in i)
            if (!(o in this.entries)) {
              const a = i[o];
              Ae(this, "type", r, n, {
                input: a,
                expected: "never",
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input: i,
                    key: o,
                    value: a
                  }
                ]
              });
              break;
            }
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function t3(e, t) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: t3,
    expects: "Object",
    async: !0,
    entries: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (i && typeof i == "object") {
        r.typed = !0, r.value = {};
        const o = await Promise.all(
          Object.entries(this.entries).map(async ([a, c]) => {
            const u = i[a];
            return [
              a,
              u,
              await c._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "object",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), (u.value !== void 0 || a in i) && (r.value[a] = u.value);
        }
        if (!r.issues || !n.abortEarly) {
          for (const a in i)
            if (!(a in this.entries)) {
              const c = i[a];
              Ae(this, "type", r, n, {
                input: c,
                expected: "never",
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input: i,
                    key: a,
                    value: c
                  }
                ]
              });
              break;
            }
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function r3(e, t) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: r3,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let o = 0; o < this.items.length; o++) {
          const a = i[o], c = this.items[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
        if (!(r.issues && n.abortEarly) && this.items.length < i.length) {
          const o = i[e.length];
          Ae(this, "type", r, n, {
            input: o,
            expected: "never",
            path: [
              {
                type: "array",
                origin: "value",
                input: i,
                key: this.items.length,
                value: o
              }
            ]
          });
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function n3(e, t) {
  return {
    kind: "schema",
    type: "strict_tuple",
    reference: n3,
    expects: "Array",
    async: !0,
    items: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        const o = await Promise.all(
          this.items.map(async (a, c) => {
            const u = i[c];
            return [
              c,
              u,
              await a._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
        if (!(r.issues && n.abortEarly) && this.items.length < i.length) {
          const a = i[e.length];
          Ae(this, "type", r, n, {
            input: a,
            expected: "never",
            path: [
              {
                type: "array",
                origin: "value",
                input: i,
                key: this.items.length,
                value: a
              }
            ]
          });
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function Nt(e) {
  return {
    kind: "schema",
    type: "string",
    reference: Nt,
    expects: "string",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "string" ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function i3(e) {
  return {
    kind: "schema",
    type: "symbol",
    reference: i3,
    expects: "symbol",
    async: !1,
    message: e,
    _run(t, r) {
      return typeof t.value == "symbol" ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function Ed(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: Ed,
    expects: "Array",
    async: !1,
    items: e,
    message: t,
    _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        for (let o = 0; o < this.items.length; o++) {
          const a = i[o], c = this.items[o]._run(
            { typed: !1, value: a },
            n
          );
          if (c.issues) {
            const u = {
              type: "array",
              origin: "value",
              input: i,
              key: o,
              value: a
            };
            for (const l of c.issues)
              l.path ? l.path.unshift(u) : l.path = [u], (s = r.issues) == null || s.push(l);
            if (r.issues || (r.issues = c.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          c.typed || (r.typed = !1), r.value.push(c.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function s3(e, t) {
  return {
    kind: "schema",
    type: "tuple",
    reference: s3,
    expects: "Array",
    async: !0,
    items: e,
    message: t,
    async _run(r, n) {
      var s;
      const i = r.value;
      if (Array.isArray(i)) {
        r.typed = !0, r.value = [];
        const o = await Promise.all(
          this.items.map(async (a, c) => {
            const u = i[c];
            return [
              c,
              u,
              await a._run({ typed: !1, value: u }, n)
            ];
          })
        );
        for (const [a, c, u] of o) {
          if (u.issues) {
            const l = {
              type: "array",
              origin: "value",
              input: i,
              key: a,
              value: c
            };
            for (const f of u.issues)
              f.path ? f.path.unshift(l) : f.path = [l], (s = r.issues) == null || s.push(f);
            if (r.issues || (r.issues = u.issues), n.abortEarly) {
              r.typed = !1;
              break;
            }
          }
          u.typed || (r.typed = !1), r.value.push(u.value);
        }
      } else
        Ae(this, "type", r, n);
      return r;
    }
  };
}
function o3(e, t, r) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: o3,
    expects: "Array",
    async: !1,
    items: e,
    rest: t,
    message: r,
    _run(n, i) {
      var o, a;
      const s = n.value;
      if (Array.isArray(s)) {
        n.typed = !0, n.value = [];
        for (let c = 0; c < this.items.length; c++) {
          const u = s[c], l = this.items[c]._run(
            { typed: !1, value: u },
            i
          );
          if (l.issues) {
            const f = {
              type: "array",
              origin: "value",
              input: s,
              key: c,
              value: u
            };
            for (const h of l.issues)
              h.path ? h.path.unshift(f) : h.path = [f], (o = n.issues) == null || o.push(h);
            if (n.issues || (n.issues = l.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          l.typed || (n.typed = !1), n.value.push(l.value);
        }
        if (!n.issues || !i.abortEarly)
          for (let c = this.items.length; c < s.length; c++) {
            const u = s[c], l = this.rest._run({ typed: !1, value: u }, i);
            if (l.issues) {
              const f = {
                type: "array",
                origin: "value",
                input: s,
                key: c,
                value: u
              };
              for (const h of l.issues)
                h.path ? h.path.unshift(f) : h.path = [f], (a = n.issues) == null || a.push(h);
              if (n.issues || (n.issues = l.issues), i.abortEarly) {
                n.typed = !1;
                break;
              }
            }
            l.typed || (n.typed = !1), n.value.push(l.value);
          }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function a3(e, t, r) {
  return {
    kind: "schema",
    type: "tuple_with_rest",
    reference: a3,
    expects: "Array",
    async: !0,
    items: e,
    rest: t,
    message: r,
    async _run(n, i) {
      var o, a;
      const s = n.value;
      if (Array.isArray(s)) {
        n.typed = !0, n.value = [];
        const [c, u] = await Promise.all([
          // Parse schema of each normal item
          Promise.all(
            this.items.map(async (l, f) => {
              const h = s[f];
              return [
                f,
                h,
                await l._run({ typed: !1, value: h }, i)
              ];
            })
          ),
          // Parse other items with rest schema
          Promise.all(
            s.slice(this.items.length).map(async (l, f) => [
              f + this.items.length,
              l,
              await this.rest._run({ typed: !1, value: l }, i)
            ])
          )
        ]);
        for (const [l, f, h] of c) {
          if (h.issues) {
            const v = {
              type: "array",
              origin: "value",
              input: s,
              key: l,
              value: f
            };
            for (const b of h.issues)
              b.path ? b.path.unshift(v) : b.path = [v], (o = n.issues) == null || o.push(b);
            if (n.issues || (n.issues = h.issues), i.abortEarly) {
              n.typed = !1;
              break;
            }
          }
          h.typed || (n.typed = !1), n.value.push(h.value);
        }
        if (!n.issues || !i.abortEarly)
          for (const [l, f, h] of u) {
            if (h.issues) {
              const v = {
                type: "array",
                origin: "value",
                input: s,
                key: l,
                value: f
              };
              for (const b of h.issues)
                b.path ? b.path.unshift(v) : b.path = [v], (a = n.issues) == null || a.push(b);
              if (n.issues || (n.issues = h.issues), i.abortEarly) {
                n.typed = !1;
                break;
              }
            }
            h.typed || (n.typed = !1), n.value.push(h.value);
          }
      } else
        Ae(this, "type", n, i);
      return n;
    }
  };
}
function m0(e) {
  return {
    kind: "schema",
    type: "undefined",
    reference: m0,
    expects: "undefined",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function Lf(e) {
  let t;
  if (e)
    for (const r of e)
      t ? t.push(...r.issues) : t = r.issues;
  return t;
}
function Xr(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: Xr,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: !1,
    options: e,
    message: t,
    _run(r, n) {
      let i, s, o;
      for (const a of this.options) {
        const c = a._run(
          { typed: !1, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            s ? s.push(c) : s = [c];
          else {
            i = c;
            break;
          }
        else
          o ? o.push(c) : o = [c];
      }
      if (i)
        return i;
      if (s) {
        if (s.length === 1)
          return s[0];
        Ae(this, "type", r, n, {
          issues: Lf(s)
        }), r.typed = !0;
      } else {
        if ((o == null ? void 0 : o.length) === 1)
          return o[0];
        Ae(this, "type", r, n, {
          issues: Lf(o)
        });
      }
      return r;
    }
  };
}
function c3(e, t) {
  return {
    kind: "schema",
    type: "union",
    reference: c3,
    expects: [...new Set(e.map((r) => r.expects))].join(" | ") || "never",
    async: !0,
    options: e,
    message: t,
    async _run(r, n) {
      let i, s, o;
      for (const a of this.options) {
        const c = await a._run(
          { typed: !1, value: r.value },
          n
        );
        if (c.typed)
          if (c.issues)
            s ? s.push(c) : s = [c];
          else {
            i = c;
            break;
          }
        else
          o ? o.push(c) : o = [c];
      }
      if (i)
        return i;
      if (s) {
        if (s.length === 1)
          return s[0];
        Ae(this, "type", r, n, {
          issues: Lf(s)
        }), r.typed = !0;
      } else {
        if ((o == null ? void 0 : o.length) === 1)
          return o[0];
        Ae(this, "type", r, n, {
          issues: Lf(o)
        });
      }
      return r;
    }
  };
}
function Mo() {
  return {
    kind: "schema",
    type: "unknown",
    reference: Mo,
    expects: "unknown",
    async: !1,
    _run(e) {
      return e.typed = !0, e;
    }
  };
}
function eg(e, t, r = /* @__PURE__ */ new Set()) {
  for (const n of t)
    n.type === "variant" ? eg(e, n.options, r) : r.add(n.entries[e].expects);
  return r;
}
function u3(e, t, r) {
  let n;
  return {
    kind: "schema",
    type: "variant",
    reference: u3,
    expects: "Object",
    async: !1,
    key: e,
    options: t,
    message: r,
    _run(i, s) {
      const o = i.value;
      if (o && typeof o == "object") {
        const a = o[this.key];
        if (this.key in o) {
          let c;
          for (const u of this.options)
            if (u.type === "variant" || !u.entries[this.key]._run(
              { typed: !1, value: a },
              s
            ).issues) {
              const l = u._run(
                { typed: !1, value: o },
                s
              );
              if (!l.issues)
                return l;
              (!c || !c.typed && l.typed) && (c = l);
            }
          if (c)
            return c;
        }
        n || (n = [...eg(this.key, this.options)].join(" | ") || "never"), Ae(this, "type", i, s, {
          input: a,
          expected: n,
          path: [
            {
              type: "object",
              origin: "value",
              input: o,
              key: this.key,
              value: a
            }
          ]
        });
      } else
        Ae(this, "type", i, s);
      return i;
    }
  };
}
function l3(e, t, r) {
  let n;
  return {
    kind: "schema",
    type: "variant",
    reference: l3,
    expects: "Object",
    async: !0,
    key: e,
    options: t,
    message: r,
    async _run(i, s) {
      const o = i.value;
      if (o && typeof o == "object") {
        const a = o[this.key];
        if (this.key in o) {
          let c;
          for (const u of this.options)
            if (u.type === "variant" || !(await u.entries[this.key]._run(
              { typed: !1, value: a },
              s
            )).issues) {
              const l = await u._run(
                { typed: !1, value: o },
                s
              );
              if (!l.issues)
                return l;
              (!c || !c.typed && l.typed) && (c = l);
            }
          if (c)
            return c;
        }
        n || (n = [...eg(this.key, this.options)].join(" | ") || "never"), Ae(this, "type", i, s, {
          input: a,
          expected: n,
          path: [
            {
              type: "object",
              origin: "value",
              input: o,
              key: this.key,
              value: a
            }
          ]
        });
      } else
        Ae(this, "type", i, s);
      return i;
    }
  };
}
function g0(e) {
  return {
    kind: "schema",
    type: "void",
    reference: g0,
    expects: "void",
    async: !1,
    message: e,
    _run(t, r) {
      return t.value === void 0 ? t.typed = !0 : Ae(this, "type", t, r), t;
    }
  };
}
function lI(e, t) {
  return Qm(Object.keys(e.entries), t);
}
function fI(e, t) {
  const r = {
    ...e.entries
  };
  for (const n of t)
    delete r[n];
  return { ...e, entries: r };
}
function fr(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    Ju(r)
  );
  if (n.issues)
    throw new Sd(n.issues);
  return n.value;
}
async function f3(e, t, r) {
  const n = await e._run(
    { typed: !1, value: t },
    Ju(r)
  );
  if (n.issues)
    throw new Sd(n.issues);
  return n.value;
}
function dI(e, t) {
  const r = (n) => fr(e, n, t);
  return r.schema = e, r.config = t, r;
}
function hI(e, t) {
  const r = (n) => f3(e, n, t);
  return r.schema = e, r.config = t, r;
}
function pI(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = !t || t.includes(n) ? qr(e.entries[n]) : e.entries[n];
  return { ...e, entries: r };
}
function mI(e, t) {
  const r = {};
  for (const n in e.entries)
    r[n] = !t || t.includes(n) ? Zm(e.entries[n]) : e.entries[n];
  return { ...e, entries: r };
}
function gI(e, t) {
  const r = {};
  for (const n of t)
    r[n] = e.entries[n];
  return { ...e, entries: r };
}
function er(...e) {
  return {
    ...e[0],
    pipe: e,
    _run(t, r) {
      for (let n = 0; n < e.length; n++) {
        if (t.issues && (e[n].kind === "schema" || e[n].kind === "transformation")) {
          t.typed = !1;
          break;
        }
        (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = e[n]._run(t, r));
      }
      return t;
    }
  };
}
function yI(...e) {
  return {
    ...e[0],
    pipe: e,
    async: !0,
    async _run(t, r) {
      for (let n = 0; n < e.length; n++) {
        if (t.issues && (e[n].kind === "schema" || e[n].kind === "transformation")) {
          t.typed = !1;
          break;
        }
        (!t.issues || !r.abortEarly && !r.abortPipeEarly) && (t = await e[n]._run(t, r));
      }
      return t;
    }
  };
}
function vI(e, t, r) {
  const n = Array.isArray(t) ? t : void 0, i = Array.isArray(t) ? r : t, s = {};
  for (const o in e.entries)
    s[o] = !n || n.includes(o) ? Xm(e.entries[o], i) : e.entries[o];
  return { ...e, entries: s };
}
function bI(e, t, r) {
  const n = Array.isArray(t) ? t : void 0, i = Array.isArray(t) ? r : t, s = {};
  for (const o in e.entries)
    s[o] = !n || n.includes(o) ? Jm(e.entries[o], i) : e.entries[o];
  return { ...e, entries: s };
}
function d3(e, t, r) {
  const n = e._run(
    { typed: !1, value: t },
    Ju(r)
  );
  return {
    typed: n.typed,
    success: !n.issues,
    output: n.value,
    issues: n.issues
  };
}
async function h3(e, t, r) {
  const n = await e._run(
    { typed: !1, value: t },
    Ju(r)
  );
  return {
    typed: n.typed,
    success: !n.issues,
    output: n.value,
    issues: n.issues
  };
}
function wI(e, t) {
  const r = (n) => d3(e, n, t);
  return r.schema = e, r.config = t, r;
}
function _I(e, t) {
  const r = (n) => h3(e, n, t);
  return r.schema = e, r.config = t, r;
}
function xI(e) {
  return e.wrapped;
}
const SI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BIC_REGEX: S4,
  CUID2_REGEX: E4,
  DECIMAL_REGEX: T4,
  EMAIL_REGEX: C4,
  EMOJI_REGEX: A4,
  HEXADECIMAL_REGEX: M4,
  HEX_COLOR_REGEX: O4,
  IMEI_REGEX: I4,
  IPV4_REGEX: k4,
  IPV6_REGEX: j4,
  IP_REGEX: R4,
  ISO_DATE_REGEX: P4,
  ISO_DATE_TIME_REGEX: N4,
  ISO_TIMESTAMP_REGEX: L4,
  ISO_TIME_REGEX: $4,
  ISO_TIME_SECOND_REGEX: D4,
  ISO_WEEK_REGEX: B4,
  MAC48_REGEX: U4,
  MAC64_REGEX: F4,
  MAC_REGEX: V4,
  OCTAL_REGEX: z4,
  ULID_REGEX: W4,
  UUID_REGEX: q4,
  ValiError: Sd,
  _addIssue: Ae,
  _isLuhnAlgo: Ym,
  _isValidObjectKey: Aa,
  _stringify: xn,
  any: x8,
  array: St,
  arrayAsync: S8,
  awaitAsync: x4,
  bic: X4,
  bigint: el,
  blob: E8,
  boolean: tl,
  brand: J4,
  bytes: Z4,
  check: Cc,
  checkAsync: Q4,
  checkItems: e6,
  config: iI,
  creditCard: t6,
  cuid2: r6,
  custom: T8,
  customAsync: C8,
  date: A8,
  decimal: n6,
  deleteGlobalConfig: VO,
  deleteGlobalMessage: WO,
  deleteSchemaMessage: HO,
  deleteSpecificMessage: KO,
  email: i6,
  emoji: s6,
  empty: o6,
  endsWith: a6,
  entriesFromList: XO,
  enum: d0,
  enum_: d0,
  everyItem: c6,
  excludes: u6,
  fallback: sI,
  fallbackAsync: oI,
  file: M8,
  filterItems: l6,
  findItem: f6,
  finite: d6,
  flatten: aI,
  forward: cI,
  forwardAsync: uI,
  function: h0,
  function_: h0,
  getDefault: Js,
  getDefaults: c0,
  getDefaultsAsync: u0,
  getDotPath: Y4,
  getFallback: Qu,
  getFallbacks: l0,
  getFallbacksAsync: f0,
  getGlobalConfig: Ju,
  getGlobalMessage: H4,
  getSchemaMessage: G4,
  getSpecificMessage: K4,
  hash: h6,
  hexColor: m6,
  hexadecimal: p6,
  imei: g6,
  includes: y6,
  instance: O8,
  integer: wr,
  intersect: I8,
  intersectAsync: k8,
  ip: v6,
  ipv4: b6,
  ipv6: w6,
  is: $f,
  isOfKind: JO,
  isOfType: ZO,
  isValiError: QO,
  isoDate: _6,
  isoDateTime: x6,
  isoTime: S6,
  isoTimeSecond: E6,
  isoTimestamp: T6,
  isoWeek: C6,
  keyof: lI,
  lazy: pc,
  lazyAsync: j8,
  length: A6,
  literal: Tt,
  looseObject: R8,
  looseObjectAsync: P8,
  looseTuple: N8,
  looseTupleAsync: $8,
  mac: M6,
  mac48: O6,
  mac64: I6,
  map: D8,
  mapAsync: L8,
  mapItems: k6,
  maxBytes: j6,
  maxLength: R6,
  maxSize: P6,
  maxValue: N6,
  mimeType: $6,
  minBytes: D6,
  minLength: L6,
  minSize: B6,
  minValue: U6,
  multipleOf: F6,
  nan: B8,
  never: U8,
  nonEmpty: V6,
  nonNullable: F8,
  nonNullableAsync: V8,
  nonNullish: z8,
  nonNullishAsync: W8,
  nonOptional: Xm,
  nonOptionalAsync: Jm,
  normalize: z6,
  notBytes: W6,
  notLength: q6,
  notSize: H6,
  notValue: G6,
  null: p0,
  null_: p0,
  nullable: Ht,
  nullableAsync: q8,
  nullish: va,
  nullishAsync: H8,
  number: vr,
  object: We,
  objectAsync: G8,
  objectWithRest: K8,
  objectWithRestAsync: Y8,
  octal: K6,
  omit: fI,
  optional: qr,
  optionalAsync: Zm,
  parse: fr,
  parseAsync: f3,
  parser: dI,
  parserAsync: hI,
  partial: pI,
  partialAsync: mI,
  partialCheck: X6,
  partialCheckAsync: J6,
  pick: gI,
  picklist: Qm,
  pipe: er,
  pipeAsync: yI,
  promise: X8,
  rawCheck: Z6,
  rawCheckAsync: Q6,
  rawTransform: e8,
  rawTransformAsync: t8,
  readonly: r8,
  record: mc,
  recordAsync: J8,
  reduceItems: n8,
  regex: i8,
  required: vI,
  requiredAsync: bI,
  safeInteger: s8,
  safeParse: d3,
  safeParseAsync: h3,
  safeParser: wI,
  safeParserAsync: _I,
  set: Z8,
  setAsync: Q8,
  setGlobalConfig: FO,
  setGlobalMessage: zO,
  setSchemaMessage: qO,
  setSpecificMessage: GO,
  size: o8,
  someItem: a8,
  sortItems: c8,
  startsWith: u8,
  strictObject: e3,
  strictObjectAsync: t3,
  strictTuple: r3,
  strictTupleAsync: n3,
  string: Nt,
  symbol: i3,
  toLowerCase: l8,
  toMaxValue: f8,
  toMinValue: d8,
  toUpperCase: h8,
  transform: Zu,
  transformAsync: p8,
  trim: m8,
  trimEnd: g8,
  trimStart: y8,
  tuple: Ed,
  tupleAsync: s3,
  tupleWithRest: o3,
  tupleWithRestAsync: a3,
  ulid: v8,
  undefined: m0,
  undefined_: m0,
  union: Xr,
  unionAsync: c3,
  unknown: Mo,
  unwrap: xI,
  url: b8,
  uuid: w8,
  value: _8,
  variant: u3,
  variantAsync: l3,
  void: g0,
  void_: g0
}, Symbol.toStringTag, { value: "Module" })), Zs = /* @__PURE__ */ Ec(SI);
var tg = Object.defineProperty, EI = Object.getOwnPropertyDescriptor, TI = Object.getOwnPropertyNames, CI = Object.prototype.hasOwnProperty, AI = (e, t) => {
  for (var r in t)
    tg(e, r, { get: t[r], enumerable: !0 });
}, MI = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of TI(t))
      !CI.call(e, i) && i !== r && tg(e, i, { get: () => t[i], enumerable: !(n = EI(t, i)) || n.enumerable });
  return e;
}, OI = (e) => MI(tg({}, "__esModule", { value: !0 }), e), p3 = {};
AI(p3, {
  $Intent: () => y3,
  Argument: () => Yn,
  BCSBytes: () => xu,
  Command: () => v3,
  GasData: () => m3,
  JsonU64: () => Oo,
  NormalizedCallArg: () => RI,
  ObjectArg: () => rg,
  ObjectID: () => da,
  ObjectRef: () => Bf,
  OpenMoveTypeSignature: () => g3,
  OpenMoveTypeSignatureBody: () => Uf,
  StructTag: () => II,
  SuiAddress: () => rl,
  TransactionData: () => PI,
  TransactionExpiration: () => b3,
  safeEnum: () => Ac
});
var Ma = OI(p3), Ee = Zs, wy = Bn;
function Ac(e) {
  const t = Object.entries(e).map(([r, n]) => (0, Ee.object)({ [r]: n }));
  return (0, Ee.pipe)(
    (0, Ee.union)(t),
    (0, Ee.transform)((r) => ({
      ...r,
      $kind: Object.keys(r)[0]
    }))
  );
}
const rl = (0, Ee.pipe)(
  (0, Ee.string)(),
  (0, Ee.transform)((e) => (0, wy.normalizeSuiAddress)(e)),
  (0, Ee.check)(wy.isValidSuiAddress)
), da = rl, xu = (0, Ee.string)(), Oo = (0, Ee.pipe)(
  (0, Ee.union)([(0, Ee.string)(), (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)())]),
  (0, Ee.check)((e) => {
    try {
      return BigInt(e), BigInt(e) >= 0 && BigInt(e) <= 18446744073709551615n;
    } catch {
      return !1;
    }
  }, "Invalid u64")
), Bf = (0, Ee.object)({
  objectId: rl,
  version: Oo,
  digest: (0, Ee.string)()
}), Yn = (0, Ee.pipe)(
  (0, Ee.union)([
    (0, Ee.object)({ GasCoin: (0, Ee.literal)(!0) }),
    (0, Ee.object)({ Input: (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)()), type: (0, Ee.optional)((0, Ee.literal)("pure")) }),
    (0, Ee.object)({ Input: (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)()), type: (0, Ee.optional)((0, Ee.literal)("object")) }),
    (0, Ee.object)({ Result: (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)()) }),
    (0, Ee.object)({ NestedResult: (0, Ee.tuple)([(0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)()), (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)())]) })
  ]),
  (0, Ee.transform)((e) => ({
    ...e,
    $kind: Object.keys(e)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
), m3 = (0, Ee.object)({
  budget: (0, Ee.nullable)(Oo),
  price: (0, Ee.nullable)(Oo),
  owner: (0, Ee.nullable)(rl),
  payment: (0, Ee.nullable)((0, Ee.array)(Bf))
}), II = (0, Ee.object)({
  address: (0, Ee.string)(),
  module: (0, Ee.string)(),
  name: (0, Ee.string)(),
  // type_params in rust, should be updated to use camelCase
  typeParams: (0, Ee.array)((0, Ee.string)())
}), Uf = (0, Ee.union)([
  (0, Ee.literal)("address"),
  (0, Ee.literal)("bool"),
  (0, Ee.literal)("u8"),
  (0, Ee.literal)("u16"),
  (0, Ee.literal)("u32"),
  (0, Ee.literal)("u64"),
  (0, Ee.literal)("u128"),
  (0, Ee.literal)("u256"),
  (0, Ee.object)({ vector: (0, Ee.lazy)(() => Uf) }),
  (0, Ee.object)({
    datatype: (0, Ee.object)({
      package: (0, Ee.string)(),
      module: (0, Ee.string)(),
      type: (0, Ee.string)(),
      typeParameters: (0, Ee.array)((0, Ee.lazy)(() => Uf))
    })
  }),
  (0, Ee.object)({ typeParameter: (0, Ee.pipe)((0, Ee.number)(), (0, Ee.integer)()) })
]), g3 = (0, Ee.object)({
  ref: (0, Ee.nullable)((0, Ee.union)([(0, Ee.literal)("&"), (0, Ee.literal)("&mut")])),
  body: Uf
}), kI = (0, Ee.object)({
  package: da,
  module: (0, Ee.string)(),
  function: (0, Ee.string)(),
  // snake case in rust
  typeArguments: (0, Ee.array)((0, Ee.string)()),
  arguments: (0, Ee.array)(Yn),
  _argumentTypes: (0, Ee.optional)((0, Ee.nullable)((0, Ee.array)(g3)))
}), y3 = (0, Ee.object)({
  name: (0, Ee.string)(),
  inputs: (0, Ee.record)((0, Ee.string)(), (0, Ee.union)([Yn, (0, Ee.array)(Yn)])),
  data: (0, Ee.record)((0, Ee.string)(), (0, Ee.unknown)())
}), v3 = Ac({
  MoveCall: kI,
  TransferObjects: (0, Ee.object)({
    objects: (0, Ee.array)(Yn),
    address: Yn
  }),
  SplitCoins: (0, Ee.object)({
    coin: Yn,
    amounts: (0, Ee.array)(Yn)
  }),
  MergeCoins: (0, Ee.object)({
    destination: Yn,
    sources: (0, Ee.array)(Yn)
  }),
  Publish: (0, Ee.object)({
    modules: (0, Ee.array)(xu),
    dependencies: (0, Ee.array)(da)
  }),
  MakeMoveVec: (0, Ee.object)({
    type: (0, Ee.nullable)((0, Ee.string)()),
    elements: (0, Ee.array)(Yn)
  }),
  Upgrade: (0, Ee.object)({
    modules: (0, Ee.array)(xu),
    dependencies: (0, Ee.array)(da),
    package: da,
    ticket: Yn
  }),
  $Intent: y3
}), rg = Ac({
  ImmOrOwnedObject: Bf,
  SharedObject: (0, Ee.object)({
    objectId: da,
    // snake case in rust
    initialSharedVersion: Oo,
    mutable: (0, Ee.boolean)()
  }),
  Receiving: Bf
}), jI = Ac({
  Object: rg,
  Pure: (0, Ee.object)({
    bytes: xu
  }),
  UnresolvedPure: (0, Ee.object)({
    value: (0, Ee.unknown)()
  }),
  UnresolvedObject: (0, Ee.object)({
    objectId: da,
    version: (0, Ee.optional)((0, Ee.nullable)(Oo)),
    digest: (0, Ee.optional)((0, Ee.nullable)((0, Ee.string)())),
    initialSharedVersion: (0, Ee.optional)((0, Ee.nullable)(Oo))
  })
}), RI = Ac({
  Object: rg,
  Pure: (0, Ee.object)({
    bytes: xu
  })
}), b3 = Ac({
  None: (0, Ee.literal)(!0),
  Epoch: Oo
}), PI = (0, Ee.object)({
  version: (0, Ee.literal)(2),
  sender: (0, Ee.nullish)(rl),
  expiration: (0, Ee.nullish)(b3),
  gasData: m3,
  inputs: (0, Ee.array)(jI),
  commands: (0, Ee.array)(v3)
});
var ng = Object.defineProperty, NI = Object.getOwnPropertyDescriptor, $I = Object.getOwnPropertyNames, DI = Object.prototype.hasOwnProperty, LI = (e, t) => {
  for (var r in t)
    ng(e, r, { get: t[r], enumerable: !0 });
}, BI = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of $I(t))
      !DI.call(e, i) && i !== r && ng(e, i, { get: () => t[i], enumerable: !(n = NI(t, i)) || n.enumerable });
  return e;
}, UI = (e) => BI(ng({}, "__esModule", { value: !0 }), e), w3 = {};
LI(w3, {
  Commands: () => FI,
  UpgradePolicy: () => _3
});
var ig = UI(w3), _y = on, Bi = Zs, xy = Bn, Ui = Ma, _3 = /* @__PURE__ */ ((e) => (e[e.COMPATIBLE = 0] = "COMPATIBLE", e[e.ADDITIVE = 128] = "ADDITIVE", e[e.DEP_ONLY = 192] = "DEP_ONLY", e))(_3 || {});
const FI = {
  MoveCall(e) {
    const [t, r = "", n = ""] = "target" in e ? e.target.split("::") : [e.package, e.module, e.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: t,
        module: r,
        function: n,
        typeArguments: e.typeArguments ?? [],
        arguments: e.arguments ?? []
      }
    };
  },
  TransferObjects(e, t) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: e.map((r) => (0, Bi.parse)(Ui.Argument, r)),
        address: (0, Bi.parse)(Ui.Argument, t)
      }
    };
  },
  SplitCoins(e, t) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: (0, Bi.parse)(Ui.Argument, e),
        amounts: t.map((r) => (0, Bi.parse)(Ui.Argument, r))
      }
    };
  },
  MergeCoins(e, t) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: (0, Bi.parse)(Ui.Argument, e),
        sources: t.map((r) => (0, Bi.parse)(Ui.Argument, r))
      }
    };
  },
  Publish({
    modules: e,
    dependencies: t
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: e.map(
          (r) => typeof r == "string" ? r : (0, _y.toBase64)(new Uint8Array(r))
        ),
        dependencies: t.map((r) => (0, xy.normalizeSuiObjectId)(r))
      }
    };
  },
  Upgrade({
    modules: e,
    dependencies: t,
    package: r,
    ticket: n
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: e.map(
          (i) => typeof i == "string" ? i : (0, _y.toBase64)(new Uint8Array(i))
        ),
        dependencies: t.map((i) => (0, xy.normalizeSuiObjectId)(i)),
        package: r,
        ticket: (0, Bi.parse)(Ui.Argument, n)
      }
    };
  },
  MakeMoveVec({
    type: e,
    elements: t
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: e ?? null,
        elements: t.map((r) => (0, Bi.parse)(Ui.Argument, r))
      }
    };
  },
  Intent({
    name: e,
    inputs: t = {},
    data: r = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name: e,
        inputs: Object.fromEntries(
          Object.entries(t).map(([n, i]) => [
            n,
            Array.isArray(i) ? i.map((s) => (0, Bi.parse)(Ui.Argument, s)) : (0, Bi.parse)(Ui.Argument, i)
          ])
        ),
        data: r
      }
    };
  }
};
var sg = Object.defineProperty, VI = Object.getOwnPropertyDescriptor, zI = Object.getOwnPropertyNames, WI = Object.prototype.hasOwnProperty, qI = (e, t) => {
  for (var r in t)
    sg(e, r, { get: t[r], enumerable: !0 });
}, HI = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of zI(t))
      !WI.call(e, i) && i !== r && sg(e, i, { get: () => t[i], enumerable: !(n = VI(t, i)) || n.enumerable });
  return e;
}, GI = (e) => HI(sg({}, "__esModule", { value: !0 }), e), x3 = {};
qI(x3, {
  NormalizedCallArg: () => y0,
  ObjectRef: () => Ff,
  SerializedTransactionDataV1: () => ak,
  StructTag: () => C3,
  TransactionArgument: () => as,
  TypeTag: () => Td,
  serializeV1TransactionData: () => ck,
  transactionDataFromV1: () => uk
});
var S3 = GI(x3), oc = on, _e = Zs, E3 = Ri, pu = Ma;
const Ff = (0, _e.object)({
  digest: (0, _e.string)(),
  objectId: (0, _e.string)(),
  version: (0, _e.union)([(0, _e.pipe)((0, _e.number)(), (0, _e.integer)()), (0, _e.string)(), (0, _e.bigint)()])
}), KI = (0, pu.safeEnum)({
  ImmOrOwned: Ff,
  Shared: (0, _e.object)({
    objectId: pu.ObjectID,
    initialSharedVersion: pu.JsonU64,
    mutable: (0, _e.boolean)()
  }),
  Receiving: Ff
}), y0 = (0, pu.safeEnum)({
  Object: KI,
  Pure: (0, _e.array)((0, _e.pipe)((0, _e.number)(), (0, _e.integer)()))
}), T3 = (0, _e.union)([
  (0, _e.object)({
    kind: (0, _e.literal)("Input"),
    index: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)()),
    value: (0, _e.unknown)(),
    type: (0, _e.optional)((0, _e.literal)("object"))
  }),
  (0, _e.object)({
    kind: (0, _e.literal)("Input"),
    index: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)()),
    value: (0, _e.unknown)(),
    type: (0, _e.literal)("pure")
  })
]), YI = (0, _e.union)([
  (0, _e.object)({ Epoch: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)()) }),
  (0, _e.object)({ None: (0, _e.nullable)((0, _e.literal)(!0)) })
]), Sy = (0, _e.pipe)(
  (0, _e.union)([(0, _e.number)(), (0, _e.string)(), (0, _e.bigint)()]),
  (0, _e.check)((e) => {
    if (!["string", "number", "bigint"].includes(typeof e))
      return !1;
    try {
      return BigInt(e), !0;
    } catch {
      return !1;
    }
  })
), Td = (0, _e.union)([
  (0, _e.object)({ bool: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ u8: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ u64: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ u128: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ address: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ signer: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ vector: (0, _e.lazy)(() => Td) }),
  (0, _e.object)({ struct: (0, _e.lazy)(() => C3) }),
  (0, _e.object)({ u16: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ u32: (0, _e.nullable)((0, _e.literal)(!0)) }),
  (0, _e.object)({ u256: (0, _e.nullable)((0, _e.literal)(!0)) })
]), C3 = (0, _e.object)({
  address: (0, _e.string)(),
  module: (0, _e.string)(),
  name: (0, _e.string)(),
  typeParams: (0, _e.array)(Td)
}), XI = (0, _e.object)({
  budget: (0, _e.optional)(Sy),
  price: (0, _e.optional)(Sy),
  payment: (0, _e.optional)((0, _e.array)(Ff)),
  owner: (0, _e.optional)((0, _e.string)())
}), JI = [
  T3,
  (0, _e.object)({ kind: (0, _e.literal)("GasCoin") }),
  (0, _e.object)({ kind: (0, _e.literal)("Result"), index: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)()) }),
  (0, _e.object)({
    kind: (0, _e.literal)("NestedResult"),
    index: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)()),
    resultIndex: (0, _e.pipe)((0, _e.number)(), (0, _e.integer)())
  })
], as = (0, _e.union)([...JI]), ZI = (0, _e.object)({
  kind: (0, _e.literal)("MoveCall"),
  target: (0, _e.pipe)(
    (0, _e.string)(),
    (0, _e.check)((e) => e.split("::").length === 3)
  ),
  typeArguments: (0, _e.array)((0, _e.string)()),
  arguments: (0, _e.array)(as)
}), QI = (0, _e.object)({
  kind: (0, _e.literal)("TransferObjects"),
  objects: (0, _e.array)(as),
  address: as
}), ek = (0, _e.object)({
  kind: (0, _e.literal)("SplitCoins"),
  coin: as,
  amounts: (0, _e.array)(as)
}), tk = (0, _e.object)({
  kind: (0, _e.literal)("MergeCoins"),
  destination: as,
  sources: (0, _e.array)(as)
}), rk = (0, _e.object)({
  kind: (0, _e.literal)("MakeMoveVec"),
  type: (0, _e.union)([(0, _e.object)({ Some: Td }), (0, _e.object)({ None: (0, _e.nullable)((0, _e.literal)(!0)) })]),
  objects: (0, _e.array)(as)
}), nk = (0, _e.object)({
  kind: (0, _e.literal)("Publish"),
  modules: (0, _e.array)((0, _e.array)((0, _e.pipe)((0, _e.number)(), (0, _e.integer)()))),
  dependencies: (0, _e.array)((0, _e.string)())
}), ik = (0, _e.object)({
  kind: (0, _e.literal)("Upgrade"),
  modules: (0, _e.array)((0, _e.array)((0, _e.pipe)((0, _e.number)(), (0, _e.integer)()))),
  dependencies: (0, _e.array)((0, _e.string)()),
  packageId: (0, _e.string)(),
  ticket: as
}), sk = [
  ZI,
  QI,
  ek,
  tk,
  nk,
  ik,
  rk
], ok = (0, _e.union)([...sk]), ak = (0, _e.object)({
  version: (0, _e.literal)(1),
  sender: (0, _e.optional)((0, _e.string)()),
  expiration: (0, _e.nullish)(YI),
  gasConfig: XI,
  inputs: (0, _e.array)(T3),
  transactions: (0, _e.array)(ok)
});
function ck(e) {
  var r;
  const t = e.inputs.map(
    (n, i) => {
      if (n.Object)
        return {
          kind: "Input",
          index: i,
          value: {
            Object: n.Object.ImmOrOwnedObject ? {
              ImmOrOwned: n.Object.ImmOrOwnedObject
            } : n.Object.Receiving ? {
              Receiving: {
                digest: n.Object.Receiving.digest,
                version: n.Object.Receiving.version,
                objectId: n.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: n.Object.SharedObject.mutable,
                initialSharedVersion: n.Object.SharedObject.initialSharedVersion,
                objectId: n.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      if (n.Pure)
        return {
          kind: "Input",
          index: i,
          value: {
            Pure: Array.from((0, oc.fromBase64)(n.Pure.bytes))
          },
          type: "pure"
        };
      if (n.UnresolvedPure)
        return {
          kind: "Input",
          type: "pure",
          index: i,
          value: n.UnresolvedPure.value
        };
      if (n.UnresolvedObject)
        return {
          kind: "Input",
          type: "object",
          index: i,
          value: n.UnresolvedObject.objectId
        };
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: e.sender ?? void 0,
    expiration: ((r = e.expiration) == null ? void 0 : r.$kind) === "Epoch" ? { Epoch: Number(e.expiration.Epoch) } : e.expiration ? { None: !0 } : null,
    gasConfig: {
      owner: e.gasData.owner ?? void 0,
      budget: e.gasData.budget ?? void 0,
      price: e.gasData.price ?? void 0,
      payment: e.gasData.payment ?? void 0
    },
    inputs: t,
    transactions: e.commands.map((n) => {
      if (n.MakeMoveVec)
        return {
          kind: "MakeMoveVec",
          type: n.MakeMoveVec.type === null ? { None: !0 } : { Some: E3.TypeTagSerializer.parseFromStr(n.MakeMoveVec.type) },
          objects: n.MakeMoveVec.elements.map(
            (i) => ws(i, t)
          )
        };
      if (n.MergeCoins)
        return {
          kind: "MergeCoins",
          destination: ws(n.MergeCoins.destination, t),
          sources: n.MergeCoins.sources.map((i) => ws(i, t))
        };
      if (n.MoveCall)
        return {
          kind: "MoveCall",
          target: `${n.MoveCall.package}::${n.MoveCall.module}::${n.MoveCall.function}`,
          typeArguments: n.MoveCall.typeArguments,
          arguments: n.MoveCall.arguments.map(
            (i) => ws(i, t)
          )
        };
      if (n.Publish)
        return {
          kind: "Publish",
          modules: n.Publish.modules.map((i) => Array.from((0, oc.fromBase64)(i))),
          dependencies: n.Publish.dependencies
        };
      if (n.SplitCoins)
        return {
          kind: "SplitCoins",
          coin: ws(n.SplitCoins.coin, t),
          amounts: n.SplitCoins.amounts.map((i) => ws(i, t))
        };
      if (n.TransferObjects)
        return {
          kind: "TransferObjects",
          objects: n.TransferObjects.objects.map(
            (i) => ws(i, t)
          ),
          address: ws(n.TransferObjects.address, t)
        };
      if (n.Upgrade)
        return {
          kind: "Upgrade",
          modules: n.Upgrade.modules.map((i) => Array.from((0, oc.fromBase64)(i))),
          dependencies: n.Upgrade.dependencies,
          packageId: n.Upgrade.package,
          ticket: ws(n.Upgrade.ticket, t)
        };
      throw new Error(`Unknown transaction ${Object.keys(n)}`);
    })
  };
}
function ws(e, t) {
  if (e.$kind === "GasCoin")
    return { kind: "GasCoin" };
  if (e.$kind === "Result")
    return { kind: "Result", index: e.Result };
  if (e.$kind === "NestedResult")
    return { kind: "NestedResult", index: e.NestedResult[0], resultIndex: e.NestedResult[1] };
  if (e.$kind === "Input")
    return t[e.Input];
  throw new Error(`Invalid argument ${Object.keys(e)}`);
}
function uk(e) {
  var t, r, n;
  return (0, _e.parse)(pu.TransactionData, {
    version: 2,
    sender: e.sender ?? null,
    expiration: e.expiration ? "Epoch" in e.expiration ? { Epoch: e.expiration.Epoch } : { None: !0 } : null,
    gasData: {
      owner: e.gasConfig.owner ?? null,
      budget: ((t = e.gasConfig.budget) == null ? void 0 : t.toString()) ?? null,
      price: ((r = e.gasConfig.price) == null ? void 0 : r.toString()) ?? null,
      payment: ((n = e.gasConfig.payment) == null ? void 0 : n.map((i) => ({
        digest: i.digest,
        objectId: i.objectId,
        version: i.version.toString()
      }))) ?? null
    },
    inputs: e.inputs.map((i) => {
      if (i.kind === "Input") {
        if ((0, _e.is)(y0, i.value)) {
          const s = (0, _e.parse)(y0, i.value);
          if (s.Object) {
            if (s.Object.ImmOrOwned)
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: s.Object.ImmOrOwned.objectId,
                    version: String(s.Object.ImmOrOwned.version),
                    digest: s.Object.ImmOrOwned.digest
                  }
                }
              };
            if (s.Object.Shared)
              return {
                Object: {
                  SharedObject: {
                    mutable: s.Object.Shared.mutable ?? null,
                    initialSharedVersion: s.Object.Shared.initialSharedVersion,
                    objectId: s.Object.Shared.objectId
                  }
                }
              };
            if (s.Object.Receiving)
              return {
                Object: {
                  Receiving: {
                    digest: s.Object.Receiving.digest,
                    version: String(s.Object.Receiving.version),
                    objectId: s.Object.Receiving.objectId
                  }
                }
              };
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: (0, oc.toBase64)(new Uint8Array(s.Pure))
            }
          };
        }
        return i.type === "object" ? {
          UnresolvedObject: {
            objectId: i.value
          }
        } : {
          UnresolvedPure: {
            value: i.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: e.transactions.map((i) => {
      switch (i.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in i.type ? E3.TypeTagSerializer.tagToString(i.type.Some) : null,
              elements: i.objects.map((s) => _s(s))
            }
          };
        case "MergeCoins":
          return {
            MergeCoins: {
              destination: _s(i.destination),
              sources: i.sources.map((s) => _s(s))
            }
          };
        case "MoveCall": {
          const [s, o, a] = i.target.split("::");
          return {
            MoveCall: {
              package: s,
              module: o,
              function: a,
              typeArguments: i.typeArguments,
              arguments: i.arguments.map((c) => _s(c))
            }
          };
        }
        case "Publish":
          return {
            Publish: {
              modules: i.modules.map((s) => (0, oc.toBase64)(Uint8Array.from(s))),
              dependencies: i.dependencies
            }
          };
        case "SplitCoins":
          return {
            SplitCoins: {
              coin: _s(i.coin),
              amounts: i.amounts.map((s) => _s(s))
            }
          };
        case "TransferObjects":
          return {
            TransferObjects: {
              objects: i.objects.map((s) => _s(s)),
              address: _s(i.address)
            }
          };
        case "Upgrade":
          return {
            Upgrade: {
              modules: i.modules.map((s) => (0, oc.toBase64)(Uint8Array.from(s))),
              dependencies: i.dependencies,
              package: i.packageId,
              ticket: _s(i.ticket)
            }
          };
      }
      throw new Error(`Unknown transaction ${Object.keys(i)}`);
    })
  });
}
function _s(e) {
  switch (e.kind) {
    case "GasCoin":
      return { GasCoin: !0 };
    case "Result":
      return { Result: e.index };
    case "NestedResult":
      return { NestedResult: [e.index, e.resultIndex] };
    case "Input":
      return { Input: e.index };
  }
}
var og = Object.defineProperty, lk = Object.getOwnPropertyDescriptor, fk = Object.getOwnPropertyNames, dk = Object.prototype.hasOwnProperty, hk = (e, t) => {
  for (var r in t)
    og(e, r, { get: t[r], enumerable: !0 });
}, pk = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of fk(t))
      !dk.call(e, i) && i !== r && og(e, i, { get: () => t[i], enumerable: !(n = lk(t, i)) || n.enumerable });
  return e;
}, mk = (e) => pk(og({}, "__esModule", { value: !0 }), e), A3 = {};
hk(A3, {
  SerializedTransactionDataV2: () => Ek
});
var gk = mk(A3), qe = Zs, kr = Ma;
function nl(e) {
  return (0, qe.union)(
    Object.entries(e).map(([t, r]) => (0, qe.object)({ [t]: r }))
  );
}
const mi = nl({
  GasCoin: (0, qe.literal)(!0),
  Input: (0, qe.pipe)((0, qe.number)(), (0, qe.integer)()),
  Result: (0, qe.pipe)((0, qe.number)(), (0, qe.integer)()),
  NestedResult: (0, qe.tuple)([(0, qe.pipe)((0, qe.number)(), (0, qe.integer)()), (0, qe.pipe)((0, qe.number)(), (0, qe.integer)())])
}), yk = (0, qe.object)({
  budget: (0, qe.nullable)(kr.JsonU64),
  price: (0, qe.nullable)(kr.JsonU64),
  owner: (0, qe.nullable)(kr.SuiAddress),
  payment: (0, qe.nullable)((0, qe.array)(kr.ObjectRef))
}), vk = (0, qe.object)({
  package: kr.ObjectID,
  module: (0, qe.string)(),
  function: (0, qe.string)(),
  // snake case in rust
  typeArguments: (0, qe.array)((0, qe.string)()),
  arguments: (0, qe.array)(mi)
}), bk = (0, qe.object)({
  name: (0, qe.string)(),
  inputs: (0, qe.record)((0, qe.string)(), (0, qe.union)([mi, (0, qe.array)(mi)])),
  data: (0, qe.record)((0, qe.string)(), (0, qe.unknown)())
}), wk = nl({
  MoveCall: vk,
  TransferObjects: (0, qe.object)({
    objects: (0, qe.array)(mi),
    address: mi
  }),
  SplitCoins: (0, qe.object)({
    coin: mi,
    amounts: (0, qe.array)(mi)
  }),
  MergeCoins: (0, qe.object)({
    destination: mi,
    sources: (0, qe.array)(mi)
  }),
  Publish: (0, qe.object)({
    modules: (0, qe.array)(kr.BCSBytes),
    dependencies: (0, qe.array)(kr.ObjectID)
  }),
  MakeMoveVec: (0, qe.object)({
    type: (0, qe.nullable)((0, qe.string)()),
    elements: (0, qe.array)(mi)
  }),
  Upgrade: (0, qe.object)({
    modules: (0, qe.array)(kr.BCSBytes),
    dependencies: (0, qe.array)(kr.ObjectID),
    package: kr.ObjectID,
    ticket: mi
  }),
  $Intent: bk
}), _k = nl({
  ImmOrOwnedObject: kr.ObjectRef,
  SharedObject: (0, qe.object)({
    objectId: kr.ObjectID,
    // snake case in rust
    initialSharedVersion: kr.JsonU64,
    mutable: (0, qe.boolean)()
  }),
  Receiving: kr.ObjectRef
}), xk = nl({
  Object: _k,
  Pure: (0, qe.object)({
    bytes: kr.BCSBytes
  }),
  UnresolvedPure: (0, qe.object)({
    value: (0, qe.unknown)()
  }),
  UnresolvedObject: (0, qe.object)({
    objectId: kr.ObjectID,
    version: (0, qe.optional)((0, qe.nullable)(kr.JsonU64)),
    digest: (0, qe.optional)((0, qe.nullable)((0, qe.string)())),
    initialSharedVersion: (0, qe.optional)((0, qe.nullable)(kr.JsonU64))
  })
}), Sk = nl({
  None: (0, qe.literal)(!0),
  Epoch: kr.JsonU64
}), Ek = (0, qe.object)({
  version: (0, qe.literal)(2),
  sender: (0, qe.nullish)(kr.SuiAddress),
  expiration: (0, qe.nullish)(Sk),
  gasData: yk,
  inputs: (0, qe.array)(xk),
  commands: (0, qe.array)(wk),
  digest: (0, qe.optional)((0, qe.nullable)((0, qe.string)()))
});
var ag = Object.defineProperty, Tk = Object.getOwnPropertyDescriptor, Ck = Object.getOwnPropertyNames, Ak = Object.prototype.hasOwnProperty, M3 = (e) => {
  throw TypeError(e);
}, Mk = (e, t) => {
  for (var r in t)
    ag(e, r, { get: t[r], enumerable: !0 });
}, Ok = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Ck(t))
      !Ak.call(e, i) && i !== r && ag(e, i, { get: () => t[i], enumerable: !(n = Tk(t, i)) || n.enumerable });
  return e;
}, Ik = (e) => Ok(ag({}, "__esModule", { value: !0 }), e), O3 = (e, t, r) => t.has(e) || M3("Cannot " + r), an = (e, t, r) => (O3(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Ey = (e, t, r) => t.has(e) ? M3("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Ty = (e, t, r, n) => (O3(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), I3 = {};
Mk(I3, {
  ClientCache: () => Rk
});
var kk = Ik(I3), Xo, yn;
const jk = class k3 {
  constructor({ prefix: t, cache: r } = {}) {
    Ey(this, Xo), Ey(this, yn), Ty(this, Xo, t ?? []), Ty(this, yn, r ?? /* @__PURE__ */ new Map());
  }
  read(t, r) {
    const n = [an(this, Xo), ...t].join(":");
    if (an(this, yn).has(n))
      return an(this, yn).get(n);
    const i = r();
    return an(this, yn).set(n, i), typeof i == "object" && i !== null && "then" in i ? Promise.resolve(i).then((s) => (an(this, yn).set(n, s), s)).catch((s) => {
      throw an(this, yn).delete(n), s;
    }) : i;
  }
  readSync(t, r) {
    const n = [an(this, Xo), ...t].join(":");
    if (an(this, yn).has(n))
      return an(this, yn).get(n);
    const i = r();
    return an(this, yn).set(n, i), i;
  }
  clear(t) {
    const r = [...an(this, Xo), ...t ?? []].join(":");
    if (!r) {
      an(this, yn).clear();
      return;
    }
    for (const n of an(this, yn).keys())
      n.startsWith(r) && an(this, yn).delete(n);
  }
  scope(t) {
    return new k3({
      prefix: [...an(this, Xo), ...Array.isArray(t) ? t : [t]],
      cache: an(this, yn)
    });
  }
};
Xo = /* @__PURE__ */ new WeakMap();
yn = /* @__PURE__ */ new WeakMap();
let Rk = jk;
const Pk = (e) => _d.encode(e), Nk = (e) => _d.decode(e);
function $k(e) {
  return Uint8Array.from(atob(e), (t) => t.charCodeAt(0));
}
const Fh = 8192;
function Dk(e) {
  if (e.length < Fh)
    return btoa(String.fromCharCode(...e));
  let t = "";
  for (var r = 0; r < e.length; r += Fh) {
    const n = e.slice(r, r + Fh);
    t += String.fromCharCode(...n);
  }
  return btoa(t);
}
function Lk(e) {
  var i;
  const t = e.startsWith("0x") ? e.slice(2) : e, r = t.length % 2 === 0 ? t : `0${t}`, n = ((i = r.match(/[0-9a-fA-F]{2}/g)) == null ? void 0 : i.map((s) => parseInt(s, 16))) ?? [];
  if (n.length !== r.length / 2)
    throw new Error(`Invalid hex string ${e}`);
  return Uint8Array.from(n);
}
function Bk(e) {
  return e.reduce((t, r) => t + r.toString(16).padStart(2, "0"), "");
}
function il(e, t) {
  return Array.from({ length: Math.ceil(e.length / t) }, (r, n) => e.slice(n * t, (n + 1) * t));
}
function Uk() {
  let e, t;
  return {
    promise: new Promise((n, i) => {
      e = n, t = i;
    }),
    resolve: e,
    reject: t
  };
}
class cg {
  constructor(t, r) {
    if (typeof t != "function")
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${t}.`
      );
    this._batchLoadFn = t, this._maxBatchSize = Wk(r), this._batchScheduleFn = qk(r), this._cacheKeyFn = Hk(r), this._cacheMap = Gk(r), this._batch = null, this.name = Kk(r);
  }
  /**
   * Loads a key, returning a `Promise` for the value represented by that key.
   */
  load(t) {
    if (t == null)
      throw new TypeError(
        `The loader.load() function must be called with a value, but got: ${String(t)}.`
      );
    const r = Vk(this), n = this._cacheMap;
    let i;
    if (n) {
      i = this._cacheKeyFn(t);
      const o = n.get(i);
      if (o) {
        const a = r.cacheHits || (r.cacheHits = []);
        return new Promise((c) => {
          a.push(() => {
            c(o);
          });
        });
      }
    }
    r.keys.push(t);
    const s = new Promise((o, a) => {
      r.callbacks.push({ resolve: o, reject: a });
    });
    return n && n.set(i, s), s;
  }
  /**
   * Loads multiple keys, promising an array of values:
   *
   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);
   *
   * This is similar to the more verbose:
   *
   *     var [ a, b ] = await Promise.all([
   *       myLoader.load('a'),
   *       myLoader.load('b')
   *     ]);
   *
   * However it is different in the case where any load fails. Where
   * Promise.all() would reject, loadMany() always resolves, however each result
   * is either a value or an Error instance.
   *
   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);
   *     // c instanceof Error
   *
   */
  loadMany(t) {
    if (!j3(t))
      throw new TypeError(
        `The loader.loadMany() function must be called with Array<key>, but got: ${t}.`
      );
    const r = [];
    for (let n = 0; n < t.length; n++)
      r.push(this.load(t[n]).catch((i) => i));
    return Promise.all(r);
  }
  /**
   * Clears the value at `key` from the cache, if it exists. Returns itself for
   * method chaining.
   */
  clear(t) {
    const r = this._cacheMap;
    if (r) {
      const n = this._cacheKeyFn(t);
      r.delete(n);
    }
    return this;
  }
  /**
   * Clears the entire cache. To be used when some event results in unknown
   * invalidations across this particular `DataLoader`. Returns itself for
   * method chaining.
   */
  clearAll() {
    const t = this._cacheMap;
    return t && t.clear(), this;
  }
  /**
   * Adds the provided key and value to the cache. If the key already
   * exists, no change is made. Returns itself for method chaining.
   *
   * To prime the cache with an error at a key, provide an Error instance.
   */
  prime(t, r) {
    const n = this._cacheMap;
    if (n) {
      const i = this._cacheKeyFn(t);
      if (n.get(i) === void 0) {
        let s;
        r instanceof Error ? (s = Promise.reject(r), s.catch(() => {
        })) : s = Promise.resolve(r), n.set(i, s);
      }
    }
    return this;
  }
}
const Fk = (
  /** @ts-ignore */
  typeof Rn == "object" && typeof Rn.nextTick == "function" ? function(e) {
    Vh || (Vh = Promise.resolve()), Vh.then(() => {
      Rn.nextTick(e);
    });
  } : (
    // @ts-ignore
    typeof setImmediate == "function" ? function(e) {
      setImmediate(e);
    } : function(e) {
      setTimeout(e);
    }
  )
);
let Vh;
function Vk(e) {
  const t = e._batch;
  if (t !== null && !t.hasDispatched && t.keys.length < e._maxBatchSize)
    return t;
  const r = { hasDispatched: !1, keys: [], callbacks: [] };
  return e._batch = r, e._batchScheduleFn(() => {
    zk(e, r);
  }), r;
}
function zk(e, t) {
  if (t.hasDispatched = !0, t.keys.length === 0) {
    v0(t);
    return;
  }
  let r;
  try {
    r = e._batchLoadFn(t.keys);
  } catch (n) {
    return zh(
      e,
      t,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(n)}.`
      )
    );
  }
  if (!r || typeof r.then != "function")
    return zh(
      e,
      t,
      new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(r)}.`
      )
    );
  Promise.resolve(r).then((n) => {
    if (!j3(n))
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(n)}.`
      );
    if (n.length !== t.keys.length)
      throw new TypeError(
        `DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(t.keys)}

Values:
${String(n)}`
      );
    v0(t);
    for (let i = 0; i < t.callbacks.length; i++) {
      const s = n[i];
      s instanceof Error ? t.callbacks[i].reject(s) : t.callbacks[i].resolve(s);
    }
  }).catch((n) => {
    zh(e, t, n);
  });
}
function zh(e, t, r) {
  v0(t);
  for (let n = 0; n < t.keys.length; n++)
    e.clear(t.keys[n]), t.callbacks[n].reject(r);
}
function v0(e) {
  if (e.cacheHits)
    for (let t = 0; t < e.cacheHits.length; t++)
      e.cacheHits[t]();
}
function Wk(e) {
  if (!(!e || e.batch !== !1))
    return 1;
  const r = e && e.maxBatchSize;
  if (r === void 0)
    return 1 / 0;
  if (typeof r != "number" || r < 1)
    throw new TypeError(`maxBatchSize must be a positive number: ${r}`);
  return r;
}
function qk(e) {
  const t = e && e.batchScheduleFn;
  if (t === void 0)
    return Fk;
  if (typeof t != "function")
    throw new TypeError(`batchScheduleFn must be a function: ${t}`);
  return t;
}
function Hk(e) {
  const t = e && e.cacheKeyFn;
  if (t === void 0)
    return (r) => r;
  if (typeof t != "function")
    throw new TypeError(`cacheKeyFn must be a function: ${t}`);
  return t;
}
function Gk(e) {
  if (!(!e || e.cache !== !1))
    return null;
  const r = e && e.cacheMap;
  if (r === void 0)
    return /* @__PURE__ */ new Map();
  if (r !== null) {
    const i = ["get", "set", "delete", "clear"].filter(
      (s) => r && typeof r[s] != "function"
    );
    if (i.length !== 0)
      throw new TypeError("Custom cacheMap missing methods: " + i.join(", "));
  }
  return r;
}
function Kk(e) {
  return e && e.name ? e.name : null;
}
function j3(e) {
  return typeof e == "object" && e !== null && "length" in e && typeof e.length == "number" && (e.length === 0 || e.length > 0 && Object.prototype.hasOwnProperty.call(e, e.length - 1));
}
const Yk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataLoader: cg,
  chunk: il,
  fromBase58: Nk,
  fromBase64: $k,
  fromHex: Lk,
  promiseWithResolvers: Uk,
  toBase58: Pk,
  toBase64: Dk,
  toHex: Bk
}, Symbol.toStringTag, { value: "Module" })), ug = /* @__PURE__ */ Ec(Yk);
var lg = Object.defineProperty, Xk = Object.getOwnPropertyDescriptor, Jk = Object.getOwnPropertyNames, Zk = Object.prototype.hasOwnProperty, Qk = (e, t) => {
  for (var r in t)
    lg(e, r, { get: t[r], enumerable: !0 });
}, ej = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Jk(t))
      !Zk.call(e, i) && i !== r && lg(e, i, { get: () => t[i], enumerable: !(n = Xk(t, i)) || n.enumerable });
  return e;
}, tj = (e) => ej(lg({}, "__esModule", { value: !0 }), e), R3 = {};
Qk(R3, {
  PACKAGE_VERSION: () => nj,
  TARGETED_RPC_VERSION: () => ij
});
var rj = tj(R3);
const nj = "1.34.0", ij = "1.51.0";
var fg = Object.defineProperty, sj = Object.getOwnPropertyDescriptor, oj = Object.getOwnPropertyNames, aj = Object.prototype.hasOwnProperty, P3 = (e) => {
  throw TypeError(e);
}, cj = (e, t) => {
  for (var r in t)
    fg(e, r, { get: t[r], enumerable: !0 });
}, uj = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of oj(t))
      !aj.call(e, i) && i !== r && fg(e, i, { get: () => t[i], enumerable: !(n = sj(t, i)) || n.enumerable });
  return e;
}, lj = (e) => uj(fg({}, "__esModule", { value: !0 }), e), dg = (e, t, r) => t.has(e) || P3("Cannot " + r), Vr = (e, t, r) => (dg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Hc = (e, t, r) => t.has(e) ? P3("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Cl = (e, t, r, n) => (dg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Cd = (e, t, r) => (dg(e, t, "access private method"), r), N3 = {};
cj(N3, {
  MvrClient: () => pj,
  extractMvrTypes: () => Vf,
  findNamesInTransaction: () => gj,
  hasMvrName: () => Rs,
  replaceNames: () => yj
});
var $3 = lj(N3), Ad = ug, hg = Am, go = Bn, fj = rj, Su, zs, Eu, yo, Xi, b0, w0, D3, L3, pg;
const dj = "/", hj = {
  "Mvr-Source": `@mysten/sui@${fj.PACKAGE_VERSION}`
};
let pj = class {
  constructor({ cache: t, url: r, pageSize: n = 50, overrides: i }) {
    Hc(this, Xi), Hc(this, Su), Hc(this, zs), Hc(this, Eu), Hc(this, yo), Cl(this, Su, t), Cl(this, zs, r), Cl(this, Eu, n), Cl(this, yo, {
      packages: i == null ? void 0 : i.packages,
      types: i == null ? void 0 : i.types
    }), mj(Vr(this, yo));
  }
  async resolvePackage({
    package: t
  }) {
    return {
      package: await Vr(this, Xi, b0).load(t)
    };
  }
  async resolveType({
    type: t
  }) {
    const r = [...Vf(t)], n = await Vr(this, Xi, w0).loadMany(r), i = {};
    for (let s = 0; s < r.length; s++) {
      const o = n[s];
      if (o instanceof Error)
        throw o;
      i[r[s]] = o;
    }
    return {
      type: _0(t, i)
    };
  }
  async resolve({
    types: t = [],
    packages: r = []
  }) {
    var l, f, h;
    const n = /* @__PURE__ */ new Set();
    for (const v of t ?? [])
      Vf(v, n);
    const i = [...n], [s, o] = await Promise.all([
      i.length > 0 ? Vr(this, Xi, w0).loadMany(i) : [],
      r.length > 0 ? Vr(this, Xi, b0).loadMany(r) : []
    ]), a = {
      ...(l = Vr(this, yo)) == null ? void 0 : l.types
    };
    for (const [v, b] of i.entries()) {
      const y = s[v];
      if (y instanceof Error)
        throw y;
      a[b] = y;
    }
    const c = {};
    for (const v of t ?? []) {
      const b = _0(v, a);
      c[v] = {
        type: b
      };
    }
    const u = {};
    for (const [v, b] of (r ?? []).entries()) {
      const y = ((h = (f = Vr(this, yo)) == null ? void 0 : f.packages) == null ? void 0 : h[b]) ?? o[v];
      if (y instanceof Error)
        throw y;
      u[b] = {
        package: y
      };
    }
    return {
      types: c,
      packages: u
    };
  }
};
Su = /* @__PURE__ */ new WeakMap();
zs = /* @__PURE__ */ new WeakMap();
Eu = /* @__PURE__ */ new WeakMap();
yo = /* @__PURE__ */ new WeakMap();
Xi = /* @__PURE__ */ new WeakSet();
b0 = function() {
  return Vr(this, Su).readSync(["#mvrPackageDataLoader", Vr(this, zs) ?? ""], () => {
    var r;
    const e = new Ad.DataLoader(async (n) => {
      if (!Vr(this, zs))
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${n.join(", ")})`
        );
      const i = await Cd(this, Xi, D3).call(this, n);
      return n.map(
        (s) => i[s] ?? new Error(`Failed to resolve package: ${s}`)
      );
    }), t = (r = Vr(this, yo)) == null ? void 0 : r.packages;
    if (t)
      for (const [n, i] of Object.entries(t))
        e.prime(n, i);
    return e;
  });
};
w0 = function() {
  return Vr(this, Su).readSync(["#mvrTypeDataLoader", Vr(this, zs) ?? ""], () => {
    var r;
    const e = new Ad.DataLoader(async (n) => {
      if (!Vr(this, zs))
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${n.join(", ")})`
        );
      const i = await Cd(this, Xi, L3).call(this, n);
      return n.map((s) => i[s] ?? new Error(`Failed to resolve type: ${s}`));
    }), t = (r = Vr(this, yo)) == null ? void 0 : r.types;
    if (t)
      for (const [n, i] of Object.entries(t))
        e.prime(n, i);
    return e;
  });
};
D3 = async function(e) {
  if (e.length === 0)
    return {};
  const t = (0, Ad.chunk)(e, Vr(this, Eu)), r = {};
  return await Promise.all(
    t.map(async (n) => {
      var s;
      const i = await Cd(this, Xi, pg).call(this, "/v1/resolution/bulk", {
        names: n
      });
      if (i != null && i.resolution)
        for (const o of Object.keys(i == null ? void 0 : i.resolution)) {
          const a = (s = i.resolution[o]) == null ? void 0 : s.package_id;
          a && (r[o] = a);
        }
    })
  ), r;
};
L3 = async function(e) {
  if (e.length === 0)
    return {};
  const t = (0, Ad.chunk)(e, Vr(this, Eu)), r = {};
  return await Promise.all(
    t.map(async (n) => {
      var s;
      const i = await Cd(this, Xi, pg).call(this, "/v1/struct-definition/bulk", {
        types: n
      });
      if (i != null && i.resolution)
        for (const o of Object.keys(i == null ? void 0 : i.resolution)) {
          const a = (s = i.resolution[o]) == null ? void 0 : s.type_tag;
          a && (r[o] = a);
        }
    })
  ), r;
};
pg = async function(e, t) {
  if (!Vr(this, zs))
    throw new Error("MVR Api URL is not set for the current client");
  const r = await fetch(`${Vr(this, zs)}${e}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...hj
    },
    body: JSON.stringify(t)
  });
  if (!r.ok) {
    const n = await r.json().catch(() => ({}));
    throw new Error(`Failed to resolve types: ${n == null ? void 0 : n.message}`);
  }
  return r.json();
};
function mj(e) {
  if (e != null && e.packages)
    for (const [t, r] of Object.entries(e.packages)) {
      if (!(0, hg.isValidNamedPackage)(t))
        throw new Error(`Invalid package name: ${t}`);
      if (!(0, go.isValidSuiAddress)((0, go.normalizeSuiAddress)(r)))
        throw new Error(`Invalid package ID: ${r}`);
    }
  if (e != null && e.types)
    for (const [t, r] of Object.entries(e.types)) {
      if ((0, go.parseStructTag)(t).typeParams.length > 0)
        throw new Error(
          "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
        );
      const n = (0, go.parseStructTag)(r);
      if (!(0, go.isValidSuiAddress)(n.address))
        throw new Error(`Invalid type: ${r}`);
    }
}
function Vf(e, t = /* @__PURE__ */ new Set()) {
  if (typeof e == "string" && !Rs(e))
    return t;
  const r = B3(e) ? e : (0, go.parseStructTag)(e);
  Rs(r.address) && t.add(`${r.address}::${r.module}::${r.name}`);
  for (const n of r.typeParams)
    Vf(n, t);
  return t;
}
function _0(e, t) {
  const r = B3(e) ? e : (0, go.parseStructTag)(e), n = `${r.address}::${r.module}::${r.name}`, i = t[n];
  return (0, go.normalizeStructTag)({
    ...r,
    address: i ? i.split("::")[0] : r.address,
    typeParams: r.typeParams.map((s) => _0(s, t))
  });
}
function Rs(e) {
  return e.includes(dj) || e.includes("@") || e.includes(".sui");
}
function B3(e) {
  return typeof e == "object" && "address" in e && "module" in e && "name" in e && "typeParams" in e;
}
function gj(e) {
  const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  for (const n of e.commands)
    switch (n.$kind) {
      case "MakeMoveVec":
        n.MakeMoveVec.type && Cy([n.MakeMoveVec.type]).forEach((o) => {
          r.add(o);
        });
        break;
      case "MoveCall":
        const i = n.MoveCall, s = i.package.split("::")[0];
        if (Rs(s)) {
          if (!(0, hg.isValidNamedPackage)(s))
            throw new Error(`Invalid package name: ${s}`);
          t.add(s);
        }
        Cy(i.typeArguments ?? []).forEach((o) => {
          r.add(o);
        });
        break;
    }
  return {
    packages: [...t],
    types: [...r]
  };
}
function yj(e, t) {
  var r;
  for (const n of e.commands) {
    if ((r = n.MakeMoveVec) != null && r.type) {
      if (!Rs(n.MakeMoveVec.type))
        continue;
      if (!t.types[n.MakeMoveVec.type])
        throw new Error(`No resolution found for type: ${n.MakeMoveVec.type}`);
      n.MakeMoveVec.type = t.types[n.MakeMoveVec.type].type;
    }
    const i = n.MoveCall;
    if (!i)
      continue;
    const s = i.package.split("::"), o = s[0];
    if (Rs(o) && !t.packages[o])
      throw new Error(`No address found for package: ${o}`);
    Rs(o) && (s[0] = t.packages[o].package, i.package = s.join("::"));
    const a = i.typeArguments;
    if (a) {
      for (let c = 0; c < a.length; c++)
        if (Rs(a[c])) {
          if (!t.types[a[c]])
            throw new Error(`No resolution found for type: ${a[c]}`);
          a[c] = t.types[a[c]].type;
        }
      i.typeArguments = a;
    }
  }
}
function Cy(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e)
    if (Rs(r)) {
      if (!(0, hg.isValidNamedType)(r))
        throw new Error(`Invalid type with names: ${r}`);
      t.add(r);
    }
  return t;
}
var mg = Object.defineProperty, vj = Object.getOwnPropertyDescriptor, bj = Object.getOwnPropertyNames, wj = Object.prototype.hasOwnProperty, _j = (e, t) => {
  for (var r in t)
    mg(e, r, { get: t[r], enumerable: !0 });
}, xj = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of bj(t))
      !wj.call(e, i) && i !== r && mg(e, i, { get: () => t[i], enumerable: !(n = vj(t, i)) || n.enumerable });
  return e;
}, Sj = (e) => xj(mg({}, "__esModule", { value: !0 }), e), U3 = {};
_j(U3, {
  getClient: () => V3,
  namedPackagesPlugin: () => Cj
});
var F3 = Sj(U3), Ej = kk, Tj = $3, Ay = $3;
const Wh = /* @__PURE__ */ new WeakMap(), Cj = (e) => {
  let t;
  if (e) {
    const r = e.overrides ?? {
      packages: {},
      types: {}
    };
    Wh.has(r) || Wh.set(r, new Ej.ClientCache()), t = new Tj.MvrClient({
      cache: Wh.get(r),
      url: e.url,
      pageSize: e.pageSize,
      overrides: r
    });
  }
  return async (r, n, i) => {
    const s = (0, Ay.findNamesInTransaction)(r);
    if (s.types.length === 0 && s.packages.length === 0)
      return i();
    const o = await (t || V3(n).core.mvr).resolve({
      types: s.types,
      packages: s.packages
    });
    (0, Ay.replaceNames)(r, o), await i();
  };
};
function V3(e) {
  if (!e.client)
    throw new Error(
      "No sui client passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e.client;
}
var gg = Object.defineProperty, Aj = Object.getOwnPropertyDescriptor, Mj = Object.getOwnPropertyNames, Oj = Object.prototype.hasOwnProperty, Ij = (e, t) => {
  for (var r in t)
    gg(e, r, { get: t[r], enumerable: !0 });
}, kj = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Mj(t))
      !Oj.call(e, i) && i !== r && gg(e, i, { get: () => t[i], enumerable: !(n = Aj(t, i)) || n.enumerable });
  return e;
}, jj = (e) => kj(gg({}, "__esModule", { value: !0 }), e), z3 = {};
Ij(z3, {
  suiClientResolveTransactionPlugin: () => Uj
});
var Rj = jj(z3), Pj = Zs, x0 = y4, Nj = Ma, Yl = Xu, qh = b4, $j = ug;
const Dj = 50, Lj = 1000n, Bj = 5e10;
function Uj(e) {
  return async function(r, n, i) {
    return await qj(r, e), await Wj(r, e), n.onlyTransactionKind || (await Fj(r, e), await Vj(r, e), await zj(r, e)), await i();
  };
}
async function Fj(e, t) {
  e.gasConfig.price || (e.gasConfig.price = String(await t.getReferenceGasPrice()));
}
async function Vj(e, t) {
  if (e.gasConfig.budget)
    return;
  const r = await t.dryRunTransactionBlock({
    transactionBlock: e.build({
      overrides: {
        gasData: {
          budget: String(Bj),
          payment: []
        }
      }
    })
  });
  if (r.effects.status.status !== "success")
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${r.effects.status.error}`,
      { cause: r }
    );
  const n = Lj * BigInt(e.gasConfig.price || 1n), i = BigInt(r.effects.gasUsed.computationCost) + n, s = i + BigInt(r.effects.gasUsed.storageCost) - BigInt(r.effects.gasUsed.storageRebate);
  e.gasConfig.budget = String(
    s > i ? s : i
  );
}
async function zj(e, t) {
  if (!e.gasConfig.payment) {
    const n = (await t.getCoins({
      owner: e.gasConfig.owner || e.sender,
      coinType: x0.SUI_TYPE_ARG
    })).data.filter((i) => !e.inputs.find((o) => {
      var a;
      return (a = o.Object) != null && a.ImmOrOwnedObject ? i.coinObjectId === o.Object.ImmOrOwnedObject.objectId : !1;
    })).map((i) => ({
      objectId: i.coinObjectId,
      digest: i.digest,
      version: i.version
    }));
    if (!n.length)
      throw new Error("No valid gas coins found for the transaction.");
    e.gasConfig.payment = n.map((i) => (0, Pj.parse)(Nj.ObjectRef, i));
  }
}
async function Wj(e, t) {
  const r = e.inputs.filter((l) => {
    var f;
    return l.UnresolvedObject && !(l.UnresolvedObject.version || (f = l.UnresolvedObject) != null && f.initialSharedVersion);
  }), n = [
    ...new Set(
      r.map((l) => (0, x0.normalizeSuiObjectId)(l.UnresolvedObject.objectId))
    )
  ], i = n.length ? (0, $j.chunk)(n, Dj) : [], s = (await Promise.all(
    i.map(
      (l) => t.multiGetObjects({
        ids: l,
        options: { showOwner: !0 }
      })
    )
  )).flat(), o = new Map(
    n.map((l, f) => [l, s[f]])
  ), a = Array.from(o).filter(([l, f]) => f.error).map(([l, f]) => JSON.stringify(f.error));
  if (a.length)
    throw new Error(`The following input objects are invalid: ${a.join(", ")}`);
  const c = s.map((l) => {
    if (l.error || !l.data)
      throw new Error(`Failed to fetch object: ${l.error}`);
    const f = l.data.owner, h = f && typeof f == "object" && "Shared" in f ? f.Shared.initial_shared_version : null;
    return {
      objectId: l.data.objectId,
      digest: l.data.digest,
      version: l.data.version,
      initialSharedVersion: h
    };
  }), u = new Map(
    n.map((l, f) => [l, c[f]])
  );
  for (const [l, f] of e.inputs.entries()) {
    if (!f.UnresolvedObject)
      continue;
    let h;
    const v = (0, x0.normalizeSuiAddress)(f.UnresolvedObject.objectId), b = u.get(v);
    f.UnresolvedObject.initialSharedVersion ?? (b == null ? void 0 : b.initialSharedVersion) ? h = Yl.Inputs.SharedObjectRef({
      objectId: v,
      initialSharedVersion: f.UnresolvedObject.initialSharedVersion || (b == null ? void 0 : b.initialSharedVersion),
      mutable: Hj(e, l)
    }) : Gj(e, l) && (h = Yl.Inputs.ReceivingRef(
      {
        objectId: v,
        digest: f.UnresolvedObject.digest ?? (b == null ? void 0 : b.digest),
        version: f.UnresolvedObject.version ?? (b == null ? void 0 : b.version)
      }
    )), e.inputs[e.inputs.indexOf(f)] = h ?? Yl.Inputs.ObjectRef({
      objectId: v,
      digest: f.UnresolvedObject.digest ?? (b == null ? void 0 : b.digest),
      version: f.UnresolvedObject.version ?? (b == null ? void 0 : b.version)
    });
  }
}
async function qj(e, t) {
  const { inputs: r, commands: n } = e, i = [], s = /* @__PURE__ */ new Set();
  n.forEach((a) => {
    if (a.MoveCall) {
      if (a.MoveCall._argumentTypes)
        return;
      if (a.MoveCall.arguments.map((l) => l.$kind === "Input" ? e.inputs[l.Input] : null).some(
        (l) => (l == null ? void 0 : l.UnresolvedPure) || (l == null ? void 0 : l.UnresolvedObject)
      )) {
        const l = `${a.MoveCall.package}::${a.MoveCall.module}::${a.MoveCall.function}`;
        s.add(l), i.push(a.MoveCall);
      }
    }
  });
  const o = /* @__PURE__ */ new Map();
  s.size > 0 && await Promise.all(
    [...s].map(async (a) => {
      const [c, u, l] = a.split("::"), f = await t.getNormalizedMoveFunction({
        package: c,
        module: u,
        function: l
      });
      o.set(
        a,
        f.parameters.map((h) => (0, qh.normalizedTypeToMoveTypeSignature)(h))
      );
    })
  ), i.length && await Promise.all(
    i.map(async (a) => {
      const c = o.get(
        `${a.package}::${a.module}::${a.function}`
      );
      if (!c)
        return;
      const l = c.length > 0 && (0, qh.isTxContext)(c.at(-1)) ? c.slice(0, c.length - 1) : c;
      a._argumentTypes = l;
    })
  ), n.forEach((a) => {
    if (!a.MoveCall)
      return;
    const c = a.MoveCall, u = `${c.package}::${c.module}::${c.function}`, l = c._argumentTypes;
    if (l) {
      if (l.length !== a.MoveCall.arguments.length)
        throw new Error(`Incorrect number of arguments for ${u}`);
      l.forEach((f, h) => {
        var O, I;
        const v = c.arguments[h];
        if (v.$kind !== "Input")
          return;
        const b = r[v.Input];
        if (!b.UnresolvedPure && !b.UnresolvedObject)
          return;
        const y = ((O = b.UnresolvedPure) == null ? void 0 : O.value) ?? ((I = b.UnresolvedObject) == null ? void 0 : I.objectId), S = (0, qh.getPureBcsSchema)(f.body);
        if (S) {
          v.type = "pure", r[r.indexOf(b)] = Yl.Inputs.Pure(S.serialize(y));
          return;
        }
        if (typeof y != "string")
          throw new Error(
            `Expect the argument to be an object id string, got ${JSON.stringify(
              y,
              null,
              2
            )}`
          );
        v.type = "object";
        const C = b.UnresolvedPure ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: {
            objectId: y
          }
        } : b;
        r[v.Input] = C;
      });
    }
  });
}
function Hj(e, t) {
  let r = !1;
  return e.getInputUses(t, (n, i) => {
    if (i.MoveCall && i.MoveCall._argumentTypes) {
      const s = i.MoveCall.arguments.indexOf(n);
      r = i.MoveCall._argumentTypes[s].ref !== "&" || r;
    }
    (i.$kind === "MakeMoveVec" || i.$kind === "MergeCoins" || i.$kind === "SplitCoins") && (r = !0);
  }), r;
}
function Gj(e, t) {
  let r = !1;
  return e.getInputUses(t, (n, i) => {
    if (i.MoveCall && i.MoveCall._argumentTypes) {
      const s = i.MoveCall.arguments.indexOf(n);
      r = Kj(i.MoveCall._argumentTypes[s]) || r;
    }
  }), r;
}
function Kj(e) {
  return typeof e.body != "object" || !("datatype" in e.body) ? !1 : e.body.datatype.package === "0x2" && e.body.datatype.module === "transfer" && e.body.datatype.type === "Receiving";
}
var yg = Object.defineProperty, Yj = Object.getOwnPropertyDescriptor, Xj = Object.getOwnPropertyNames, Jj = Object.prototype.hasOwnProperty, Zj = (e, t) => {
  for (var r in t)
    yg(e, r, { get: t[r], enumerable: !0 });
}, Qj = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Xj(t))
      !Jj.call(e, i) && i !== r && yg(e, i, { get: () => t[i], enumerable: !(n = Yj(t, i)) || n.enumerable });
  return e;
}, eR = (e) => Qj(yg({}, "__esModule", { value: !0 }), e), W3 = {};
Zj(W3, {
  getClient: () => G3,
  needsTransactionResolution: () => H3,
  resolveTransactionPlugin: () => iR
});
var q3 = eR(W3), tR = Xu, My = Ri, rR = F3, nR = Rj;
function H3(e, t) {
  return !!(e.inputs.some((r) => r.UnresolvedObject || r.UnresolvedPure) || !t.onlyTransactionKind && (!e.gasConfig.price || !e.gasConfig.budget || !e.gasConfig.payment));
}
async function iR(e, t, r) {
  var s;
  if (sR(e), !H3(e, t))
    return await Oy(e), r();
  const n = G3(t), i = ((s = n.core) == null ? void 0 : s.resolveTransactionPlugin()) ?? (0, nR.suiClientResolveTransactionPlugin)(n);
  return (0, rR.namedPackagesPlugin)()(e, t, async () => {
    await i(e, t, async () => {
      await Oy(e), await r();
    });
  });
}
function Oy(e) {
  e.inputs.forEach((t, r) => {
    if (t.$kind !== "Object" && t.$kind !== "Pure")
      throw new Error(
        `Input at index ${r} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          t
        )}`
      );
  });
}
function G3(e) {
  if (!e.client)
    throw new Error(
      "No sui client passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e.client;
}
function sR(e) {
  for (const t of e.commands)
    switch (t.$kind) {
      case "SplitCoins":
        t.SplitCoins.amounts.forEach((r) => {
          Iy(r, My.bcs.U64, e);
        });
        break;
      case "TransferObjects":
        Iy(t.TransferObjects.address, My.bcs.Address, e);
        break;
    }
}
function Iy(e, t, r) {
  if (e.$kind !== "Input")
    return;
  const n = r.inputs[e.Input];
  n.$kind === "UnresolvedPure" && (r.inputs[e.Input] = tR.Inputs.Pure(t.serialize(n.UnresolvedPure.value)));
}
var vg = Object.defineProperty, oR = Object.getOwnPropertyDescriptor, aR = Object.getOwnPropertyNames, cR = Object.prototype.hasOwnProperty, uR = (e, t) => {
  for (var r in t)
    vg(e, r, { get: t[r], enumerable: !0 });
}, lR = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of aR(t))
      !cR.call(e, i) && i !== r && vg(e, i, { get: () => t[i], enumerable: !(n = oR(t, i)) || n.enumerable });
  return e;
}, fR = (e) => lR(vg({}, "__esModule", { value: !0 }), e), K3 = {};
uR(K3, {
  createObjectMethods: () => dR
});
var Y3 = fR(K3);
function dR(e) {
  function t(r) {
    return e(r);
  }
  return t.system = () => t("0x5"), t.clock = () => t("0x6"), t.random = () => t("0x8"), t.denyList = () => t("0x403"), t.option = ({ type: r, value: n }) => (i) => i.moveCall({
    typeArguments: [r],
    target: `0x1::option::${n === null ? "none" : "some"}`,
    arguments: n === null ? [] : [i.object(n)]
  }), t;
}
var bg = Object.defineProperty, hR = Object.getOwnPropertyDescriptor, pR = Object.getOwnPropertyNames, mR = Object.prototype.hasOwnProperty, gR = (e, t) => {
  for (var r in t)
    bg(e, r, { get: t[r], enumerable: !0 });
}, yR = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of pR(t))
      !mR.call(e, i) && i !== r && bg(e, i, { get: () => t[i], enumerable: !(n = hR(t, i)) || n.enumerable });
  return e;
}, vR = (e) => yR(bg({}, "__esModule", { value: !0 }), e), X3 = {};
gR(X3, {
  createPure: () => wR
});
var J3 = vR(X3), bR = on, hi = Ri, Hh = Q2;
function wR(e) {
  function t(r, n) {
    if (typeof r == "string")
      return e((0, Hh.pureBcsSchemaFromTypeName)(r).serialize(n));
    if (r instanceof Uint8Array || (0, bR.isSerializedBcs)(r))
      return e(r);
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  return t.u8 = (r) => e(hi.bcs.U8.serialize(r)), t.u16 = (r) => e(hi.bcs.U16.serialize(r)), t.u32 = (r) => e(hi.bcs.U32.serialize(r)), t.u64 = (r) => e(hi.bcs.U64.serialize(r)), t.u128 = (r) => e(hi.bcs.U128.serialize(r)), t.u256 = (r) => e(hi.bcs.U256.serialize(r)), t.bool = (r) => e(hi.bcs.Bool.serialize(r)), t.string = (r) => e(hi.bcs.String.serialize(r)), t.address = (r) => e(hi.bcs.Address.serialize(r)), t.id = t.address, t.vector = (r, n) => e(
    hi.bcs.vector((0, Hh.pureBcsSchemaFromTypeName)(r)).serialize(n)
  ), t.option = (r, n) => e(hi.bcs.option((0, Hh.pureBcsSchemaFromTypeName)(r)).serialize(n)), t;
}
var wg = Object.defineProperty, _R = Object.getOwnPropertyDescriptor, xR = Object.getOwnPropertyNames, SR = Object.prototype.hasOwnProperty, ER = (e, t) => {
  for (var r in t)
    wg(e, r, { get: t[r], enumerable: !0 });
}, TR = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of xR(t))
      !SR.call(e, i) && i !== r && wg(e, i, { get: () => t[i], enumerable: !(n = _R(t, i)) || n.enumerable });
  return e;
}, CR = (e) => TR(wg({}, "__esModule", { value: !0 }), e), Z3 = {};
ER(Z3, {
  hashTypedData: () => OR
});
var AR = CR(Z3), MR = p4;
function OR(e, t) {
  const r = Array.from(`${e}::`).map((i) => i.charCodeAt(0)), n = new Uint8Array(r.length + t.length);
  return n.set(r), n.set(t, r.length), (0, MR.blake2b)(n, { dkLen: 32 });
}
var _g = Object.defineProperty, IR = Object.getOwnPropertyDescriptor, kR = Object.getOwnPropertyNames, jR = Object.prototype.hasOwnProperty, RR = (e, t) => {
  for (var r in t)
    _g(e, r, { get: t[r], enumerable: !0 });
}, PR = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of kR(t))
      !jR.call(e, i) && i !== r && _g(e, i, { get: () => t[i], enumerable: !(n = IR(t, i)) || n.enumerable });
  return e;
}, NR = (e) => PR(_g({}, "__esModule", { value: !0 }), e), Q3 = {};
RR(Q3, {
  TransactionDataBuilder: () => UR
});
var xg = NR(Q3), $R = on, Gh = Zs, Al = Ri, DR = Bn, Kh = Ma, LR = S3, BR = AR;
function ky(e) {
  return (0, DR.normalizeSuiAddress)(e).replace("0x", "");
}
let UR = class Jo {
  constructor(t) {
    this.version = 2, this.sender = (t == null ? void 0 : t.sender) ?? null, this.expiration = (t == null ? void 0 : t.expiration) ?? null, this.inputs = (t == null ? void 0 : t.inputs) ?? [], this.commands = (t == null ? void 0 : t.commands) ?? [], this.gasData = (t == null ? void 0 : t.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(t) {
    const n = Al.bcs.TransactionKind.parse(t).ProgrammableTransaction;
    if (!n)
      throw new Error("Unable to deserialize from bytes.");
    return Jo.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: n.inputs,
      commands: n.commands
    });
  }
  static fromBytes(t) {
    const r = Al.bcs.TransactionData.parse(t), n = r == null ? void 0 : r.V1, i = n.kind.ProgrammableTransaction;
    if (!n || !i)
      throw new Error("Unable to deserialize from bytes.");
    return Jo.restore({
      version: 2,
      sender: n.sender,
      expiration: n.expiration,
      gasData: n.gasData,
      inputs: i.inputs,
      commands: i.commands
    });
  }
  static restore(t) {
    return t.version === 2 ? new Jo((0, Gh.parse)(Kh.TransactionData, t)) : new Jo((0, Gh.parse)(Kh.TransactionData, (0, LR.transactionDataFromV1)(t)));
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(t) {
    const r = (0, BR.hashTypedData)("TransactionData", t);
    return (0, $R.toBase58)(r);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(t) {
    this.gasData = t;
  }
  build({
    maxSizeBytes: t = 1 / 0,
    overrides: r,
    onlyTransactionKind: n
  } = {}) {
    const i = this.inputs, s = this.commands, o = {
      ProgrammableTransaction: {
        inputs: i,
        commands: s
      }
    };
    if (n)
      return Al.bcs.TransactionKind.serialize(o, { maxSize: t }).toBytes();
    const a = (r == null ? void 0 : r.expiration) ?? this.expiration, c = (r == null ? void 0 : r.sender) ?? this.sender, u = { ...this.gasData, ...r == null ? void 0 : r.gasConfig, ...r == null ? void 0 : r.gasData };
    if (!c)
      throw new Error("Missing transaction sender");
    if (!u.budget)
      throw new Error("Missing gas budget");
    if (!u.payment)
      throw new Error("Missing gas payment");
    if (!u.price)
      throw new Error("Missing gas price");
    const l = {
      sender: ky(c),
      expiration: a || { None: !0 },
      gasData: {
        payment: u.payment,
        owner: ky(this.gasData.owner ?? c),
        price: BigInt(u.price),
        budget: BigInt(u.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs: i,
          commands: s
        }
      }
    };
    return Al.bcs.TransactionData.serialize(
      { V1: l },
      { maxSize: t }
    ).toBytes();
  }
  addInput(t, r) {
    const n = this.inputs.length;
    return this.inputs.push(r), { Input: n, type: t, $kind: "Input" };
  }
  getInputUses(t, r) {
    this.mapArguments((n, i) => (n.$kind === "Input" && n.Input === t && r(n, i), n));
  }
  mapCommandArguments(t, r) {
    const n = this.commands[t];
    switch (n.$kind) {
      case "MoveCall":
        n.MoveCall.arguments = n.MoveCall.arguments.map(
          (s) => r(s, n, t)
        );
        break;
      case "TransferObjects":
        n.TransferObjects.objects = n.TransferObjects.objects.map(
          (s) => r(s, n, t)
        ), n.TransferObjects.address = r(n.TransferObjects.address, n, t);
        break;
      case "SplitCoins":
        n.SplitCoins.coin = r(n.SplitCoins.coin, n, t), n.SplitCoins.amounts = n.SplitCoins.amounts.map(
          (s) => r(s, n, t)
        );
        break;
      case "MergeCoins":
        n.MergeCoins.destination = r(n.MergeCoins.destination, n, t), n.MergeCoins.sources = n.MergeCoins.sources.map(
          (s) => r(s, n, t)
        );
        break;
      case "MakeMoveVec":
        n.MakeMoveVec.elements = n.MakeMoveVec.elements.map(
          (s) => r(s, n, t)
        );
        break;
      case "Upgrade":
        n.Upgrade.ticket = r(n.Upgrade.ticket, n, t);
        break;
      case "$Intent":
        const i = n.$Intent.inputs;
        n.$Intent.inputs = {};
        for (const [s, o] of Object.entries(i))
          n.$Intent.inputs[s] = Array.isArray(o) ? o.map((a) => r(a, n, t)) : r(o, n, t);
        break;
      case "Publish":
        break;
      default:
        throw new Error(`Unexpected transaction kind: ${n.$kind}`);
    }
  }
  mapArguments(t) {
    for (const r of this.commands.keys())
      this.mapCommandArguments(r, t);
  }
  replaceCommand(t, r, n = t) {
    if (!Array.isArray(r)) {
      this.commands[t] = r;
      return;
    }
    const i = r.length - 1;
    this.commands.splice(t, 1, ...r), i !== 0 && this.mapArguments((s, o, a) => {
      if (a < t + r.length)
        return s;
      switch (s.$kind) {
        case "Result":
          s.Result === t && (s.Result = n), s.Result > t && (s.Result += i);
          break;
        case "NestedResult":
          s.NestedResult[0] === t && (s.NestedResult[0] = n), s.NestedResult[0] > t && (s.NestedResult[0] += i);
          break;
      }
      return s;
    });
  }
  getDigest() {
    const t = this.build({ onlyTransactionKind: !1 });
    return Jo.getDigestFromBytes(t);
  }
  snapshot() {
    return (0, Gh.parse)(Kh.TransactionData, this);
  }
  shallowClone() {
    return new Jo({
      version: this.version,
      sender: this.sender,
      expiration: this.expiration,
      gasData: {
        ...this.gasData
      },
      inputs: [...this.inputs],
      commands: [...this.commands]
    });
  }
};
var Sg = Object.defineProperty, FR = Object.getOwnPropertyDescriptor, VR = Object.getOwnPropertyNames, zR = Object.prototype.hasOwnProperty, WR = (e, t) => {
  for (var r in t)
    Sg(e, r, { get: t[r], enumerable: !0 });
}, qR = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of VR(t))
      !zR.call(e, i) && i !== r && Sg(e, i, { get: () => t[i], enumerable: !(n = FR(t, i)) || n.enumerable });
  return e;
}, HR = (e) => qR(Sg({}, "__esModule", { value: !0 }), e), e_ = {};
WR(e_, {
  extractMutableReference: () => r_,
  extractReference: () => n_,
  extractStructTag: () => YR,
  getIdFromCallArg: () => XR,
  isArgument: () => JR
});
var t_ = HR(e_), GR = Zs, Gc = Bn, KR = Ma;
function r_(e) {
  return typeof e == "object" && "MutableReference" in e ? e.MutableReference : void 0;
}
function n_(e) {
  return typeof e == "object" && "Reference" in e ? e.Reference : void 0;
}
function YR(e) {
  if (typeof e == "object" && "Struct" in e)
    return e;
  const t = n_(e), r = r_(e);
  if (typeof t == "object" && "Struct" in t)
    return t;
  if (typeof r == "object" && "Struct" in r)
    return r;
}
function XR(e) {
  if (typeof e == "string")
    return (0, Gc.normalizeSuiAddress)(e);
  if (e.Object)
    return e.Object.ImmOrOwnedObject ? (0, Gc.normalizeSuiAddress)(e.Object.ImmOrOwnedObject.objectId) : e.Object.Receiving ? (0, Gc.normalizeSuiAddress)(e.Object.Receiving.objectId) : (0, Gc.normalizeSuiAddress)(e.Object.SharedObject.objectId);
  if (e.UnresolvedObject)
    return (0, Gc.normalizeSuiAddress)(e.UnresolvedObject.objectId);
}
function JR(e) {
  return (0, GR.is)(KR.Argument, e);
}
var Eg = Object.defineProperty, ZR = Object.getOwnPropertyDescriptor, QR = Object.getOwnPropertyNames, eP = Object.prototype.hasOwnProperty, i_ = (e) => {
  throw TypeError(e);
}, tP = (e, t) => {
  for (var r in t)
    Eg(e, r, { get: t[r], enumerable: !0 });
}, rP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of QR(t))
      !eP.call(e, i) && i !== r && Eg(e, i, { get: () => t[i], enumerable: !(n = ZR(t, i)) || n.enumerable });
  return e;
}, nP = (e) => rP(Eg({}, "__esModule", { value: !0 }), e), Tg = (e, t, r) => t.has(e) || i_("Cannot " + r), Fe = (e, t, r) => (Tg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Fi = (e, t, r) => t.has(e) ? i_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), sr = (e, t, r, n) => (Tg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), $r = (e, t, r) => (Tg(e, t, "access private method"), r), s_ = {};
tP(s_, {
  Transaction: () => cP,
  isTransaction: () => f_
});
var Md = nP(s_), Xl = on, ho = Zs, iP = Bn, zo = ig, ra = Ma, jy = S3, sP = gk, Ml = Xu, o_ = q3, oP = Y3, aP = J3, Kc = xg, Ry = t_, sa, ha, As, rs, ei, ti, Si, vo, mt, Tr, a_, Jl, Zl, Ql, zf, S0, Cg, c_, u_;
function Yh(e, t = 1 / 0) {
  const r = {
    $kind: "Result",
    get Result() {
      return typeof e == "function" ? e() : e;
    }
  }, n = [], i = (s) => n[s] ?? (n[s] = {
    $kind: "NestedResult",
    get NestedResult() {
      return [typeof e == "function" ? e() : e, s];
    }
  });
  return new Proxy(r, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(s, o) {
      if (o in s)
        return Reflect.get(s, o);
      if (o === Symbol.iterator)
        return function* () {
          let c = 0;
          for (; c < t; )
            yield i(c), c++;
        };
      if (typeof o == "symbol")
        return;
      const a = parseInt(o, 10);
      if (!(Number.isNaN(a) || a < 0))
        return i(a);
    }
  });
}
const l_ = Symbol.for("@mysten/transaction");
function f_(e) {
  return !!e && typeof e == "object" && e[l_] === !0;
}
const Py = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
}, Xh = Symbol.for("@mysten/transaction/registry");
function Yc() {
  try {
    const e = globalThis;
    return e[Xh] || (e[Xh] = Py), e[Xh];
  } catch {
    return Py;
  }
}
const d_ = class E0 {
  constructor() {
    Fi(this, Tr), Fi(this, sa), Fi(this, ha), Fi(this, As, /* @__PURE__ */ new Map()), Fi(this, rs, []), Fi(this, ei, []), Fi(this, ti, /* @__PURE__ */ new Set()), Fi(this, Si, /* @__PURE__ */ new Set()), Fi(this, vo, /* @__PURE__ */ new Map()), Fi(this, mt), this.object = (0, oP.createObjectMethods)(
      (r) => {
        var s, o;
        if (typeof r == "function")
          return this.object(this.add(r));
        if (typeof r == "object" && (0, ho.is)(ra.Argument, r))
          return r;
        const n = (0, Ry.getIdFromCallArg)(r), i = Fe(this, mt).inputs.find((a) => n === (0, Ry.getIdFromCallArg)(a));
        return (s = i == null ? void 0 : i.Object) != null && s.SharedObject && typeof r == "object" && ((o = r.Object) != null && o.SharedObject) && (i.Object.SharedObject.mutable = i.Object.SharedObject.mutable || r.Object.SharedObject.mutable), i ? { $kind: "Input", Input: Fe(this, mt).inputs.indexOf(i), type: "object" } : $r(this, Tr, Zl).call(this, "object", typeof r == "string" ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: { objectId: (0, iP.normalizeSuiAddress)(r) }
        } : r);
      }
    );
    const t = Yc();
    sr(this, mt, new Kc.TransactionDataBuilder()), sr(this, ha, [...t.buildPlugins.values()]), sr(this, sa, [...t.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(t) {
    const r = new E0();
    return sr(r, mt, Kc.TransactionDataBuilder.fromKindBytes(
      typeof t == "string" ? (0, Xl.fromBase64)(t) : t
    )), sr(r, rs, Fe(r, mt).inputs.slice()), sr(r, ei, Fe(r, mt).commands.slice()), sr(r, ti, new Set(Fe(r, ei).map((n, i) => i))), r;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(t) {
    const r = new E0();
    return f_(t) ? sr(r, mt, new Kc.TransactionDataBuilder(t.getData())) : typeof t != "string" || !t.startsWith("{") ? sr(r, mt, Kc.TransactionDataBuilder.fromBytes(
      typeof t == "string" ? (0, Xl.fromBase64)(t) : t
    )) : sr(r, mt, Kc.TransactionDataBuilder.restore(JSON.parse(t))), sr(r, rs, Fe(r, mt).inputs.slice()), sr(r, ei, Fe(r, mt).commands.slice()), sr(r, ti, new Set(Fe(r, ei).map((n, i) => i))), r;
  }
  static registerGlobalSerializationPlugin(t, r) {
    Yc().serializationPlugins.set(
      t,
      r ?? t
    );
  }
  static unregisterGlobalSerializationPlugin(t) {
    Yc().serializationPlugins.delete(t);
  }
  static registerGlobalBuildPlugin(t, r) {
    Yc().buildPlugins.set(
      t,
      r ?? t
    );
  }
  static unregisterGlobalBuildPlugin(t) {
    Yc().buildPlugins.delete(t);
  }
  addSerializationPlugin(t) {
    Fe(this, sa).push(t);
  }
  addBuildPlugin(t) {
    Fe(this, ha).push(t);
  }
  addIntentResolver(t, r) {
    if (Fe(this, As).has(t) && Fe(this, As).get(t) !== r)
      throw new Error(`Intent resolver for ${t} already exists`);
    Fe(this, As).set(t, r);
  }
  setSender(t) {
    Fe(this, mt).sender = t;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(t) {
    Fe(this, mt).sender || (Fe(this, mt).sender = t);
  }
  setExpiration(t) {
    Fe(this, mt).expiration = t ? (0, ho.parse)(ra.TransactionExpiration, t) : null;
  }
  setGasPrice(t) {
    Fe(this, mt).gasConfig.price = String(t);
  }
  setGasBudget(t) {
    Fe(this, mt).gasConfig.budget = String(t);
  }
  setGasBudgetIfNotSet(t) {
    Fe(this, mt).gasData.budget == null && (Fe(this, mt).gasConfig.budget = String(t));
  }
  setGasOwner(t) {
    Fe(this, mt).gasConfig.owner = t;
  }
  setGasPayment(t) {
    Fe(this, mt).gasConfig.payment = t.map((r) => (0, ho.parse)(ra.ObjectRef, r));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return (0, jy.serializeV1TransactionData)(Fe(this, mt).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return Fe(this, mt).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [l_]() {
    return !0;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    return Object.defineProperty(this, "pure", {
      enumerable: !1,
      value: (0, aP.createPure)((t) => (0, Xl.isSerializedBcs)(t) ? $r(this, Tr, Zl).call(this, "pure", {
        $kind: "Pure",
        Pure: {
          bytes: t.toBase64()
        }
      }) : $r(this, Tr, Zl).call(this, "pure", (0, ho.is)(ra.NormalizedCallArg, t) ? (0, ho.parse)(ra.NormalizedCallArg, t) : t instanceof Uint8Array ? Ml.Inputs.Pure(t) : { $kind: "UnresolvedPure", UnresolvedPure: { value: t } }))
    }), this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: !0 };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...t) {
    return this.object(Ml.Inputs.ObjectRef(...t));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...t) {
    return this.object(Ml.Inputs.ReceivingRef(...t));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...t) {
    return this.object(Ml.Inputs.SharedObjectRef(...t));
  }
  add(t) {
    if (typeof t == "function") {
      if (Fe(this, vo).has(t))
        return Fe(this, vo).get(t);
      const r = $r(this, Tr, a_).call(this), n = t(r);
      if (!(n && typeof n == "object" && "then" in n))
        return sr(this, ti, Fe(r, ti)), Fe(this, vo).set(t, n), n;
      const i = $r(this, Tr, Jl).call(this, {
        $kind: "$Intent",
        $Intent: {
          name: "AsyncTransactionThunk",
          inputs: {},
          data: {
            resultIndex: Fe(this, mt).commands.length,
            result: null
          }
        }
      });
      Fe(this, Si).add(
        Promise.resolve(n).then((o) => {
          i.$Intent.data.result = o;
        })
      );
      const s = Yh(() => i.$Intent.data.resultIndex);
      return Fe(this, vo).set(t, s), s;
    } else
      $r(this, Tr, Jl).call(this, t);
    return Yh(Fe(this, mt).commands.length - 1);
  }
  // Method shorthands:
  splitCoins(t, r) {
    const n = zo.Commands.SplitCoins(
      typeof t == "string" ? this.object(t) : $r(this, Tr, zf).call(this, t),
      r.map(
        (i) => typeof i == "number" || typeof i == "bigint" || typeof i == "string" ? this.pure.u64(i) : $r(this, Tr, Ql).call(this, i)
      )
    );
    return $r(this, Tr, Jl).call(this, n), Yh(Fe(this, mt).commands.length - 1, r.length);
  }
  mergeCoins(t, r) {
    return this.add(
      zo.Commands.MergeCoins(
        this.object(t),
        r.map((n) => this.object(n))
      )
    );
  }
  publish({ modules: t, dependencies: r }) {
    return this.add(
      zo.Commands.Publish({
        modules: t,
        dependencies: r
      })
    );
  }
  upgrade({
    modules: t,
    dependencies: r,
    package: n,
    ticket: i
  }) {
    return this.add(
      zo.Commands.Upgrade({
        modules: t,
        dependencies: r,
        package: n,
        ticket: this.object(i)
      })
    );
  }
  moveCall({
    arguments: t,
    ...r
  }) {
    return this.add(
      zo.Commands.MoveCall({
        ...r,
        arguments: t == null ? void 0 : t.map((n) => $r(this, Tr, Ql).call(this, n))
      })
    );
  }
  transferObjects(t, r) {
    return this.add(
      zo.Commands.TransferObjects(
        t.map((n) => this.object(n)),
        typeof r == "string" ? this.pure.address(r) : $r(this, Tr, Ql).call(this, r)
      )
    );
  }
  makeMoveVec({
    type: t,
    elements: r
  }) {
    return this.add(
      zo.Commands.MakeMoveVec({
        type: t,
        elements: r.map((n) => this.object(n))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify((0, jy.serializeV1TransactionData)(Fe(this, mt).snapshot()));
  }
  async toJSON(t = {}) {
    await this.prepareForSerialization(t);
    const r = this.isFullyResolved();
    return JSON.stringify(
      (0, ho.parse)(
        sP.SerializedTransactionDataV2,
        r ? {
          ...Fe(this, mt).snapshot(),
          digest: Fe(this, mt).getDigest()
        } : Fe(this, mt).snapshot()
      ),
      (n, i) => typeof i == "bigint" ? i.toString() : i,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(t) {
    const { signer: r, ...n } = t, i = await this.build(n);
    return r.signTransaction(i);
  }
  /**
   *  Ensures that:
   *  - All objects have been fully resolved to a specific version
   *  - All pure inputs have been serialized to bytes
   *  - All async thunks have been fully resolved
   *  - All transaction intents have been resolved
   * 	- The gas payment, budget, and price have been set
   *  - The transaction sender has been set
   *
   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)
   */
  isFullyResolved() {
    return !(!Fe(this, mt).sender || Fe(this, Si).size > 0 || Fe(this, mt).commands.some((t) => t.$Intent) || (0, o_.needsTransactionResolution)(Fe(this, mt), {}));
  }
  /** Build the transaction to BCS bytes. */
  async build(t = {}) {
    return await this.prepareForSerialization(t), await $r(this, Tr, S0).call(this, t), Fe(this, mt).build({
      onlyTransactionKind: t.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(t = {}) {
    return await $r(this, Tr, S0).call(this, t), Fe(this, mt).getDigest();
  }
  async prepareForSerialization(t) {
    var i;
    await $r(this, Tr, c_).call(this), $r(this, Tr, u_).call(this);
    const r = /* @__PURE__ */ new Set();
    for (const s of Fe(this, mt).commands)
      s.$Intent && r.add(s.$Intent.name);
    const n = [...Fe(this, sa)];
    for (const s of r)
      if (!((i = t.supportedIntents) != null && i.includes(s))) {
        if (!Fe(this, As).has(s))
          throw new Error(`Missing intent resolver for ${s}`);
        n.push(Fe(this, As).get(s));
      }
    await $r(this, Tr, Cg).call(this, n, t);
  }
};
sa = /* @__PURE__ */ new WeakMap();
ha = /* @__PURE__ */ new WeakMap();
As = /* @__PURE__ */ new WeakMap();
rs = /* @__PURE__ */ new WeakMap();
ei = /* @__PURE__ */ new WeakMap();
ti = /* @__PURE__ */ new WeakMap();
Si = /* @__PURE__ */ new WeakMap();
vo = /* @__PURE__ */ new WeakMap();
mt = /* @__PURE__ */ new WeakMap();
Tr = /* @__PURE__ */ new WeakSet();
a_ = function() {
  const e = new d_();
  return sr(e, mt, Fe(this, mt)), sr(e, sa, Fe(this, sa)), sr(e, ha, Fe(this, ha)), sr(e, As, Fe(this, As)), sr(e, Si, Fe(this, Si)), sr(e, ti, new Set(Fe(this, ti))), sr(e, vo, Fe(this, vo)), Fe(this, rs).push(Fe(e, rs)), Fe(this, ei).push(Fe(e, ei)), e;
};
Jl = function(e) {
  const t = Fe(this, mt).commands.length;
  return Fe(this, ei).push(e), Fe(this, ti).add(t), Fe(this, mt).commands.push(e), Fe(this, mt).mapCommandArguments(t, (r) => {
    if (r.$kind === "Result" && !Fe(this, ti).has(r.Result))
      throw new Error(
        `Result { Result: ${r.Result} } is not available to use the current transaction`
      );
    if (r.$kind === "NestedResult" && !Fe(this, ti).has(r.NestedResult[0]))
      throw new Error(
        `Result { NestedResult: [${r.NestedResult[0]}, ${r.NestedResult[1]}] } is not available to use the current transaction`
      );
    if (r.$kind === "Input" && r.Input >= Fe(this, mt).inputs.length)
      throw new Error(
        `Input { Input: ${r.Input} } references an input that does not exist in the current transaction`
      );
    return r;
  }), e;
};
Zl = function(e, t) {
  return Fe(this, rs).push(t), Fe(this, mt).addInput(e, t);
};
Ql = function(e) {
  return (0, Xl.isSerializedBcs)(e) ? this.pure(e) : $r(this, Tr, zf).call(this, e);
};
zf = function(e) {
  if (typeof e == "function") {
    const t = this.add(e);
    return typeof t == "function" ? $r(this, Tr, zf).call(this, t) : (0, ho.parse)(ra.Argument, t);
  }
  return (0, ho.parse)(ra.Argument, e);
};
S0 = async function(e) {
  if (!e.onlyTransactionKind && !Fe(this, mt).sender)
    throw new Error("Missing transaction sender");
  await $r(this, Tr, Cg).call(this, [...Fe(this, ha), o_.resolveTransactionPlugin], e);
};
Cg = async function(e, t) {
  const r = (n) => {
    if (n >= e.length)
      return () => {
      };
    const i = e[n];
    return async () => {
      const s = r(n + 1);
      let o = !1, a = !1;
      if (await i(Fe(this, mt), t, async () => {
        if (o)
          throw new Error(`next() was call multiple times in TransactionPlugin ${n}`);
        o = !0, await s(), a = !0;
      }), !o)
        throw new Error(`next() was not called in TransactionPlugin ${n}`);
      if (!a)
        throw new Error(`next() was not awaited in TransactionPlugin ${n}`);
    };
  };
  await r(0)(), sr(this, rs, Fe(this, mt).inputs.slice()), sr(this, ei, Fe(this, mt).commands.slice());
};
c_ = async function() {
  for (; Fe(this, Si).size > 0; ) {
    const e = Promise.all(Fe(this, Si));
    Fe(this, Si).clear(), Fe(this, Si).add(e), await e, Fe(this, Si).delete(e);
  }
};
u_ = function() {
  var o;
  const e = Fe(this, mt).commands, t = Fe(this, mt).inputs, r = Fe(this, ei).flat(1 / 0), n = Fe(this, rs).flat(1 / 0);
  if (r.length !== e.length)
    throw new Error("Unexpected number of commands found in transaction data");
  if (n.length !== t.length)
    throw new Error("Unexpected number of inputs found in transaction data");
  const i = r.filter(
    (a) => {
      var c;
      return ((c = a.$Intent) == null ? void 0 : c.name) !== "AsyncTransactionThunk";
    }
  );
  Fe(this, mt).commands = i, Fe(this, mt).inputs = n, sr(this, ei, i), sr(this, rs, n), sr(this, ti, new Set(i.map((a, c) => c)));
  function s(a) {
    var l;
    const c = e[a];
    if (((l = c.$Intent) == null ? void 0 : l.name) === "AsyncTransactionThunk") {
      const f = c.$Intent.data.result;
      if (f == null)
        throw new Error("AsyncTransactionThunk has not been resolved");
      return s(f.Result);
    }
    const u = i.indexOf(c);
    if (u === -1)
      throw new Error("Unable to find original index for command");
    return u;
  }
  Fe(this, mt).mapArguments((a) => {
    if (a.$kind === "Input") {
      const c = n.indexOf(t[a.Input]);
      if (c === -1)
        throw new Error("Input has not been resolved");
      return { ...a, Input: c };
    } else if (a.$kind === "Result") {
      const c = s(a.Result);
      return { ...a, Result: c };
    } else if (a.$kind === "NestedResult") {
      const c = s(a.NestedResult[0]);
      return { ...a, NestedResult: [c, a.NestedResult[1]] };
    }
    return a;
  });
  for (const [a, c] of e.entries())
    if (((o = c.$Intent) == null ? void 0 : o.name) === "AsyncTransactionThunk")
      try {
        c.$Intent.data.resultIndex = s(a);
      } catch {
      }
};
let cP = d_;
var Ag = Object.defineProperty, uP = Object.getOwnPropertyDescriptor, lP = Object.getOwnPropertyNames, fP = Object.prototype.hasOwnProperty, h_ = (e) => {
  throw TypeError(e);
}, dP = (e, t) => {
  for (var r in t)
    Ag(e, r, { get: t[r], enumerable: !0 });
}, hP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of lP(t))
      !fP.call(e, i) && i !== r && Ag(e, i, { get: () => t[i], enumerable: !(n = uP(t, i)) || n.enumerable });
  return e;
}, pP = (e) => hP(Ag({}, "__esModule", { value: !0 }), e), p_ = (e, t, r) => t.has(e) || h_("Cannot " + r), Lr = (e, t, r) => (p_(e, t, "read from private field"), r ? r.call(e) : t.get(e)), T0 = (e, t, r) => t.has(e) ? h_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Ny = (e, t, r, n) => (p_(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), m_ = {};
dP(m_, {
  AsyncCache: () => y_,
  InMemoryCache: () => v_,
  ObjectCache: () => mP
});
var g_ = pP(m_), Jh = Bn, Zo, ln, ef;
class y_ {
  async getObject(t) {
    const [r, n] = await Promise.all([
      this.get("OwnedObject", t),
      this.get("SharedOrImmutableObject", t)
    ]);
    return r ?? n ?? null;
  }
  async getObjects(t) {
    return Promise.all([...t.map((r) => this.getObject(r))]);
  }
  async addObject(t) {
    return t.owner ? await this.set("OwnedObject", t.objectId, t) : await this.set("SharedOrImmutableObject", t.objectId, t), t;
  }
  async addObjects(t) {
    await Promise.all(t.map(async (r) => this.addObject(r)));
  }
  async deleteObject(t) {
    await Promise.all([this.delete("OwnedObject", t), this.delete("SharedOrImmutableObject", t)]);
  }
  async deleteObjects(t) {
    await Promise.all(t.map((r) => this.deleteObject(r)));
  }
  async getMoveFunctionDefinition(t) {
    const r = `${(0, Jh.normalizeSuiAddress)(t.package)}::${t.module}::${t.function}`;
    return this.get("MoveFunction", r);
  }
  async addMoveFunctionDefinition(t) {
    const r = (0, Jh.normalizeSuiAddress)(t.package), n = `${r}::${t.module}::${t.function}`, i = {
      ...t,
      package: r
    };
    return await this.set("MoveFunction", n, i), i;
  }
  async deleteMoveFunctionDefinition(t) {
    const r = `${(0, Jh.normalizeSuiAddress)(t.package)}::${t.module}::${t.function}`;
    await this.delete("MoveFunction", r);
  }
  async getCustom(t) {
    return this.get("Custom", t);
  }
  async setCustom(t, r) {
    return this.set("Custom", t, r);
  }
  async deleteCustom(t) {
    return this.delete("Custom", t);
  }
}
class v_ extends y_ {
  constructor() {
    super(...arguments), T0(this, Zo, {
      OwnedObject: /* @__PURE__ */ new Map(),
      SharedOrImmutableObject: /* @__PURE__ */ new Map(),
      MoveFunction: /* @__PURE__ */ new Map(),
      Custom: /* @__PURE__ */ new Map()
    });
  }
  async get(t, r) {
    return Lr(this, Zo)[t].get(r) ?? null;
  }
  async set(t, r, n) {
    Lr(this, Zo)[t].set(r, n);
  }
  async delete(t, r) {
    Lr(this, Zo)[t].delete(r);
  }
  async clear(t) {
    if (t)
      Lr(this, Zo)[t].clear();
    else
      for (const r of Object.values(Lr(this, Zo)))
        r.clear();
  }
}
Zo = /* @__PURE__ */ new WeakMap();
class mP {
  constructor({ cache: t = new v_(), onEffects: r }) {
    T0(this, ln), T0(this, ef), Ny(this, ln, t), Ny(this, ef, r);
  }
  asPlugin() {
    return async (t, r, n) => {
      const i = t.inputs.filter((a) => a.UnresolvedObject).map((a) => a.UnresolvedObject.objectId), s = (await Lr(this, ln).getObjects(i)).filter(
        (a) => a !== null
      ), o = new Map(s.map((a) => [a.objectId, a]));
      for (const a of t.inputs) {
        if (!a.UnresolvedObject)
          continue;
        const c = o.get(a.UnresolvedObject.objectId);
        c && (c.initialSharedVersion && !a.UnresolvedObject.initialSharedVersion ? a.UnresolvedObject.initialSharedVersion = c.initialSharedVersion : (c.version && !a.UnresolvedObject.version && (a.UnresolvedObject.version = c.version), c.digest && !a.UnresolvedObject.digest && (a.UnresolvedObject.digest = c.digest)));
      }
      await Promise.all(
        t.commands.map(async (a) => {
          if (a.MoveCall) {
            const c = await this.getMoveFunctionDefinition({
              package: a.MoveCall.package,
              module: a.MoveCall.module,
              function: a.MoveCall.function
            });
            c && (a.MoveCall._argumentTypes = c.parameters);
          }
        })
      ), await n(), await Promise.all(
        t.commands.map(async (a) => {
          var c;
          (c = a.MoveCall) != null && c._argumentTypes && await Lr(this, ln).addMoveFunctionDefinition({
            package: a.MoveCall.package,
            module: a.MoveCall.module,
            function: a.MoveCall.function,
            parameters: a.MoveCall._argumentTypes
          });
        })
      );
    };
  }
  async clear() {
    await Lr(this, ln).clear();
  }
  async getMoveFunctionDefinition(t) {
    return Lr(this, ln).getMoveFunctionDefinition(t);
  }
  async getObjects(t) {
    return Lr(this, ln).getObjects(t);
  }
  async deleteObjects(t) {
    return Lr(this, ln).deleteObjects(t);
  }
  async clearOwnedObjects() {
    await Lr(this, ln).clear("OwnedObject");
  }
  async clearCustom() {
    await Lr(this, ln).clear("Custom");
  }
  async getCustom(t) {
    return Lr(this, ln).getCustom(t);
  }
  async setCustom(t, r) {
    return Lr(this, ln).setCustom(t, r);
  }
  async deleteCustom(t) {
    return Lr(this, ln).deleteCustom(t);
  }
  async applyEffects(t) {
    var r;
    if (!t.V2)
      throw new Error(`Unsupported transaction effects version ${t.$kind}`);
    const { lamportVersion: n, changedObjects: i } = t.V2, s = [], o = [];
    i.forEach(([a, c]) => {
      var u;
      if (c.outputState.NotExist)
        s.push(a);
      else if (c.outputState.ObjectWrite) {
        const [l, f] = c.outputState.ObjectWrite;
        o.push({
          objectId: a,
          digest: l,
          version: n,
          owner: f.AddressOwner ?? f.ObjectOwner ?? null,
          initialSharedVersion: ((u = f.Shared) == null ? void 0 : u.initialSharedVersion) ?? null
        });
      }
    }), await Promise.all([
      Lr(this, ln).addObjects(o),
      Lr(this, ln).deleteObjects(s),
      (r = Lr(this, ef)) == null ? void 0 : r.call(this, t)
    ]);
  }
}
ln = /* @__PURE__ */ new WeakMap();
ef = /* @__PURE__ */ new WeakMap();
var Mg = Object.defineProperty, gP = Object.getOwnPropertyDescriptor, yP = Object.getOwnPropertyNames, vP = Object.prototype.hasOwnProperty, b_ = (e) => {
  throw TypeError(e);
}, bP = (e, t) => {
  for (var r in t)
    Mg(e, r, { get: t[r], enumerable: !0 });
}, wP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of yP(t))
      !vP.call(e, i) && i !== r && Mg(e, i, { get: () => t[i], enumerable: !(n = gP(t, i)) || n.enumerable });
  return e;
}, _P = (e) => wP(Mg({}, "__esModule", { value: !0 }), e), w_ = (e, t, r) => t.has(e) || b_("Cannot " + r), Xc = (e, t, r) => (w_(e, t, "read from private field"), r ? r.call(e) : t.get(e)), $y = (e, t, r) => t.has(e) ? b_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Zh = (e, t, r, n) => (w_(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), __ = {};
bP(__, {
  CachingTransactionExecutor: () => TP
});
var x_ = _P(__), xP = Ri, SP = g_, EP = Md, Xa, Ja;
class TP {
  constructor({
    client: t,
    ...r
  }) {
    $y(this, Xa), $y(this, Ja, null), Zh(this, Xa, t), this.cache = new SP.ObjectCache(r);
  }
  /**
   * Clears all Owned objects
   * Immutable objects, Shared objects, and Move function definitions will be preserved
   */
  async reset() {
    await Promise.all([
      this.cache.clearOwnedObjects(),
      this.cache.clearCustom(),
      this.waitForLastTransaction()
    ]);
  }
  async buildTransaction({
    transaction: t,
    ...r
  }) {
    return t.addBuildPlugin(this.cache.asPlugin()), t.build({
      client: Xc(this, Xa),
      ...r
    });
  }
  async executeTransaction({
    transaction: t,
    options: r,
    ...n
  }) {
    const i = (0, EP.isTransaction)(t) ? await this.buildTransaction({ transaction: t }) : t, s = await Xc(this, Xa).executeTransactionBlock({
      ...n,
      transactionBlock: i,
      options: {
        ...r,
        showRawEffects: !0
      }
    });
    if (s.rawEffects) {
      const o = xP.bcs.TransactionEffects.parse(Uint8Array.from(s.rawEffects));
      await this.applyEffects(o);
    }
    return s;
  }
  async signAndExecuteTransaction({
    options: t,
    transaction: r,
    ...n
  }) {
    r.setSenderIfNotSet(n.signer.toSuiAddress());
    const i = await this.buildTransaction({ transaction: r }), { signature: s } = await n.signer.signTransaction(i);
    return await this.executeTransaction({
      transaction: i,
      signature: s,
      options: t
    });
  }
  async applyEffects(t) {
    var r;
    Zh(this, Ja, ((r = t.V2) == null ? void 0 : r.transactionDigest) ?? null), await this.cache.applyEffects(t);
  }
  async waitForLastTransaction() {
    Xc(this, Ja) && (await Xc(this, Xa).waitForTransaction({ digest: Xc(this, Ja) }), Zh(this, Ja, null));
  }
}
Xa = /* @__PURE__ */ new WeakMap();
Ja = /* @__PURE__ */ new WeakMap();
var Og = Object.defineProperty, CP = Object.getOwnPropertyDescriptor, AP = Object.getOwnPropertyNames, MP = Object.prototype.hasOwnProperty, S_ = (e) => {
  throw TypeError(e);
}, OP = (e, t) => {
  for (var r in t)
    Og(e, r, { get: t[r], enumerable: !0 });
}, IP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of AP(t))
      !MP.call(e, i) && i !== r && Og(e, i, { get: () => t[i], enumerable: !(n = CP(t, i)) || n.enumerable });
  return e;
}, kP = (e) => IP(Og({}, "__esModule", { value: !0 }), e), jP = (e, t, r) => t.has(e) || S_("Cannot " + r), wi = (e, t, r) => (jP(e, t, "read from private field"), r ? r.call(e) : t.get(e)), E_ = (e, t, r) => t.has(e) ? S_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), T_ = {};
OP(T_, {
  ParallelQueue: () => PP,
  SerialQueue: () => RP
});
var C_ = kP(T_), ao, Qo;
class RP {
  constructor() {
    E_(this, ao, []);
  }
  async runTask(t) {
    return new Promise((r, n) => {
      wi(this, ao).push(() => {
        t().finally(() => {
          wi(this, ao).shift(), wi(this, ao).length > 0 && wi(this, ao)[0]();
        }).then(r, n);
      }), wi(this, ao).length === 1 && wi(this, ao)[0]();
    });
  }
}
ao = /* @__PURE__ */ new WeakMap();
class PP {
  constructor(t) {
    E_(this, Qo, []), this.activeTasks = 0, this.maxTasks = t;
  }
  runTask(t) {
    return new Promise((r, n) => {
      this.activeTasks < this.maxTasks ? (this.activeTasks++, t().finally(() => {
        wi(this, Qo).length > 0 ? wi(this, Qo).shift()() : this.activeTasks--;
      }).then(r, n)) : wi(this, Qo).push(() => {
        t().finally(() => {
          wi(this, Qo).length > 0 ? wi(this, Qo).shift()() : this.activeTasks--;
        }).then(r, n);
      });
    });
  }
}
Qo = /* @__PURE__ */ new WeakMap();
var Ig = Object.defineProperty, NP = Object.getOwnPropertyDescriptor, $P = Object.getOwnPropertyNames, DP = Object.prototype.hasOwnProperty, A_ = (e) => {
  throw TypeError(e);
}, LP = (e, t) => {
  for (var r in t)
    Ig(e, r, { get: t[r], enumerable: !0 });
}, BP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of $P(t))
      !DP.call(e, i) && i !== r && Ig(e, i, { get: () => t[i], enumerable: !(n = NP(t, i)) || n.enumerable });
  return e;
}, UP = (e) => BP(Ig({}, "__esModule", { value: !0 }), e), M_ = (e, t, r) => t.has(e) || A_("Cannot " + r), cn = (e, t, r) => (M_(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Da = (e, t, r) => t.has(e) ? A_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Qh = (e, t, r, n) => (M_(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), O_ = {};
LP(O_, {
  SerialTransactionExecutor: () => WP,
  getGasCoinFromEffects: () => k_
});
var I_ = UP(O_), FP = on, Dy = Md, VP = x_, zP = C_, tf, ou, pi, rf, C0, nf;
class WP {
  constructor({
    signer: t,
    defaultGasBudget: r = 50000000n,
    ...n
  }) {
    Da(this, tf, new zP.SerialQueue()), Da(this, ou), Da(this, pi), Da(this, rf), Da(this, C0, async (i) => {
      if (!i.V2)
        return;
      const s = k_(i).ref;
      s ? cn(this, pi).cache.setCustom("gasCoin", s) : cn(this, pi).cache.deleteCustom("gasCoin");
    }), Da(this, nf, async (i) => {
      const s = await cn(this, pi).cache.getCustom("gasCoin"), o = Dy.Transaction.from(i);
      return s && o.setGasPayment([s]), o.setGasBudgetIfNotSet(cn(this, rf)), o.setSenderIfNotSet(cn(this, ou).toSuiAddress()), cn(this, pi).buildTransaction({ transaction: o });
    }), Qh(this, ou, t), Qh(this, rf, r), Qh(this, pi, new VP.CachingTransactionExecutor({
      client: n.client,
      cache: n.cache,
      onEffects: (i) => cn(this, C0).call(this, i)
    }));
  }
  async applyEffects(t) {
    return cn(this, pi).applyEffects(t);
  }
  async buildTransaction(t) {
    return cn(this, tf).runTask(() => cn(this, nf).call(this, t));
  }
  resetCache() {
    return cn(this, pi).reset();
  }
  waitForLastTransaction() {
    return cn(this, pi).waitForLastTransaction();
  }
  executeTransaction(t, r, n = []) {
    return cn(this, tf).runTask(async () => {
      const i = (0, Dy.isTransaction)(t) ? await cn(this, nf).call(this, t) : t, { signature: s } = await cn(this, ou).signTransaction(i), o = await cn(this, pi).executeTransaction({
        signature: [s, ...n],
        transaction: i,
        options: r
      }).catch(async (c) => {
        throw await this.resetCache(), c;
      }), a = Uint8Array.from(o.rawEffects);
      return {
        digest: o.digest,
        effects: (0, FP.toBase64)(a),
        data: o
      };
    });
  }
}
tf = /* @__PURE__ */ new WeakMap();
ou = /* @__PURE__ */ new WeakMap();
pi = /* @__PURE__ */ new WeakMap();
rf = /* @__PURE__ */ new WeakMap();
C0 = /* @__PURE__ */ new WeakMap();
nf = /* @__PURE__ */ new WeakMap();
function k_(e) {
  if (!e.V2)
    throw new Error("Unexpected effects version");
  const t = e.V2.changedObjects[e.V2.gasObjectIndex];
  if (!t)
    throw new Error("Gas object not found in effects");
  const [r, { outputState: n }] = t;
  if (!n.ObjectWrite)
    throw new Error("Unexpected gas object state");
  const [i, s] = n.ObjectWrite;
  return {
    ref: {
      objectId: r,
      digest: i,
      version: e.V2.lamportVersion
    },
    owner: s.AddressOwner || s.ObjectOwner
  };
}
var kg = Object.defineProperty, qP = Object.getOwnPropertyDescriptor, HP = Object.getOwnPropertyNames, GP = Object.prototype.hasOwnProperty, j_ = (e) => {
  throw TypeError(e);
}, KP = (e, t) => {
  for (var r in t)
    kg(e, r, { get: t[r], enumerable: !0 });
}, YP = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of HP(t))
      !GP.call(e, i) && i !== r && kg(e, i, { get: () => t[i], enumerable: !(n = qP(t, i)) || n.enumerable });
  return e;
}, XP = (e) => YP(kg({}, "__esModule", { value: !0 }), e), jg = (e, t, r) => t.has(e) || j_("Cannot " + r), ut = (e, t, r) => (jg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Nr = (e, t, r) => t.has(e) ? j_("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), xr = (e, t, r, n) => (jg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), ri = (e, t, r) => (jg(e, t, "access private method"), r), Ly = (e, t, r, n) => ({
  set _(i) {
    xr(e, t, i, r);
  },
  get _() {
    return ut(e, t, n);
  }
}), R_ = {};
KP(R_, {
  ParallelTransactionExecutor: () => nN
});
var JP = XP(R_), ZP = on, QP = ug, P_ = Ri, eN = Md, tN = xg, rN = x_, By = C_, N_ = I_, To, ns, Wf, Tu, mu, Cu, qf, ac, _n, Co, pa, oa, Rg, sf, Au, ec, gc, Ms, On, $_, D_, Mu, Pg, L_, A0, B_;
const Jc = {
  coinBatchSize: 20,
  initialCoinBalance: 200000000n,
  minimumCoinBalance: 50000000n,
  maxPoolSize: 50,
  epochBoundaryWindow: 1e3
};
class nN {
  constructor(t) {
    Nr(this, On), Nr(this, To), Nr(this, ns), Nr(this, Wf), Nr(this, Tu), Nr(this, mu), Nr(this, Cu), Nr(this, qf), Nr(this, ac), Nr(this, _n), Nr(this, Co, []), Nr(this, pa), Nr(this, oa, /* @__PURE__ */ new Map()), Nr(this, Rg, new By.SerialQueue()), Nr(this, sf), Nr(this, Au, null), Nr(this, ec, null), Nr(this, gc, 0), Nr(this, Ms, null), xr(this, To, t.signer), xr(this, ns, t.client), xr(this, Wf, t.coinBatchSize ?? Jc.coinBatchSize), xr(this, Tu, t.initialCoinBalance ?? Jc.initialCoinBalance), xr(this, mu, t.minimumCoinBalance ?? Jc.minimumCoinBalance), xr(this, qf, t.defaultGasBudget ?? ut(this, mu)), xr(this, Cu, t.epochBoundaryWindow ?? Jc.epochBoundaryWindow), xr(this, ac, t.maxPoolSize ?? Jc.maxPoolSize), xr(this, pa, new rN.CachingTransactionExecutor({
      client: t.client,
      cache: t.cache
    })), xr(this, sf, new By.ParallelQueue(ut(this, ac))), xr(this, _n, t.sourceCoins ? new Map(t.sourceCoins.map((r) => [r, null])) : null);
  }
  resetCache() {
    return xr(this, Ms, null), ri(this, On, Mu).call(this, () => ut(this, pa).reset());
  }
  async waitForLastTransaction() {
    await ri(this, On, Mu).call(this, () => ri(this, On, Pg).call(this));
  }
  async executeTransaction(t, r, n = []) {
    const { promise: i, resolve: s, reject: o } = (0, QP.promiseWithResolvers)(), a = await ri(this, On, $_).call(this, t), c = () => {
      ut(this, sf).runTask(() => ri(this, On, D_).call(this, t, a, r, n).then(s, o));
    }, u = /* @__PURE__ */ new Set();
    return a.forEach((l) => {
      ut(this, oa).get(l) ? (u.add(l), ut(this, oa).get(l).push(() => {
        u.delete(l), u.size === 0 && c();
      })) : ut(this, oa).set(l, []);
    }), u.size === 0 && c(), i;
  }
}
To = /* @__PURE__ */ new WeakMap();
ns = /* @__PURE__ */ new WeakMap();
Wf = /* @__PURE__ */ new WeakMap();
Tu = /* @__PURE__ */ new WeakMap();
mu = /* @__PURE__ */ new WeakMap();
Cu = /* @__PURE__ */ new WeakMap();
qf = /* @__PURE__ */ new WeakMap();
ac = /* @__PURE__ */ new WeakMap();
_n = /* @__PURE__ */ new WeakMap();
Co = /* @__PURE__ */ new WeakMap();
pa = /* @__PURE__ */ new WeakMap();
oa = /* @__PURE__ */ new WeakMap();
Rg = /* @__PURE__ */ new WeakMap();
sf = /* @__PURE__ */ new WeakMap();
Au = /* @__PURE__ */ new WeakMap();
ec = /* @__PURE__ */ new WeakMap();
gc = /* @__PURE__ */ new WeakMap();
Ms = /* @__PURE__ */ new WeakMap();
On = /* @__PURE__ */ new WeakSet();
$_ = async function(e) {
  const t = /* @__PURE__ */ new Set();
  let r = !1;
  return e.addSerializationPlugin(async (n, i, s) => {
    await s(), !r && (r = !0, n.inputs.forEach((o) => {
      var a, c, u, l, f;
      (c = (a = o.Object) == null ? void 0 : a.ImmOrOwnedObject) != null && c.objectId ? t.add(o.Object.ImmOrOwnedObject.objectId) : (l = (u = o.Object) == null ? void 0 : u.Receiving) != null && l.objectId ? t.add(o.Object.Receiving.objectId) : (f = o.UnresolvedObject) != null && f.objectId && !o.UnresolvedObject.initialSharedVersion && t.add(o.UnresolvedObject.objectId);
    }));
  }), await e.prepareForSerialization({ client: ut(this, ns) }), t;
};
D_ = async function(e, t, r, n = []) {
  var s;
  let i;
  try {
    e.setSenderIfNotSet(ut(this, To).toSuiAddress()), await ut(this, Rg).runTask(async () => {
      e.getData().gasData.price || e.setGasPrice(await ri(this, On, A0).call(this)), e.setGasBudgetIfNotSet(ut(this, qf)), await ri(this, On, Mu).call(this), i = await ri(this, On, L_).call(this), Ly(this, gc)._++, e.setGasPayment([
        {
          objectId: i.id,
          version: i.version,
          digest: i.digest
        }
      ]), await ut(this, pa).buildTransaction({ transaction: e, onlyTransactionKind: !0 });
    });
    const o = await e.build({ client: ut(this, ns) }), { signature: a } = await ut(this, To).signTransaction(o), c = await ut(this, pa).executeTransaction({
      transaction: o,
      signature: [a, ...n],
      options: {
        ...r,
        showEffects: !0
      }
    }), u = Uint8Array.from(c.rawEffects), l = P_.bcs.TransactionEffects.parse(u), f = (0, N_.getGasCoinFromEffects)(l), h = (s = l.V2) == null ? void 0 : s.gasUsed;
    if (i && h && f.owner === ut(this, To).toSuiAddress()) {
      const v = BigInt(h.computationCost) + BigInt(h.storageCost) + BigInt(h.storageCost) - BigInt(h.storageRebate);
      let b = !1;
      new tN.TransactionDataBuilder(e.getData()).mapArguments((y) => (y.$kind === "GasCoin" && (b = !0), y)), !b && i.balance >= ut(this, mu) ? ut(this, Co).push({
        id: f.ref.objectId,
        version: f.ref.version,
        digest: f.ref.digest,
        balance: i.balance - v
      }) : (ut(this, _n) || xr(this, _n, /* @__PURE__ */ new Map()), ut(this, _n).set(f.ref.objectId, f.ref));
    }
    return xr(this, Au, c.digest), {
      digest: c.digest,
      effects: (0, ZP.toBase64)(u),
      data: c
    };
  } catch (o) {
    throw i && (ut(this, _n) || xr(this, _n, /* @__PURE__ */ new Map()), ut(this, _n).set(i.id, null)), await ri(this, On, Mu).call(this, async () => {
      await Promise.all([
        ut(this, pa).cache.deleteObjects([...t]),
        ri(this, On, Pg).call(this)
      ]);
    }), o;
  } finally {
    t.forEach((o) => {
      const a = ut(this, oa).get(o);
      a && a.length > 0 ? a.shift()() : a && ut(this, oa).delete(o);
    }), Ly(this, gc)._--;
  }
};
Mu = async function(e) {
  ut(this, ec) && await ut(this, ec), xr(this, ec, (e == null ? void 0 : e().then(
    () => {
      xr(this, ec, null);
    },
    () => {
    }
  )) ?? null);
};
Pg = async function() {
  const e = ut(this, Au);
  e && (xr(this, Au, null), await ut(this, ns).waitForTransaction({ digest: e }));
};
L_ = async function() {
  if (ut(this, Co).length === 0 && ut(this, gc) <= ut(this, ac) && await ri(this, On, B_).call(this), ut(this, Co).length === 0)
    throw new Error("No coins available");
  return ut(this, Co).shift();
};
A0 = async function() {
  if ((ut(this, Ms) ? ut(this, Ms).expiration - ut(this, Cu) - Date.now() : 0) > 0)
    return ut(this, Ms).price;
  if (ut(this, Ms)) {
    const r = Math.max(
      ut(this, Ms).expiration + ut(this, Cu) - Date.now(),
      1e3
    );
    await new Promise((n) => setTimeout(n, r));
  }
  const t = await ut(this, ns).getLatestSuiSystemState();
  return xr(this, Ms, {
    price: BigInt(t.referenceGasPrice),
    expiration: Number.parseInt(t.epochStartTimestampMs, 10) + Number.parseInt(t.epochDurationMs, 10)
  }), ri(this, On, A0).call(this);
};
B_ = async function() {
  var u;
  const e = Math.min(
    ut(this, Wf),
    ut(this, ac) - (ut(this, Co).length + ut(this, gc)) + 1
  );
  if (e === 0)
    return;
  const t = new eN.Transaction(), r = ut(this, To).toSuiAddress();
  if (t.setSender(r), ut(this, _n)) {
    const l = [], f = [];
    for (const [h, v] of ut(this, _n))
      v ? l.push(v) : f.push(h);
    if (f.length > 0) {
      const h = await ut(this, ns).multiGetObjects({
        ids: f
      });
      l.push(
        ...h.filter((v) => v.data !== null).map(({ data: v }) => ({
          objectId: v.objectId,
          version: v.version,
          digest: v.digest
        }))
      );
    }
    t.setGasPayment(l), xr(this, _n, /* @__PURE__ */ new Map());
  }
  const n = new Array(e).fill(ut(this, Tu)), i = t.splitCoins(t.gas, n), s = [];
  for (let l = 0; l < n.length; l++)
    s.push(i[l]);
  t.transferObjects(s, r), await this.waitForLastTransaction();
  const o = await ut(this, ns).signAndExecuteTransaction({
    transaction: t,
    signer: ut(this, To),
    options: {
      showRawEffects: !0
    }
  }), a = P_.bcs.TransactionEffects.parse(Uint8Array.from(o.rawEffects));
  (u = a.V2) == null || u.changedObjects.forEach(([l, { outputState: f }], h) => {
    var v;
    h === ((v = a.V2) == null ? void 0 : v.gasObjectIndex) || !f.ObjectWrite || ut(this, Co).push({
      id: l,
      version: a.V2.lamportVersion,
      digest: f.ObjectWrite[0],
      balance: BigInt(ut(this, Tu))
    });
  }), ut(this, _n) || xr(this, _n, /* @__PURE__ */ new Map());
  const c = (0, N_.getGasCoinFromEffects)(a).ref;
  ut(this, _n).set(c.objectId, c), await ut(this, ns).waitForTransaction({ digest: o.digest });
};
var Ng = Object.defineProperty, iN = Object.getOwnPropertyDescriptor, sN = Object.getOwnPropertyNames, oN = Object.prototype.hasOwnProperty, aN = (e, t) => {
  for (var r in t)
    Ng(e, r, { get: t[r], enumerable: !0 });
}, cN = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of sN(t))
      !oN.call(e, i) && i !== r && Ng(e, i, { get: () => t[i], enumerable: !(n = iN(t, i)) || n.enumerable });
  return e;
}, uN = (e) => cN(Ng({}, "__esModule", { value: !0 }), e), U_ = {};
aN(U_, {
  coinWithBalance: () => hN,
  getSuiClient: () => V_
});
var lN = uN(U_), of = Zs, fN = Ri, F_ = Bn, af = ig, Uy = Xu, dN = q3;
const Hf = "CoinWithBalance", Fy = (0, F_.normalizeStructTag)("0x2::sui::SUI");
function hN({
  type: e = Fy,
  balance: t,
  useGasCoin: r = !0
}) {
  let n = null;
  return (i) => {
    if (n)
      return n;
    i.addIntentResolver(Hf, mN);
    const s = e === "gas" ? e : (0, F_.normalizeStructTag)(e);
    return n = i.add(
      af.Commands.Intent({
        name: Hf,
        inputs: {},
        data: {
          type: s === Fy && r ? "gas" : s,
          balance: BigInt(t)
        }
      })
    ), n;
  };
}
const pN = (0, of.object)({
  type: (0, of.string)(),
  balance: (0, of.bigint)()
});
async function mN(e, t, r) {
  var u, l;
  const n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
  if (!e.sender)
    throw new Error("Sender must be set to resolve CoinWithBalance");
  for (const f of e.commands)
    if (f.$kind === "$Intent" && f.$Intent.name === Hf) {
      const { type: h, balance: v } = (0, of.parse)(pN, f.$Intent.data);
      h !== "gas" && v > 0n && n.add(h), i.set(h, (i.get(h) ?? 0n) + v);
    }
  const s = /* @__PURE__ */ new Set();
  for (const f of e.inputs)
    (u = f.Object) != null && u.ImmOrOwnedObject && s.add(f.Object.ImmOrOwnedObject.objectId), (l = f.UnresolvedObject) != null && l.objectId && s.add(f.UnresolvedObject.objectId);
  const o = /* @__PURE__ */ new Map(), a = V_(t);
  await Promise.all(
    [...n].map(async (f) => {
      o.set(
        f,
        await gN({
          coinType: f,
          balance: i.get(f),
          client: a,
          owner: e.sender,
          usedIds: s
        })
      );
    })
  );
  const c = /* @__PURE__ */ new Map();
  c.set("gas", { $kind: "GasCoin", GasCoin: !0 });
  for (const [f, h] of e.commands.entries()) {
    if (h.$kind !== "$Intent" || h.$Intent.name !== Hf)
      continue;
    const { type: v, balance: b } = h.$Intent.data;
    if (b === 0n && v !== "gas") {
      e.replaceCommand(
        f,
        af.Commands.MoveCall({ target: "0x2::coin::zero", typeArguments: [v] })
      );
      continue;
    }
    const y = [];
    if (!c.has(v)) {
      const [S, ...C] = o.get(v).map(
        (O) => e.addInput(
          "object",
          Uy.Inputs.ObjectRef({
            objectId: O.coinObjectId,
            digest: O.digest,
            version: O.version
          })
        )
      );
      C.length > 0 && y.push(af.Commands.MergeCoins(S, C)), c.set(v, S);
    }
    y.push(
      af.Commands.SplitCoins(c.get(v), [
        e.addInput("pure", Uy.Inputs.Pure(fN.bcs.u64().serialize(b)))
      ])
    ), e.replaceCommand(f, y), e.mapArguments((S) => S.$kind === "Result" && S.Result === f ? {
      $kind: "NestedResult",
      NestedResult: [f + y.length - 1, 0]
    } : S);
  }
  return r();
}
async function gN({
  coinType: e,
  balance: t,
  client: r,
  owner: n,
  usedIds: i
}) {
  let s = t;
  const o = [];
  return a();
  async function a(c = null) {
    const { data: u, hasNextPage: l, nextCursor: f } = await r.getCoins({ owner: n, coinType: e, cursor: c }), h = u.sort((v, b) => Number(BigInt(b.balance) - BigInt(v.balance)));
    for (const v of h) {
      if (i.has(v.coinObjectId))
        continue;
      const b = BigInt(v.balance);
      if (o.push(v), s -= b, s <= 0)
        return o;
    }
    if (l)
      return a(f);
    throw new Error(`Not enough coins of type ${e} to satisfy requested balance`);
  }
}
function V_(e) {
  const t = (0, dN.getClient)(e);
  if (!t.jsonRpc)
    throw new Error("CoinWithBalance intent currently only works with SuiClient");
  return t;
}
var $g = Object.defineProperty, yN = Object.getOwnPropertyDescriptor, vN = Object.getOwnPropertyNames, bN = Object.prototype.hasOwnProperty, wN = (e, t) => {
  for (var r in t)
    $g(e, r, { get: t[r], enumerable: !0 });
}, _N = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of vN(t))
      !bN.call(e, i) && i !== r && $g(e, i, { get: () => t[i], enumerable: !(n = yN(t, i)) || n.enumerable });
  return e;
}, xN = (e) => _N($g({}, "__esModule", { value: !0 }), e), z_ = {};
wN(z_, {
  Arguments: () => CN
});
var SN = xN(z_), EN = Y3, TN = J3;
const CN = {
  pure: (0, TN.createPure)((e) => (t) => t.pure(e)),
  object: (0, EN.createObjectMethods)((e) => (t) => t.object(e)),
  sharedObjectRef: (...e) => (t) => t.sharedObjectRef(...e),
  objectRef: (...e) => (t) => t.objectRef(...e),
  receivingRef: (...e) => (t) => t.receivingRef(...e)
};
var Dg = Object.defineProperty, AN = Object.getOwnPropertyDescriptor, MN = Object.getOwnPropertyNames, ON = Object.prototype.hasOwnProperty, IN = (e, t) => {
  for (var r in t)
    Dg(e, r, { get: t[r], enumerable: !0 });
}, kN = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of MN(t))
      !ON.call(e, i) && i !== r && Dg(e, i, { get: () => t[i], enumerable: !(n = AN(t, i)) || n.enumerable });
  return e;
}, jN = (e) => kN(Dg({}, "__esModule", { value: !0 }), e), W_ = {};
IN(W_, {
  Arguments: () => LN.Arguments,
  AsyncCache: () => qy.AsyncCache,
  Commands: () => zy.Commands,
  Inputs: () => RN.Inputs,
  ObjectCache: () => qy.ObjectCache,
  ParallelTransactionExecutor: () => $N.ParallelTransactionExecutor,
  SerialTransactionExecutor: () => NN.SerialTransactionExecutor,
  Transaction: () => Wy.Transaction,
  TransactionDataBuilder: () => PN.TransactionDataBuilder,
  UpgradePolicy: () => zy.UpgradePolicy,
  coinWithBalance: () => DN.coinWithBalance,
  getPureBcsSchema: () => Vy.getPureBcsSchema,
  isArgument: () => UN.isArgument,
  isTransaction: () => Wy.isTransaction,
  namedPackagesPlugin: () => BN.namedPackagesPlugin,
  normalizedTypeToMoveTypeSignature: () => Vy.normalizedTypeToMoveTypeSignature
});
var ni = jN(W_), Vy = b4, RN = Xu, zy = ig, Wy = Md, PN = xg, qy = g_, NN = I_, $N = JP, DN = lN, LN = SN, BN = F3, UN = t_, Od = { exports: {} }, q_ = { exports: {} }, H_ = { exports: {} };
(function(e) {
  (function(t) {
    var r, n = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, s = Math.floor, o = "[BigNumber Error] ", a = o + "Number primitive has more than 15 significant digits: ", c = 1e14, u = 14, l = 9007199254740991, f = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], h = 1e7, v = 1e9;
    function b(H) {
      var z, ne, le, te = P.prototype = { constructor: P, toString: null, valueOf: null }, ce = new P(1), V = 20, L = 4, p = -7, d = 21, m = -1e7, x = 1e7, E = !1, A = 1, j = 0, k = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "",
        // non-breaking space
        suffix: ""
      }, g = "0123456789abcdefghijklmnopqrstuvwxyz", w = !0;
      function P(N, F) {
        var G, ee, Z, q, he, Y, X, B, se = this;
        if (!(se instanceof P))
          return new P(N, F);
        if (F == null) {
          if (N && N._isBigNumber === !0) {
            se.s = N.s, !N.c || N.e > x ? se.c = se.e = null : N.e < m ? se.c = [se.e = 0] : (se.e = N.e, se.c = N.c.slice());
            return;
          }
          if ((Y = typeof N == "number") && N * 0 == 0) {
            if (se.s = 1 / N < 0 ? (N = -N, -1) : 1, N === ~~N) {
              for (q = 0, he = N; he >= 10; he /= 10, q++)
                ;
              q > x ? se.c = se.e = null : (se.e = q, se.c = [N]);
              return;
            }
            B = String(N);
          } else {
            if (!n.test(B = String(N)))
              return le(se, B, Y);
            se.s = B.charCodeAt(0) == 45 ? (B = B.slice(1), -1) : 1;
          }
          (q = B.indexOf(".")) > -1 && (B = B.replace(".", "")), (he = B.search(/e/i)) > 0 ? (q < 0 && (q = he), q += +B.slice(he + 1), B = B.substring(0, he)) : q < 0 && (q = B.length);
        } else {
          if (O(F, 2, g.length, "Base"), F == 10 && w)
            return se = new P(N), ye(se, V + se.e + 1, L);
          if (B = String(N), Y = typeof N == "number") {
            if (N * 0 != 0)
              return le(se, B, Y, F);
            if (se.s = 1 / N < 0 ? (B = B.slice(1), -1) : 1, P.DEBUG && B.replace(/^0\.0*|\./, "").length > 15)
              throw Error(a + N);
          } else
            se.s = B.charCodeAt(0) === 45 ? (B = B.slice(1), -1) : 1;
          for (G = g.slice(0, F), q = he = 0, X = B.length; he < X; he++)
            if (G.indexOf(ee = B.charAt(he)) < 0) {
              if (ee == ".") {
                if (he > q) {
                  q = X;
                  continue;
                }
              } else if (!Z && (B == B.toUpperCase() && (B = B.toLowerCase()) || B == B.toLowerCase() && (B = B.toUpperCase()))) {
                Z = !0, he = -1, q = 0;
                continue;
              }
              return le(se, String(N), Y, F);
            }
          Y = !1, B = ne(B, F, 10, se.s), (q = B.indexOf(".")) > -1 ? B = B.replace(".", "") : q = B.length;
        }
        for (he = 0; B.charCodeAt(he) === 48; he++)
          ;
        for (X = B.length; B.charCodeAt(--X) === 48; )
          ;
        if (B = B.slice(he, ++X)) {
          if (X -= he, Y && P.DEBUG && X > 15 && (N > l || N !== s(N)))
            throw Error(a + se.s * N);
          if ((q = q - he - 1) > x)
            se.c = se.e = null;
          else if (q < m)
            se.c = [se.e = 0];
          else {
            if (se.e = q, se.c = [], he = (q + 1) % u, q < 0 && (he += u), he < X) {
              for (he && se.c.push(+B.slice(0, he)), X -= u; he < X; )
                se.c.push(+B.slice(he, he += u));
              he = u - (B = B.slice(he)).length;
            } else
              he -= X;
            for (; he--; B += "0")
              ;
            se.c.push(+B);
          }
        } else
          se.c = [se.e = 0];
      }
      P.clone = b, P.ROUND_UP = 0, P.ROUND_DOWN = 1, P.ROUND_CEIL = 2, P.ROUND_FLOOR = 3, P.ROUND_HALF_UP = 4, P.ROUND_HALF_DOWN = 5, P.ROUND_HALF_EVEN = 6, P.ROUND_HALF_CEIL = 7, P.ROUND_HALF_FLOOR = 8, P.EUCLID = 9, P.config = P.set = function(N) {
        var F, G;
        if (N != null)
          if (typeof N == "object") {
            if (N.hasOwnProperty(F = "DECIMAL_PLACES") && (G = N[F], O(G, 0, v, F), V = G), N.hasOwnProperty(F = "ROUNDING_MODE") && (G = N[F], O(G, 0, 8, F), L = G), N.hasOwnProperty(F = "EXPONENTIAL_AT") && (G = N[F], G && G.pop ? (O(G[0], -v, 0, F), O(G[1], 0, v, F), p = G[0], d = G[1]) : (O(G, -v, v, F), p = -(d = G < 0 ? -G : G))), N.hasOwnProperty(F = "RANGE"))
              if (G = N[F], G && G.pop)
                O(G[0], -v, -1, F), O(G[1], 1, v, F), m = G[0], x = G[1];
              else if (O(G, -v, v, F), G)
                m = -(x = G < 0 ? -G : G);
              else
                throw Error(o + F + " cannot be zero: " + G);
            if (N.hasOwnProperty(F = "CRYPTO"))
              if (G = N[F], G === !!G)
                if (G)
                  if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    E = G;
                  else
                    throw E = !G, Error(o + "crypto unavailable");
                else
                  E = G;
              else
                throw Error(o + F + " not true or false: " + G);
            if (N.hasOwnProperty(F = "MODULO_MODE") && (G = N[F], O(G, 0, 9, F), A = G), N.hasOwnProperty(F = "POW_PRECISION") && (G = N[F], O(G, 0, v, F), j = G), N.hasOwnProperty(F = "FORMAT"))
              if (G = N[F], typeof G == "object")
                k = G;
              else
                throw Error(o + F + " not an object: " + G);
            if (N.hasOwnProperty(F = "ALPHABET"))
              if (G = N[F], typeof G == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(G))
                w = G.slice(0, 10) == "0123456789", g = G;
              else
                throw Error(o + F + " invalid: " + G);
          } else
            throw Error(o + "Object expected: " + N);
        return {
          DECIMAL_PLACES: V,
          ROUNDING_MODE: L,
          EXPONENTIAL_AT: [p, d],
          RANGE: [m, x],
          CRYPTO: E,
          MODULO_MODE: A,
          POW_PRECISION: j,
          FORMAT: k,
          ALPHABET: g
        };
      }, P.isBigNumber = function(N) {
        if (!N || N._isBigNumber !== !0)
          return !1;
        if (!P.DEBUG)
          return !0;
        var F, G, ee = N.c, Z = N.e, q = N.s;
        e:
          if ({}.toString.call(ee) == "[object Array]") {
            if ((q === 1 || q === -1) && Z >= -v && Z <= v && Z === s(Z)) {
              if (ee[0] === 0) {
                if (Z === 0 && ee.length === 1)
                  return !0;
                break e;
              }
              if (F = (Z + 1) % u, F < 1 && (F += u), String(ee[0]).length == F) {
                for (F = 0; F < ee.length; F++)
                  if (G = ee[F], G < 0 || G >= c || G !== s(G))
                    break e;
                if (G !== 0)
                  return !0;
              }
            }
          } else if (ee === null && Z === null && (q === null || q === 1 || q === -1))
            return !0;
        throw Error(o + "Invalid BigNumber: " + N);
      }, P.maximum = P.max = function() {
        return ie(arguments, -1);
      }, P.minimum = P.min = function() {
        return ie(arguments, 1);
      }, P.random = function() {
        var N = 9007199254740992, F = Math.random() * N & 2097151 ? function() {
          return s(Math.random() * N);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(G) {
          var ee, Z, q, he, Y, X = 0, B = [], se = new P(ce);
          if (G == null ? G = V : O(G, 0, v), he = i(G / u), E)
            if (crypto.getRandomValues) {
              for (ee = crypto.getRandomValues(new Uint32Array(he *= 2)); X < he; )
                Y = ee[X] * 131072 + (ee[X + 1] >>> 11), Y >= 9e15 ? (Z = crypto.getRandomValues(new Uint32Array(2)), ee[X] = Z[0], ee[X + 1] = Z[1]) : (B.push(Y % 1e14), X += 2);
              X = he / 2;
            } else if (crypto.randomBytes) {
              for (ee = crypto.randomBytes(he *= 7); X < he; )
                Y = (ee[X] & 31) * 281474976710656 + ee[X + 1] * 1099511627776 + ee[X + 2] * 4294967296 + ee[X + 3] * 16777216 + (ee[X + 4] << 16) + (ee[X + 5] << 8) + ee[X + 6], Y >= 9e15 ? crypto.randomBytes(7).copy(ee, X) : (B.push(Y % 1e14), X += 7);
              X = he / 7;
            } else
              throw E = !1, Error(o + "crypto unavailable");
          if (!E)
            for (; X < he; )
              Y = F(), Y < 9e15 && (B[X++] = Y % 1e14);
          for (he = B[--X], G %= u, he && G && (Y = f[u - G], B[X] = s(he / Y) * Y); B[X] === 0; B.pop(), X--)
            ;
          if (X < 0)
            B = [q = 0];
          else {
            for (q = -1; B[0] === 0; B.splice(0, 1), q -= u)
              ;
            for (X = 1, Y = B[0]; Y >= 10; Y /= 10, X++)
              ;
            X < u && (q -= u - X);
          }
          return se.e = q, se.c = B, se;
        };
      }(), P.sum = function() {
        for (var N = 1, F = arguments, G = new P(F[0]); N < F.length; )
          G = G.plus(F[N++]);
        return G;
      }, ne = function() {
        var N = "0123456789";
        function F(G, ee, Z, q) {
          for (var he, Y = [0], X, B = 0, se = G.length; B < se; ) {
            for (X = Y.length; X--; Y[X] *= ee)
              ;
            for (Y[0] += q.indexOf(G.charAt(B++)), he = 0; he < Y.length; he++)
              Y[he] > Z - 1 && (Y[he + 1] == null && (Y[he + 1] = 0), Y[he + 1] += Y[he] / Z | 0, Y[he] %= Z);
          }
          return Y.reverse();
        }
        return function(G, ee, Z, q, he) {
          var Y, X, B, se, me, de, xe, Oe, Be = G.indexOf("."), Xe = V, Re = L;
          for (Be >= 0 && (se = j, j = 0, G = G.replace(".", ""), Oe = new P(ee), de = Oe.pow(G.length - Be), j = se, Oe.c = F(
            D(S(de.c), de.e, "0"),
            10,
            Z,
            N
          ), Oe.e = Oe.c.length), xe = F(G, ee, Z, he ? (Y = g, N) : (Y = N, g)), B = se = xe.length; xe[--se] == 0; xe.pop())
            ;
          if (!xe[0])
            return Y.charAt(0);
          if (Be < 0 ? --B : (de.c = xe, de.e = B, de.s = q, de = z(de, Oe, Xe, Re, Z), xe = de.c, me = de.r, B = de.e), X = B + Xe + 1, Be = xe[X], se = Z / 2, me = me || X < 0 || xe[X + 1] != null, me = Re < 4 ? (Be != null || me) && (Re == 0 || Re == (de.s < 0 ? 3 : 2)) : Be > se || Be == se && (Re == 4 || me || Re == 6 && xe[X - 1] & 1 || Re == (de.s < 0 ? 8 : 7)), X < 1 || !xe[0])
            G = me ? D(Y.charAt(1), -Xe, Y.charAt(0)) : Y.charAt(0);
          else {
            if (xe.length = X, me)
              for (--Z; ++xe[--X] > Z; )
                xe[X] = 0, X || (++B, xe = [1].concat(xe));
            for (se = xe.length; !xe[--se]; )
              ;
            for (Be = 0, G = ""; Be <= se; G += Y.charAt(xe[Be++]))
              ;
            G = D(G, B, Y.charAt(0));
          }
          return G;
        };
      }(), z = function() {
        function N(ee, Z, q) {
          var he, Y, X, B, se = 0, me = ee.length, de = Z % h, xe = Z / h | 0;
          for (ee = ee.slice(); me--; )
            X = ee[me] % h, B = ee[me] / h | 0, he = xe * X + B * de, Y = de * X + he % h * h + se, se = (Y / q | 0) + (he / h | 0) + xe * B, ee[me] = Y % q;
          return se && (ee = [se].concat(ee)), ee;
        }
        function F(ee, Z, q, he) {
          var Y, X;
          if (q != he)
            X = q > he ? 1 : -1;
          else
            for (Y = X = 0; Y < q; Y++)
              if (ee[Y] != Z[Y]) {
                X = ee[Y] > Z[Y] ? 1 : -1;
                break;
              }
          return X;
        }
        function G(ee, Z, q, he) {
          for (var Y = 0; q--; )
            ee[q] -= Y, Y = ee[q] < Z[q] ? 1 : 0, ee[q] = Y * he + ee[q] - Z[q];
          for (; !ee[0] && ee.length > 1; ee.splice(0, 1))
            ;
        }
        return function(ee, Z, q, he, Y) {
          var X, B, se, me, de, xe, Oe, Be, Xe, Re, He, rt, Qe, Ot, $t, Ge, ht, ct = ee.s == Z.s ? 1 : -1, et = ee.c, st = Z.c;
          if (!et || !et[0] || !st || !st[0])
            return new P(
              // Return NaN if either NaN, or both Infinity or 0.
              !ee.s || !Z.s || (et ? st && et[0] == st[0] : !st) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                et && et[0] == 0 || !st ? ct * 0 : ct / 0
              )
            );
          for (Be = new P(ct), Xe = Be.c = [], B = ee.e - Z.e, ct = q + B + 1, Y || (Y = c, B = y(ee.e / u) - y(Z.e / u), ct = ct / u | 0), se = 0; st[se] == (et[se] || 0); se++)
            ;
          if (st[se] > (et[se] || 0) && B--, ct < 0)
            Xe.push(1), me = !0;
          else {
            for (Ot = et.length, Ge = st.length, se = 0, ct += 2, de = s(Y / (st[0] + 1)), de > 1 && (st = N(st, de, Y), et = N(et, de, Y), Ge = st.length, Ot = et.length), Qe = Ge, Re = et.slice(0, Ge), He = Re.length; He < Ge; Re[He++] = 0)
              ;
            ht = st.slice(), ht = [0].concat(ht), $t = st[0], st[1] >= Y / 2 && $t++;
            do {
              if (de = 0, X = F(st, Re, Ge, He), X < 0) {
                if (rt = Re[0], Ge != He && (rt = rt * Y + (Re[1] || 0)), de = s(rt / $t), de > 1)
                  for (de >= Y && (de = Y - 1), xe = N(st, de, Y), Oe = xe.length, He = Re.length; F(xe, Re, Oe, He) == 1; )
                    de--, G(xe, Ge < Oe ? ht : st, Oe, Y), Oe = xe.length, X = 1;
                else
                  de == 0 && (X = de = 1), xe = st.slice(), Oe = xe.length;
                if (Oe < He && (xe = [0].concat(xe)), G(Re, xe, He, Y), He = Re.length, X == -1)
                  for (; F(st, Re, Ge, He) < 1; )
                    de++, G(Re, Ge < He ? ht : st, He, Y), He = Re.length;
              } else
                X === 0 && (de++, Re = [0]);
              Xe[se++] = de, Re[0] ? Re[He++] = et[Qe] || 0 : (Re = [et[Qe]], He = 1);
            } while ((Qe++ < Ot || Re[0] != null) && ct--);
            me = Re[0] != null, Xe[0] || Xe.splice(0, 1);
          }
          if (Y == c) {
            for (se = 1, ct = Xe[0]; ct >= 10; ct /= 10, se++)
              ;
            ye(Be, q + (Be.e = se + B * u - 1) + 1, he, me);
          } else
            Be.e = B, Be.r = +me;
          return Be;
        };
      }();
      function ue(N, F, G, ee) {
        var Z, q, he, Y, X;
        if (G == null ? G = L : O(G, 0, 8), !N.c)
          return N.toString();
        if (Z = N.c[0], he = N.e, F == null)
          X = S(N.c), X = ee == 1 || ee == 2 && (he <= p || he >= d) ? U(X, he) : D(X, he, "0");
        else if (N = ye(new P(N), F, G), q = N.e, X = S(N.c), Y = X.length, ee == 1 || ee == 2 && (F <= q || q <= p)) {
          for (; Y < F; X += "0", Y++)
            ;
          X = U(X, q);
        } else if (F -= he + (ee === 2 && q > he), X = D(X, q, "0"), q + 1 > Y) {
          if (--F > 0)
            for (X += "."; F--; X += "0")
              ;
        } else if (F += q - Y, F > 0)
          for (q + 1 == Y && (X += "."); F--; X += "0")
            ;
        return N.s < 0 && Z ? "-" + X : X;
      }
      function ie(N, F) {
        for (var G, ee, Z = 1, q = new P(N[0]); Z < N.length; Z++)
          ee = new P(N[Z]), (!ee.s || (G = C(q, ee)) === F || G === 0 && q.s === F) && (q = ee);
        return q;
      }
      function fe(N, F, G) {
        for (var ee = 1, Z = F.length; !F[--Z]; F.pop())
          ;
        for (Z = F[0]; Z >= 10; Z /= 10, ee++)
          ;
        return (G = ee + G * u - 1) > x ? N.c = N.e = null : G < m ? N.c = [N.e = 0] : (N.e = G, N.c = F), N;
      }
      le = function() {
        var N = /^(-?)0([xbo])(?=\w[\w.]*$)/i, F = /^([^.]+)\.$/, G = /^\.([^.]+)$/, ee = /^-?(Infinity|NaN)$/, Z = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(q, he, Y, X) {
          var B, se = Y ? he : he.replace(Z, "");
          if (ee.test(se))
            q.s = isNaN(se) ? null : se < 0 ? -1 : 1;
          else {
            if (!Y && (se = se.replace(N, function(me, de, xe) {
              return B = (xe = xe.toLowerCase()) == "x" ? 16 : xe == "b" ? 2 : 8, !X || X == B ? de : me;
            }), X && (B = X, se = se.replace(F, "$1").replace(G, "0.$1")), he != se))
              return new P(se, B);
            if (P.DEBUG)
              throw Error(o + "Not a" + (X ? " base " + X : "") + " number: " + he);
            q.s = null;
          }
          q.c = q.e = null;
        };
      }();
      function ye(N, F, G, ee) {
        var Z, q, he, Y, X, B, se, me = N.c, de = f;
        if (me) {
          e: {
            for (Z = 1, Y = me[0]; Y >= 10; Y /= 10, Z++)
              ;
            if (q = F - Z, q < 0)
              q += u, he = F, X = me[B = 0], se = s(X / de[Z - he - 1] % 10);
            else if (B = i((q + 1) / u), B >= me.length)
              if (ee) {
                for (; me.length <= B; me.push(0))
                  ;
                X = se = 0, Z = 1, q %= u, he = q - u + 1;
              } else
                break e;
            else {
              for (X = Y = me[B], Z = 1; Y >= 10; Y /= 10, Z++)
                ;
              q %= u, he = q - u + Z, se = he < 0 ? 0 : s(X / de[Z - he - 1] % 10);
            }
            if (ee = ee || F < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            me[B + 1] != null || (he < 0 ? X : X % de[Z - he - 1]), ee = G < 4 ? (se || ee) && (G == 0 || G == (N.s < 0 ? 3 : 2)) : se > 5 || se == 5 && (G == 4 || ee || G == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (q > 0 ? he > 0 ? X / de[Z - he] : 0 : me[B - 1]) % 10 & 1 || G == (N.s < 0 ? 8 : 7)), F < 1 || !me[0])
              return me.length = 0, ee ? (F -= N.e + 1, me[0] = de[(u - F % u) % u], N.e = -F || 0) : me[0] = N.e = 0, N;
            if (q == 0 ? (me.length = B, Y = 1, B--) : (me.length = B + 1, Y = de[u - q], me[B] = he > 0 ? s(X / de[Z - he] % de[he]) * Y : 0), ee)
              for (; ; )
                if (B == 0) {
                  for (q = 1, he = me[0]; he >= 10; he /= 10, q++)
                    ;
                  for (he = me[0] += Y, Y = 1; he >= 10; he /= 10, Y++)
                    ;
                  q != Y && (N.e++, me[0] == c && (me[0] = 1));
                  break;
                } else {
                  if (me[B] += Y, me[B] != c)
                    break;
                  me[B--] = 0, Y = 1;
                }
            for (q = me.length; me[--q] === 0; me.pop())
              ;
          }
          N.e > x ? N.c = N.e = null : N.e < m && (N.c = [N.e = 0]);
        }
        return N;
      }
      function Te(N) {
        var F, G = N.e;
        return G === null ? N.toString() : (F = S(N.c), F = G <= p || G >= d ? U(F, G) : D(F, G, "0"), N.s < 0 ? "-" + F : F);
      }
      return te.absoluteValue = te.abs = function() {
        var N = new P(this);
        return N.s < 0 && (N.s = 1), N;
      }, te.comparedTo = function(N, F) {
        return C(this, new P(N, F));
      }, te.decimalPlaces = te.dp = function(N, F) {
        var G, ee, Z, q = this;
        if (N != null)
          return O(N, 0, v), F == null ? F = L : O(F, 0, 8), ye(new P(q), N + q.e + 1, F);
        if (!(G = q.c))
          return null;
        if (ee = ((Z = G.length - 1) - y(this.e / u)) * u, Z = G[Z])
          for (; Z % 10 == 0; Z /= 10, ee--)
            ;
        return ee < 0 && (ee = 0), ee;
      }, te.dividedBy = te.div = function(N, F) {
        return z(this, new P(N, F), V, L);
      }, te.dividedToIntegerBy = te.idiv = function(N, F) {
        return z(this, new P(N, F), 0, 1);
      }, te.exponentiatedBy = te.pow = function(N, F) {
        var G, ee, Z, q, he, Y, X, B, se, me = this;
        if (N = new P(N), N.c && !N.isInteger())
          throw Error(o + "Exponent not an integer: " + Te(N));
        if (F != null && (F = new P(F)), Y = N.e > 14, !me.c || !me.c[0] || me.c[0] == 1 && !me.e && me.c.length == 1 || !N.c || !N.c[0])
          return se = new P(Math.pow(+Te(me), Y ? N.s * (2 - I(N)) : +Te(N))), F ? se.mod(F) : se;
        if (X = N.s < 0, F) {
          if (F.c ? !F.c[0] : !F.s)
            return new P(NaN);
          ee = !X && me.isInteger() && F.isInteger(), ee && (me = me.mod(F));
        } else {
          if (N.e > 9 && (me.e > 0 || me.e < -1 || (me.e == 0 ? me.c[0] > 1 || Y && me.c[1] >= 24e7 : me.c[0] < 8e13 || Y && me.c[0] <= 9999975e7)))
            return q = me.s < 0 && I(N) ? -0 : 0, me.e > -1 && (q = 1 / q), new P(X ? 1 / q : q);
          j && (q = i(j / u + 2));
        }
        for (Y ? (G = new P(0.5), X && (N.s = 1), B = I(N)) : (Z = Math.abs(+Te(N)), B = Z % 2), se = new P(ce); ; ) {
          if (B) {
            if (se = se.times(me), !se.c)
              break;
            q ? se.c.length > q && (se.c.length = q) : ee && (se = se.mod(F));
          }
          if (Z) {
            if (Z = s(Z / 2), Z === 0)
              break;
            B = Z % 2;
          } else if (N = N.times(G), ye(N, N.e + 1, 1), N.e > 14)
            B = I(N);
          else {
            if (Z = +Te(N), Z === 0)
              break;
            B = Z % 2;
          }
          me = me.times(me), q ? me.c && me.c.length > q && (me.c.length = q) : ee && (me = me.mod(F));
        }
        return ee ? se : (X && (se = ce.div(se)), F ? se.mod(F) : q ? ye(se, j, L, he) : se);
      }, te.integerValue = function(N) {
        var F = new P(this);
        return N == null ? N = L : O(N, 0, 8), ye(F, F.e + 1, N);
      }, te.isEqualTo = te.eq = function(N, F) {
        return C(this, new P(N, F)) === 0;
      }, te.isFinite = function() {
        return !!this.c;
      }, te.isGreaterThan = te.gt = function(N, F) {
        return C(this, new P(N, F)) > 0;
      }, te.isGreaterThanOrEqualTo = te.gte = function(N, F) {
        return (F = C(this, new P(N, F))) === 1 || F === 0;
      }, te.isInteger = function() {
        return !!this.c && y(this.e / u) > this.c.length - 2;
      }, te.isLessThan = te.lt = function(N, F) {
        return C(this, new P(N, F)) < 0;
      }, te.isLessThanOrEqualTo = te.lte = function(N, F) {
        return (F = C(this, new P(N, F))) === -1 || F === 0;
      }, te.isNaN = function() {
        return !this.s;
      }, te.isNegative = function() {
        return this.s < 0;
      }, te.isPositive = function() {
        return this.s > 0;
      }, te.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, te.minus = function(N, F) {
        var G, ee, Z, q, he = this, Y = he.s;
        if (N = new P(N, F), F = N.s, !Y || !F)
          return new P(NaN);
        if (Y != F)
          return N.s = -F, he.plus(N);
        var X = he.e / u, B = N.e / u, se = he.c, me = N.c;
        if (!X || !B) {
          if (!se || !me)
            return se ? (N.s = -F, N) : new P(me ? he : NaN);
          if (!se[0] || !me[0])
            return me[0] ? (N.s = -F, N) : new P(se[0] ? he : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              L == 3 ? -0 : 0
            ));
        }
        if (X = y(X), B = y(B), se = se.slice(), Y = X - B) {
          for ((q = Y < 0) ? (Y = -Y, Z = se) : (B = X, Z = me), Z.reverse(), F = Y; F--; Z.push(0))
            ;
          Z.reverse();
        } else
          for (ee = (q = (Y = se.length) < (F = me.length)) ? Y : F, Y = F = 0; F < ee; F++)
            if (se[F] != me[F]) {
              q = se[F] < me[F];
              break;
            }
        if (q && (Z = se, se = me, me = Z, N.s = -N.s), F = (ee = me.length) - (G = se.length), F > 0)
          for (; F--; se[G++] = 0)
            ;
        for (F = c - 1; ee > Y; ) {
          if (se[--ee] < me[ee]) {
            for (G = ee; G && !se[--G]; se[G] = F)
              ;
            --se[G], se[ee] += c;
          }
          se[ee] -= me[ee];
        }
        for (; se[0] == 0; se.splice(0, 1), --B)
          ;
        return se[0] ? fe(N, se, B) : (N.s = L == 3 ? -1 : 1, N.c = [N.e = 0], N);
      }, te.modulo = te.mod = function(N, F) {
        var G, ee, Z = this;
        return N = new P(N, F), !Z.c || !N.s || N.c && !N.c[0] ? new P(NaN) : !N.c || Z.c && !Z.c[0] ? new P(Z) : (A == 9 ? (ee = N.s, N.s = 1, G = z(Z, N, 0, 3), N.s = ee, G.s *= ee) : G = z(Z, N, 0, A), N = Z.minus(G.times(N)), !N.c[0] && A == 1 && (N.s = Z.s), N);
      }, te.multipliedBy = te.times = function(N, F) {
        var G, ee, Z, q, he, Y, X, B, se, me, de, xe, Oe, Be, Xe, Re = this, He = Re.c, rt = (N = new P(N, F)).c;
        if (!He || !rt || !He[0] || !rt[0])
          return !Re.s || !N.s || He && !He[0] && !rt || rt && !rt[0] && !He ? N.c = N.e = N.s = null : (N.s *= Re.s, !He || !rt ? N.c = N.e = null : (N.c = [0], N.e = 0)), N;
        for (ee = y(Re.e / u) + y(N.e / u), N.s *= Re.s, X = He.length, me = rt.length, X < me && (Oe = He, He = rt, rt = Oe, Z = X, X = me, me = Z), Z = X + me, Oe = []; Z--; Oe.push(0))
          ;
        for (Be = c, Xe = h, Z = me; --Z >= 0; ) {
          for (G = 0, de = rt[Z] % Xe, xe = rt[Z] / Xe | 0, he = X, q = Z + he; q > Z; )
            B = He[--he] % Xe, se = He[he] / Xe | 0, Y = xe * B + se * de, B = de * B + Y % Xe * Xe + Oe[q] + G, G = (B / Be | 0) + (Y / Xe | 0) + xe * se, Oe[q--] = B % Be;
          Oe[q] = G;
        }
        return G ? ++ee : Oe.splice(0, 1), fe(N, Oe, ee);
      }, te.negated = function() {
        var N = new P(this);
        return N.s = -N.s || null, N;
      }, te.plus = function(N, F) {
        var G, ee = this, Z = ee.s;
        if (N = new P(N, F), F = N.s, !Z || !F)
          return new P(NaN);
        if (Z != F)
          return N.s = -F, ee.minus(N);
        var q = ee.e / u, he = N.e / u, Y = ee.c, X = N.c;
        if (!q || !he) {
          if (!Y || !X)
            return new P(Z / 0);
          if (!Y[0] || !X[0])
            return X[0] ? N : new P(Y[0] ? ee : Z * 0);
        }
        if (q = y(q), he = y(he), Y = Y.slice(), Z = q - he) {
          for (Z > 0 ? (he = q, G = X) : (Z = -Z, G = Y), G.reverse(); Z--; G.push(0))
            ;
          G.reverse();
        }
        for (Z = Y.length, F = X.length, Z - F < 0 && (G = X, X = Y, Y = G, F = Z), Z = 0; F; )
          Z = (Y[--F] = Y[F] + X[F] + Z) / c | 0, Y[F] = c === Y[F] ? 0 : Y[F] % c;
        return Z && (Y = [Z].concat(Y), ++he), fe(N, Y, he);
      }, te.precision = te.sd = function(N, F) {
        var G, ee, Z, q = this;
        if (N != null && N !== !!N)
          return O(N, 1, v), F == null ? F = L : O(F, 0, 8), ye(new P(q), N, F);
        if (!(G = q.c))
          return null;
        if (Z = G.length - 1, ee = Z * u + 1, Z = G[Z]) {
          for (; Z % 10 == 0; Z /= 10, ee--)
            ;
          for (Z = G[0]; Z >= 10; Z /= 10, ee++)
            ;
        }
        return N && q.e + 1 > ee && (ee = q.e + 1), ee;
      }, te.shiftedBy = function(N) {
        return O(N, -l, l), this.times("1e" + N);
      }, te.squareRoot = te.sqrt = function() {
        var N, F, G, ee, Z, q = this, he = q.c, Y = q.s, X = q.e, B = V + 4, se = new P("0.5");
        if (Y !== 1 || !he || !he[0])
          return new P(!Y || Y < 0 && (!he || he[0]) ? NaN : he ? q : 1 / 0);
        if (Y = Math.sqrt(+Te(q)), Y == 0 || Y == 1 / 0 ? (F = S(he), (F.length + X) % 2 == 0 && (F += "0"), Y = Math.sqrt(+F), X = y((X + 1) / 2) - (X < 0 || X % 2), Y == 1 / 0 ? F = "5e" + X : (F = Y.toExponential(), F = F.slice(0, F.indexOf("e") + 1) + X), G = new P(F)) : G = new P(Y + ""), G.c[0]) {
          for (X = G.e, Y = X + B, Y < 3 && (Y = 0); ; )
            if (Z = G, G = se.times(Z.plus(z(q, Z, B, 1))), S(Z.c).slice(0, Y) === (F = S(G.c)).slice(0, Y))
              if (G.e < X && --Y, F = F.slice(Y - 3, Y + 1), F == "9999" || !ee && F == "4999") {
                if (!ee && (ye(Z, Z.e + V + 2, 0), Z.times(Z).eq(q))) {
                  G = Z;
                  break;
                }
                B += 4, Y += 4, ee = 1;
              } else {
                (!+F || !+F.slice(1) && F.charAt(0) == "5") && (ye(G, G.e + V + 2, 1), N = !G.times(G).eq(q));
                break;
              }
        }
        return ye(G, G.e + V + 1, L, N);
      }, te.toExponential = function(N, F) {
        return N != null && (O(N, 0, v), N++), ue(this, N, F, 1);
      }, te.toFixed = function(N, F) {
        return N != null && (O(N, 0, v), N = N + this.e + 1), ue(this, N, F);
      }, te.toFormat = function(N, F, G) {
        var ee, Z = this;
        if (G == null)
          N != null && F && typeof F == "object" ? (G = F, F = null) : N && typeof N == "object" ? (G = N, N = F = null) : G = k;
        else if (typeof G != "object")
          throw Error(o + "Argument not an object: " + G);
        if (ee = Z.toFixed(N, F), Z.c) {
          var q, he = ee.split("."), Y = +G.groupSize, X = +G.secondaryGroupSize, B = G.groupSeparator || "", se = he[0], me = he[1], de = Z.s < 0, xe = de ? se.slice(1) : se, Oe = xe.length;
          if (X && (q = Y, Y = X, X = q, Oe -= q), Y > 0 && Oe > 0) {
            for (q = Oe % Y || Y, se = xe.substr(0, q); q < Oe; q += Y)
              se += B + xe.substr(q, Y);
            X > 0 && (se += B + xe.slice(q)), de && (se = "-" + se);
          }
          ee = me ? se + (G.decimalSeparator || "") + ((X = +G.fractionGroupSize) ? me.replace(
            new RegExp("\\d{" + X + "}\\B", "g"),
            "$&" + (G.fractionGroupSeparator || "")
          ) : me) : se;
        }
        return (G.prefix || "") + ee + (G.suffix || "");
      }, te.toFraction = function(N) {
        var F, G, ee, Z, q, he, Y, X, B, se, me, de, xe = this, Oe = xe.c;
        if (N != null && (Y = new P(N), !Y.isInteger() && (Y.c || Y.s !== 1) || Y.lt(ce)))
          throw Error(o + "Argument " + (Y.isInteger() ? "out of range: " : "not an integer: ") + Te(Y));
        if (!Oe)
          return new P(xe);
        for (F = new P(ce), B = G = new P(ce), ee = X = new P(ce), de = S(Oe), q = F.e = de.length - xe.e - 1, F.c[0] = f[(he = q % u) < 0 ? u + he : he], N = !N || Y.comparedTo(F) > 0 ? q > 0 ? F : B : Y, he = x, x = 1 / 0, Y = new P(de), X.c[0] = 0; se = z(Y, F, 0, 1), Z = G.plus(se.times(ee)), Z.comparedTo(N) != 1; )
          G = ee, ee = Z, B = X.plus(se.times(Z = B)), X = Z, F = Y.minus(se.times(Z = F)), Y = Z;
        return Z = z(N.minus(G), ee, 0, 1), X = X.plus(Z.times(B)), G = G.plus(Z.times(ee)), X.s = B.s = xe.s, q = q * 2, me = z(B, ee, q, L).minus(xe).abs().comparedTo(
          z(X, G, q, L).minus(xe).abs()
        ) < 1 ? [B, ee] : [X, G], x = he, me;
      }, te.toNumber = function() {
        return +Te(this);
      }, te.toPrecision = function(N, F) {
        return N != null && O(N, 1, v), ue(this, N, F, 2);
      }, te.toString = function(N) {
        var F, G = this, ee = G.s, Z = G.e;
        return Z === null ? ee ? (F = "Infinity", ee < 0 && (F = "-" + F)) : F = "NaN" : (N == null ? F = Z <= p || Z >= d ? U(S(G.c), Z) : D(S(G.c), Z, "0") : N === 10 && w ? (G = ye(new P(G), V + Z + 1, L), F = D(S(G.c), G.e, "0")) : (O(N, 2, g.length, "Base"), F = ne(D(S(G.c), Z, "0"), 10, N, ee, !0)), ee < 0 && G.c[0] && (F = "-" + F)), F;
      }, te.valueOf = te.toJSON = function() {
        return Te(this);
      }, te._isBigNumber = !0, H != null && P.set(H), P;
    }
    function y(H) {
      var z = H | 0;
      return H > 0 || H === z ? z : z - 1;
    }
    function S(H) {
      for (var z, ne, le = 1, te = H.length, ce = H[0] + ""; le < te; ) {
        for (z = H[le++] + "", ne = u - z.length; ne--; z = "0" + z)
          ;
        ce += z;
      }
      for (te = ce.length; ce.charCodeAt(--te) === 48; )
        ;
      return ce.slice(0, te + 1 || 1);
    }
    function C(H, z) {
      var ne, le, te = H.c, ce = z.c, V = H.s, L = z.s, p = H.e, d = z.e;
      if (!V || !L)
        return null;
      if (ne = te && !te[0], le = ce && !ce[0], ne || le)
        return ne ? le ? 0 : -L : V;
      if (V != L)
        return V;
      if (ne = V < 0, le = p == d, !te || !ce)
        return le ? 0 : !te ^ ne ? 1 : -1;
      if (!le)
        return p > d ^ ne ? 1 : -1;
      for (L = (p = te.length) < (d = ce.length) ? p : d, V = 0; V < L; V++)
        if (te[V] != ce[V])
          return te[V] > ce[V] ^ ne ? 1 : -1;
      return p == d ? 0 : p > d ^ ne ? 1 : -1;
    }
    function O(H, z, ne, le) {
      if (H < z || H > ne || H !== s(H))
        throw Error(o + (le || "Argument") + (typeof H == "number" ? H < z || H > ne ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(H));
    }
    function I(H) {
      var z = H.c.length - 1;
      return y(H.e / u) == z && H.c[z] % 2 != 0;
    }
    function U(H, z) {
      return (H.length > 1 ? H.charAt(0) + "." + H.slice(1) : H) + (z < 0 ? "e" : "e+") + z;
    }
    function D(H, z, ne) {
      var le, te;
      if (z < 0) {
        for (te = ne + "."; ++z; te += ne)
          ;
        H = te + H;
      } else if (le = H.length, ++z > le) {
        for (te = ne, z -= le; --z; te += ne)
          ;
        H += te;
      } else
        z < le && (H = H.slice(0, z) + "." + H.slice(z));
      return H;
    }
    r = b(), r.default = r.BigNumber = r, e.exports ? e.exports = r : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = r);
  })(Yr);
})(H_);
var G_ = H_.exports;
(function(e) {
  var t = G_, r = e.exports;
  (function() {
    var n = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, i, s, o = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, a;
    function c(l) {
      return n.lastIndex = 0, n.test(l) ? '"' + l.replace(n, function(f) {
        var h = o[f];
        return typeof h == "string" ? h : "\\u" + ("0000" + f.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + l + '"';
    }
    function u(l, f) {
      var h, v, b, y, S = i, C, O = f[l], I = O != null && (O instanceof t || t.isBigNumber(O));
      switch (O && typeof O == "object" && typeof O.toJSON == "function" && (O = O.toJSON(l)), typeof a == "function" && (O = a.call(f, l, O)), typeof O) {
        case "string":
          return I ? O : c(O);
        case "number":
          return isFinite(O) ? String(O) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(O);
        case "object":
          if (!O)
            return "null";
          if (i += s, C = [], Object.prototype.toString.apply(O) === "[object Array]") {
            for (y = O.length, h = 0; h < y; h += 1)
              C[h] = u(h, O) || "null";
            return b = C.length === 0 ? "[]" : i ? `[
` + i + C.join(`,
` + i) + `
` + S + "]" : "[" + C.join(",") + "]", i = S, b;
          }
          if (a && typeof a == "object")
            for (y = a.length, h = 0; h < y; h += 1)
              typeof a[h] == "string" && (v = a[h], b = u(v, O), b && C.push(c(v) + (i ? ": " : ":") + b));
          else
            Object.keys(O).forEach(function(U) {
              var D = u(U, O);
              D && C.push(c(U) + (i ? ": " : ":") + D);
            });
          return b = C.length === 0 ? "{}" : i ? `{
` + i + C.join(`,
` + i) + `
` + S + "}" : "{" + C.join(",") + "}", i = S, b;
      }
    }
    typeof r.stringify != "function" && (r.stringify = function(l, f, h) {
      var v;
      if (i = "", s = "", typeof h == "number")
        for (v = 0; v < h; v += 1)
          s += " ";
      else
        typeof h == "string" && (s = h);
      if (a = f, f && typeof f != "function" && (typeof f != "object" || typeof f.length != "number"))
        throw new Error("JSON.stringify");
      return u("", { "": l });
    });
  })();
})(q_);
var FN = q_.exports, Ol = null;
const VN = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, zN = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
var WN = function(e) {
  var t = {
    strict: !1,
    // not being strict means do not generate syntax errors for "duplicate key"
    storeAsString: !1,
    // toggles whether the values should be stored as BigNumber (default) or a string
    alwaysParseAsBig: !1,
    // toggles whether all numbers should be Big
    useNativeBigInt: !1,
    // toggles whether to use native BigInt instead of bignumber.js
    protoAction: "error",
    constructorAction: "error"
  };
  if (e != null) {
    if (e.strict === !0 && (t.strict = !0), e.storeAsString === !0 && (t.storeAsString = !0), t.alwaysParseAsBig = e.alwaysParseAsBig === !0 ? e.alwaysParseAsBig : !1, t.useNativeBigInt = e.useNativeBigInt === !0 ? e.useNativeBigInt : !1, typeof e.constructorAction < "u")
      if (e.constructorAction === "error" || e.constructorAction === "ignore" || e.constructorAction === "preserve")
        t.constructorAction = e.constructorAction;
      else
        throw new Error(
          `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${e.constructorAction}`
        );
    if (typeof e.protoAction < "u")
      if (e.protoAction === "error" || e.protoAction === "ignore" || e.protoAction === "preserve")
        t.protoAction = e.protoAction;
      else
        throw new Error(
          `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${e.protoAction}`
        );
  }
  var r, n, i = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, s, o = function(y) {
    throw {
      name: "SyntaxError",
      message: y,
      at: r,
      text: s
    };
  }, a = function(y) {
    return y && y !== n && o("Expected '" + y + "' instead of '" + n + "'"), n = s.charAt(r), r += 1, n;
  }, c = function() {
    var y, S = "";
    for (n === "-" && (S = "-", a("-")); n >= "0" && n <= "9"; )
      S += n, a();
    if (n === ".")
      for (S += "."; a() && n >= "0" && n <= "9"; )
        S += n;
    if (n === "e" || n === "E")
      for (S += n, a(), (n === "-" || n === "+") && (S += n, a()); n >= "0" && n <= "9"; )
        S += n, a();
    if (y = +S, !isFinite(y))
      o("Bad number");
    else
      return Ol == null && (Ol = G_), S.length > 15 ? t.storeAsString ? S : t.useNativeBigInt ? BigInt(S) : new Ol(S) : t.alwaysParseAsBig ? t.useNativeBigInt ? BigInt(y) : new Ol(y) : y;
  }, u = function() {
    var y, S, C = "", O;
    if (n === '"')
      for (var I = r; a(); ) {
        if (n === '"')
          return r - 1 > I && (C += s.substring(I, r - 1)), a(), C;
        if (n === "\\") {
          if (r - 1 > I && (C += s.substring(I, r - 1)), a(), n === "u") {
            for (O = 0, S = 0; S < 4 && (y = parseInt(a(), 16), !!isFinite(y)); S += 1)
              O = O * 16 + y;
            C += String.fromCharCode(O);
          } else if (typeof i[n] == "string")
            C += i[n];
          else
            break;
          I = r;
        }
      }
    o("Bad string");
  }, l = function() {
    for (; n && n <= " "; )
      a();
  }, f = function() {
    switch (n) {
      case "t":
        return a("t"), a("r"), a("u"), a("e"), !0;
      case "f":
        return a("f"), a("a"), a("l"), a("s"), a("e"), !1;
      case "n":
        return a("n"), a("u"), a("l"), a("l"), null;
    }
    o("Unexpected '" + n + "'");
  }, h, v = function() {
    var y = [];
    if (n === "[") {
      if (a("["), l(), n === "]")
        return a("]"), y;
      for (; n; ) {
        if (y.push(h()), l(), n === "]")
          return a("]"), y;
        a(","), l();
      }
    }
    o("Bad array");
  }, b = function() {
    var y, S = /* @__PURE__ */ Object.create(null);
    if (n === "{") {
      if (a("{"), l(), n === "}")
        return a("}"), S;
      for (; n; ) {
        if (y = u(), l(), a(":"), t.strict === !0 && Object.hasOwnProperty.call(S, y) && o('Duplicate key "' + y + '"'), VN.test(y) === !0 ? t.protoAction === "error" ? o("Object contains forbidden prototype property") : t.protoAction === "ignore" ? h() : S[y] = h() : zN.test(y) === !0 ? t.constructorAction === "error" ? o("Object contains forbidden constructor property") : t.constructorAction === "ignore" ? h() : S[y] = h() : S[y] = h(), l(), n === "}")
          return a("}"), S;
        a(","), l();
      }
    }
    o("Bad object");
  };
  return h = function() {
    switch (l(), n) {
      case "{":
        return b();
      case "[":
        return v();
      case '"':
        return u();
      case "-":
        return c();
      default:
        return n >= "0" && n <= "9" ? c() : f();
    }
  }, function(y, S) {
    var C;
    return s = y + "", r = 0, n = " ", C = h(), l(), n && o("Syntax error"), typeof S == "function" ? function O(I, U) {
      var D, H = I[U];
      return H && typeof H == "object" && Object.keys(H).forEach(function(z) {
        D = O(H, z), D !== void 0 ? H[z] = D : delete H[z];
      }), S.call(I, U, H);
    }({ "": C }, "") : C;
  };
}, qN = WN, K_ = FN.stringify, Y_ = qN;
Od.exports = function(e) {
  return {
    parse: Y_(e),
    stringify: K_
  };
};
Od.exports.parse = Y_();
Od.exports.stringify = K_;
var HN = Od.exports;
const X_ = "";
function GN(e) {
  if (e.length <= 6)
    return e;
  const t = e.startsWith("0x") ? 2 : 0;
  return `0x${e.slice(t, t + 4)}${X_}${e.slice(-4)}`;
}
function KN(e) {
  return `${e.slice(0, 10)}${X_}`;
}
const J_ = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i, Z_ = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i, YN = 235;
function Q_(e) {
  return e.length > YN ? !1 : e.includes("@") ? J_.test(e) : Z_.test(e);
}
function ex(e, t = "at") {
  const r = e.toLowerCase();
  let n;
  if (r.includes("@")) {
    if (!J_.test(r))
      throw new Error(`Invalid SuiNS name ${e}`);
    const [i, s] = r.split("@");
    n = [...i ? i.split(".") : [], s];
  } else {
    if (!Z_.test(r))
      throw new Error(`Invalid SuiNS name ${e}`);
    n = r.split(".").slice(0, -1);
  }
  return t === "dot" ? `${n.join(".")}.sui` : `${n.slice(0, -1).join(".")}@${n[n.length - 1]}`;
}
const XN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/, JN = /^\d+$/, ZN = 64, tx = "/", An = (e) => {
  const t = e.split(tx);
  if (t.length < 2 || t.length > 3)
    return !1;
  const [r, n, i] = t;
  return i !== void 0 && !JN.test(i) || !Q_(r) ? !1 : XN.test(n) && n.length < ZN;
}, rx = (e) => {
  const t = e.split(/::|<|>|,/);
  for (const r of t)
    if (r.includes(tx) && !An(r))
      return !1;
  return !0;
}, QN = 32;
function M0(e) {
  try {
    return Fs(e).length === QN;
  } catch {
    return !1;
  }
}
const sl = 32;
function Jn(e) {
  return t$(e) && r$(e) === sl;
}
function au(e) {
  return Jn(e);
}
function e$(e) {
  return e.includes("::") ? Io(e) : e;
}
function Io(e) {
  const [t, r] = e.split("::"), n = An(t), i = e.slice(t.length + r.length + 4), s = i.includes("<") ? i.slice(0, i.indexOf("<")) : i, o = i.includes("<") ? Em(i.slice(i.indexOf("<") + 1, i.lastIndexOf(">"))).map(
    (a) => e$(a.trim())
  ) : [];
  return {
    address: n ? t : Gt(t),
    module: r,
    name: s,
    typeParams: o
  };
}
function Ou(e) {
  const { address: t, module: r, name: n, typeParams: i } = typeof e == "string" ? Io(e) : e, s = (i == null ? void 0 : i.length) > 0 ? `<${i.map(
    (o) => typeof o == "string" ? o : Ou(o)
  ).join(",")}>` : "";
  return `${t}::${r}::${n}${s}`;
}
function Gt(e, t = !1) {
  let r = e.toLowerCase();
  return !t && r.startsWith("0x") && (r = r.slice(2)), `0x${r.padStart(sl * 2, "0")}`;
}
function ai(e, t = !1) {
  return Gt(e, t);
}
function t$(e) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(e) && e.length % 2 === 0;
}
function r$(e) {
  return /^(0x|0X)/.test(e) ? (e.length - 2) / 2 : e.length / 2;
}
const n$ = 9, i$ = BigInt(1e9), nx = "0x1", Lg = "0x2", s$ = "0x3", o$ = ai("0x6"), a$ = "sui_system", Id = `${Lg}::sui::SUI`, c$ = ai("0x5"), u$ = /^vector<(.+)>$/, l$ = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class Ei {
  static parseFromStr(t, r = !1) {
    if (t === "address")
      return { address: null };
    if (t === "bool")
      return { bool: null };
    if (t === "u8")
      return { u8: null };
    if (t === "u16")
      return { u16: null };
    if (t === "u32")
      return { u32: null };
    if (t === "u64")
      return { u64: null };
    if (t === "u128")
      return { u128: null };
    if (t === "u256")
      return { u256: null };
    if (t === "signer")
      return { signer: null };
    const n = t.match(u$);
    if (n)
      return {
        vector: Ei.parseFromStr(n[1], r)
      };
    const i = t.match(l$);
    if (i)
      return {
        struct: {
          address: r ? Gt(i[1]) : i[1],
          module: i[2],
          name: i[3],
          typeParams: i[5] === void 0 ? [] : Ei.parseStructTypeArgs(i[5], r)
        }
      };
    throw new Error(`Encountered unexpected token when parsing type args for ${t}`);
  }
  static parseStructTypeArgs(t, r = !1) {
    return Em(t).map(
      (n) => Ei.parseFromStr(n, r)
    );
  }
  static tagToString(t) {
    if ("bool" in t)
      return "bool";
    if ("u8" in t)
      return "u8";
    if ("u16" in t)
      return "u16";
    if ("u32" in t)
      return "u32";
    if ("u64" in t)
      return "u64";
    if ("u128" in t)
      return "u128";
    if ("u256" in t)
      return "u256";
    if ("address" in t)
      return "address";
    if ("signer" in t)
      return "signer";
    if ("vector" in t)
      return `vector<${Ei.tagToString(t.vector)}>`;
    if ("struct" in t) {
      const r = t.struct, n = r.typeParams.map(Ei.tagToString).join(", ");
      return `${r.address}::${r.module}::${r.name}${n ? `<${n}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
}
function f$(e) {
  return re.u64({
    name: "unsafe_u64",
    ...e
  }).transform({
    input: (t) => t,
    output: (t) => Number(t)
  });
}
function d$(e) {
  return re.enum("Option", {
    None: null,
    Some: e
  });
}
const dr = re.bytes(sl).transform({
  validate: (e) => {
    const t = typeof e == "string" ? e : Vs(e);
    if (!t || !Jn(Gt(t)))
      throw new Error(`Invalid Sui address ${t}`);
  },
  input: (e) => typeof e == "string" ? Tc(Gt(e)) : e,
  output: (e) => Gt(Vs(e))
}), Ci = re.vector(re.u8()).transform({
  name: "ObjectDigest",
  input: (e) => Fs(e),
  output: (e) => Ca(new Uint8Array(e)),
  validate: (e) => {
    if (Fs(e).length !== 32)
      throw new Error("ObjectDigest must be 32 bytes");
  }
}), Xn = re.struct("SuiObjectRef", {
  objectId: dr,
  version: re.u64(),
  digest: Ci
}), ix = re.struct("SharedObjectRef", {
  objectId: dr,
  initialSharedVersion: re.u64(),
  mutable: re.bool()
}), sx = re.enum("ObjectArg", {
  ImmOrOwnedObject: Xn,
  SharedObject: ix,
  Receiving: Xn
}), aa = re.enum("Owner", {
  AddressOwner: dr,
  ObjectOwner: dr,
  Shared: re.struct("Shared", {
    initialSharedVersion: re.u64()
  }),
  Immutable: null,
  ConsensusV2: re.struct("ConsensusV2", {
    authenticator: re.enum("Authenticator", {
      SingleOwner: dr
    }),
    startVersion: re.u64()
  })
}), ox = re.enum("CallArg", {
  Pure: re.struct("Pure", {
    bytes: re.vector(re.u8()).transform({
      input: (e) => typeof e == "string" ? Hr(e) : e,
      output: (e) => Wr(new Uint8Array(e))
    })
  }),
  Object: sx
}), Bg = re.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: re.lazy(() => Bg),
  struct: re.lazy(() => dx),
  u16: null,
  u32: null,
  u256: null
}), Ug = Bg.transform({
  input: (e) => typeof e == "string" ? Ei.parseFromStr(e, !0) : e,
  output: (e) => Ei.tagToString(e)
}), Hi = re.enum("Argument", {
  GasCoin: null,
  Input: re.u16(),
  Result: re.u16(),
  NestedResult: re.tuple([re.u16(), re.u16()])
}), ax = re.struct("ProgrammableMoveCall", {
  package: dr,
  module: re.string(),
  function: re.string(),
  typeArguments: re.vector(Ug),
  arguments: re.vector(Hi)
}), cx = re.enum("Command", {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: ax,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: re.struct("TransferObjects", {
    objects: re.vector(Hi),
    address: Hi
  }),
  // /**
  //  * Split `amount` from a `coin`.
  //  */
  SplitCoins: re.struct("SplitCoins", {
    coin: Hi,
    amounts: re.vector(Hi)
  }),
  // /**
  //  * Merge Vector of Coins (`sources`) into a `destination`.
  //  */
  MergeCoins: re.struct("MergeCoins", {
    destination: Hi,
    sources: re.vector(Hi)
  }),
  // /**
  //  * Publish a Move module.
  //  */
  Publish: re.struct("Publish", {
    modules: re.vector(
      re.vector(re.u8()).transform({
        input: (e) => typeof e == "string" ? Hr(e) : e,
        output: (e) => Wr(new Uint8Array(e))
      })
    ),
    dependencies: re.vector(dr)
  }),
  // /**
  //  * Build a vector of objects using the input arguments.
  //  * It is impossible to export construct a `vector<T: key>` otherwise,
  //  * so this call serves a utility function.
  //  */
  MakeMoveVec: re.struct("MakeMoveVec", {
    type: d$(Ug).transform({
      input: (e) => e === null ? {
        None: !0
      } : {
        Some: e
      },
      output: (e) => e.Some ?? null
    }),
    elements: re.vector(Hi)
  }),
  Upgrade: re.struct("Upgrade", {
    modules: re.vector(
      re.vector(re.u8()).transform({
        input: (e) => typeof e == "string" ? Hr(e) : e,
        output: (e) => Wr(new Uint8Array(e))
      })
    ),
    dependencies: re.vector(dr),
    package: dr,
    ticket: Hi
  })
}), ux = re.struct("ProgrammableTransaction", {
  inputs: re.vector(ox),
  commands: re.vector(cx)
}), lx = re.enum("TransactionKind", {
  ProgrammableTransaction: ux,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
}), fx = re.enum("TransactionExpiration", {
  None: null,
  Epoch: f$()
}), dx = re.struct("StructTag", {
  address: dr,
  module: re.string(),
  name: re.string(),
  typeParams: re.vector(Bg)
}), hx = re.struct("GasData", {
  payment: re.vector(Xn),
  owner: dr,
  price: re.u64(),
  budget: re.u64()
}), px = re.struct("TransactionDataV1", {
  kind: lx,
  sender: dr,
  gasData: hx,
  expiration: fx
}), mx = re.enum("TransactionData", {
  V1: px
}), gx = re.enum("IntentScope", {
  TransactionData: null,
  TransactionEffects: null,
  CheckpointSummary: null,
  PersonalMessage: null
}), yx = re.enum("IntentVersion", {
  V0: null
}), vx = re.enum("AppId", {
  Sui: null
}), bx = re.struct("Intent", {
  scope: gx,
  version: yx,
  appId: vx
});
function wx(e) {
  return re.struct(`IntentMessage<${e.name}>`, {
    intent: bx,
    value: e
  });
}
const _x = re.enum("CompressedSignature", {
  ED25519: re.fixedArray(64, re.u8()),
  Secp256k1: re.fixedArray(64, re.u8()),
  Secp256r1: re.fixedArray(64, re.u8()),
  ZkLogin: re.vector(re.u8())
}), xx = re.enum("PublicKey", {
  ED25519: re.fixedArray(32, re.u8()),
  Secp256k1: re.fixedArray(33, re.u8()),
  Secp256r1: re.fixedArray(33, re.u8()),
  ZkLogin: re.vector(re.u8())
}), Sx = re.struct("MultiSigPkMap", {
  pubKey: xx,
  weight: re.u8()
}), Ex = re.struct("MultiSigPublicKey", {
  pk_map: re.vector(Sx),
  threshold: re.u16()
}), h$ = re.struct("MultiSig", {
  sigs: re.vector(_x),
  bitmap: re.u16(),
  multisig_pk: Ex
}), p$ = re.vector(re.u8()).transform({
  input: (e) => typeof e == "string" ? Hr(e) : e,
  output: (e) => Wr(new Uint8Array(e))
}), Tx = re.struct("SenderSignedTransaction", {
  intentMessage: wx(mx),
  txSignatures: re.vector(p$)
}), m$ = re.vector(Tx, {
  name: "SenderSignedData"
}), g$ = re.struct("PasskeyAuthenticator", {
  authenticatorData: re.vector(re.u8()),
  clientDataJson: re.string(),
  userSignature: re.vector(re.u8())
}), y$ = re.enum("PackageUpgradeError", {
  UnableToFetchPackage: re.struct("UnableToFetchPackage", { packageId: dr }),
  NotAPackage: re.struct("NotAPackage", { objectId: dr }),
  IncompatibleUpgrade: null,
  DigestDoesNotMatch: re.struct("DigestDoesNotMatch", { digest: re.vector(re.u8()) }),
  UnknownUpgradePolicy: re.struct("UnknownUpgradePolicy", { policy: re.u8() }),
  PackageIDDoesNotMatch: re.struct("PackageIDDoesNotMatch", {
    packageId: dr,
    ticketId: dr
  })
}), v$ = re.struct("ModuleId", {
  address: dr,
  name: re.string()
}), Hy = re.struct("MoveLocation", {
  module: v$,
  function: re.u16(),
  instruction: re.u16(),
  functionName: re.option(re.string())
}), b$ = re.enum("CommandArgumentError", {
  TypeMismatch: null,
  InvalidBCSBytes: null,
  InvalidUsageOfPureArg: null,
  InvalidArgumentToPrivateEntryFunction: null,
  IndexOutOfBounds: re.struct("IndexOutOfBounds", { idx: re.u16() }),
  SecondaryIndexOutOfBounds: re.struct("SecondaryIndexOutOfBounds", {
    resultIdx: re.u16(),
    secondaryIdx: re.u16()
  }),
  InvalidResultArity: re.struct("InvalidResultArity", { resultIdx: re.u16() }),
  InvalidGasCoinUsage: null,
  InvalidValueUsage: null,
  InvalidObjectByValue: null,
  InvalidObjectByMutRef: null,
  SharedObjectOperationNotAllowed: null
}), w$ = re.enum("TypeArgumentError", {
  TypeNotFound: null,
  ConstraintNotSatisfied: null
}), _$ = re.enum("ExecutionFailureStatus", {
  InsufficientGas: null,
  InvalidGasObject: null,
  InvariantViolation: null,
  FeatureNotYetSupported: null,
  MoveObjectTooBig: re.struct("MoveObjectTooBig", {
    objectSize: re.u64(),
    maxObjectSize: re.u64()
  }),
  MovePackageTooBig: re.struct("MovePackageTooBig", {
    objectSize: re.u64(),
    maxObjectSize: re.u64()
  }),
  CircularObjectOwnership: re.struct("CircularObjectOwnership", { object: dr }),
  InsufficientCoinBalance: null,
  CoinBalanceOverflow: null,
  PublishErrorNonZeroAddress: null,
  SuiMoveVerificationError: null,
  MovePrimitiveRuntimeError: re.option(Hy),
  MoveAbort: re.tuple([Hy, re.u64()]),
  VMVerificationOrDeserializationError: null,
  VMInvariantViolation: null,
  FunctionNotFound: null,
  ArityMismatch: null,
  TypeArityMismatch: null,
  NonEntryFunctionInvoked: null,
  CommandArgumentError: re.struct("CommandArgumentError", {
    argIdx: re.u16(),
    kind: b$
  }),
  TypeArgumentError: re.struct("TypeArgumentError", {
    argumentIdx: re.u16(),
    kind: w$
  }),
  UnusedValueWithoutDrop: re.struct("UnusedValueWithoutDrop", {
    resultIdx: re.u16(),
    secondaryIdx: re.u16()
  }),
  InvalidPublicFunctionReturnType: re.struct("InvalidPublicFunctionReturnType", {
    idx: re.u16()
  }),
  InvalidTransferObject: null,
  EffectsTooLarge: re.struct("EffectsTooLarge", { currentSize: re.u64(), maxSize: re.u64() }),
  PublishUpgradeMissingDependency: null,
  PublishUpgradeDependencyDowngrade: null,
  PackageUpgradeError: re.struct("PackageUpgradeError", { upgradeError: y$ }),
  WrittenObjectsTooLarge: re.struct("WrittenObjectsTooLarge", {
    currentSize: re.u64(),
    maxSize: re.u64()
  }),
  CertificateDenied: null,
  SuiMoveVerificationTimedout: null,
  SharedObjectOperationNotAllowed: null,
  InputObjectDeleted: null,
  ExecutionCancelledDueToSharedObjectCongestion: re.struct(
    "ExecutionCancelledDueToSharedObjectCongestion",
    {
      congestedObjects: re.vector(dr)
    }
  ),
  AddressDeniedForCoin: re.struct("AddressDeniedForCoin", {
    address: dr,
    coinType: re.string()
  }),
  CoinTypeGlobalPause: re.struct("CoinTypeGlobalPause", { coinType: re.string() }),
  ExecutionCancelledDueToRandomnessUnavailable: null
}), Cx = re.enum("ExecutionStatus", {
  Success: null,
  Failed: re.struct("ExecutionFailed", {
    error: _$,
    command: re.option(re.u64())
  })
}), Ax = re.struct("GasCostSummary", {
  computationCost: re.u64(),
  storageCost: re.u64(),
  storageRebate: re.u64(),
  nonRefundableStorageFee: re.u64()
}), x$ = re.struct("TransactionEffectsV1", {
  status: Cx,
  executedEpoch: re.u64(),
  gasUsed: Ax,
  modifiedAtVersions: re.vector(re.tuple([dr, re.u64()])),
  sharedObjects: re.vector(Xn),
  transactionDigest: Ci,
  created: re.vector(re.tuple([Xn, aa])),
  mutated: re.vector(re.tuple([Xn, aa])),
  unwrapped: re.vector(re.tuple([Xn, aa])),
  deleted: re.vector(Xn),
  unwrappedThenDeleted: re.vector(Xn),
  wrapped: re.vector(Xn),
  gasObject: re.tuple([Xn, aa]),
  eventsDigest: re.option(Ci),
  dependencies: re.vector(Ci)
}), Fg = re.tuple([re.u64(), Ci]), S$ = re.enum("ObjectIn", {
  NotExist: null,
  Exist: re.tuple([Fg, aa])
}), E$ = re.enum("ObjectOut", {
  NotExist: null,
  ObjectWrite: re.tuple([Ci, aa]),
  PackageWrite: Fg
}), T$ = re.enum("IDOperation", {
  None: null,
  Created: null,
  Deleted: null
}), C$ = re.struct("EffectsObjectChange", {
  inputState: S$,
  outputState: E$,
  idOperation: T$
}), A$ = re.enum("UnchangedSharedKind", {
  ReadOnlyRoot: Fg,
  MutateDeleted: re.u64(),
  ReadDeleted: re.u64(),
  Cancelled: re.u64(),
  PerEpochConfig: null
}), M$ = re.struct("TransactionEffectsV2", {
  status: Cx,
  executedEpoch: re.u64(),
  gasUsed: Ax,
  transactionDigest: Ci,
  gasObjectIndex: re.option(re.u32()),
  eventsDigest: re.option(Ci),
  dependencies: re.vector(Ci),
  lamportVersion: re.u64(),
  changedObjects: re.vector(re.tuple([dr, C$])),
  unchangedSharedObjects: re.vector(re.tuple([dr, A$])),
  auxDataDigest: re.option(Ci)
}), O$ = re.enum("TransactionEffects", {
  V1: x$,
  V2: M$
});
function gu(e) {
  switch (e) {
    case "u8":
      return re.u8();
    case "u16":
      return re.u16();
    case "u32":
      return re.u32();
    case "u64":
      return re.u64();
    case "u128":
      return re.u128();
    case "u256":
      return re.u256();
    case "bool":
      return re.bool();
    case "string":
      return re.string();
    case "id":
    case "address":
      return dr;
  }
  const t = e.match(/^(vector|option)<(.+)>$/);
  if (t) {
    const [r, n] = t.slice(1);
    return r === "vector" ? re.vector(gu(n)) : re.option(gu(n));
  }
  throw new Error(`Invalid Pure type name: ${e}`);
}
const kt = {
  ...re,
  U8: re.u8(),
  U16: re.u16(),
  U32: re.u32(),
  U64: re.u64(),
  U128: re.u128(),
  U256: re.u256(),
  ULEB128: re.uleb128(),
  Bool: re.bool(),
  String: re.string(),
  Address: dr,
  AppId: vx,
  Argument: Hi,
  CallArg: ox,
  Command: cx,
  CompressedSignature: _x,
  GasData: hx,
  Intent: bx,
  IntentMessage: wx,
  IntentScope: gx,
  IntentVersion: yx,
  MultiSig: h$,
  MultiSigPkMap: Sx,
  MultiSigPublicKey: Ex,
  ObjectArg: sx,
  ObjectDigest: Ci,
  Owner: aa,
  PasskeyAuthenticator: g$,
  ProgrammableMoveCall: ax,
  ProgrammableTransaction: ux,
  PublicKey: xx,
  SenderSignedData: m$,
  SenderSignedTransaction: Tx,
  SharedObjectRef: ix,
  StructTag: dx,
  SuiObjectRef: Xn,
  TransactionData: mx,
  TransactionDataV1: px,
  TransactionEffects: O$,
  TransactionExpiration: fx,
  TransactionKind: lx,
  TypeTag: Ug
};
function Mx(e, t, r) {
  const n = kt.Address.serialize(e).toBytes(), i = kt.TypeTag.serialize(t).toBytes(), s = kt.u64().serialize(r.length).toBytes(), o = Wm.create({
    dkLen: 32
  });
  return o.update(new Uint8Array([240])), o.update(n), o.update(s), o.update(r), o.update(i), `0x${Vs(o.digest().slice(0, 32))}`;
}
const I$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MIST_PER_SUI: i$,
  MOVE_STDLIB_ADDRESS: nx,
  SUI_ADDRESS_LENGTH: sl,
  SUI_CLOCK_OBJECT_ID: o$,
  SUI_DECIMALS: n$,
  SUI_FRAMEWORK_ADDRESS: Lg,
  SUI_SYSTEM_ADDRESS: s$,
  SUI_SYSTEM_MODULE_NAME: a$,
  SUI_SYSTEM_STATE_OBJECT_ID: c$,
  SUI_TYPE_ARG: Id,
  deriveDynamicFieldID: Mx,
  formatAddress: GN,
  formatDigest: KN,
  fromB64: c2,
  fromBase58: Fs,
  fromBase64: Hr,
  fromHEX: l2,
  fromHex: Tc,
  isValidNamedPackage: An,
  isValidNamedType: rx,
  isValidSuiAddress: Jn,
  isValidSuiNSName: Q_,
  isValidSuiObjectId: au,
  isValidTransactionDigest: M0,
  normalizeStructTag: Ou,
  normalizeSuiAddress: Gt,
  normalizeSuiNSName: ex,
  normalizeSuiObjectId: ai,
  parseStructTag: Io,
  toB64: a2,
  toBase58: Ca,
  toBase64: Wr,
  toHEX: u2,
  toHex: Vs
}, Symbol.toStringTag, { value: "Module" })), Ox = /* @__PURE__ */ Ec(I$), Ix = "1.34.0", k$ = "1.51.0", j$ = {
  "-32700": "ParseError",
  "-32701": "OversizedRequest",
  "-32702": "OversizedResponse",
  "-32600": "InvalidRequest",
  "-32601": "MethodNotFound",
  "-32602": "InvalidParams",
  "-32603": "InternalError",
  "-32604": "ServerBusy",
  "-32000": "CallExecutionFailed",
  "-32001": "UnknownError",
  "-32003": "SubscriptionClosed",
  "-32004": "SubscriptionClosedWithError",
  "-32005": "BatchesNotSupported",
  "-32006": "TooManySubscriptions",
  "-32050": "TransientError",
  "-32002": "TransactionExecutionClientError"
};
class Vg extends Error {
}
class zg extends Vg {
  constructor(t, r) {
    super(t), this.code = r, this.type = j$[r] ?? "ServerError";
  }
}
class kx extends Vg {
  constructor(t, r, n) {
    super(t), this.status = r, this.statusText = n;
  }
}
var jx = (e) => {
  throw TypeError(e);
}, Wg = (e, t, r) => t.has(e) || jx("Cannot " + r), gr = (e, t, r) => (Wg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Wo = (e, t, r) => t.has(e) ? jx("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), cc = (e, t, r, n) => (Wg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Rx = (e, t, r) => (Wg(e, t, "access private method"), r), R$ = (e, t, r, n) => ({
  set _(i) {
    cc(e, t, i, r);
  },
  get _() {
    return gr(e, t, n);
  }
}), co, yu, Os, ca, Iu, ua, Gf, Px, Nx;
function P$(e) {
  const t = new URL(e);
  return t.protocol = t.protocol.replace("http", "ws"), t.toString();
}
const N$ = {
  // We fudge the typing because we also check for undefined in the constructor:
  WebSocketConstructor: typeof WebSocket < "u" ? WebSocket : void 0,
  callTimeout: 3e4,
  reconnectTimeout: 3e3,
  maxReconnects: 5
};
class $$ {
  constructor(t, r = {}) {
    if (Wo(this, Gf), Wo(this, co, 0), Wo(this, yu, 0), Wo(this, Os, null), Wo(this, ca, null), Wo(this, Iu, /* @__PURE__ */ new Set()), Wo(this, ua, /* @__PURE__ */ new Map()), this.endpoint = t, this.options = { ...N$, ...r }, !this.options.WebSocketConstructor)
      throw new Error("Missing WebSocket constructor");
    this.endpoint.startsWith("http") && (this.endpoint = P$(this.endpoint));
  }
  async makeRequest(t, r, n) {
    const i = await Rx(this, Gf, Px).call(this);
    return new Promise((s, o) => {
      cc(this, co, gr(this, co) + 1), gr(this, ua).set(gr(this, co), {
        resolve: s,
        reject: o,
        timeout: setTimeout(() => {
          gr(this, ua).delete(gr(this, co)), o(new Error(`Request timeout: ${t}`));
        }, this.options.callTimeout)
      }), n == null || n.addEventListener("abort", () => {
        gr(this, ua).delete(gr(this, co)), o(n.reason);
      }), i.send(JSON.stringify({ jsonrpc: "2.0", id: gr(this, co), method: t, params: r }));
    }).then(({ error: s, result: o }) => {
      if (s)
        throw new zg(s.message, s.code);
      return o;
    });
  }
  async subscribe(t) {
    const r = new D$(t);
    return gr(this, Iu).add(r), await r.subscribe(this), () => r.unsubscribe(this);
  }
}
co = /* @__PURE__ */ new WeakMap();
yu = /* @__PURE__ */ new WeakMap();
Os = /* @__PURE__ */ new WeakMap();
ca = /* @__PURE__ */ new WeakMap();
Iu = /* @__PURE__ */ new WeakMap();
ua = /* @__PURE__ */ new WeakMap();
Gf = /* @__PURE__ */ new WeakSet();
Px = function() {
  return gr(this, ca) ? gr(this, ca) : (cc(this, ca, new Promise((e) => {
    var t;
    (t = gr(this, Os)) == null || t.close(), cc(this, Os, new this.options.WebSocketConstructor(this.endpoint)), gr(this, Os).addEventListener("open", () => {
      cc(this, yu, 0), e(gr(this, Os));
    }), gr(this, Os).addEventListener("close", () => {
      R$(this, yu)._++, gr(this, yu) <= this.options.maxReconnects && setTimeout(() => {
        Rx(this, Gf, Nx).call(this);
      }, this.options.reconnectTimeout);
    }), gr(this, Os).addEventListener("message", ({ data: r }) => {
      let n;
      try {
        n = JSON.parse(r);
      } catch (i) {
        console.error(new Error(`Failed to parse RPC message: ${r}`, { cause: i }));
        return;
      }
      if ("id" in n && n.id != null && gr(this, ua).has(n.id)) {
        const { resolve: i, timeout: s } = gr(this, ua).get(n.id);
        clearTimeout(s), i(n);
      } else if ("params" in n) {
        const { params: i } = n;
        gr(this, Iu).forEach((s) => {
          s.subscriptionId === i.subscription && i.subscription === s.subscriptionId && s.onMessage(i.result);
        });
      }
    });
  })), gr(this, ca));
};
Nx = async function() {
  var e;
  return (e = gr(this, Os)) == null || e.close(), cc(this, ca, null), Promise.allSettled(
    [...gr(this, Iu)].map((t) => t.subscribe(this))
  );
};
class D$ {
  constructor(t) {
    this.subscriptionId = null, this.subscribed = !1, this.input = t;
  }
  onMessage(t) {
    this.subscribed && this.input.onMessage(t);
  }
  async unsubscribe(t) {
    const { subscriptionId: r } = this;
    return this.subscribed = !1, r == null ? !1 : (this.subscriptionId = null, t.makeRequest(this.input.unsubscribe, [r]));
  }
  async subscribe(t) {
    this.subscriptionId = null, this.subscribed = !0;
    const r = await t.makeRequest(
      this.input.method,
      this.input.params,
      this.input.signal
    );
    this.subscribed && (this.subscriptionId = r);
  }
}
var $x = (e) => {
  throw TypeError(e);
}, qg = (e, t, r) => t.has(e) || $x("Cannot " + r), Zn = (e, t, r) => (qg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Il = (e, t, r) => t.has(e) ? $x("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), O0 = (e, t, r, n) => (qg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), L$ = (e, t, r) => (qg(e, t, "access private method"), r), cu, _i, vu, I0, Dx;
class Lx {
  constructor(t) {
    Il(this, I0), Il(this, cu, 0), Il(this, _i), Il(this, vu), O0(this, _i, t);
  }
  fetch(t, r) {
    const n = Zn(this, _i).fetch ?? fetch;
    if (!n)
      throw new Error(
        "The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport."
      );
    return n(t, r);
  }
  async request(t) {
    var i, s;
    O0(this, cu, Zn(this, cu) + 1);
    const r = await this.fetch(((i = Zn(this, _i).rpc) == null ? void 0 : i.url) ?? Zn(this, _i).url, {
      method: "POST",
      signal: t.signal,
      headers: {
        "Content-Type": "application/json",
        "Client-Sdk-Type": "typescript",
        "Client-Sdk-Version": Ix,
        "Client-Target-Api-Version": k$,
        "Client-Request-Method": t.method,
        ...(s = Zn(this, _i).rpc) == null ? void 0 : s.headers
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: Zn(this, cu),
        method: t.method,
        params: t.params
      })
    });
    if (!r.ok)
      throw new kx(
        `Unexpected status code: ${r.status}`,
        r.status,
        r.statusText
      );
    const n = await r.json();
    if ("error" in n && n.error != null)
      throw new zg(n.error.message, n.error.code);
    return n.result;
  }
  async subscribe(t) {
    const r = await L$(this, I0, Dx).call(this).subscribe(t);
    return t.signal && (t.signal.throwIfAborted(), t.signal.addEventListener("abort", () => {
      r();
    })), async () => !!await r();
  }
}
cu = /* @__PURE__ */ new WeakMap();
_i = /* @__PURE__ */ new WeakMap();
vu = /* @__PURE__ */ new WeakMap();
I0 = /* @__PURE__ */ new WeakSet();
Dx = function() {
  var e;
  if (!Zn(this, vu)) {
    const t = Zn(this, _i).WebSocketConstructor ?? WebSocket;
    if (!t)
      throw new Error(
        "The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport."
      );
    O0(this, vu, new $$(
      ((e = Zn(this, _i).websocket) == null ? void 0 : e.url) ?? Zn(this, _i).url,
      {
        WebSocketConstructor: t,
        ...Zn(this, _i).websocket
      }
    ));
  }
  return Zn(this, vu);
};
function Bx(e) {
  switch (e) {
    case "mainnet":
      return "https://fullnode.mainnet.sui.io:443";
    case "testnet":
      return "https://fullnode.testnet.sui.io:443";
    case "devnet":
      return "https://fullnode.devnet.sui.io:443";
    case "localnet":
      return "http://127.0.0.1:9000";
    default:
      throw new Error(`Unknown network: ${e}`);
  }
}
var Ux = (e) => {
  throw TypeError(e);
}, Fx = (e, t, r) => t.has(e) || Ux("Cannot " + r), un = (e, t, r) => (Fx(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Gy = (e, t, r) => t.has(e) ? Ux("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), Ky = (e, t, r, n) => (Fx(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), ea, vn;
const B$ = class Vx {
  constructor({ prefix: t, cache: r } = {}) {
    Gy(this, ea), Gy(this, vn), Ky(this, ea, t ?? []), Ky(this, vn, r ?? /* @__PURE__ */ new Map());
  }
  read(t, r) {
    const n = [un(this, ea), ...t].join(":");
    if (un(this, vn).has(n))
      return un(this, vn).get(n);
    const i = r();
    return un(this, vn).set(n, i), typeof i == "object" && i !== null && "then" in i ? Promise.resolve(i).then((s) => (un(this, vn).set(n, s), s)).catch((s) => {
      throw un(this, vn).delete(n), s;
    }) : i;
  }
  readSync(t, r) {
    const n = [un(this, ea), ...t].join(":");
    if (un(this, vn).has(n))
      return un(this, vn).get(n);
    const i = r();
    return un(this, vn).set(n, i), i;
  }
  clear(t) {
    const r = [...un(this, ea), ...t ?? []].join(":");
    if (!r) {
      un(this, vn).clear();
      return;
    }
    for (const n of un(this, vn).keys())
      n.startsWith(r) && un(this, vn).delete(n);
  }
  scope(t) {
    return new Vx({
      prefix: [...un(this, ea), ...Array.isArray(t) ? t : [t]],
      cache: un(this, vn)
    });
  }
};
ea = /* @__PURE__ */ new WeakMap();
vn = /* @__PURE__ */ new WeakMap();
let zx = B$;
class Wx {
  constructor({ network: t, base: r }) {
    this.cache = new zx(), this.network = t, this.base = r ?? this;
  }
  $extend(...t) {
    return Object.create(
      this,
      Object.fromEntries(
        t.map((r) => {
          if ("experimental_asClientExtension" in r) {
            const { name: n, register: i } = r.experimental_asClientExtension();
            return [n, { value: i(this) }];
          }
          return [r.name, { value: r.register(this) }];
        })
      )
    );
  }
}
function Oa(e) {
  const t = Object.entries(e).map(([r, n]) => We({ [r]: n }));
  return er(
    Xr(t),
    Zu((r) => ({
      ...r,
      $kind: Object.keys(r)[0]
    }))
  );
}
const Mc = er(
  Nt(),
  Zu((e) => Gt(e)),
  Cc(Jn)
), zn = Mc, ba = Nt(), Nn = er(
  Xr([Nt(), er(vr(), wr())]),
  Cc((e) => {
    try {
      return BigInt(e), BigInt(e) >= 0 && BigInt(e) <= 18446744073709551615n;
    } catch {
      return !1;
    }
  }, "Invalid u64")
), ko = We({
  objectId: Mc,
  version: Nn,
  digest: Nt()
}), yr = er(
  Xr([
    We({ GasCoin: Tt(!0) }),
    We({ Input: er(vr(), wr()), type: qr(Tt("pure")) }),
    We({ Input: er(vr(), wr()), type: qr(Tt("object")) }),
    We({ Result: er(vr(), wr()) }),
    We({ NestedResult: Ed([er(vr(), wr()), er(vr(), wr())]) })
  ]),
  Zu((e) => ({
    ...e,
    $kind: Object.keys(e)[0]
  }))
  // Defined manually to add `type?: 'pure' | 'object'` to Input
), U$ = We({
  budget: Ht(Nn),
  price: Ht(Nn),
  owner: Ht(Mc),
  payment: Ht(St(ko))
}), k0 = Xr([
  Tt("address"),
  Tt("bool"),
  Tt("u8"),
  Tt("u16"),
  Tt("u32"),
  Tt("u64"),
  Tt("u128"),
  Tt("u256"),
  We({ vector: pc(() => k0) }),
  We({
    datatype: We({
      package: Nt(),
      module: Nt(),
      type: Nt(),
      typeParameters: St(pc(() => k0))
    })
  }),
  We({ typeParameter: er(vr(), wr()) })
]), F$ = We({
  ref: Ht(Xr([Tt("&"), Tt("&mut")])),
  body: k0
}), V$ = We({
  package: zn,
  module: Nt(),
  function: Nt(),
  // snake case in rust
  typeArguments: St(Nt()),
  arguments: St(yr),
  _argumentTypes: qr(Ht(St(F$)))
}), z$ = We({
  name: Nt(),
  inputs: mc(Nt(), Xr([yr, St(yr)])),
  data: mc(Nt(), Mo())
}), W$ = Oa({
  MoveCall: V$,
  TransferObjects: We({
    objects: St(yr),
    address: yr
  }),
  SplitCoins: We({
    coin: yr,
    amounts: St(yr)
  }),
  MergeCoins: We({
    destination: yr,
    sources: St(yr)
  }),
  Publish: We({
    modules: St(ba),
    dependencies: St(zn)
  }),
  MakeMoveVec: We({
    type: Ht(Nt()),
    elements: St(yr)
  }),
  Upgrade: We({
    modules: St(ba),
    dependencies: St(zn),
    package: zn,
    ticket: yr
  }),
  $Intent: z$
}), qx = Oa({
  ImmOrOwnedObject: ko,
  SharedObject: We({
    objectId: zn,
    // snake case in rust
    initialSharedVersion: Nn,
    mutable: tl()
  }),
  Receiving: ko
}), q$ = Oa({
  Object: qx,
  Pure: We({
    bytes: ba
  }),
  UnresolvedPure: We({
    value: Mo()
  }),
  UnresolvedObject: We({
    objectId: zn,
    version: qr(Ht(Nn)),
    digest: qr(Ht(Nt())),
    initialSharedVersion: qr(Ht(Nn))
  })
}), Yy = Oa({
  Object: qx,
  Pure: We({
    bytes: ba
  })
}), Hx = Oa({
  None: Tt(!0),
  Epoch: Nn
}), cf = We({
  version: Tt(2),
  sender: va(Mc),
  expiration: va(Hx),
  gasData: U$,
  inputs: St(q$),
  commands: St(W$)
}), qo = {
  MoveCall(e) {
    const [t, r = "", n = ""] = "target" in e ? e.target.split("::") : [e.package, e.module, e.function];
    return {
      $kind: "MoveCall",
      MoveCall: {
        package: t,
        module: r,
        function: n,
        typeArguments: e.typeArguments ?? [],
        arguments: e.arguments ?? []
      }
    };
  },
  TransferObjects(e, t) {
    return {
      $kind: "TransferObjects",
      TransferObjects: {
        objects: e.map((r) => fr(yr, r)),
        address: fr(yr, t)
      }
    };
  },
  SplitCoins(e, t) {
    return {
      $kind: "SplitCoins",
      SplitCoins: {
        coin: fr(yr, e),
        amounts: t.map((r) => fr(yr, r))
      }
    };
  },
  MergeCoins(e, t) {
    return {
      $kind: "MergeCoins",
      MergeCoins: {
        destination: fr(yr, e),
        sources: t.map((r) => fr(yr, r))
      }
    };
  },
  Publish({
    modules: e,
    dependencies: t
  }) {
    return {
      $kind: "Publish",
      Publish: {
        modules: e.map(
          (r) => typeof r == "string" ? r : Wr(new Uint8Array(r))
        ),
        dependencies: t.map((r) => ai(r))
      }
    };
  },
  Upgrade({
    modules: e,
    dependencies: t,
    package: r,
    ticket: n
  }) {
    return {
      $kind: "Upgrade",
      Upgrade: {
        modules: e.map(
          (i) => typeof i == "string" ? i : Wr(new Uint8Array(i))
        ),
        dependencies: t.map((i) => ai(i)),
        package: r,
        ticket: fr(yr, n)
      }
    };
  },
  MakeMoveVec({
    type: e,
    elements: t
  }) {
    return {
      $kind: "MakeMoveVec",
      MakeMoveVec: {
        type: e ?? null,
        elements: t.map((r) => fr(yr, r))
      }
    };
  },
  Intent({
    name: e,
    inputs: t = {},
    data: r = {}
  }) {
    return {
      $kind: "$Intent",
      $Intent: {
        name: e,
        inputs: Object.fromEntries(
          Object.entries(t).map(([n, i]) => [
            n,
            Array.isArray(i) ? i.map((s) => fr(yr, s)) : fr(yr, i)
          ])
        ),
        data: r
      }
    };
  }
}, j0 = We({
  digest: Nt(),
  objectId: Nt(),
  version: Xr([er(vr(), wr()), Nt(), el()])
}), H$ = Oa({
  ImmOrOwned: j0,
  Shared: We({
    objectId: zn,
    initialSharedVersion: Nn,
    mutable: tl()
  }),
  Receiving: j0
}), Xy = Oa({
  Object: H$,
  Pure: St(er(vr(), wr()))
}), Gx = Xr([
  We({
    kind: Tt("Input"),
    index: er(vr(), wr()),
    value: Mo(),
    type: qr(Tt("object"))
  }),
  We({
    kind: Tt("Input"),
    index: er(vr(), wr()),
    value: Mo(),
    type: Tt("pure")
  })
]), G$ = Xr([
  We({ Epoch: er(vr(), wr()) }),
  We({ None: Ht(Tt(!0)) })
]), Jy = er(
  Xr([vr(), Nt(), el()]),
  Cc((e) => {
    if (!["string", "number", "bigint"].includes(typeof e))
      return !1;
    try {
      return BigInt(e), !0;
    } catch {
      return !1;
    }
  })
), Hg = Xr([
  We({ bool: Ht(Tt(!0)) }),
  We({ u8: Ht(Tt(!0)) }),
  We({ u64: Ht(Tt(!0)) }),
  We({ u128: Ht(Tt(!0)) }),
  We({ address: Ht(Tt(!0)) }),
  We({ signer: Ht(Tt(!0)) }),
  We({ vector: pc(() => Hg) }),
  We({ struct: pc(() => K$) }),
  We({ u16: Ht(Tt(!0)) }),
  We({ u32: Ht(Tt(!0)) }),
  We({ u256: Ht(Tt(!0)) })
]), K$ = We({
  address: Nt(),
  module: Nt(),
  name: Nt(),
  typeParams: St(Hg)
}), Y$ = We({
  budget: qr(Jy),
  price: qr(Jy),
  payment: qr(St(j0)),
  owner: qr(Nt())
}), X$ = [
  Gx,
  We({ kind: Tt("GasCoin") }),
  We({ kind: Tt("Result"), index: er(vr(), wr()) }),
  We({
    kind: Tt("NestedResult"),
    index: er(vr(), wr()),
    resultIndex: er(vr(), wr())
  })
], Ws = Xr([...X$]), J$ = We({
  kind: Tt("MoveCall"),
  target: er(
    Nt(),
    Cc((e) => e.split("::").length === 3)
  ),
  typeArguments: St(Nt()),
  arguments: St(Ws)
}), Z$ = We({
  kind: Tt("TransferObjects"),
  objects: St(Ws),
  address: Ws
}), Q$ = We({
  kind: Tt("SplitCoins"),
  coin: Ws,
  amounts: St(Ws)
}), eD = We({
  kind: Tt("MergeCoins"),
  destination: Ws,
  sources: St(Ws)
}), tD = We({
  kind: Tt("MakeMoveVec"),
  type: Xr([We({ Some: Hg }), We({ None: Ht(Tt(!0)) })]),
  objects: St(Ws)
}), rD = We({
  kind: Tt("Publish"),
  modules: St(St(er(vr(), wr()))),
  dependencies: St(Nt())
}), nD = We({
  kind: Tt("Upgrade"),
  modules: St(St(er(vr(), wr()))),
  dependencies: St(Nt()),
  packageId: Nt(),
  ticket: Ws
}), iD = [
  J$,
  Z$,
  Q$,
  eD,
  rD,
  nD,
  tD
], sD = Xr([...iD]);
We({
  version: Tt(1),
  sender: qr(Nt()),
  expiration: va(G$),
  gasConfig: Y$,
  inputs: St(Gx),
  transactions: St(sD)
});
function Zy(e) {
  var r;
  const t = e.inputs.map(
    (n, i) => {
      if (n.Object)
        return {
          kind: "Input",
          index: i,
          value: {
            Object: n.Object.ImmOrOwnedObject ? {
              ImmOrOwned: n.Object.ImmOrOwnedObject
            } : n.Object.Receiving ? {
              Receiving: {
                digest: n.Object.Receiving.digest,
                version: n.Object.Receiving.version,
                objectId: n.Object.Receiving.objectId
              }
            } : {
              Shared: {
                mutable: n.Object.SharedObject.mutable,
                initialSharedVersion: n.Object.SharedObject.initialSharedVersion,
                objectId: n.Object.SharedObject.objectId
              }
            }
          },
          type: "object"
        };
      if (n.Pure)
        return {
          kind: "Input",
          index: i,
          value: {
            Pure: Array.from(Hr(n.Pure.bytes))
          },
          type: "pure"
        };
      if (n.UnresolvedPure)
        return {
          kind: "Input",
          type: "pure",
          index: i,
          value: n.UnresolvedPure.value
        };
      if (n.UnresolvedObject)
        return {
          kind: "Input",
          type: "object",
          index: i,
          value: n.UnresolvedObject.objectId
        };
      throw new Error("Invalid input");
    }
  );
  return {
    version: 1,
    sender: e.sender ?? void 0,
    expiration: ((r = e.expiration) == null ? void 0 : r.$kind) === "Epoch" ? { Epoch: Number(e.expiration.Epoch) } : e.expiration ? { None: !0 } : null,
    gasConfig: {
      owner: e.gasData.owner ?? void 0,
      budget: e.gasData.budget ?? void 0,
      price: e.gasData.price ?? void 0,
      payment: e.gasData.payment ?? void 0
    },
    inputs: t,
    transactions: e.commands.map((n) => {
      if (n.MakeMoveVec)
        return {
          kind: "MakeMoveVec",
          type: n.MakeMoveVec.type === null ? { None: !0 } : { Some: Ei.parseFromStr(n.MakeMoveVec.type) },
          objects: n.MakeMoveVec.elements.map(
            (i) => xs(i, t)
          )
        };
      if (n.MergeCoins)
        return {
          kind: "MergeCoins",
          destination: xs(n.MergeCoins.destination, t),
          sources: n.MergeCoins.sources.map((i) => xs(i, t))
        };
      if (n.MoveCall)
        return {
          kind: "MoveCall",
          target: `${n.MoveCall.package}::${n.MoveCall.module}::${n.MoveCall.function}`,
          typeArguments: n.MoveCall.typeArguments,
          arguments: n.MoveCall.arguments.map(
            (i) => xs(i, t)
          )
        };
      if (n.Publish)
        return {
          kind: "Publish",
          modules: n.Publish.modules.map((i) => Array.from(Hr(i))),
          dependencies: n.Publish.dependencies
        };
      if (n.SplitCoins)
        return {
          kind: "SplitCoins",
          coin: xs(n.SplitCoins.coin, t),
          amounts: n.SplitCoins.amounts.map((i) => xs(i, t))
        };
      if (n.TransferObjects)
        return {
          kind: "TransferObjects",
          objects: n.TransferObjects.objects.map(
            (i) => xs(i, t)
          ),
          address: xs(n.TransferObjects.address, t)
        };
      if (n.Upgrade)
        return {
          kind: "Upgrade",
          modules: n.Upgrade.modules.map((i) => Array.from(Hr(i))),
          dependencies: n.Upgrade.dependencies,
          packageId: n.Upgrade.package,
          ticket: xs(n.Upgrade.ticket, t)
        };
      throw new Error(`Unknown transaction ${Object.keys(n)}`);
    })
  };
}
function xs(e, t) {
  if (e.$kind === "GasCoin")
    return { kind: "GasCoin" };
  if (e.$kind === "Result")
    return { kind: "Result", index: e.Result };
  if (e.$kind === "NestedResult")
    return { kind: "NestedResult", index: e.NestedResult[0], resultIndex: e.NestedResult[1] };
  if (e.$kind === "Input")
    return t[e.Input];
  throw new Error(`Invalid argument ${Object.keys(e)}`);
}
function oD(e) {
  var t, r, n;
  return fr(cf, {
    version: 2,
    sender: e.sender ?? null,
    expiration: e.expiration ? "Epoch" in e.expiration ? { Epoch: e.expiration.Epoch } : { None: !0 } : null,
    gasData: {
      owner: e.gasConfig.owner ?? null,
      budget: ((t = e.gasConfig.budget) == null ? void 0 : t.toString()) ?? null,
      price: ((r = e.gasConfig.price) == null ? void 0 : r.toString()) ?? null,
      payment: ((n = e.gasConfig.payment) == null ? void 0 : n.map((i) => ({
        digest: i.digest,
        objectId: i.objectId,
        version: i.version.toString()
      }))) ?? null
    },
    inputs: e.inputs.map((i) => {
      if (i.kind === "Input") {
        if ($f(Xy, i.value)) {
          const s = fr(Xy, i.value);
          if (s.Object) {
            if (s.Object.ImmOrOwned)
              return {
                Object: {
                  ImmOrOwnedObject: {
                    objectId: s.Object.ImmOrOwned.objectId,
                    version: String(s.Object.ImmOrOwned.version),
                    digest: s.Object.ImmOrOwned.digest
                  }
                }
              };
            if (s.Object.Shared)
              return {
                Object: {
                  SharedObject: {
                    mutable: s.Object.Shared.mutable ?? null,
                    initialSharedVersion: s.Object.Shared.initialSharedVersion,
                    objectId: s.Object.Shared.objectId
                  }
                }
              };
            if (s.Object.Receiving)
              return {
                Object: {
                  Receiving: {
                    digest: s.Object.Receiving.digest,
                    version: String(s.Object.Receiving.version),
                    objectId: s.Object.Receiving.objectId
                  }
                }
              };
            throw new Error("Invalid object input");
          }
          return {
            Pure: {
              bytes: Wr(new Uint8Array(s.Pure))
            }
          };
        }
        return i.type === "object" ? {
          UnresolvedObject: {
            objectId: i.value
          }
        } : {
          UnresolvedPure: {
            value: i.value
          }
        };
      }
      throw new Error("Invalid input");
    }),
    commands: e.transactions.map((i) => {
      switch (i.kind) {
        case "MakeMoveVec":
          return {
            MakeMoveVec: {
              type: "Some" in i.type ? Ei.tagToString(i.type.Some) : null,
              elements: i.objects.map((s) => Ss(s))
            }
          };
        case "MergeCoins":
          return {
            MergeCoins: {
              destination: Ss(i.destination),
              sources: i.sources.map((s) => Ss(s))
            }
          };
        case "MoveCall": {
          const [s, o, a] = i.target.split("::");
          return {
            MoveCall: {
              package: s,
              module: o,
              function: a,
              typeArguments: i.typeArguments,
              arguments: i.arguments.map((c) => Ss(c))
            }
          };
        }
        case "Publish":
          return {
            Publish: {
              modules: i.modules.map((s) => Wr(Uint8Array.from(s))),
              dependencies: i.dependencies
            }
          };
        case "SplitCoins":
          return {
            SplitCoins: {
              coin: Ss(i.coin),
              amounts: i.amounts.map((s) => Ss(s))
            }
          };
        case "TransferObjects":
          return {
            TransferObjects: {
              objects: i.objects.map((s) => Ss(s)),
              address: Ss(i.address)
            }
          };
        case "Upgrade":
          return {
            Upgrade: {
              modules: i.modules.map((s) => Wr(Uint8Array.from(s))),
              dependencies: i.dependencies,
              package: i.packageId,
              ticket: Ss(i.ticket)
            }
          };
      }
      throw new Error(`Unknown transaction ${Object.keys(i)}`);
    })
  });
}
function Ss(e) {
  switch (e.kind) {
    case "GasCoin":
      return { GasCoin: !0 };
    case "Result":
      return { Result: e.index };
    case "NestedResult":
      return { NestedResult: [e.index, e.resultIndex] };
    case "Input":
      return { Input: e.index };
  }
}
function ol(e) {
  return Xr(
    Object.entries(e).map(([t, r]) => We({ [t]: r }))
  );
}
const gi = ol({
  GasCoin: Tt(!0),
  Input: er(vr(), wr()),
  Result: er(vr(), wr()),
  NestedResult: Ed([er(vr(), wr()), er(vr(), wr())])
}), aD = We({
  budget: Ht(Nn),
  price: Ht(Nn),
  owner: Ht(Mc),
  payment: Ht(St(ko))
}), cD = We({
  package: zn,
  module: Nt(),
  function: Nt(),
  // snake case in rust
  typeArguments: St(Nt()),
  arguments: St(gi)
}), uD = We({
  name: Nt(),
  inputs: mc(Nt(), Xr([gi, St(gi)])),
  data: mc(Nt(), Mo())
}), lD = ol({
  MoveCall: cD,
  TransferObjects: We({
    objects: St(gi),
    address: gi
  }),
  SplitCoins: We({
    coin: gi,
    amounts: St(gi)
  }),
  MergeCoins: We({
    destination: gi,
    sources: St(gi)
  }),
  Publish: We({
    modules: St(ba),
    dependencies: St(zn)
  }),
  MakeMoveVec: We({
    type: Ht(Nt()),
    elements: St(gi)
  }),
  Upgrade: We({
    modules: St(ba),
    dependencies: St(zn),
    package: zn,
    ticket: gi
  }),
  $Intent: uD
}), fD = ol({
  ImmOrOwnedObject: ko,
  SharedObject: We({
    objectId: zn,
    // snake case in rust
    initialSharedVersion: Nn,
    mutable: tl()
  }),
  Receiving: ko
}), dD = ol({
  Object: fD,
  Pure: We({
    bytes: ba
  }),
  UnresolvedPure: We({
    value: Mo()
  }),
  UnresolvedObject: We({
    objectId: zn,
    version: qr(Ht(Nn)),
    digest: qr(Ht(Nt())),
    initialSharedVersion: qr(Ht(Nn))
  })
}), hD = ol({
  None: Tt(!0),
  Epoch: Nn
}), pD = We({
  version: Tt(2),
  sender: va(Mc),
  expiration: va(hD),
  gasData: aD,
  inputs: St(dD),
  commands: St(lD),
  digest: qr(Ht(Nt()))
});
function mD(e) {
  return {
    $kind: "Pure",
    Pure: {
      bytes: e instanceof Uint8Array ? Wr(e) : e.toBase64()
    }
  };
}
const Ps = {
  Pure: mD,
  ObjectRef({ objectId: e, digest: t, version: r }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "ImmOrOwnedObject",
        ImmOrOwnedObject: {
          digest: t,
          version: r,
          objectId: Gt(e)
        }
      }
    };
  },
  SharedObjectRef({
    objectId: e,
    mutable: t,
    initialSharedVersion: r
  }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "SharedObject",
        SharedObject: {
          mutable: t,
          initialSharedVersion: r,
          objectId: Gt(e)
        }
      }
    };
  },
  ReceivingRef({ objectId: e, digest: t, version: r }) {
    return {
      $kind: "Object",
      Object: {
        $kind: "Receiving",
        Receiving: {
          digest: t,
          version: r,
          objectId: Gt(e)
        }
      }
    };
  }
};
var Kx = (e) => {
  throw TypeError(e);
}, Gg = (e, t, r) => t.has(e) || Kx("Cannot " + r), zr = (e, t, r) => (Gg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Zc = (e, t, r) => t.has(e) ? Kx("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), kl = (e, t, r, n) => (Gg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), kd = (e, t, r) => (Gg(e, t, "access private method"), r), ku, qs, ju, bo, Ji, R0, P0, Yx, Xx, Kg;
const gD = "/", yD = {
  "Mvr-Source": `@mysten/sui@${Ix}`
};
class Jx {
  constructor({ cache: t, url: r, pageSize: n = 50, overrides: i }) {
    Zc(this, Ji), Zc(this, ku), Zc(this, qs), Zc(this, ju), Zc(this, bo), kl(this, ku, t), kl(this, qs, r), kl(this, ju, n), kl(this, bo, {
      packages: i == null ? void 0 : i.packages,
      types: i == null ? void 0 : i.types
    }), vD(zr(this, bo));
  }
  async resolvePackage({
    package: t
  }) {
    return {
      package: await zr(this, Ji, R0).load(t)
    };
  }
  async resolveType({
    type: t
  }) {
    const r = [...N0(t)], n = await zr(this, Ji, P0).loadMany(r), i = {};
    for (let s = 0; s < r.length; s++) {
      const o = n[s];
      if (o instanceof Error)
        throw o;
      i[r[s]] = o;
    }
    return {
      type: $0(t, i)
    };
  }
  async resolve({
    types: t = [],
    packages: r = []
  }) {
    var l, f, h;
    const n = /* @__PURE__ */ new Set();
    for (const v of t ?? [])
      N0(v, n);
    const i = [...n], [s, o] = await Promise.all([
      i.length > 0 ? zr(this, Ji, P0).loadMany(i) : [],
      r.length > 0 ? zr(this, Ji, R0).loadMany(r) : []
    ]), a = {
      ...(l = zr(this, bo)) == null ? void 0 : l.types
    };
    for (const [v, b] of i.entries()) {
      const y = s[v];
      if (y instanceof Error)
        throw y;
      a[b] = y;
    }
    const c = {};
    for (const v of t ?? []) {
      const b = $0(v, a);
      c[v] = {
        type: b
      };
    }
    const u = {};
    for (const [v, b] of (r ?? []).entries()) {
      const y = ((h = (f = zr(this, bo)) == null ? void 0 : f.packages) == null ? void 0 : h[b]) ?? o[v];
      if (y instanceof Error)
        throw y;
      u[b] = {
        package: y
      };
    }
    return {
      types: c,
      packages: u
    };
  }
}
ku = /* @__PURE__ */ new WeakMap();
qs = /* @__PURE__ */ new WeakMap();
ju = /* @__PURE__ */ new WeakMap();
bo = /* @__PURE__ */ new WeakMap();
Ji = /* @__PURE__ */ new WeakSet();
R0 = function() {
  return zr(this, ku).readSync(["#mvrPackageDataLoader", zr(this, qs) ?? ""], () => {
    var r;
    const e = new cg(async (n) => {
      if (!zr(this, qs))
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${n.join(", ")})`
        );
      const i = await kd(this, Ji, Yx).call(this, n);
      return n.map(
        (s) => i[s] ?? new Error(`Failed to resolve package: ${s}`)
      );
    }), t = (r = zr(this, bo)) == null ? void 0 : r.packages;
    if (t)
      for (const [n, i] of Object.entries(t))
        e.prime(n, i);
    return e;
  });
};
P0 = function() {
  return zr(this, ku).readSync(["#mvrTypeDataLoader", zr(this, qs) ?? ""], () => {
    var r;
    const e = new cg(async (n) => {
      if (!zr(this, qs))
        throw new Error(
          `MVR Api URL is not set for the current client (resolving ${n.join(", ")})`
        );
      const i = await kd(this, Ji, Xx).call(this, n);
      return n.map((s) => i[s] ?? new Error(`Failed to resolve type: ${s}`));
    }), t = (r = zr(this, bo)) == null ? void 0 : r.types;
    if (t)
      for (const [n, i] of Object.entries(t))
        e.prime(n, i);
    return e;
  });
};
Yx = async function(e) {
  if (e.length === 0)
    return {};
  const t = il(e, zr(this, ju)), r = {};
  return await Promise.all(
    t.map(async (n) => {
      var s;
      const i = await kd(this, Ji, Kg).call(this, "/v1/resolution/bulk", {
        names: n
      });
      if (i != null && i.resolution)
        for (const o of Object.keys(i == null ? void 0 : i.resolution)) {
          const a = (s = i.resolution[o]) == null ? void 0 : s.package_id;
          a && (r[o] = a);
        }
    })
  ), r;
};
Xx = async function(e) {
  if (e.length === 0)
    return {};
  const t = il(e, zr(this, ju)), r = {};
  return await Promise.all(
    t.map(async (n) => {
      var s;
      const i = await kd(this, Ji, Kg).call(this, "/v1/struct-definition/bulk", {
        types: n
      });
      if (i != null && i.resolution)
        for (const o of Object.keys(i == null ? void 0 : i.resolution)) {
          const a = (s = i.resolution[o]) == null ? void 0 : s.type_tag;
          a && (r[o] = a);
        }
    })
  ), r;
};
Kg = async function(e, t) {
  if (!zr(this, qs))
    throw new Error("MVR Api URL is not set for the current client");
  const r = await fetch(`${zr(this, qs)}${e}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...yD
    },
    body: JSON.stringify(t)
  });
  if (!r.ok) {
    const n = await r.json().catch(() => ({}));
    throw new Error(`Failed to resolve types: ${n == null ? void 0 : n.message}`);
  }
  return r.json();
};
function vD(e) {
  if (e != null && e.packages)
    for (const [t, r] of Object.entries(e.packages)) {
      if (!An(t))
        throw new Error(`Invalid package name: ${t}`);
      if (!Jn(Gt(r)))
        throw new Error(`Invalid package ID: ${r}`);
    }
  if (e != null && e.types)
    for (const [t, r] of Object.entries(e.types)) {
      if (Io(t).typeParams.length > 0)
        throw new Error(
          "Type overrides must be first-level only. If you want to supply generic types, just pass each type individually."
        );
      const n = Io(r);
      if (!Jn(n.address))
        throw new Error(`Invalid type: ${r}`);
    }
}
function N0(e, t = /* @__PURE__ */ new Set()) {
  if (typeof e == "string" && !In(e))
    return t;
  const r = Zx(e) ? e : Io(e);
  In(r.address) && t.add(`${r.address}::${r.module}::${r.name}`);
  for (const n of r.typeParams)
    N0(n, t);
  return t;
}
function $0(e, t) {
  const r = Zx(e) ? e : Io(e), n = `${r.address}::${r.module}::${r.name}`, i = t[n];
  return Ou({
    ...r,
    address: i ? i.split("::")[0] : r.address,
    typeParams: r.typeParams.map((s) => $0(s, t))
  });
}
function In(e) {
  return e.includes(gD) || e.includes("@") || e.includes(".sui");
}
function Zx(e) {
  return typeof e == "object" && "address" in e && "module" in e && "name" in e && "typeParams" in e;
}
function bD(e) {
  const t = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
  for (const n of e.commands)
    switch (n.$kind) {
      case "MakeMoveVec":
        n.MakeMoveVec.type && Qy([n.MakeMoveVec.type]).forEach((o) => {
          r.add(o);
        });
        break;
      case "MoveCall":
        const i = n.MoveCall, s = i.package.split("::")[0];
        if (In(s)) {
          if (!An(s))
            throw new Error(`Invalid package name: ${s}`);
          t.add(s);
        }
        Qy(i.typeArguments ?? []).forEach((o) => {
          r.add(o);
        });
        break;
    }
  return {
    packages: [...t],
    types: [...r]
  };
}
function wD(e, t) {
  var r;
  for (const n of e.commands) {
    if ((r = n.MakeMoveVec) != null && r.type) {
      if (!In(n.MakeMoveVec.type))
        continue;
      if (!t.types[n.MakeMoveVec.type])
        throw new Error(`No resolution found for type: ${n.MakeMoveVec.type}`);
      n.MakeMoveVec.type = t.types[n.MakeMoveVec.type].type;
    }
    const i = n.MoveCall;
    if (!i)
      continue;
    const s = i.package.split("::"), o = s[0];
    if (In(o) && !t.packages[o])
      throw new Error(`No address found for package: ${o}`);
    In(o) && (s[0] = t.packages[o].package, i.package = s.join("::"));
    const a = i.typeArguments;
    if (a) {
      for (let c = 0; c < a.length; c++)
        if (In(a[c])) {
          if (!t.types[a[c]])
            throw new Error(`No resolution found for type: ${a[c]}`);
          a[c] = t.types[a[c]].type;
        }
      i.typeArguments = a;
    }
  }
}
function Qy(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e)
    if (In(r)) {
      if (!rx(r))
        throw new Error(`Invalid type with names: ${r}`);
      t.add(r);
    }
  return t;
}
const ep = /* @__PURE__ */ new WeakMap(), _D = (e) => {
  let t;
  if (e) {
    const r = e.overrides ?? {
      packages: {},
      types: {}
    };
    ep.has(r) || ep.set(r, new zx()), t = new Jx({
      cache: ep.get(r),
      url: e.url,
      pageSize: e.pageSize,
      overrides: r
    });
  }
  return async (r, n, i) => {
    const s = bD(r);
    if (s.types.length === 0 && s.packages.length === 0)
      return i();
    const o = await (t || xD(n).core.mvr).resolve({
      types: s.types,
      packages: s.packages
    });
    wD(r, o), await i();
  };
};
function xD(e) {
  if (!e.client)
    throw new Error(
      "No sui client passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e.client;
}
const SD = "object", ED = "ID", TD = "ascii", CD = "String", AD = "string", MD = "String", OD = "option", ID = "Option";
function kD(e) {
  const t = typeof e.body == "object" && "datatype" in e.body ? e.body.datatype : null;
  return !!t && Gt(t.package) === Gt("0x2") && t.module === "tx_context" && t.type === "TxContext";
}
function D0(e) {
  if (typeof e == "string")
    switch (e) {
      case "address":
        return kt.Address;
      case "bool":
        return kt.Bool;
      case "u8":
        return kt.U8;
      case "u16":
        return kt.U16;
      case "u32":
        return kt.U32;
      case "u64":
        return kt.U64;
      case "u128":
        return kt.U128;
      case "u256":
        return kt.U256;
      default:
        throw new Error(`Unknown type signature ${e}`);
    }
  if ("vector" in e) {
    if (e.vector === "u8")
      return kt.vector(kt.U8).transform({
        input: (r) => typeof r == "string" ? new TextEncoder().encode(r) : r,
        output: (r) => r
      });
    const t = D0(e.vector);
    return t ? kt.vector(t) : null;
  }
  if ("datatype" in e) {
    const t = Gt(e.datatype.package);
    if (t === Gt(nx)) {
      if (e.datatype.module === TD && e.datatype.type === CD || e.datatype.module === AD && e.datatype.type === MD)
        return kt.String;
      if (e.datatype.module === OD && e.datatype.type === ID) {
        const r = D0(e.datatype.typeParameters[0]);
        return r ? kt.vector(r) : null;
      }
    }
    if (t === Gt(Lg) && e.datatype.module === SD && e.datatype.type === ED)
      return kt.Address;
  }
  return null;
}
function jD(e) {
  return typeof e == "object" && "Reference" in e ? {
    ref: "&",
    body: bu(e.Reference)
  } : typeof e == "object" && "MutableReference" in e ? {
    ref: "&mut",
    body: bu(e.MutableReference)
  } : {
    ref: null,
    body: bu(e)
  };
}
function bu(e) {
  if (typeof e == "string")
    switch (e) {
      case "Address":
        return "address";
      case "Bool":
        return "bool";
      case "U8":
        return "u8";
      case "U16":
        return "u16";
      case "U32":
        return "u32";
      case "U64":
        return "u64";
      case "U128":
        return "u128";
      case "U256":
        return "u256";
      default:
        throw new Error(`Unexpected type ${e}`);
    }
  if ("Vector" in e)
    return { vector: bu(e.Vector) };
  if ("Struct" in e)
    return {
      datatype: {
        package: e.Struct.address,
        module: e.Struct.module,
        type: e.Struct.name,
        typeParameters: e.Struct.typeArguments.map(bu)
      }
    };
  if ("TypeParameter" in e)
    return { typeParameter: e.TypeParameter };
  throw new Error(`Unexpected type ${JSON.stringify(e)}`);
}
const RD = 50, PD = 1000n, ND = 5e10;
function Qx(e) {
  return async function(r, n, i) {
    return await UD(r, e), await BD(r, e), n.onlyTransactionKind || (await $D(r, e), await DD(r, e), await LD(r, e)), await i();
  };
}
async function $D(e, t) {
  e.gasConfig.price || (e.gasConfig.price = String(await t.getReferenceGasPrice()));
}
async function DD(e, t) {
  if (e.gasConfig.budget)
    return;
  const r = await t.dryRunTransactionBlock({
    transactionBlock: e.build({
      overrides: {
        gasData: {
          budget: String(ND),
          payment: []
        }
      }
    })
  });
  if (r.effects.status.status !== "success")
    throw new Error(
      `Dry run failed, could not automatically determine a budget: ${r.effects.status.error}`,
      { cause: r }
    );
  const n = PD * BigInt(e.gasConfig.price || 1n), i = BigInt(r.effects.gasUsed.computationCost) + n, s = i + BigInt(r.effects.gasUsed.storageCost) - BigInt(r.effects.gasUsed.storageRebate);
  e.gasConfig.budget = String(
    s > i ? s : i
  );
}
async function LD(e, t) {
  if (!e.gasConfig.payment) {
    const n = (await t.getCoins({
      owner: e.gasConfig.owner || e.sender,
      coinType: Id
    })).data.filter((i) => !e.inputs.find((o) => {
      var a;
      return (a = o.Object) != null && a.ImmOrOwnedObject ? i.coinObjectId === o.Object.ImmOrOwnedObject.objectId : !1;
    })).map((i) => ({
      objectId: i.coinObjectId,
      digest: i.digest,
      version: i.version
    }));
    if (!n.length)
      throw new Error("No valid gas coins found for the transaction.");
    e.gasConfig.payment = n.map((i) => fr(ko, i));
  }
}
async function BD(e, t) {
  const r = e.inputs.filter((l) => {
    var f;
    return l.UnresolvedObject && !(l.UnresolvedObject.version || (f = l.UnresolvedObject) != null && f.initialSharedVersion);
  }), n = [
    ...new Set(
      r.map((l) => ai(l.UnresolvedObject.objectId))
    )
  ], i = n.length ? il(n, RD) : [], s = (await Promise.all(
    i.map(
      (l) => t.multiGetObjects({
        ids: l,
        options: { showOwner: !0 }
      })
    )
  )).flat(), o = new Map(
    n.map((l, f) => [l, s[f]])
  ), a = Array.from(o).filter(([l, f]) => f.error).map(([l, f]) => JSON.stringify(f.error));
  if (a.length)
    throw new Error(`The following input objects are invalid: ${a.join(", ")}`);
  const c = s.map((l) => {
    if (l.error || !l.data)
      throw new Error(`Failed to fetch object: ${l.error}`);
    const f = l.data.owner, h = f && typeof f == "object" && "Shared" in f ? f.Shared.initial_shared_version : null;
    return {
      objectId: l.data.objectId,
      digest: l.data.digest,
      version: l.data.version,
      initialSharedVersion: h
    };
  }), u = new Map(
    n.map((l, f) => [l, c[f]])
  );
  for (const [l, f] of e.inputs.entries()) {
    if (!f.UnresolvedObject)
      continue;
    let h;
    const v = Gt(f.UnresolvedObject.objectId), b = u.get(v);
    f.UnresolvedObject.initialSharedVersion ?? (b == null ? void 0 : b.initialSharedVersion) ? h = Ps.SharedObjectRef({
      objectId: v,
      initialSharedVersion: f.UnresolvedObject.initialSharedVersion || (b == null ? void 0 : b.initialSharedVersion),
      mutable: FD(e, l)
    }) : VD(e, l) && (h = Ps.ReceivingRef(
      {
        objectId: v,
        digest: f.UnresolvedObject.digest ?? (b == null ? void 0 : b.digest),
        version: f.UnresolvedObject.version ?? (b == null ? void 0 : b.version)
      }
    )), e.inputs[e.inputs.indexOf(f)] = h ?? Ps.ObjectRef({
      objectId: v,
      digest: f.UnresolvedObject.digest ?? (b == null ? void 0 : b.digest),
      version: f.UnresolvedObject.version ?? (b == null ? void 0 : b.version)
    });
  }
}
async function UD(e, t) {
  const { inputs: r, commands: n } = e, i = [], s = /* @__PURE__ */ new Set();
  n.forEach((a) => {
    if (a.MoveCall) {
      if (a.MoveCall._argumentTypes)
        return;
      if (a.MoveCall.arguments.map((l) => l.$kind === "Input" ? e.inputs[l.Input] : null).some(
        (l) => (l == null ? void 0 : l.UnresolvedPure) || (l == null ? void 0 : l.UnresolvedObject)
      )) {
        const l = `${a.MoveCall.package}::${a.MoveCall.module}::${a.MoveCall.function}`;
        s.add(l), i.push(a.MoveCall);
      }
    }
  });
  const o = /* @__PURE__ */ new Map();
  s.size > 0 && await Promise.all(
    [...s].map(async (a) => {
      const [c, u, l] = a.split("::"), f = await t.getNormalizedMoveFunction({
        package: c,
        module: u,
        function: l
      });
      o.set(
        a,
        f.parameters.map((h) => jD(h))
      );
    })
  ), i.length && await Promise.all(
    i.map(async (a) => {
      const c = o.get(
        `${a.package}::${a.module}::${a.function}`
      );
      if (!c)
        return;
      const l = c.length > 0 && kD(c.at(-1)) ? c.slice(0, c.length - 1) : c;
      a._argumentTypes = l;
    })
  ), n.forEach((a) => {
    if (!a.MoveCall)
      return;
    const c = a.MoveCall, u = `${c.package}::${c.module}::${c.function}`, l = c._argumentTypes;
    if (l) {
      if (l.length !== a.MoveCall.arguments.length)
        throw new Error(`Incorrect number of arguments for ${u}`);
      l.forEach((f, h) => {
        var O, I;
        const v = c.arguments[h];
        if (v.$kind !== "Input")
          return;
        const b = r[v.Input];
        if (!b.UnresolvedPure && !b.UnresolvedObject)
          return;
        const y = ((O = b.UnresolvedPure) == null ? void 0 : O.value) ?? ((I = b.UnresolvedObject) == null ? void 0 : I.objectId), S = D0(f.body);
        if (S) {
          v.type = "pure", r[r.indexOf(b)] = Ps.Pure(S.serialize(y));
          return;
        }
        if (typeof y != "string")
          throw new Error(
            `Expect the argument to be an object id string, got ${JSON.stringify(
              y,
              null,
              2
            )}`
          );
        v.type = "object";
        const C = b.UnresolvedPure ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: {
            objectId: y
          }
        } : b;
        r[v.Input] = C;
      });
    }
  });
}
function FD(e, t) {
  let r = !1;
  return e.getInputUses(t, (n, i) => {
    if (i.MoveCall && i.MoveCall._argumentTypes) {
      const s = i.MoveCall.arguments.indexOf(n);
      r = i.MoveCall._argumentTypes[s].ref !== "&" || r;
    }
    (i.$kind === "MakeMoveVec" || i.$kind === "MergeCoins" || i.$kind === "SplitCoins") && (r = !0);
  }), r;
}
function VD(e, t) {
  let r = !1;
  return e.getInputUses(t, (n, i) => {
    if (i.MoveCall && i.MoveCall._argumentTypes) {
      const s = i.MoveCall.arguments.indexOf(n);
      r = zD(i.MoveCall._argumentTypes[s]) || r;
    }
  }), r;
}
function zD(e) {
  return typeof e.body != "object" || !("datatype" in e.body) ? !1 : e.body.datatype.package === "0x2" && e.body.datatype.module === "transfer" && e.body.datatype.type === "Receiving";
}
function eS(e, t) {
  return !!(e.inputs.some((r) => r.UnresolvedObject || r.UnresolvedPure) || !t.onlyTransactionKind && (!e.gasConfig.price || !e.gasConfig.budget || !e.gasConfig.payment));
}
async function WD(e, t, r) {
  var s;
  if (HD(e), !eS(e, t))
    return await ev(e), r();
  const n = qD(t), i = ((s = n.core) == null ? void 0 : s.resolveTransactionPlugin()) ?? Qx(n);
  return _D()(e, t, async () => {
    await i(e, t, async () => {
      await ev(e), await r();
    });
  });
}
function ev(e) {
  e.inputs.forEach((t, r) => {
    if (t.$kind !== "Object" && t.$kind !== "Pure")
      throw new Error(
        `Input at index ${r} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(
          t
        )}`
      );
  });
}
function qD(e) {
  if (!e.client)
    throw new Error(
      "No sui client passed to Transaction#build, but transaction data was not sufficient to build offline."
    );
  return e.client;
}
function HD(e) {
  for (const t of e.commands)
    switch (t.$kind) {
      case "SplitCoins":
        t.SplitCoins.amounts.forEach((r) => {
          tv(r, kt.U64, e);
        });
        break;
      case "TransferObjects":
        tv(t.TransferObjects.address, kt.Address, e);
        break;
    }
}
function tv(e, t, r) {
  if (e.$kind !== "Input")
    return;
  const n = r.inputs[e.Input];
  n.$kind === "UnresolvedPure" && (r.inputs[e.Input] = Ps.Pure(t.serialize(n.UnresolvedPure.value)));
}
function GD(e) {
  function t(r) {
    return e(r);
  }
  return t.system = () => t("0x5"), t.clock = () => t("0x6"), t.random = () => t("0x8"), t.denyList = () => t("0x403"), t.option = ({ type: r, value: n }) => (i) => i.moveCall({
    typeArguments: [r],
    target: `0x1::option::${n === null ? "none" : "some"}`,
    arguments: n === null ? [] : [i.object(n)]
  }), t;
}
function KD(e) {
  function t(r, n) {
    if (typeof r == "string")
      return e(gu(r).serialize(n));
    if (r instanceof Uint8Array || xd(r))
      return e(r);
    throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value");
  }
  return t.u8 = (r) => e(kt.U8.serialize(r)), t.u16 = (r) => e(kt.U16.serialize(r)), t.u32 = (r) => e(kt.U32.serialize(r)), t.u64 = (r) => e(kt.U64.serialize(r)), t.u128 = (r) => e(kt.U128.serialize(r)), t.u256 = (r) => e(kt.U256.serialize(r)), t.bool = (r) => e(kt.Bool.serialize(r)), t.string = (r) => e(kt.String.serialize(r)), t.address = (r) => e(kt.Address.serialize(r)), t.id = t.address, t.vector = (r, n) => e(
    kt.vector(gu(r)).serialize(n)
  ), t.option = (r, n) => e(kt.option(gu(r)).serialize(n)), t;
}
function YD(e, t) {
  const r = Array.from(`${e}::`).map((i) => i.charCodeAt(0)), n = new Uint8Array(r.length + t.length);
  return n.set(r), n.set(t, r.length), Wm(n, { dkLen: 32 });
}
function rv(e) {
  return Gt(e).replace("0x", "");
}
class kn {
  constructor(t) {
    this.version = 2, this.sender = (t == null ? void 0 : t.sender) ?? null, this.expiration = (t == null ? void 0 : t.expiration) ?? null, this.inputs = (t == null ? void 0 : t.inputs) ?? [], this.commands = (t == null ? void 0 : t.commands) ?? [], this.gasData = (t == null ? void 0 : t.gasData) ?? {
      budget: null,
      price: null,
      owner: null,
      payment: null
    };
  }
  static fromKindBytes(t) {
    const n = kt.TransactionKind.parse(t).ProgrammableTransaction;
    if (!n)
      throw new Error("Unable to deserialize from bytes.");
    return kn.restore({
      version: 2,
      sender: null,
      expiration: null,
      gasData: {
        budget: null,
        owner: null,
        payment: null,
        price: null
      },
      inputs: n.inputs,
      commands: n.commands
    });
  }
  static fromBytes(t) {
    const r = kt.TransactionData.parse(t), n = r == null ? void 0 : r.V1, i = n.kind.ProgrammableTransaction;
    if (!n || !i)
      throw new Error("Unable to deserialize from bytes.");
    return kn.restore({
      version: 2,
      sender: n.sender,
      expiration: n.expiration,
      gasData: n.gasData,
      inputs: i.inputs,
      commands: i.commands
    });
  }
  static restore(t) {
    return t.version === 2 ? new kn(fr(cf, t)) : new kn(fr(cf, oD(t)));
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(t) {
    const r = YD("TransactionData", t);
    return Ca(r);
  }
  // @deprecated use gasData instead
  get gasConfig() {
    return this.gasData;
  }
  // @deprecated use gasData instead
  set gasConfig(t) {
    this.gasData = t;
  }
  build({
    maxSizeBytes: t = 1 / 0,
    overrides: r,
    onlyTransactionKind: n
  } = {}) {
    const i = this.inputs, s = this.commands, o = {
      ProgrammableTransaction: {
        inputs: i,
        commands: s
      }
    };
    if (n)
      return kt.TransactionKind.serialize(o, { maxSize: t }).toBytes();
    const a = (r == null ? void 0 : r.expiration) ?? this.expiration, c = (r == null ? void 0 : r.sender) ?? this.sender, u = { ...this.gasData, ...r == null ? void 0 : r.gasConfig, ...r == null ? void 0 : r.gasData };
    if (!c)
      throw new Error("Missing transaction sender");
    if (!u.budget)
      throw new Error("Missing gas budget");
    if (!u.payment)
      throw new Error("Missing gas payment");
    if (!u.price)
      throw new Error("Missing gas price");
    const l = {
      sender: rv(c),
      expiration: a || { None: !0 },
      gasData: {
        payment: u.payment,
        owner: rv(this.gasData.owner ?? c),
        price: BigInt(u.price),
        budget: BigInt(u.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs: i,
          commands: s
        }
      }
    };
    return kt.TransactionData.serialize(
      { V1: l },
      { maxSize: t }
    ).toBytes();
  }
  addInput(t, r) {
    const n = this.inputs.length;
    return this.inputs.push(r), { Input: n, type: t, $kind: "Input" };
  }
  getInputUses(t, r) {
    this.mapArguments((n, i) => (n.$kind === "Input" && n.Input === t && r(n, i), n));
  }
  mapCommandArguments(t, r) {
    const n = this.commands[t];
    switch (n.$kind) {
      case "MoveCall":
        n.MoveCall.arguments = n.MoveCall.arguments.map(
          (s) => r(s, n, t)
        );
        break;
      case "TransferObjects":
        n.TransferObjects.objects = n.TransferObjects.objects.map(
          (s) => r(s, n, t)
        ), n.TransferObjects.address = r(n.TransferObjects.address, n, t);
        break;
      case "SplitCoins":
        n.SplitCoins.coin = r(n.SplitCoins.coin, n, t), n.SplitCoins.amounts = n.SplitCoins.amounts.map(
          (s) => r(s, n, t)
        );
        break;
      case "MergeCoins":
        n.MergeCoins.destination = r(n.MergeCoins.destination, n, t), n.MergeCoins.sources = n.MergeCoins.sources.map(
          (s) => r(s, n, t)
        );
        break;
      case "MakeMoveVec":
        n.MakeMoveVec.elements = n.MakeMoveVec.elements.map(
          (s) => r(s, n, t)
        );
        break;
      case "Upgrade":
        n.Upgrade.ticket = r(n.Upgrade.ticket, n, t);
        break;
      case "$Intent":
        const i = n.$Intent.inputs;
        n.$Intent.inputs = {};
        for (const [s, o] of Object.entries(i))
          n.$Intent.inputs[s] = Array.isArray(o) ? o.map((a) => r(a, n, t)) : r(o, n, t);
        break;
      case "Publish":
        break;
      default:
        throw new Error(`Unexpected transaction kind: ${n.$kind}`);
    }
  }
  mapArguments(t) {
    for (const r of this.commands.keys())
      this.mapCommandArguments(r, t);
  }
  replaceCommand(t, r, n = t) {
    if (!Array.isArray(r)) {
      this.commands[t] = r;
      return;
    }
    const i = r.length - 1;
    this.commands.splice(t, 1, ...r), i !== 0 && this.mapArguments((s, o, a) => {
      if (a < t + r.length)
        return s;
      switch (s.$kind) {
        case "Result":
          s.Result === t && (s.Result = n), s.Result > t && (s.Result += i);
          break;
        case "NestedResult":
          s.NestedResult[0] === t && (s.NestedResult[0] = n), s.NestedResult[0] > t && (s.NestedResult[0] += i);
          break;
      }
      return s;
    });
  }
  getDigest() {
    const t = this.build({ onlyTransactionKind: !1 });
    return kn.getDigestFromBytes(t);
  }
  snapshot() {
    return fr(cf, this);
  }
  shallowClone() {
    return new kn({
      version: this.version,
      sender: this.sender,
      expiration: this.expiration,
      gasData: {
        ...this.gasData
      },
      inputs: [...this.inputs],
      commands: [...this.commands]
    });
  }
}
function nv(e) {
  if (typeof e == "string")
    return Gt(e);
  if (e.Object)
    return e.Object.ImmOrOwnedObject ? Gt(e.Object.ImmOrOwnedObject.objectId) : e.Object.Receiving ? Gt(e.Object.Receiving.objectId) : Gt(e.Object.SharedObject.objectId);
  if (e.UnresolvedObject)
    return Gt(e.UnresolvedObject.objectId);
}
var tS = (e) => {
  throw TypeError(e);
}, Yg = (e, t, r) => t.has(e) || tS("Cannot " + r), Ve = (e, t, r) => (Yg(e, t, "read from private field"), r ? r.call(e) : t.get(e)), Vi = (e, t, r) => t.has(e) ? tS("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), or = (e, t, r, n) => (Yg(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), Dr = (e, t, r) => (Yg(e, t, "access private method"), r), la, ma, Is, is, ii, si, Ti, wo, gt, Cr, rS, uf, lf, ff, Kf, L0, Xg, nS, iS;
function tp(e, t = 1 / 0) {
  const r = {
    $kind: "Result",
    get Result() {
      return typeof e == "function" ? e() : e;
    }
  }, n = [], i = (s) => n[s] ?? (n[s] = {
    $kind: "NestedResult",
    get NestedResult() {
      return [typeof e == "function" ? e() : e, s];
    }
  });
  return new Proxy(r, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(s, o) {
      if (o in s)
        return Reflect.get(s, o);
      if (o === Symbol.iterator)
        return function* () {
          let c = 0;
          for (; c < t; )
            yield i(c), c++;
        };
      if (typeof o == "symbol")
        return;
      const a = parseInt(o, 10);
      if (!(Number.isNaN(a) || a < 0))
        return i(a);
    }
  });
}
const sS = Symbol.for("@mysten/transaction");
function oS(e) {
  return !!e && typeof e == "object" && e[sS] === !0;
}
const iv = {
  buildPlugins: /* @__PURE__ */ new Map(),
  serializationPlugins: /* @__PURE__ */ new Map()
}, rp = Symbol.for("@mysten/transaction/registry");
function Qc() {
  try {
    const e = globalThis;
    return e[rp] || (e[rp] = iv), e[rp];
  } catch {
    return iv;
  }
}
const aS = class B0 {
  constructor() {
    Vi(this, Cr), Vi(this, la), Vi(this, ma), Vi(this, Is, /* @__PURE__ */ new Map()), Vi(this, is, []), Vi(this, ii, []), Vi(this, si, /* @__PURE__ */ new Set()), Vi(this, Ti, /* @__PURE__ */ new Set()), Vi(this, wo, /* @__PURE__ */ new Map()), Vi(this, gt), this.object = GD(
      (r) => {
        var s, o;
        if (typeof r == "function")
          return this.object(this.add(r));
        if (typeof r == "object" && $f(yr, r))
          return r;
        const n = nv(r), i = Ve(this, gt).inputs.find((a) => n === nv(a));
        return (s = i == null ? void 0 : i.Object) != null && s.SharedObject && typeof r == "object" && ((o = r.Object) != null && o.SharedObject) && (i.Object.SharedObject.mutable = i.Object.SharedObject.mutable || r.Object.SharedObject.mutable), i ? { $kind: "Input", Input: Ve(this, gt).inputs.indexOf(i), type: "object" } : Dr(this, Cr, lf).call(this, "object", typeof r == "string" ? {
          $kind: "UnresolvedObject",
          UnresolvedObject: { objectId: Gt(r) }
        } : r);
      }
    );
    const t = Qc();
    or(this, gt, new kn()), or(this, ma, [...t.buildPlugins.values()]), or(this, la, [...t.serializationPlugins.values()]);
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(t) {
    const r = new B0();
    return or(r, gt, kn.fromKindBytes(
      typeof t == "string" ? Hr(t) : t
    )), or(r, is, Ve(r, gt).inputs.slice()), or(r, ii, Ve(r, gt).commands.slice()), or(r, si, new Set(Ve(r, ii).map((n, i) => i))), r;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(t) {
    const r = new B0();
    return oS(t) ? or(r, gt, new kn(t.getData())) : typeof t != "string" || !t.startsWith("{") ? or(r, gt, kn.fromBytes(
      typeof t == "string" ? Hr(t) : t
    )) : or(r, gt, kn.restore(JSON.parse(t))), or(r, is, Ve(r, gt).inputs.slice()), or(r, ii, Ve(r, gt).commands.slice()), or(r, si, new Set(Ve(r, ii).map((n, i) => i))), r;
  }
  static registerGlobalSerializationPlugin(t, r) {
    Qc().serializationPlugins.set(
      t,
      r ?? t
    );
  }
  static unregisterGlobalSerializationPlugin(t) {
    Qc().serializationPlugins.delete(t);
  }
  static registerGlobalBuildPlugin(t, r) {
    Qc().buildPlugins.set(
      t,
      r ?? t
    );
  }
  static unregisterGlobalBuildPlugin(t) {
    Qc().buildPlugins.delete(t);
  }
  addSerializationPlugin(t) {
    Ve(this, la).push(t);
  }
  addBuildPlugin(t) {
    Ve(this, ma).push(t);
  }
  addIntentResolver(t, r) {
    if (Ve(this, Is).has(t) && Ve(this, Is).get(t) !== r)
      throw new Error(`Intent resolver for ${t} already exists`);
    Ve(this, Is).set(t, r);
  }
  setSender(t) {
    Ve(this, gt).sender = t;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(t) {
    Ve(this, gt).sender || (Ve(this, gt).sender = t);
  }
  setExpiration(t) {
    Ve(this, gt).expiration = t ? fr(Hx, t) : null;
  }
  setGasPrice(t) {
    Ve(this, gt).gasConfig.price = String(t);
  }
  setGasBudget(t) {
    Ve(this, gt).gasConfig.budget = String(t);
  }
  setGasBudgetIfNotSet(t) {
    Ve(this, gt).gasData.budget == null && (Ve(this, gt).gasConfig.budget = String(t));
  }
  setGasOwner(t) {
    Ve(this, gt).gasConfig.owner = t;
  }
  setGasPayment(t) {
    Ve(this, gt).gasConfig.payment = t.map((r) => fr(ko, r));
  }
  /** @deprecated Use `getData()` instead. */
  get blockData() {
    return Zy(Ve(this, gt).snapshot());
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  getData() {
    return Ve(this, gt).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [sS]() {
    return !0;
  }
  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage
  get pure() {
    return Object.defineProperty(this, "pure", {
      enumerable: !1,
      value: KD((t) => xd(t) ? Dr(this, Cr, lf).call(this, "pure", {
        $kind: "Pure",
        Pure: {
          bytes: t.toBase64()
        }
      }) : Dr(this, Cr, lf).call(this, "pure", $f(Yy, t) ? fr(Yy, t) : t instanceof Uint8Array ? Ps.Pure(t) : { $kind: "UnresolvedPure", UnresolvedPure: { value: t } }))
    }), this.pure;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { $kind: "GasCoin", GasCoin: !0 };
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...t) {
    return this.object(Ps.ObjectRef(...t));
  }
  /**
   * Add a new receiving input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  receivingRef(...t) {
    return this.object(Ps.ReceivingRef(...t));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...t) {
    return this.object(Ps.SharedObjectRef(...t));
  }
  add(t) {
    if (typeof t == "function") {
      if (Ve(this, wo).has(t))
        return Ve(this, wo).get(t);
      const r = Dr(this, Cr, rS).call(this), n = t(r);
      if (!(n && typeof n == "object" && "then" in n))
        return or(this, si, Ve(r, si)), Ve(this, wo).set(t, n), n;
      const i = Dr(this, Cr, uf).call(this, {
        $kind: "$Intent",
        $Intent: {
          name: "AsyncTransactionThunk",
          inputs: {},
          data: {
            resultIndex: Ve(this, gt).commands.length,
            result: null
          }
        }
      });
      Ve(this, Ti).add(
        Promise.resolve(n).then((o) => {
          i.$Intent.data.result = o;
        })
      );
      const s = tp(() => i.$Intent.data.resultIndex);
      return Ve(this, wo).set(t, s), s;
    } else
      Dr(this, Cr, uf).call(this, t);
    return tp(Ve(this, gt).commands.length - 1);
  }
  // Method shorthands:
  splitCoins(t, r) {
    const n = qo.SplitCoins(
      typeof t == "string" ? this.object(t) : Dr(this, Cr, Kf).call(this, t),
      r.map(
        (i) => typeof i == "number" || typeof i == "bigint" || typeof i == "string" ? this.pure.u64(i) : Dr(this, Cr, ff).call(this, i)
      )
    );
    return Dr(this, Cr, uf).call(this, n), tp(Ve(this, gt).commands.length - 1, r.length);
  }
  mergeCoins(t, r) {
    return this.add(
      qo.MergeCoins(
        this.object(t),
        r.map((n) => this.object(n))
      )
    );
  }
  publish({ modules: t, dependencies: r }) {
    return this.add(
      qo.Publish({
        modules: t,
        dependencies: r
      })
    );
  }
  upgrade({
    modules: t,
    dependencies: r,
    package: n,
    ticket: i
  }) {
    return this.add(
      qo.Upgrade({
        modules: t,
        dependencies: r,
        package: n,
        ticket: this.object(i)
      })
    );
  }
  moveCall({
    arguments: t,
    ...r
  }) {
    return this.add(
      qo.MoveCall({
        ...r,
        arguments: t == null ? void 0 : t.map((n) => Dr(this, Cr, ff).call(this, n))
      })
    );
  }
  transferObjects(t, r) {
    return this.add(
      qo.TransferObjects(
        t.map((n) => this.object(n)),
        typeof r == "string" ? this.pure.address(r) : Dr(this, Cr, ff).call(this, r)
      )
    );
  }
  makeMoveVec({
    type: t,
    elements: r
  }) {
    return this.add(
      qo.MakeMoveVec({
        type: t,
        elements: r.map((n) => this.object(n))
      })
    );
  }
  /**
   * @deprecated Use toJSON instead.
   * For synchronous serialization, you can use `getData()`
   * */
  serialize() {
    return JSON.stringify(Zy(Ve(this, gt).snapshot()));
  }
  async toJSON(t = {}) {
    await this.prepareForSerialization(t);
    const r = this.isFullyResolved();
    return JSON.stringify(
      fr(
        pD,
        r ? {
          ...Ve(this, gt).snapshot(),
          digest: Ve(this, gt).getDigest()
        } : Ve(this, gt).snapshot()
      ),
      (n, i) => typeof i == "bigint" ? i.toString() : i,
      2
    );
  }
  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
  async sign(t) {
    const { signer: r, ...n } = t, i = await this.build(n);
    return r.signTransaction(i);
  }
  /**
   *  Ensures that:
   *  - All objects have been fully resolved to a specific version
   *  - All pure inputs have been serialized to bytes
   *  - All async thunks have been fully resolved
   *  - All transaction intents have been resolved
   * 	- The gas payment, budget, and price have been set
   *  - The transaction sender has been set
   *
   *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)
   */
  isFullyResolved() {
    return !(!Ve(this, gt).sender || Ve(this, Ti).size > 0 || Ve(this, gt).commands.some((t) => t.$Intent) || eS(Ve(this, gt), {}));
  }
  /** Build the transaction to BCS bytes. */
  async build(t = {}) {
    return await this.prepareForSerialization(t), await Dr(this, Cr, L0).call(this, t), Ve(this, gt).build({
      onlyTransactionKind: t.onlyTransactionKind
    });
  }
  /** Derive transaction digest */
  async getDigest(t = {}) {
    return await Dr(this, Cr, L0).call(this, t), Ve(this, gt).getDigest();
  }
  async prepareForSerialization(t) {
    var i;
    await Dr(this, Cr, nS).call(this), Dr(this, Cr, iS).call(this);
    const r = /* @__PURE__ */ new Set();
    for (const s of Ve(this, gt).commands)
      s.$Intent && r.add(s.$Intent.name);
    const n = [...Ve(this, la)];
    for (const s of r)
      if (!((i = t.supportedIntents) != null && i.includes(s))) {
        if (!Ve(this, Is).has(s))
          throw new Error(`Missing intent resolver for ${s}`);
        n.push(Ve(this, Is).get(s));
      }
    await Dr(this, Cr, Xg).call(this, n, t);
  }
};
la = /* @__PURE__ */ new WeakMap();
ma = /* @__PURE__ */ new WeakMap();
Is = /* @__PURE__ */ new WeakMap();
is = /* @__PURE__ */ new WeakMap();
ii = /* @__PURE__ */ new WeakMap();
si = /* @__PURE__ */ new WeakMap();
Ti = /* @__PURE__ */ new WeakMap();
wo = /* @__PURE__ */ new WeakMap();
gt = /* @__PURE__ */ new WeakMap();
Cr = /* @__PURE__ */ new WeakSet();
rS = function() {
  const e = new aS();
  return or(e, gt, Ve(this, gt)), or(e, la, Ve(this, la)), or(e, ma, Ve(this, ma)), or(e, Is, Ve(this, Is)), or(e, Ti, Ve(this, Ti)), or(e, si, new Set(Ve(this, si))), or(e, wo, Ve(this, wo)), Ve(this, is).push(Ve(e, is)), Ve(this, ii).push(Ve(e, ii)), e;
};
uf = function(e) {
  const t = Ve(this, gt).commands.length;
  return Ve(this, ii).push(e), Ve(this, si).add(t), Ve(this, gt).commands.push(e), Ve(this, gt).mapCommandArguments(t, (r) => {
    if (r.$kind === "Result" && !Ve(this, si).has(r.Result))
      throw new Error(
        `Result { Result: ${r.Result} } is not available to use the current transaction`
      );
    if (r.$kind === "NestedResult" && !Ve(this, si).has(r.NestedResult[0]))
      throw new Error(
        `Result { NestedResult: [${r.NestedResult[0]}, ${r.NestedResult[1]}] } is not available to use the current transaction`
      );
    if (r.$kind === "Input" && r.Input >= Ve(this, gt).inputs.length)
      throw new Error(
        `Input { Input: ${r.Input} } references an input that does not exist in the current transaction`
      );
    return r;
  }), e;
};
lf = function(e, t) {
  return Ve(this, is).push(t), Ve(this, gt).addInput(e, t);
};
ff = function(e) {
  return xd(e) ? this.pure(e) : Dr(this, Cr, Kf).call(this, e);
};
Kf = function(e) {
  if (typeof e == "function") {
    const t = this.add(e);
    return typeof t == "function" ? Dr(this, Cr, Kf).call(this, t) : fr(yr, t);
  }
  return fr(yr, e);
};
L0 = async function(e) {
  if (!e.onlyTransactionKind && !Ve(this, gt).sender)
    throw new Error("Missing transaction sender");
  await Dr(this, Cr, Xg).call(this, [...Ve(this, ma), WD], e);
};
Xg = async function(e, t) {
  const r = (n) => {
    if (n >= e.length)
      return () => {
      };
    const i = e[n];
    return async () => {
      const s = r(n + 1);
      let o = !1, a = !1;
      if (await i(Ve(this, gt), t, async () => {
        if (o)
          throw new Error(`next() was call multiple times in TransactionPlugin ${n}`);
        o = !0, await s(), a = !0;
      }), !o)
        throw new Error(`next() was not called in TransactionPlugin ${n}`);
      if (!a)
        throw new Error(`next() was not awaited in TransactionPlugin ${n}`);
    };
  };
  await r(0)(), or(this, is, Ve(this, gt).inputs.slice()), or(this, ii, Ve(this, gt).commands.slice());
};
nS = async function() {
  for (; Ve(this, Ti).size > 0; ) {
    const e = Promise.all(Ve(this, Ti));
    Ve(this, Ti).clear(), Ve(this, Ti).add(e), await e, Ve(this, Ti).delete(e);
  }
};
iS = function() {
  var o;
  const e = Ve(this, gt).commands, t = Ve(this, gt).inputs, r = Ve(this, ii).flat(1 / 0), n = Ve(this, is).flat(1 / 0);
  if (r.length !== e.length)
    throw new Error("Unexpected number of commands found in transaction data");
  if (n.length !== t.length)
    throw new Error("Unexpected number of inputs found in transaction data");
  const i = r.filter(
    (a) => {
      var c;
      return ((c = a.$Intent) == null ? void 0 : c.name) !== "AsyncTransactionThunk";
    }
  );
  Ve(this, gt).commands = i, Ve(this, gt).inputs = n, or(this, ii, i), or(this, is, n), or(this, si, new Set(i.map((a, c) => c)));
  function s(a) {
    var l;
    const c = e[a];
    if (((l = c.$Intent) == null ? void 0 : l.name) === "AsyncTransactionThunk") {
      const f = c.$Intent.data.result;
      if (f == null)
        throw new Error("AsyncTransactionThunk has not been resolved");
      return s(f.Result);
    }
    const u = i.indexOf(c);
    if (u === -1)
      throw new Error("Unable to find original index for command");
    return u;
  }
  Ve(this, gt).mapArguments((a) => {
    if (a.$kind === "Input") {
      const c = n.indexOf(t[a.Input]);
      if (c === -1)
        throw new Error("Input has not been resolved");
      return { ...a, Input: c };
    } else if (a.$kind === "Result") {
      const c = s(a.Result);
      return { ...a, Result: c };
    } else if (a.$kind === "NestedResult") {
      const c = s(a.NestedResult[0]);
      return { ...a, NestedResult: [c, a.NestedResult[1]] };
    }
    return a;
  });
  for (const [a, c] of e.entries())
    if (((o = c.$Intent) == null ? void 0 : o.name) === "AsyncTransactionThunk")
      try {
        c.$Intent.data.resultIndex = s(a);
      } catch {
      }
};
let XD = aS;
class JD extends Wx {
  constructor(t) {
    var r, n, i;
    super(t), this.core = this, this.mvr = new Jx({
      cache: this.base.cache.scope("core"),
      url: (r = t.mvr) == null ? void 0 : r.url,
      pageSize: (n = t.mvr) == null ? void 0 : n.pageSize,
      overrides: (i = t.mvr) == null ? void 0 : i.overrides
    });
  }
  async getObject(t) {
    const { objectId: r } = t, {
      objects: [n]
    } = await this.getObjects({ objectIds: [r], signal: t.signal });
    if (n instanceof Error)
      throw n;
    return { object: n };
  }
  async getDynamicField(t) {
    const r = Mx(
      t.parentId,
      Ei.parseFromStr(t.name.type),
      t.name.bcs
    ), {
      objects: [n]
    } = await this.getObjects({
      objectIds: [r],
      signal: t.signal
    });
    if (n instanceof Error)
      throw n;
    const i = Io(n.type), s = await n.content;
    return {
      dynamicField: {
        id: n.id,
        digest: n.digest,
        version: n.version,
        type: n.type,
        name: {
          type: typeof i.typeParams[0] == "string" ? i.typeParams[0] : Ou(i.typeParams[0]),
          bcs: t.name.bcs
        },
        value: {
          type: typeof i.typeParams[1] == "string" ? i.typeParams[1] : Ou(i.typeParams[1]),
          bcs: s.slice(sl + t.name.bcs.length)
        }
      }
    };
  }
  async waitForTransaction({
    signal: t,
    timeout: r = 60 * 1e3,
    ...n
  }) {
    const i = t ? AbortSignal.any([AbortSignal.timeout(r), t]) : AbortSignal.timeout(r), s = new Promise((o, a) => {
      i.addEventListener("abort", () => a(i.reason));
    });
    for (s.catch(() => {
    }); ; ) {
      i.throwIfAborted();
      try {
        return await this.getTransaction({
          ...n,
          signal: i
        });
      } catch {
        await Promise.race([new Promise((a) => setTimeout(a, 2e3)), s]);
      }
    }
  }
}
class ZD extends Error {
}
class _o extends ZD {
  constructor(t, r) {
    super(r), this.code = t;
  }
  static fromResponse(t, r) {
    switch (t.code) {
      case "notExists":
        return new _o(t.code, `Object ${t.object_id} does not exist`);
      case "dynamicFieldNotFound":
        return new _o(
          t.code,
          `Dynamic field not found for object ${t.parent_object_id}`
        );
      case "deleted":
        return new _o(t.code, `Object ${t.object_id} has been deleted`);
      case "displayError":
        return new _o(t.code, `Display error: ${t.error}`);
      case "unknown":
      default:
        return new _o(
          t.code,
          `Unknown error while loading object${r ? ` ${r}` : ""}`
        );
    }
  }
}
function QD(e) {
  return {
    ...kn.fromBytes(e).snapshot(),
    bcs: e
  };
}
function eL(e) {
  const t = kt.TransactionEffects.parse(e);
  switch (t.$kind) {
    case "V1":
      return tL({ bytes: e, effects: t.V1 });
    case "V2":
      return rL({ bytes: e, effects: t.V2 });
    default:
      throw new Error(
        `Unknown transaction effects version: ${t.$kind}`
      );
  }
}
function tL(e) {
  throw new Error("V1 effects are not supported yet");
}
function rL({
  bytes: e,
  effects: t
}) {
  const r = t.changedObjects.map(
    ([n, i]) => {
      var s, o, a, c, u, l;
      return {
        id: n,
        inputState: i.inputState.$kind === "Exist" ? "Exists" : "DoesNotExist",
        inputVersion: ((s = i.inputState.Exist) == null ? void 0 : s[0][0]) ?? null,
        inputDigest: ((o = i.inputState.Exist) == null ? void 0 : o[0][1]) ?? null,
        inputOwner: ((a = i.inputState.Exist) == null ? void 0 : a[1]) ?? null,
        outputState: i.outputState.$kind === "NotExist" ? "DoesNotExist" : i.outputState.$kind,
        outputVersion: i.outputState.$kind === "PackageWrite" ? (c = i.outputState.PackageWrite) == null ? void 0 : c[0] : i.outputState.ObjectWrite ? t.lamportVersion : null,
        outputDigest: i.outputState.$kind === "PackageWrite" ? (u = i.outputState.PackageWrite) == null ? void 0 : u[1] : ((l = i.outputState.ObjectWrite) == null ? void 0 : l[0]) ?? null,
        outputOwner: i.outputState.ObjectWrite ? i.outputState.ObjectWrite[1] : null,
        idOperation: i.idOperation.$kind
      };
    }
  );
  return {
    bcs: e,
    digest: t.transactionDigest,
    version: 2,
    status: t.status.$kind === "Success" ? {
      success: !0,
      error: null
    } : {
      success: !1,
      // TODO: add command
      error: t.status.Failed.error.$kind
    },
    gasUsed: t.gasUsed,
    transactionDigest: t.transactionDigest,
    gasObject: t.gasObjectIndex === null ? null : r[t.gasObjectIndex] ?? null,
    eventsDigest: t.eventsDigest,
    dependencies: t.dependencies,
    lamportVersion: t.lamportVersion,
    changedObjects: r,
    unchangedSharedObjects: t.unchangedSharedObjects.map(
      ([n, i]) => ({
        kind: i.$kind,
        objectId: n,
        version: i.$kind === "ReadOnlyRoot" ? i.ReadOnlyRoot[0] : i[i.$kind],
        digest: i.$kind === "ReadOnlyRoot" ? i.ReadOnlyRoot[1] : null
      })
    ),
    auxiliaryDataDigest: t.auxDataDigest
  };
}
var cS = (e) => {
  throw TypeError(e);
}, uS = (e, t, r) => t.has(e) || cS("Cannot " + r), Un = (e, t, r) => (uS(e, t, "read from private field"), r ? r.call(e) : t.get(e)), nL = (e, t, r) => t.has(e) ? cS("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), iL = (e, t, r, n) => (uS(e, t, "write to private field"), n ? n.call(e, r) : t.set(e, r), r), fn;
class sL extends JD {
  constructor({
    jsonRpcClient: t,
    mvr: r
  }) {
    super({ network: t.network, base: t, mvr: r }), nL(this, fn), iL(this, fn, t);
  }
  async getObjects(t) {
    const r = il(t.objectIds, 50), n = [];
    for (const i of r) {
      const s = await Un(this, fn).multiGetObjects({
        ids: i,
        options: {
          showOwner: !0,
          showType: !0,
          showBcs: !0
        },
        signal: t.signal
      });
      for (const [o, a] of s.entries())
        a.error ? n.push(_o.fromResponse(a.error, i[o])) : n.push(sv(a.data));
    }
    return {
      objects: n
    };
  }
  async getOwnedObjects(t) {
    const r = await Un(this, fn).getOwnedObjects({
      owner: t.address,
      limit: t.limit,
      cursor: t.cursor,
      options: {
        showOwner: !0,
        showType: !0,
        showBcs: !0
      },
      filter: t.type ? { StructType: t.type } : null,
      signal: t.signal
    });
    return {
      objects: r.data.map((n) => {
        if (n.error)
          throw _o.fromResponse(n.error);
        return sv(n.data);
      }),
      hasNextPage: r.hasNextPage,
      cursor: r.nextCursor ?? null
    };
  }
  async getCoins(t) {
    const r = await Un(this, fn).getCoins({
      owner: t.address,
      coinType: t.coinType,
      limit: t.limit,
      cursor: t.cursor,
      signal: t.signal
    });
    return {
      objects: r.data.map((n) => ({
        id: n.coinObjectId,
        version: n.version,
        digest: n.digest,
        balance: n.balance,
        type: `0x2::coin::Coin<${n.coinType}>`,
        content: Promise.resolve(
          cL.serialize({
            id: n.coinObjectId,
            balance: {
              value: n.balance
            }
          }).toBytes()
        ),
        owner: {
          $kind: "ObjectOwner",
          ObjectOwner: t.address
        }
      })),
      hasNextPage: r.hasNextPage,
      cursor: r.nextCursor ?? null
    };
  }
  async getBalance(t) {
    const r = await Un(this, fn).getBalance({
      owner: t.address,
      coinType: t.coinType,
      signal: t.signal
    });
    return {
      balance: {
        coinType: r.coinType,
        balance: r.totalBalance
      }
    };
  }
  async getAllBalances(t) {
    return {
      balances: (await Un(this, fn).getAllBalances({
        owner: t.address,
        signal: t.signal
      })).map((n) => ({
        coinType: n.coinType,
        balance: n.totalBalance
      })),
      hasNextPage: !1,
      cursor: null
    };
  }
  async getTransaction(t) {
    const r = await Un(this, fn).getTransactionBlock({
      digest: t.digest,
      options: {
        showRawInput: !0,
        showObjectChanges: !0,
        showRawEffects: !0,
        showEvents: !0,
        showEffects: !0
      },
      signal: t.signal
    });
    return {
      transaction: ov(r)
    };
  }
  async executeTransaction(t) {
    const r = await Un(this, fn).executeTransactionBlock({
      transactionBlock: t.transaction,
      signature: t.signatures,
      options: {
        showRawEffects: !0,
        showEvents: !0,
        showObjectChanges: !0,
        showRawInput: !0,
        showEffects: !0
      },
      signal: t.signal
    });
    return {
      transaction: ov(r)
    };
  }
  async dryRunTransaction(t) {
    const r = XD.from(t.transaction), n = await Un(this, fn).dryRunTransactionBlock({
      transactionBlock: t.transaction,
      signal: t.signal
    }), { effects: i, objectTypes: s } = oL({
      effects: n.effects,
      objectChanges: n.objectChanges
    });
    return {
      transaction: {
        digest: await r.getDigest(),
        epoch: null,
        effects: i,
        objectTypes: Promise.resolve(s),
        signatures: [],
        transaction: QD(t.transaction)
      }
    };
  }
  async getReferenceGasPrice(t) {
    const r = await Un(this, fn).getReferenceGasPrice({
      signal: t == null ? void 0 : t.signal
    });
    return {
      referenceGasPrice: String(r)
    };
  }
  async getDynamicFields(t) {
    const r = await Un(this, fn).getDynamicFields({
      parentId: t.parentId,
      limit: t.limit,
      cursor: t.cursor
    });
    return {
      dynamicFields: r.data.map((n) => ({
        id: n.objectId,
        type: n.objectType,
        name: {
          type: n.name.type,
          bcs: Hr(n.bcsName)
        }
      })),
      hasNextPage: r.hasNextPage,
      cursor: r.nextCursor
    };
  }
  async verifyZkLoginSignature(t) {
    const r = await Un(this, fn).verifyZkLoginSignature({
      bytes: t.bytes,
      signature: t.signature,
      intentScope: t.intentScope,
      author: t.author
    });
    return {
      success: r.success,
      errors: r.errors
    };
  }
  resolveNameServiceNames(t) {
    return Un(this, fn).resolveNameServiceNames(t);
  }
  resolveTransactionPlugin() {
    return Qx(Un(this, fn));
  }
}
fn = /* @__PURE__ */ new WeakMap();
function sv(e) {
  var t;
  return {
    id: e.objectId,
    version: e.version,
    digest: e.digest,
    type: e.type,
    content: Promise.resolve(
      ((t = e.bcs) == null ? void 0 : t.dataType) === "moveObject" ? Hr(e.bcs.bcsBytes) : new Uint8Array()
    ),
    owner: Za(e.owner)
  };
}
function Za(e) {
  if (e === "Immutable")
    return {
      $kind: "Immutable",
      Immutable: !0
    };
  if ("ConsensusV2" in e)
    return {
      $kind: "ConsensusV2",
      ConsensusV2: {
        authenticator: {
          $kind: "SingleOwner",
          SingleOwner: e.ConsensusV2.authenticator.SingleOwner
        },
        startVersion: e.ConsensusV2.start_version
      }
    };
  if ("AddressOwner" in e)
    return {
      $kind: "AddressOwner",
      AddressOwner: e.AddressOwner
    };
  if ("ObjectOwner" in e)
    return {
      $kind: "ObjectOwner",
      ObjectOwner: e.ObjectOwner
    };
  if ("Shared" in e)
    return {
      $kind: "Shared",
      Shared: {
        initialSharedVersion: e.Shared.initial_shared_version
      }
    };
  throw new Error(`Unknown owner type: ${JSON.stringify(e)}`);
}
function ov(e) {
  var s, o;
  const t = kt.SenderSignedData.parse(Hr(e.rawTransaction))[0], r = {};
  (s = e.objectChanges) == null || s.forEach((a) => {
    a.type !== "published" && (r[a.objectId] = a.objectType);
  });
  const n = kt.TransactionData.serialize(t.intentMessage.value).toBytes(), i = kn.restore({
    version: 2,
    sender: t.intentMessage.value.V1.sender,
    expiration: t.intentMessage.value.V1.expiration,
    gasData: t.intentMessage.value.V1.gasData,
    inputs: t.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,
    commands: t.intentMessage.value.V1.kind.ProgrammableTransaction.commands
  });
  return {
    digest: e.digest,
    epoch: ((o = e.effects) == null ? void 0 : o.executedEpoch) ?? null,
    effects: eL(new Uint8Array(e.rawEffects)),
    objectTypes: Promise.resolve(r),
    transaction: {
      ...i,
      bcs: n
    },
    signatures: t.txSignatures
  };
}
function oL({
  bytes: e,
  effects: t,
  objectChanges: r
}) {
  var o;
  const n = [], i = [], s = {};
  return r == null || r.forEach((a) => {
    var c, u, l, f;
    switch (a.type) {
      case "published":
        n.push({
          id: a.packageId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "PackageWrite",
          outputVersion: a.version,
          outputDigest: a.digest,
          outputOwner: null,
          idOperation: "Created"
        });
        break;
      case "transferred":
        n.push({
          id: a.objectId,
          inputState: "Exists",
          inputVersion: a.version,
          inputDigest: a.digest,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: a.sender
          },
          outputState: "ObjectWrite",
          outputVersion: a.version,
          outputDigest: a.digest,
          outputOwner: Za(a.recipient),
          idOperation: "None"
        }), s[a.objectId] = a.objectType;
        break;
      case "mutated":
        n.push({
          id: a.objectId,
          inputState: "Exists",
          inputVersion: a.previousVersion,
          inputDigest: null,
          inputOwner: Za(a.owner),
          outputState: "ObjectWrite",
          outputVersion: a.version,
          outputDigest: a.digest,
          outputOwner: Za(a.owner),
          idOperation: "None"
        }), s[a.objectId] = a.objectType;
        break;
      case "deleted":
        n.push({
          id: a.objectId,
          inputState: "Exists",
          inputVersion: a.version,
          inputDigest: ((u = (c = t.deleted) == null ? void 0 : c.find((h) => h.objectId === a.objectId)) == null ? void 0 : u.digest) ?? null,
          inputOwner: null,
          outputState: "DoesNotExist",
          outputVersion: null,
          outputDigest: null,
          outputOwner: null,
          idOperation: "Deleted"
        }), s[a.objectId] = a.objectType;
        break;
      case "wrapped":
        n.push({
          id: a.objectId,
          inputState: "Exists",
          inputVersion: a.version,
          inputDigest: null,
          inputOwner: {
            $kind: "AddressOwner",
            AddressOwner: a.sender
          },
          outputState: "ObjectWrite",
          outputVersion: a.version,
          outputDigest: ((f = (l = t.wrapped) == null ? void 0 : l.find((h) => h.objectId === a.objectId)) == null ? void 0 : f.digest) ?? null,
          outputOwner: {
            $kind: "ObjectOwner",
            ObjectOwner: a.sender
          },
          idOperation: "None"
        }), s[a.objectId] = a.objectType;
        break;
      case "created":
        n.push({
          id: a.objectId,
          inputState: "DoesNotExist",
          inputVersion: null,
          inputDigest: null,
          inputOwner: null,
          outputState: "ObjectWrite",
          outputVersion: a.version,
          outputDigest: a.digest,
          outputOwner: Za(a.owner),
          idOperation: "Created"
        }), s[a.objectId] = a.objectType;
        break;
    }
  }), {
    objectTypes: s,
    effects: {
      bcs: e ?? null,
      digest: t.transactionDigest,
      version: 2,
      status: t.status.status === "success" ? { success: !0, error: null } : { success: !1, error: t.status.error },
      gasUsed: t.gasUsed,
      transactionDigest: t.transactionDigest,
      gasObject: {
        id: (o = t.gasObject) == null ? void 0 : o.reference.objectId,
        inputState: "Exists",
        inputVersion: null,
        inputDigest: null,
        inputOwner: null,
        outputState: "ObjectWrite",
        outputVersion: t.gasObject.reference.version,
        outputDigest: t.gasObject.reference.digest,
        outputOwner: Za(t.gasObject.owner),
        idOperation: "None"
      },
      eventsDigest: t.eventsDigest ?? null,
      dependencies: t.dependencies ?? [],
      lamportVersion: t.gasObject.reference.version,
      changedObjects: n,
      unchangedSharedObjects: i,
      auxiliaryDataDigest: null
    }
  };
}
const aL = kt.struct("Balance", {
  value: kt.u64()
}), cL = kt.struct("Coin", {
  id: kt.Address,
  balance: aL
}), lS = Symbol.for("@mysten/SuiClient");
function uL(e) {
  return typeof e == "object" && e !== null && e[lS] === !0;
}
class wa extends Wx {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param options configuration options for the API Client
   */
  constructor(t) {
    super({ network: t.network ?? "unknown" }), this.jsonRpc = this, this.transport = t.transport ?? new Lx({ url: t.url }), this.core = new sL({
      jsonRpcClient: this,
      mvr: t.mvr
    });
  }
  get [lS]() {
    return !0;
  }
  async getRpcApiVersion({ signal: t } = {}) {
    return (await this.transport.request({
      method: "rpc.discover",
      params: [],
      signal: t
    })).info.version;
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins({
    coinType: t,
    owner: r,
    cursor: n,
    limit: i,
    signal: s
  }) {
    if (!r || !Jn(Gt(r)))
      throw new Error("Invalid Sui address");
    return t && In(t) && (t = (await this.core.mvr.resolveType({
      type: t
    })).type), await this.transport.request({
      method: "suix_getCoins",
      params: [r, t, n, i],
      signal: s
    });
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(t) {
    if (!t.owner || !Jn(Gt(t.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getAllCoins",
      params: [t.owner, t.cursor, t.limit],
      signal: t.signal
    });
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance({ owner: t, coinType: r, signal: n }) {
    if (!t || !Jn(Gt(t)))
      throw new Error("Invalid Sui address");
    return r && In(r) && (r = (await this.core.mvr.resolveType({
      type: r
    })).type), await this.transport.request({
      method: "suix_getBalance",
      params: [t, r],
      signal: n
    });
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(t) {
    if (!t.owner || !Jn(Gt(t.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getAllBalances",
      params: [t.owner],
      signal: t.signal
    });
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata({ coinType: t, signal: r }) {
    return t && In(t) && (t = (await this.core.mvr.resolveType({
      type: t
    })).type), await this.transport.request({
      method: "suix_getCoinMetadata",
      params: [t],
      signal: r
    });
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply({ coinType: t, signal: r }) {
    return t && In(t) && (t = (await this.core.mvr.resolveType({
      type: t
    })).type), await this.transport.request({
      method: "suix_getTotalSupply",
      params: [t],
      signal: r
    });
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(t, r, { signal: n } = {}) {
    return await this.transport.request({ method: t, params: r, signal: n });
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes({
    package: t,
    module: r,
    function: n,
    signal: i
  }) {
    return t && An(t) && (t = (await this.core.mvr.resolvePackage({
      package: t
    })).package), await this.transport.request({
      method: "sui_getMoveFunctionArgTypes",
      params: [t, r, n],
      signal: i
    });
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage({
    package: t,
    signal: r
  }) {
    return t && An(t) && (t = (await this.core.mvr.resolvePackage({
      package: t
    })).package), await this.transport.request({
      method: "sui_getNormalizedMoveModulesByPackage",
      params: [t],
      signal: r
    });
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule({
    package: t,
    module: r,
    signal: n
  }) {
    return t && An(t) && (t = (await this.core.mvr.resolvePackage({
      package: t
    })).package), await this.transport.request({
      method: "sui_getNormalizedMoveModule",
      params: [t, r],
      signal: n
    });
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction({
    package: t,
    module: r,
    function: n,
    signal: i
  }) {
    return t && An(t) && (t = (await this.core.mvr.resolvePackage({
      package: t
    })).package), await this.transport.request({
      method: "sui_getNormalizedMoveFunction",
      params: [t, r, n],
      signal: i
    });
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct({
    package: t,
    module: r,
    struct: n,
    signal: i
  }) {
    return t && An(t) && (t = (await this.core.mvr.resolvePackage({
      package: t
    })).package), await this.transport.request({
      method: "sui_getNormalizedMoveStruct",
      params: [t, r, n],
      signal: i
    });
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(t) {
    if (!t.owner || !Jn(Gt(t.owner)))
      throw new Error("Invalid Sui address");
    const r = t.filter ? {
      ...t.filter
    } : void 0;
    return r && "MoveModule" in r && An(r.MoveModule.package) ? r.MoveModule = {
      module: r.MoveModule.module,
      package: (await this.core.mvr.resolvePackage({
        package: r.MoveModule.package
      })).package
    } : r && "StructType" in r && In(r.StructType) && (r.StructType = (await this.core.mvr.resolveType({
      type: r.StructType
    })).type), await this.transport.request({
      method: "suix_getOwnedObjects",
      params: [
        t.owner,
        {
          filter: r,
          options: t.options
        },
        t.cursor,
        t.limit
      ],
      signal: t.signal
    });
  }
  /**
   * Get details about an object
   */
  async getObject(t) {
    if (!t.id || !au(ai(t.id)))
      throw new Error("Invalid Sui Object id");
    return await this.transport.request({
      method: "sui_getObject",
      params: [t.id, t.options],
      signal: t.signal
    });
  }
  async tryGetPastObject(t) {
    return await this.transport.request({
      method: "sui_tryGetPastObject",
      params: [t.id, t.version, t.options],
      signal: t.signal
    });
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(t) {
    if (t.ids.forEach((n) => {
      if (!n || !au(ai(n)))
        throw new Error(`Invalid Sui Object id ${n}`);
    }), t.ids.length !== new Set(t.ids).size)
      throw new Error(`Duplicate object ids in batch call ${t.ids}`);
    return await this.transport.request({
      method: "sui_multiGetObjects",
      params: [t.ids, t.options],
      signal: t.signal
    });
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks({
    filter: t,
    options: r,
    cursor: n,
    limit: i,
    order: s,
    signal: o
  }) {
    return t && "MoveFunction" in t && An(t.MoveFunction.package) && (t = {
      ...t,
      MoveFunction: {
        package: (await this.core.mvr.resolvePackage({
          package: t.MoveFunction.package
        })).package
      }
    }), await this.transport.request({
      method: "suix_queryTransactionBlocks",
      params: [
        {
          filter: t,
          options: r
        },
        n,
        i,
        (s || "descending") === "descending"
      ],
      signal: o
    });
  }
  async getTransactionBlock(t) {
    if (!M0(t.digest))
      throw new Error("Invalid Transaction digest");
    return await this.transport.request({
      method: "sui_getTransactionBlock",
      params: [t.digest, t.options],
      signal: t.signal
    });
  }
  async multiGetTransactionBlocks(t) {
    if (t.digests.forEach((n) => {
      if (!M0(n))
        throw new Error(`Invalid Transaction digest ${n}`);
    }), t.digests.length !== new Set(t.digests).size)
      throw new Error(`Duplicate digests in batch call ${t.digests}`);
    return await this.transport.request({
      method: "sui_multiGetTransactionBlocks",
      params: [t.digests, t.options],
      signal: t.signal
    });
  }
  async executeTransactionBlock({
    transactionBlock: t,
    signature: r,
    options: n,
    requestType: i,
    signal: s
  }) {
    const o = await this.transport.request({
      method: "sui_executeTransactionBlock",
      params: [
        typeof t == "string" ? t : Wr(t),
        Array.isArray(r) ? r : [r],
        n
      ],
      signal: s
    });
    if (i === "WaitForLocalExecution")
      try {
        await this.waitForTransaction({
          digest: o.digest
        });
      } catch {
      }
    return o;
  }
  async signAndExecuteTransaction({
    transaction: t,
    signer: r,
    ...n
  }) {
    let i;
    t instanceof Uint8Array ? i = t : (t.setSenderIfNotSet(r.toSuiAddress()), i = await t.build({ client: this }));
    const { signature: s, bytes: o } = await r.signTransaction(i);
    return this.executeTransactionBlock({
      transactionBlock: o,
      signature: s,
      ...n
    });
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks({ signal: t } = {}) {
    const r = await this.transport.request({
      method: "sui_getTotalTransactionBlocks",
      params: [],
      signal: t
    });
    return BigInt(r);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice({ signal: t } = {}) {
    const r = await this.transport.request({
      method: "suix_getReferenceGasPrice",
      params: [],
      signal: t
    });
    return BigInt(r);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(t) {
    if (!t.owner || !Jn(Gt(t.owner)))
      throw new Error("Invalid Sui address");
    return await this.transport.request({
      method: "suix_getStakes",
      params: [t.owner],
      signal: t.signal
    });
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(t) {
    return t.stakedSuiIds.forEach((r) => {
      if (!r || !au(ai(r)))
        throw new Error(`Invalid Sui Stake id ${r}`);
    }), await this.transport.request({
      method: "suix_getStakesByIds",
      params: [t.stakedSuiIds],
      signal: t.signal
    });
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState({
    signal: t
  } = {}) {
    return await this.transport.request({
      method: "suix_getLatestSuiSystemState",
      params: [],
      signal: t
    });
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents({
    query: t,
    cursor: r,
    limit: n,
    order: i,
    signal: s
  }) {
    return t && "MoveEventType" in t && In(t.MoveEventType) && (t = {
      ...t,
      MoveEventType: (await this.core.mvr.resolveType({
        type: t.MoveEventType
      })).type
    }), t && "MoveEventModule" in t && An(t.MoveEventModule.package) && (t = {
      ...t,
      MoveEventModule: {
        module: t.MoveEventModule.module,
        package: (await this.core.mvr.resolvePackage({
          package: t.MoveEventModule.package
        })).package
      }
    }), "MoveModule" in t && An(t.MoveModule.package) && (t = {
      ...t,
      MoveModule: {
        module: t.MoveModule.module,
        package: (await this.core.mvr.resolvePackage({
          package: t.MoveModule.package
        })).package
      }
    }), await this.transport.request({
      method: "suix_queryEvents",
      params: [t, r, n, (i || "descending") === "descending"],
      signal: s
    });
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   *
   * @deprecated
   */
  async subscribeEvent(t) {
    return this.transport.subscribe({
      method: "suix_subscribeEvent",
      unsubscribe: "suix_unsubscribeEvent",
      params: [t.filter],
      onMessage: t.onMessage,
      signal: t.signal
    });
  }
  /**
   * @deprecated
   */
  async subscribeTransaction(t) {
    return this.transport.subscribe({
      method: "suix_subscribeTransaction",
      unsubscribe: "suix_unsubscribeTransaction",
      params: [t.filter],
      onMessage: t.onMessage,
      signal: t.signal
    });
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(t) {
    var n, i;
    let r;
    if (oS(t.transactionBlock))
      t.transactionBlock.setSenderIfNotSet(t.sender), r = Wr(
        await t.transactionBlock.build({
          client: this,
          onlyTransactionKind: !0
        })
      );
    else if (typeof t.transactionBlock == "string")
      r = t.transactionBlock;
    else if (t.transactionBlock instanceof Uint8Array)
      r = Wr(t.transactionBlock);
    else
      throw new Error("Unknown transaction block format.");
    return (n = t.signal) == null || n.throwIfAborted(), await this.transport.request({
      method: "sui_devInspectTransactionBlock",
      params: [t.sender, r, (i = t.gasPrice) == null ? void 0 : i.toString(), t.epoch],
      signal: t.signal
    });
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(t) {
    return await this.transport.request({
      method: "sui_dryRunTransactionBlock",
      params: [
        typeof t.transactionBlock == "string" ? t.transactionBlock : Wr(t.transactionBlock)
      ]
    });
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(t) {
    if (!t.parentId || !au(ai(t.parentId)))
      throw new Error("Invalid Sui Object id");
    return await this.transport.request({
      method: "suix_getDynamicFields",
      params: [t.parentId, t.cursor, t.limit],
      signal: t.signal
    });
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(t) {
    return await this.transport.request({
      method: "suix_getDynamicFieldObject",
      params: [t.parentId, t.name],
      signal: t.signal
    });
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber({
    signal: t
  } = {}) {
    const r = await this.transport.request({
      method: "sui_getLatestCheckpointSequenceNumber",
      params: [],
      signal: t
    });
    return String(r);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(t) {
    return await this.transport.request({
      method: "sui_getCheckpoint",
      params: [t.id],
      signal: t.signal
    });
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(t) {
    return await this.transport.request({
      method: "sui_getCheckpoints",
      params: [t.cursor, t == null ? void 0 : t.limit, t.descendingOrder],
      signal: t.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(t) {
    return await this.transport.request({
      method: "suix_getCommitteeInfo",
      params: [t == null ? void 0 : t.epoch],
      signal: t == null ? void 0 : t.signal
    });
  }
  async getNetworkMetrics({ signal: t } = {}) {
    return await this.transport.request({
      method: "suix_getNetworkMetrics",
      params: [],
      signal: t
    });
  }
  async getAddressMetrics({ signal: t } = {}) {
    return await this.transport.request({
      method: "suix_getLatestAddressMetrics",
      params: [],
      signal: t
    });
  }
  async getEpochMetrics(t) {
    return await this.transport.request({
      method: "suix_getEpochMetrics",
      params: [t == null ? void 0 : t.cursor, t == null ? void 0 : t.limit, t == null ? void 0 : t.descendingOrder],
      signal: t == null ? void 0 : t.signal
    });
  }
  async getAllEpochAddressMetrics(t) {
    return await this.transport.request({
      method: "suix_getAllEpochAddressMetrics",
      params: [t == null ? void 0 : t.descendingOrder],
      signal: t == null ? void 0 : t.signal
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(t) {
    return await this.transport.request({
      method: "suix_getEpochs",
      params: [t == null ? void 0 : t.cursor, t == null ? void 0 : t.limit, t == null ? void 0 : t.descendingOrder],
      signal: t == null ? void 0 : t.signal
    });
  }
  /**
   * Returns list of top move calls by usage
   */
  async getMoveCallMetrics({ signal: t } = {}) {
    return await this.transport.request({
      method: "suix_getMoveCallMetrics",
      params: [],
      signal: t
    });
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch({ signal: t } = {}) {
    return await this.transport.request({
      method: "suix_getCurrentEpoch",
      params: [],
      signal: t
    });
  }
  /**
   * Return the Validators APYs
   */
  async getValidatorsApy({ signal: t } = {}) {
    return await this.transport.request({
      method: "suix_getValidatorsApy",
      params: [],
      signal: t
    });
  }
  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.
  async getChainIdentifier({ signal: t } = {}) {
    const r = await this.getCheckpoint({ id: "0", signal: t }), n = Fs(r.digest);
    return Vs(n.slice(0, 4));
  }
  async resolveNameServiceAddress(t) {
    return await this.transport.request({
      method: "suix_resolveNameServiceAddress",
      params: [t.name],
      signal: t.signal
    });
  }
  async resolveNameServiceNames({
    format: t = "dot",
    ...r
  }) {
    const { nextCursor: n, hasNextPage: i, data: s } = await this.transport.request({
      method: "suix_resolveNameServiceNames",
      params: [r.address, r.cursor, r.limit],
      signal: r.signal
    });
    return {
      hasNextPage: i,
      nextCursor: n,
      data: s.map((o) => ex(o, t))
    };
  }
  async getProtocolConfig(t) {
    return await this.transport.request({
      method: "sui_getProtocolConfig",
      params: [t == null ? void 0 : t.version],
      signal: t == null ? void 0 : t.signal
    });
  }
  async verifyZkLoginSignature(t) {
    return await this.transport.request({
      method: "sui_verifyZkLoginSignature",
      params: [t.bytes, t.signature, t.intentScope, t.author],
      signal: t.signal
    });
  }
  /**
   * Wait for a transaction block result to be available over the API.
   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to
   * be available via the API.
   * This currently polls the `getTransactionBlock` API to check for the transaction.
   */
  async waitForTransaction({
    signal: t,
    timeout: r = 60 * 1e3,
    pollInterval: n = 2 * 1e3,
    ...i
  }) {
    const s = AbortSignal.timeout(r), o = new Promise((a, c) => {
      s.addEventListener("abort", () => c(s.reason));
    });
    for (o.catch(() => {
    }); !s.aborted; ) {
      t == null || t.throwIfAborted();
      try {
        return await this.getTransactionBlock(i);
      } catch {
        await Promise.race([
          new Promise((c) => setTimeout(c, n)),
          o
        ]);
      }
    }
    throw s.throwIfAborted(), new Error("Unexpected error while waiting for transaction block.");
  }
  experimental_asClientExtension() {
    return {
      name: "jsonRPC",
      register: () => this
    };
  }
}
const lL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonRpcError: zg,
  SuiClient: wa,
  SuiHTTPStatusError: kx,
  SuiHTTPTransport: Lx,
  SuiHTTPTransportError: Vg,
  getFullnodeUrl: Bx,
  isSuiClient: uL
}, Symbol.toStringTag, { value: "Module" })), fL = /* @__PURE__ */ Ec(lL);
var fS = {}, jd = {}, Jg = {}, Rd = {}, Zg = {}, Pd = {};
Object.defineProperty(Pd, "__esModule", { value: !0 });
Pd.Convert = void 0;
class dL {
  static toPriceFeed(t) {
    return np(t, ks("PriceFeed"));
  }
  static priceFeedToJson(t) {
    return ip(t, ks("PriceFeed"));
  }
  static toPrice(t) {
    return np(t, ks("Price"));
  }
  static priceToJson(t) {
    return ip(t, ks("Price"));
  }
  static toPriceFeedMetadata(t) {
    return np(t, ks("PriceFeedMetadata"));
  }
  static priceFeedMetadataToJson(t) {
    return ip(t, ks("PriceFeedMetadata"));
  }
}
Pd.Convert = dL;
function Es(e, t, r = "") {
  throw Error(r ? `Invalid value for key "${r}". Expected type ${JSON.stringify(e)} but got ${JSON.stringify(t)}` : `Invalid value ${JSON.stringify(t)} for type ${JSON.stringify(e)}`);
}
function hL(e) {
  if (e.jsonToJS === void 0) {
    const t = {};
    e.props.forEach((r) => t[r.json] = { key: r.js, typ: r.typ }), e.jsonToJS = t;
  }
  return e.jsonToJS;
}
function pL(e) {
  if (e.jsToJSON === void 0) {
    const t = {};
    e.props.forEach((r) => t[r.js] = { key: r.json, typ: r.typ }), e.jsToJSON = t;
  }
  return e.jsToJSON;
}
function tc(e, t, r, n = "") {
  function i(l, f) {
    return typeof l == typeof f ? f : Es(l, f, n);
  }
  function s(l, f) {
    const h = l.length;
    for (let v = 0; v < h; v++) {
      const b = l[v];
      try {
        return tc(f, b, r);
      } catch {
      }
    }
    return Es(l, f);
  }
  function o(l, f) {
    return l.indexOf(f) !== -1 ? f : Es(l, f);
  }
  function a(l, f) {
    return Array.isArray(f) ? f.map((h) => tc(h, l, r)) : Es("array", f);
  }
  function c(l) {
    if (l === null)
      return null;
    const f = new Date(l);
    return isNaN(f.valueOf()) ? Es("Date", l) : f;
  }
  function u(l, f, h) {
    if (h === null || typeof h != "object" || Array.isArray(h))
      return Es("object", h);
    const v = {};
    return Object.getOwnPropertyNames(l).forEach((b) => {
      const y = l[b], S = Object.prototype.hasOwnProperty.call(h, b) ? h[b] : void 0;
      v[y.key] = tc(S, y.typ, r, y.key);
    }), Object.getOwnPropertyNames(h).forEach((b) => {
      Object.prototype.hasOwnProperty.call(l, b) || (v[b] = tc(h[b], f, r, b));
    }), v;
  }
  if (t === "any")
    return e;
  if (t === null)
    return e === null ? e : Es(t, e);
  if (t === !1)
    return Es(t, e);
  for (; typeof t == "object" && t.ref !== void 0; )
    t = mL[t.ref];
  return Array.isArray(t) ? o(t, e) : typeof t == "object" ? t.hasOwnProperty("unionMembers") ? s(t.unionMembers, e) : t.hasOwnProperty("arrayItems") ? a(t.arrayItems, e) : t.hasOwnProperty("props") ? u(r(t), t.additional, e) : Es(t, e) : t === Date && typeof e != "number" ? c(e) : i(t, e);
}
function np(e, t) {
  return tc(e, t, hL);
}
function ip(e, t) {
  return tc(e, t, pL);
}
function Ho(...e) {
  return { unionMembers: e };
}
function sp(e, t) {
  return { props: e, additional: t };
}
function ks(e) {
  return { ref: e };
}
const mL = {
  PriceFeed: sp([
    { json: "ema_price", js: "ema_price", typ: ks("Price") },
    { json: "id", js: "id", typ: "" },
    {
      json: "metadata",
      js: "metadata",
      typ: Ho(void 0, ks("PriceFeedMetadata"))
    },
    { json: "price", js: "price", typ: ks("Price") },
    { json: "vaa", js: "vaa", typ: Ho(void 0, "") }
  ], "any"),
  Price: sp([
    { json: "conf", js: "conf", typ: "" },
    { json: "expo", js: "expo", typ: 0 },
    { json: "price", js: "price", typ: "" },
    { json: "publish_time", js: "publish_time", typ: 0 }
  ], "any"),
  PriceFeedMetadata: sp([
    {
      json: "attestation_time",
      js: "attestation_time",
      typ: Ho(void 0, 0)
    },
    { json: "emitter_chain", js: "emitter_chain", typ: 0 },
    {
      json: "prev_publish_time",
      js: "prev_publish_time",
      typ: Ho(void 0, 0)
    },
    {
      json: "price_service_receive_time",
      js: "price_service_receive_time",
      typ: Ho(void 0, 0)
    },
    { json: "sequence_number", js: "sequence_number", typ: Ho(void 0, 0) },
    { json: "slot", js: "slot", typ: Ho(void 0, 0) }
  ], "any")
};
var op = {}, av;
function Nd() {
  return av || (av = 1, function(e) {
    Object.defineProperties(e, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
    var t = {}, r = {};
    r.byteLength = l, r.toByteArray = h, r.fromByteArray = y;
    for (var n = [], i = [], s = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = o.length; a < c; ++a)
      n[a] = o[a], i[o.charCodeAt(a)] = a;
    i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
    function u(O) {
      var I = O.length;
      if (I % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var U = O.indexOf("=");
      U === -1 && (U = I);
      var D = U === I ? 0 : 4 - U % 4;
      return [U, D];
    }
    function l(O) {
      var I = u(O), U = I[0], D = I[1];
      return (U + D) * 3 / 4 - D;
    }
    function f(O, I, U) {
      return (I + U) * 3 / 4 - U;
    }
    function h(O) {
      var I, U = u(O), D = U[0], H = U[1], z = new s(f(O, D, H)), ne = 0, le = H > 0 ? D - 4 : D, te;
      for (te = 0; te < le; te += 4)
        I = i[O.charCodeAt(te)] << 18 | i[O.charCodeAt(te + 1)] << 12 | i[O.charCodeAt(te + 2)] << 6 | i[O.charCodeAt(te + 3)], z[ne++] = I >> 16 & 255, z[ne++] = I >> 8 & 255, z[ne++] = I & 255;
      return H === 2 && (I = i[O.charCodeAt(te)] << 2 | i[O.charCodeAt(te + 1)] >> 4, z[ne++] = I & 255), H === 1 && (I = i[O.charCodeAt(te)] << 10 | i[O.charCodeAt(te + 1)] << 4 | i[O.charCodeAt(te + 2)] >> 2, z[ne++] = I >> 8 & 255, z[ne++] = I & 255), z;
    }
    function v(O) {
      return n[O >> 18 & 63] + n[O >> 12 & 63] + n[O >> 6 & 63] + n[O & 63];
    }
    function b(O, I, U) {
      for (var D, H = [], z = I; z < U; z += 3)
        D = (O[z] << 16 & 16711680) + (O[z + 1] << 8 & 65280) + (O[z + 2] & 255), H.push(v(D));
      return H.join("");
    }
    function y(O) {
      for (var I, U = O.length, D = U % 3, H = [], z = 16383, ne = 0, le = U - D; ne < le; ne += z)
        H.push(b(O, ne, ne + z > le ? le : ne + z));
      return D === 1 ? (I = O[U - 1], H.push(
        n[I >> 2] + n[I << 4 & 63] + "=="
      )) : D === 2 && (I = (O[U - 2] << 8) + O[U - 1], H.push(
        n[I >> 10] + n[I >> 4 & 63] + n[I << 2 & 63] + "="
      )), H.join("");
    }
    var S = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    S.read = function(O, I, U, D, H) {
      var z, ne, le = H * 8 - D - 1, te = (1 << le) - 1, ce = te >> 1, V = -7, L = U ? H - 1 : 0, p = U ? -1 : 1, d = O[I + L];
      for (L += p, z = d & (1 << -V) - 1, d >>= -V, V += le; V > 0; z = z * 256 + O[I + L], L += p, V -= 8)
        ;
      for (ne = z & (1 << -V) - 1, z >>= -V, V += D; V > 0; ne = ne * 256 + O[I + L], L += p, V -= 8)
        ;
      if (z === 0)
        z = 1 - ce;
      else {
        if (z === te)
          return ne ? NaN : (d ? -1 : 1) * (1 / 0);
        ne = ne + Math.pow(2, D), z = z - ce;
      }
      return (d ? -1 : 1) * ne * Math.pow(2, z - D);
    }, S.write = function(O, I, U, D, H, z) {
      var ne, le, te, ce = z * 8 - H - 1, V = (1 << ce) - 1, L = V >> 1, p = H === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = D ? 0 : z - 1, m = D ? 1 : -1, x = I < 0 || I === 0 && 1 / I < 0 ? 1 : 0;
      for (I = Math.abs(I), isNaN(I) || I === 1 / 0 ? (le = isNaN(I) ? 1 : 0, ne = V) : (ne = Math.floor(Math.log(I) / Math.LN2), I * (te = Math.pow(2, -ne)) < 1 && (ne--, te *= 2), ne + L >= 1 ? I += p / te : I += p * Math.pow(2, 1 - L), I * te >= 2 && (ne++, te /= 2), ne + L >= V ? (le = 0, ne = V) : ne + L >= 1 ? (le = (I * te - 1) * Math.pow(2, H), ne = ne + L) : (le = I * Math.pow(2, L - 1) * Math.pow(2, H), ne = 0)); H >= 8; O[U + d] = le & 255, d += m, le /= 256, H -= 8)
        ;
      for (ne = ne << H | le, ce += H; ce > 0; O[U + d] = ne & 255, d += m, ne /= 256, ce -= 8)
        ;
      O[U + d - m] |= x * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(O) {
      const I = r, U = S, D = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
      O.Buffer = V, O.SlowBuffer = w, O.INSPECT_MAX_BYTES = 50;
      const H = 2147483647;
      O.kMaxLength = H;
      const { Uint8Array: z, ArrayBuffer: ne, SharedArrayBuffer: le } = globalThis;
      V.TYPED_ARRAY_SUPPORT = te(), !V.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
      function te() {
        try {
          const $ = new z(1), T = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(T, z.prototype), Object.setPrototypeOf($, T), $.foo() === 42;
        } catch {
          return !1;
        }
      }
      Object.defineProperty(V.prototype, "parent", {
        enumerable: !0,
        get: function() {
          if (V.isBuffer(this))
            return this.buffer;
        }
      }), Object.defineProperty(V.prototype, "offset", {
        enumerable: !0,
        get: function() {
          if (V.isBuffer(this))
            return this.byteOffset;
        }
      });
      function ce($) {
        if ($ > H)
          throw new RangeError('The value "' + $ + '" is invalid for option "size"');
        const T = new z($);
        return Object.setPrototypeOf(T, V.prototype), T;
      }
      function V($, T, M) {
        if (typeof $ == "number") {
          if (typeof T == "string")
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return m($);
        }
        return L($, T, M);
      }
      V.poolSize = 8192;
      function L($, T, M) {
        if (typeof $ == "string")
          return x($, T);
        if (ne.isView($))
          return A($);
        if ($ == null)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
          );
        if (It($, ne) || $ && It($.buffer, ne) || typeof le < "u" && (It($, le) || $ && It($.buffer, le)))
          return j($, T, M);
        if (typeof $ == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const K = $.valueOf && $.valueOf();
        if (K != null && K !== $)
          return V.from(K, T, M);
        const ae = k($);
        if (ae)
          return ae;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] == "function")
          return V.from($[Symbol.toPrimitive]("string"), T, M);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
        );
      }
      V.from = function($, T, M) {
        return L($, T, M);
      }, Object.setPrototypeOf(V.prototype, z.prototype), Object.setPrototypeOf(V, z);
      function p($) {
        if (typeof $ != "number")
          throw new TypeError('"size" argument must be of type number');
        if ($ < 0)
          throw new RangeError('The value "' + $ + '" is invalid for option "size"');
      }
      function d($, T, M) {
        return p($), $ <= 0 ? ce($) : T !== void 0 ? typeof M == "string" ? ce($).fill(T, M) : ce($).fill(T) : ce($);
      }
      V.alloc = function($, T, M) {
        return d($, T, M);
      };
      function m($) {
        return p($), ce($ < 0 ? 0 : g($) | 0);
      }
      V.allocUnsafe = function($) {
        return m($);
      }, V.allocUnsafeSlow = function($) {
        return m($);
      };
      function x($, T) {
        if ((typeof T != "string" || T === "") && (T = "utf8"), !V.isEncoding(T))
          throw new TypeError("Unknown encoding: " + T);
        const M = P($, T) | 0;
        let K = ce(M);
        const ae = K.write($, T);
        return ae !== M && (K = K.slice(0, ae)), K;
      }
      function E($) {
        const T = $.length < 0 ? 0 : g($.length) | 0, M = ce(T);
        for (let K = 0; K < T; K += 1)
          M[K] = $[K] & 255;
        return M;
      }
      function A($) {
        if (It($, z)) {
          const T = new z($);
          return j(T.buffer, T.byteOffset, T.byteLength);
        }
        return E($);
      }
      function j($, T, M) {
        if (T < 0 || $.byteLength < T)
          throw new RangeError('"offset" is outside of buffer bounds');
        if ($.byteLength < T + (M || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let K;
        return T === void 0 && M === void 0 ? K = new z($) : M === void 0 ? K = new z($, T) : K = new z($, T, M), Object.setPrototypeOf(K, V.prototype), K;
      }
      function k($) {
        if (V.isBuffer($)) {
          const T = g($.length) | 0, M = ce(T);
          return M.length === 0 || $.copy(M, 0, 0, T), M;
        }
        if ($.length !== void 0)
          return typeof $.length != "number" || Vt($.length) ? ce(0) : E($);
        if ($.type === "Buffer" && Array.isArray($.data))
          return E($.data);
      }
      function g($) {
        if ($ >= H)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + H.toString(16) + " bytes");
        return $ | 0;
      }
      function w($) {
        return +$ != $ && ($ = 0), V.alloc(+$);
      }
      V.isBuffer = function(T) {
        return T != null && T._isBuffer === !0 && T !== V.prototype;
      }, V.compare = function(T, M) {
        if (It(T, z) && (T = V.from(T, T.offset, T.byteLength)), It(M, z) && (M = V.from(M, M.offset, M.byteLength)), !V.isBuffer(T) || !V.isBuffer(M))
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (T === M)
          return 0;
        let K = T.length, ae = M.length;
        for (let ve = 0, we = Math.min(K, ae); ve < we; ++ve)
          if (T[ve] !== M[ve]) {
            K = T[ve], ae = M[ve];
            break;
          }
        return K < ae ? -1 : ae < K ? 1 : 0;
      }, V.isEncoding = function(T) {
        switch (String(T).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, V.concat = function(T, M) {
        if (!Array.isArray(T))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (T.length === 0)
          return V.alloc(0);
        let K;
        if (M === void 0)
          for (M = 0, K = 0; K < T.length; ++K)
            M += T[K].length;
        const ae = V.allocUnsafe(M);
        let ve = 0;
        for (K = 0; K < T.length; ++K) {
          let we = T[K];
          if (It(we, z))
            ve + we.length > ae.length ? (V.isBuffer(we) || (we = V.from(we)), we.copy(ae, ve)) : z.prototype.set.call(
              ae,
              we,
              ve
            );
          else if (V.isBuffer(we))
            we.copy(ae, ve);
          else
            throw new TypeError('"list" argument must be an Array of Buffers');
          ve += we.length;
        }
        return ae;
      };
      function P($, T) {
        if (V.isBuffer($))
          return $.length;
        if (ne.isView($) || It($, ne))
          return $.byteLength;
        if (typeof $ != "string")
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $
          );
        const M = $.length, K = arguments.length > 2 && arguments[2] === !0;
        if (!K && M === 0)
          return 0;
        let ae = !1;
        for (; ; )
          switch (T) {
            case "ascii":
            case "latin1":
            case "binary":
              return M;
            case "utf8":
            case "utf-8":
              return yt($).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return M * 2;
            case "hex":
              return M >>> 1;
            case "base64":
              return Dt($).length;
            default:
              if (ae)
                return K ? -1 : yt($).length;
              T = ("" + T).toLowerCase(), ae = !0;
          }
      }
      V.byteLength = P;
      function ue($, T, M) {
        let K = !1;
        if ((T === void 0 || T < 0) && (T = 0), T > this.length || ((M === void 0 || M > this.length) && (M = this.length), M <= 0) || (M >>>= 0, T >>>= 0, M <= T))
          return "";
        for ($ || ($ = "utf8"); ; )
          switch ($) {
            case "hex":
              return se(this, T, M);
            case "utf8":
            case "utf-8":
              return q(this, T, M);
            case "ascii":
              return X(this, T, M);
            case "latin1":
            case "binary":
              return B(this, T, M);
            case "base64":
              return Z(this, T, M);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return me(this, T, M);
            default:
              if (K)
                throw new TypeError("Unknown encoding: " + $);
              $ = ($ + "").toLowerCase(), K = !0;
          }
      }
      V.prototype._isBuffer = !0;
      function ie($, T, M) {
        const K = $[T];
        $[T] = $[M], $[M] = K;
      }
      V.prototype.swap16 = function() {
        const T = this.length;
        if (T % 2 !== 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let M = 0; M < T; M += 2)
          ie(this, M, M + 1);
        return this;
      }, V.prototype.swap32 = function() {
        const T = this.length;
        if (T % 4 !== 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let M = 0; M < T; M += 4)
          ie(this, M, M + 3), ie(this, M + 1, M + 2);
        return this;
      }, V.prototype.swap64 = function() {
        const T = this.length;
        if (T % 8 !== 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let M = 0; M < T; M += 8)
          ie(this, M, M + 7), ie(this, M + 1, M + 6), ie(this, M + 2, M + 5), ie(this, M + 3, M + 4);
        return this;
      }, V.prototype.toString = function() {
        const T = this.length;
        return T === 0 ? "" : arguments.length === 0 ? q(this, 0, T) : ue.apply(this, arguments);
      }, V.prototype.toLocaleString = V.prototype.toString, V.prototype.equals = function(T) {
        if (!V.isBuffer(T))
          throw new TypeError("Argument must be a Buffer");
        return this === T ? !0 : V.compare(this, T) === 0;
      }, V.prototype.inspect = function() {
        let T = "";
        const M = O.INSPECT_MAX_BYTES;
        return T = this.toString("hex", 0, M).replace(/(.{2})/g, "$1 ").trim(), this.length > M && (T += " ... "), "<Buffer " + T + ">";
      }, D && (V.prototype[D] = V.prototype.inspect), V.prototype.compare = function(T, M, K, ae, ve) {
        if (It(T, z) && (T = V.from(T, T.offset, T.byteLength)), !V.isBuffer(T))
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof T
          );
        if (M === void 0 && (M = 0), K === void 0 && (K = T ? T.length : 0), ae === void 0 && (ae = 0), ve === void 0 && (ve = this.length), M < 0 || K > T.length || ae < 0 || ve > this.length)
          throw new RangeError("out of range index");
        if (ae >= ve && M >= K)
          return 0;
        if (ae >= ve)
          return -1;
        if (M >= K)
          return 1;
        if (M >>>= 0, K >>>= 0, ae >>>= 0, ve >>>= 0, this === T)
          return 0;
        let we = ve - ae, nt = K - M;
        const _t = Math.min(we, nt), tt = this.slice(ae, ve), Q = T.slice(M, K);
        for (let Se = 0; Se < _t; ++Se)
          if (tt[Se] !== Q[Se]) {
            we = tt[Se], nt = Q[Se];
            break;
          }
        return we < nt ? -1 : nt < we ? 1 : 0;
      };
      function fe($, T, M, K, ae) {
        if ($.length === 0)
          return -1;
        if (typeof M == "string" ? (K = M, M = 0) : M > 2147483647 ? M = 2147483647 : M < -2147483648 && (M = -2147483648), M = +M, Vt(M) && (M = ae ? 0 : $.length - 1), M < 0 && (M = $.length + M), M >= $.length) {
          if (ae)
            return -1;
          M = $.length - 1;
        } else if (M < 0)
          if (ae)
            M = 0;
          else
            return -1;
        if (typeof T == "string" && (T = V.from(T, K)), V.isBuffer(T))
          return T.length === 0 ? -1 : ye($, T, M, K, ae);
        if (typeof T == "number")
          return T = T & 255, typeof z.prototype.indexOf == "function" ? ae ? z.prototype.indexOf.call($, T, M) : z.prototype.lastIndexOf.call($, T, M) : ye($, [T], M, K, ae);
        throw new TypeError("val must be string, number or Buffer");
      }
      function ye($, T, M, K, ae) {
        let ve = 1, we = $.length, nt = T.length;
        if (K !== void 0 && (K = String(K).toLowerCase(), K === "ucs2" || K === "ucs-2" || K === "utf16le" || K === "utf-16le")) {
          if ($.length < 2 || T.length < 2)
            return -1;
          ve = 2, we /= 2, nt /= 2, M /= 2;
        }
        function _t(Q, Se) {
          return ve === 1 ? Q[Se] : Q.readUInt16BE(Se * ve);
        }
        let tt;
        if (ae) {
          let Q = -1;
          for (tt = M; tt < we; tt++)
            if (_t($, tt) === _t(T, Q === -1 ? 0 : tt - Q)) {
              if (Q === -1 && (Q = tt), tt - Q + 1 === nt)
                return Q * ve;
            } else
              Q !== -1 && (tt -= tt - Q), Q = -1;
        } else
          for (M + nt > we && (M = we - nt), tt = M; tt >= 0; tt--) {
            let Q = !0;
            for (let Se = 0; Se < nt; Se++)
              if (_t($, tt + Se) !== _t(T, Se)) {
                Q = !1;
                break;
              }
            if (Q)
              return tt;
          }
        return -1;
      }
      V.prototype.includes = function(T, M, K) {
        return this.indexOf(T, M, K) !== -1;
      }, V.prototype.indexOf = function(T, M, K) {
        return fe(this, T, M, K, !0);
      }, V.prototype.lastIndexOf = function(T, M, K) {
        return fe(this, T, M, K, !1);
      };
      function Te($, T, M, K) {
        M = Number(M) || 0;
        const ae = $.length - M;
        K ? (K = Number(K), K > ae && (K = ae)) : K = ae;
        const ve = T.length;
        K > ve / 2 && (K = ve / 2);
        let we;
        for (we = 0; we < K; ++we) {
          const nt = parseInt(T.substr(we * 2, 2), 16);
          if (Vt(nt))
            return we;
          $[M + we] = nt;
        }
        return we;
      }
      function N($, T, M, K) {
        return pt(yt(T, $.length - M), $, M, K);
      }
      function F($, T, M, K) {
        return pt(it(T), $, M, K);
      }
      function G($, T, M, K) {
        return pt(Dt(T), $, M, K);
      }
      function ee($, T, M, K) {
        return pt(vt(T, $.length - M), $, M, K);
      }
      V.prototype.write = function(T, M, K, ae) {
        if (M === void 0)
          ae = "utf8", K = this.length, M = 0;
        else if (K === void 0 && typeof M == "string")
          ae = M, K = this.length, M = 0;
        else if (isFinite(M))
          M = M >>> 0, isFinite(K) ? (K = K >>> 0, ae === void 0 && (ae = "utf8")) : (ae = K, K = void 0);
        else
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        const ve = this.length - M;
        if ((K === void 0 || K > ve) && (K = ve), T.length > 0 && (K < 0 || M < 0) || M > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        ae || (ae = "utf8");
        let we = !1;
        for (; ; )
          switch (ae) {
            case "hex":
              return Te(this, T, M, K);
            case "utf8":
            case "utf-8":
              return N(this, T, M, K);
            case "ascii":
            case "latin1":
            case "binary":
              return F(this, T, M, K);
            case "base64":
              return G(this, T, M, K);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ee(this, T, M, K);
            default:
              if (we)
                throw new TypeError("Unknown encoding: " + ae);
              ae = ("" + ae).toLowerCase(), we = !0;
          }
      }, V.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function Z($, T, M) {
        return T === 0 && M === $.length ? I.fromByteArray($) : I.fromByteArray($.slice(T, M));
      }
      function q($, T, M) {
        M = Math.min($.length, M);
        const K = [];
        let ae = T;
        for (; ae < M; ) {
          const ve = $[ae];
          let we = null, nt = ve > 239 ? 4 : ve > 223 ? 3 : ve > 191 ? 2 : 1;
          if (ae + nt <= M) {
            let _t, tt, Q, Se;
            switch (nt) {
              case 1:
                ve < 128 && (we = ve);
                break;
              case 2:
                _t = $[ae + 1], (_t & 192) === 128 && (Se = (ve & 31) << 6 | _t & 63, Se > 127 && (we = Se));
                break;
              case 3:
                _t = $[ae + 1], tt = $[ae + 2], (_t & 192) === 128 && (tt & 192) === 128 && (Se = (ve & 15) << 12 | (_t & 63) << 6 | tt & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (we = Se));
                break;
              case 4:
                _t = $[ae + 1], tt = $[ae + 2], Q = $[ae + 3], (_t & 192) === 128 && (tt & 192) === 128 && (Q & 192) === 128 && (Se = (ve & 15) << 18 | (_t & 63) << 12 | (tt & 63) << 6 | Q & 63, Se > 65535 && Se < 1114112 && (we = Se));
            }
          }
          we === null ? (we = 65533, nt = 1) : we > 65535 && (we -= 65536, K.push(we >>> 10 & 1023 | 55296), we = 56320 | we & 1023), K.push(we), ae += nt;
        }
        return Y(K);
      }
      const he = 4096;
      function Y($) {
        const T = $.length;
        if (T <= he)
          return String.fromCharCode.apply(String, $);
        let M = "", K = 0;
        for (; K < T; )
          M += String.fromCharCode.apply(
            String,
            $.slice(K, K += he)
          );
        return M;
      }
      function X($, T, M) {
        let K = "";
        M = Math.min($.length, M);
        for (let ae = T; ae < M; ++ae)
          K += String.fromCharCode($[ae] & 127);
        return K;
      }
      function B($, T, M) {
        let K = "";
        M = Math.min($.length, M);
        for (let ae = T; ae < M; ++ae)
          K += String.fromCharCode($[ae]);
        return K;
      }
      function se($, T, M) {
        const K = $.length;
        (!T || T < 0) && (T = 0), (!M || M < 0 || M > K) && (M = K);
        let ae = "";
        for (let ve = T; ve < M; ++ve)
          ae += Ke[$[ve]];
        return ae;
      }
      function me($, T, M) {
        const K = $.slice(T, M);
        let ae = "";
        for (let ve = 0; ve < K.length - 1; ve += 2)
          ae += String.fromCharCode(K[ve] + K[ve + 1] * 256);
        return ae;
      }
      V.prototype.slice = function(T, M) {
        const K = this.length;
        T = ~~T, M = M === void 0 ? K : ~~M, T < 0 ? (T += K, T < 0 && (T = 0)) : T > K && (T = K), M < 0 ? (M += K, M < 0 && (M = 0)) : M > K && (M = K), M < T && (M = T);
        const ae = this.subarray(T, M);
        return Object.setPrototypeOf(ae, V.prototype), ae;
      };
      function de($, T, M) {
        if ($ % 1 !== 0 || $ < 0)
          throw new RangeError("offset is not uint");
        if ($ + T > M)
          throw new RangeError("Trying to access beyond buffer length");
      }
      V.prototype.readUintLE = V.prototype.readUIntLE = function(T, M, K) {
        T = T >>> 0, M = M >>> 0, K || de(T, M, this.length);
        let ae = this[T], ve = 1, we = 0;
        for (; ++we < M && (ve *= 256); )
          ae += this[T + we] * ve;
        return ae;
      }, V.prototype.readUintBE = V.prototype.readUIntBE = function(T, M, K) {
        T = T >>> 0, M = M >>> 0, K || de(T, M, this.length);
        let ae = this[T + --M], ve = 1;
        for (; M > 0 && (ve *= 256); )
          ae += this[T + --M] * ve;
        return ae;
      }, V.prototype.readUint8 = V.prototype.readUInt8 = function(T, M) {
        return T = T >>> 0, M || de(T, 1, this.length), this[T];
      }, V.prototype.readUint16LE = V.prototype.readUInt16LE = function(T, M) {
        return T = T >>> 0, M || de(T, 2, this.length), this[T] | this[T + 1] << 8;
      }, V.prototype.readUint16BE = V.prototype.readUInt16BE = function(T, M) {
        return T = T >>> 0, M || de(T, 2, this.length), this[T] << 8 | this[T + 1];
      }, V.prototype.readUint32LE = V.prototype.readUInt32LE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), (this[T] | this[T + 1] << 8 | this[T + 2] << 16) + this[T + 3] * 16777216;
      }, V.prototype.readUint32BE = V.prototype.readUInt32BE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), this[T] * 16777216 + (this[T + 1] << 16 | this[T + 2] << 8 | this[T + 3]);
      }, V.prototype.readBigUInt64LE = Rt(function(T) {
        T = T >>> 0, ht(T, "offset");
        const M = this[T], K = this[T + 7];
        (M === void 0 || K === void 0) && ct(T, this.length - 8);
        const ae = M + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + this[++T] * 2 ** 24, ve = this[++T] + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + K * 2 ** 24;
        return BigInt(ae) + (BigInt(ve) << BigInt(32));
      }), V.prototype.readBigUInt64BE = Rt(function(T) {
        T = T >>> 0, ht(T, "offset");
        const M = this[T], K = this[T + 7];
        (M === void 0 || K === void 0) && ct(T, this.length - 8);
        const ae = M * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + this[++T], ve = this[++T] * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + K;
        return (BigInt(ae) << BigInt(32)) + BigInt(ve);
      }), V.prototype.readIntLE = function(T, M, K) {
        T = T >>> 0, M = M >>> 0, K || de(T, M, this.length);
        let ae = this[T], ve = 1, we = 0;
        for (; ++we < M && (ve *= 256); )
          ae += this[T + we] * ve;
        return ve *= 128, ae >= ve && (ae -= Math.pow(2, 8 * M)), ae;
      }, V.prototype.readIntBE = function(T, M, K) {
        T = T >>> 0, M = M >>> 0, K || de(T, M, this.length);
        let ae = M, ve = 1, we = this[T + --ae];
        for (; ae > 0 && (ve *= 256); )
          we += this[T + --ae] * ve;
        return ve *= 128, we >= ve && (we -= Math.pow(2, 8 * M)), we;
      }, V.prototype.readInt8 = function(T, M) {
        return T = T >>> 0, M || de(T, 1, this.length), this[T] & 128 ? (255 - this[T] + 1) * -1 : this[T];
      }, V.prototype.readInt16LE = function(T, M) {
        T = T >>> 0, M || de(T, 2, this.length);
        const K = this[T] | this[T + 1] << 8;
        return K & 32768 ? K | 4294901760 : K;
      }, V.prototype.readInt16BE = function(T, M) {
        T = T >>> 0, M || de(T, 2, this.length);
        const K = this[T + 1] | this[T] << 8;
        return K & 32768 ? K | 4294901760 : K;
      }, V.prototype.readInt32LE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), this[T] | this[T + 1] << 8 | this[T + 2] << 16 | this[T + 3] << 24;
      }, V.prototype.readInt32BE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), this[T] << 24 | this[T + 1] << 16 | this[T + 2] << 8 | this[T + 3];
      }, V.prototype.readBigInt64LE = Rt(function(T) {
        T = T >>> 0, ht(T, "offset");
        const M = this[T], K = this[T + 7];
        (M === void 0 || K === void 0) && ct(T, this.length - 8);
        const ae = this[T + 4] + this[T + 5] * 2 ** 8 + this[T + 6] * 2 ** 16 + (K << 24);
        return (BigInt(ae) << BigInt(32)) + BigInt(M + this[++T] * 2 ** 8 + this[++T] * 2 ** 16 + this[++T] * 2 ** 24);
      }), V.prototype.readBigInt64BE = Rt(function(T) {
        T = T >>> 0, ht(T, "offset");
        const M = this[T], K = this[T + 7];
        (M === void 0 || K === void 0) && ct(T, this.length - 8);
        const ae = (M << 24) + // Overflow
        this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + this[++T];
        return (BigInt(ae) << BigInt(32)) + BigInt(this[++T] * 2 ** 24 + this[++T] * 2 ** 16 + this[++T] * 2 ** 8 + K);
      }), V.prototype.readFloatLE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), U.read(this, T, !0, 23, 4);
      }, V.prototype.readFloatBE = function(T, M) {
        return T = T >>> 0, M || de(T, 4, this.length), U.read(this, T, !1, 23, 4);
      }, V.prototype.readDoubleLE = function(T, M) {
        return T = T >>> 0, M || de(T, 8, this.length), U.read(this, T, !0, 52, 8);
      }, V.prototype.readDoubleBE = function(T, M) {
        return T = T >>> 0, M || de(T, 8, this.length), U.read(this, T, !1, 52, 8);
      };
      function xe($, T, M, K, ae, ve) {
        if (!V.isBuffer($))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (T > ae || T < ve)
          throw new RangeError('"value" argument is out of bounds');
        if (M + K > $.length)
          throw new RangeError("Index out of range");
      }
      V.prototype.writeUintLE = V.prototype.writeUIntLE = function(T, M, K, ae) {
        if (T = +T, M = M >>> 0, K = K >>> 0, !ae) {
          const nt = Math.pow(2, 8 * K) - 1;
          xe(this, T, M, K, nt, 0);
        }
        let ve = 1, we = 0;
        for (this[M] = T & 255; ++we < K && (ve *= 256); )
          this[M + we] = T / ve & 255;
        return M + K;
      }, V.prototype.writeUintBE = V.prototype.writeUIntBE = function(T, M, K, ae) {
        if (T = +T, M = M >>> 0, K = K >>> 0, !ae) {
          const nt = Math.pow(2, 8 * K) - 1;
          xe(this, T, M, K, nt, 0);
        }
        let ve = K - 1, we = 1;
        for (this[M + ve] = T & 255; --ve >= 0 && (we *= 256); )
          this[M + ve] = T / we & 255;
        return M + K;
      }, V.prototype.writeUint8 = V.prototype.writeUInt8 = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 1, 255, 0), this[M] = T & 255, M + 1;
      }, V.prototype.writeUint16LE = V.prototype.writeUInt16LE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 2, 65535, 0), this[M] = T & 255, this[M + 1] = T >>> 8, M + 2;
      }, V.prototype.writeUint16BE = V.prototype.writeUInt16BE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 2, 65535, 0), this[M] = T >>> 8, this[M + 1] = T & 255, M + 2;
      }, V.prototype.writeUint32LE = V.prototype.writeUInt32LE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 4, 4294967295, 0), this[M + 3] = T >>> 24, this[M + 2] = T >>> 16, this[M + 1] = T >>> 8, this[M] = T & 255, M + 4;
      }, V.prototype.writeUint32BE = V.prototype.writeUInt32BE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 4, 4294967295, 0), this[M] = T >>> 24, this[M + 1] = T >>> 16, this[M + 2] = T >>> 8, this[M + 3] = T & 255, M + 4;
      };
      function Oe($, T, M, K, ae) {
        Ge(T, K, ae, $, M, 7);
        let ve = Number(T & BigInt(4294967295));
        $[M++] = ve, ve = ve >> 8, $[M++] = ve, ve = ve >> 8, $[M++] = ve, ve = ve >> 8, $[M++] = ve;
        let we = Number(T >> BigInt(32) & BigInt(4294967295));
        return $[M++] = we, we = we >> 8, $[M++] = we, we = we >> 8, $[M++] = we, we = we >> 8, $[M++] = we, M;
      }
      function Be($, T, M, K, ae) {
        Ge(T, K, ae, $, M, 7);
        let ve = Number(T & BigInt(4294967295));
        $[M + 7] = ve, ve = ve >> 8, $[M + 6] = ve, ve = ve >> 8, $[M + 5] = ve, ve = ve >> 8, $[M + 4] = ve;
        let we = Number(T >> BigInt(32) & BigInt(4294967295));
        return $[M + 3] = we, we = we >> 8, $[M + 2] = we, we = we >> 8, $[M + 1] = we, we = we >> 8, $[M] = we, M + 8;
      }
      V.prototype.writeBigUInt64LE = Rt(function(T, M = 0) {
        return Oe(this, T, M, BigInt(0), BigInt("0xffffffffffffffff"));
      }), V.prototype.writeBigUInt64BE = Rt(function(T, M = 0) {
        return Be(this, T, M, BigInt(0), BigInt("0xffffffffffffffff"));
      }), V.prototype.writeIntLE = function(T, M, K, ae) {
        if (T = +T, M = M >>> 0, !ae) {
          const _t = Math.pow(2, 8 * K - 1);
          xe(this, T, M, K, _t - 1, -_t);
        }
        let ve = 0, we = 1, nt = 0;
        for (this[M] = T & 255; ++ve < K && (we *= 256); )
          T < 0 && nt === 0 && this[M + ve - 1] !== 0 && (nt = 1), this[M + ve] = (T / we >> 0) - nt & 255;
        return M + K;
      }, V.prototype.writeIntBE = function(T, M, K, ae) {
        if (T = +T, M = M >>> 0, !ae) {
          const _t = Math.pow(2, 8 * K - 1);
          xe(this, T, M, K, _t - 1, -_t);
        }
        let ve = K - 1, we = 1, nt = 0;
        for (this[M + ve] = T & 255; --ve >= 0 && (we *= 256); )
          T < 0 && nt === 0 && this[M + ve + 1] !== 0 && (nt = 1), this[M + ve] = (T / we >> 0) - nt & 255;
        return M + K;
      }, V.prototype.writeInt8 = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 1, 127, -128), T < 0 && (T = 255 + T + 1), this[M] = T & 255, M + 1;
      }, V.prototype.writeInt16LE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 2, 32767, -32768), this[M] = T & 255, this[M + 1] = T >>> 8, M + 2;
      }, V.prototype.writeInt16BE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 2, 32767, -32768), this[M] = T >>> 8, this[M + 1] = T & 255, M + 2;
      }, V.prototype.writeInt32LE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 4, 2147483647, -2147483648), this[M] = T & 255, this[M + 1] = T >>> 8, this[M + 2] = T >>> 16, this[M + 3] = T >>> 24, M + 4;
      }, V.prototype.writeInt32BE = function(T, M, K) {
        return T = +T, M = M >>> 0, K || xe(this, T, M, 4, 2147483647, -2147483648), T < 0 && (T = 4294967295 + T + 1), this[M] = T >>> 24, this[M + 1] = T >>> 16, this[M + 2] = T >>> 8, this[M + 3] = T & 255, M + 4;
      }, V.prototype.writeBigInt64LE = Rt(function(T, M = 0) {
        return Oe(this, T, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      }), V.prototype.writeBigInt64BE = Rt(function(T, M = 0) {
        return Be(this, T, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function Xe($, T, M, K, ae, ve) {
        if (M + K > $.length)
          throw new RangeError("Index out of range");
        if (M < 0)
          throw new RangeError("Index out of range");
      }
      function Re($, T, M, K, ae) {
        return T = +T, M = M >>> 0, ae || Xe($, T, M, 4), U.write($, T, M, K, 23, 4), M + 4;
      }
      V.prototype.writeFloatLE = function(T, M, K) {
        return Re(this, T, M, !0, K);
      }, V.prototype.writeFloatBE = function(T, M, K) {
        return Re(this, T, M, !1, K);
      };
      function He($, T, M, K, ae) {
        return T = +T, M = M >>> 0, ae || Xe($, T, M, 8), U.write($, T, M, K, 52, 8), M + 8;
      }
      V.prototype.writeDoubleLE = function(T, M, K) {
        return He(this, T, M, !0, K);
      }, V.prototype.writeDoubleBE = function(T, M, K) {
        return He(this, T, M, !1, K);
      }, V.prototype.copy = function(T, M, K, ae) {
        if (!V.isBuffer(T))
          throw new TypeError("argument should be a Buffer");
        if (K || (K = 0), !ae && ae !== 0 && (ae = this.length), M >= T.length && (M = T.length), M || (M = 0), ae > 0 && ae < K && (ae = K), ae === K || T.length === 0 || this.length === 0)
          return 0;
        if (M < 0)
          throw new RangeError("targetStart out of bounds");
        if (K < 0 || K >= this.length)
          throw new RangeError("Index out of range");
        if (ae < 0)
          throw new RangeError("sourceEnd out of bounds");
        ae > this.length && (ae = this.length), T.length - M < ae - K && (ae = T.length - M + K);
        const ve = ae - K;
        return this === T && typeof z.prototype.copyWithin == "function" ? this.copyWithin(M, K, ae) : z.prototype.set.call(
          T,
          this.subarray(K, ae),
          M
        ), ve;
      }, V.prototype.fill = function(T, M, K, ae) {
        if (typeof T == "string") {
          if (typeof M == "string" ? (ae = M, M = 0, K = this.length) : typeof K == "string" && (ae = K, K = this.length), ae !== void 0 && typeof ae != "string")
            throw new TypeError("encoding must be a string");
          if (typeof ae == "string" && !V.isEncoding(ae))
            throw new TypeError("Unknown encoding: " + ae);
          if (T.length === 1) {
            const we = T.charCodeAt(0);
            (ae === "utf8" && we < 128 || ae === "latin1") && (T = we);
          }
        } else
          typeof T == "number" ? T = T & 255 : typeof T == "boolean" && (T = Number(T));
        if (M < 0 || this.length < M || this.length < K)
          throw new RangeError("Out of range index");
        if (K <= M)
          return this;
        M = M >>> 0, K = K === void 0 ? this.length : K >>> 0, T || (T = 0);
        let ve;
        if (typeof T == "number")
          for (ve = M; ve < K; ++ve)
            this[ve] = T;
        else {
          const we = V.isBuffer(T) ? T : V.from(T, ae), nt = we.length;
          if (nt === 0)
            throw new TypeError('The value "' + T + '" is invalid for argument "value"');
          for (ve = 0; ve < K - M; ++ve)
            this[ve + M] = we[ve % nt];
        }
        return this;
      };
      const rt = {};
      function Qe($, T, M) {
        rt[$] = class extends M {
          constructor() {
            super(), Object.defineProperty(this, "message", {
              value: T.apply(this, arguments),
              writable: !0,
              configurable: !0
            }), this.name = `${this.name} [${$}]`, this.stack, delete this.name;
          }
          get code() {
            return $;
          }
          set code(ae) {
            Object.defineProperty(this, "code", {
              configurable: !0,
              enumerable: !0,
              value: ae,
              writable: !0
            });
          }
          toString() {
            return `${this.name} [${$}]: ${this.message}`;
          }
        };
      }
      Qe(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function($) {
          return $ ? `${$} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        },
        RangeError
      ), Qe(
        "ERR_INVALID_ARG_TYPE",
        function($, T) {
          return `The "${$}" argument must be of type number. Received type ${typeof T}`;
        },
        TypeError
      ), Qe(
        "ERR_OUT_OF_RANGE",
        function($, T, M) {
          let K = `The value of "${$}" is out of range.`, ae = M;
          return Number.isInteger(M) && Math.abs(M) > 2 ** 32 ? ae = Ot(String(M)) : typeof M == "bigint" && (ae = String(M), (M > BigInt(2) ** BigInt(32) || M < -(BigInt(2) ** BigInt(32))) && (ae = Ot(ae)), ae += "n"), K += ` It must be ${T}. Received ${ae}`, K;
        },
        RangeError
      );
      function Ot($) {
        let T = "", M = $.length;
        const K = $[0] === "-" ? 1 : 0;
        for (; M >= K + 4; M -= 3)
          T = `_${$.slice(M - 3, M)}${T}`;
        return `${$.slice(0, M)}${T}`;
      }
      function $t($, T, M) {
        ht(T, "offset"), ($[T] === void 0 || $[T + M] === void 0) && ct(T, $.length - (M + 1));
      }
      function Ge($, T, M, K, ae, ve) {
        if ($ > M || $ < T) {
          const we = typeof T == "bigint" ? "n" : "";
          let nt;
          throw ve > 3 ? T === 0 || T === BigInt(0) ? nt = `>= 0${we} and < 2${we} ** ${(ve + 1) * 8}${we}` : nt = `>= -(2${we} ** ${(ve + 1) * 8 - 1}${we}) and < 2 ** ${(ve + 1) * 8 - 1}${we}` : nt = `>= ${T}${we} and <= ${M}${we}`, new rt.ERR_OUT_OF_RANGE("value", nt, $);
        }
        $t(K, ae, ve);
      }
      function ht($, T) {
        if (typeof $ != "number")
          throw new rt.ERR_INVALID_ARG_TYPE(T, "number", $);
      }
      function ct($, T, M) {
        throw Math.floor($) !== $ ? (ht($, M), new rt.ERR_OUT_OF_RANGE(M || "offset", "an integer", $)) : T < 0 ? new rt.ERR_BUFFER_OUT_OF_BOUNDS() : new rt.ERR_OUT_OF_RANGE(
          M || "offset",
          `>= ${M ? 1 : 0} and <= ${T}`,
          $
        );
      }
      const et = /[^+/0-9A-Za-z-_]/g;
      function st($) {
        if ($ = $.split("=")[0], $ = $.trim().replace(et, ""), $.length < 2)
          return "";
        for (; $.length % 4 !== 0; )
          $ = $ + "=";
        return $;
      }
      function yt($, T) {
        T = T || 1 / 0;
        let M;
        const K = $.length;
        let ae = null;
        const ve = [];
        for (let we = 0; we < K; ++we) {
          if (M = $.charCodeAt(we), M > 55295 && M < 57344) {
            if (!ae) {
              if (M > 56319) {
                (T -= 3) > -1 && ve.push(239, 191, 189);
                continue;
              } else if (we + 1 === K) {
                (T -= 3) > -1 && ve.push(239, 191, 189);
                continue;
              }
              ae = M;
              continue;
            }
            if (M < 56320) {
              (T -= 3) > -1 && ve.push(239, 191, 189), ae = M;
              continue;
            }
            M = (ae - 55296 << 10 | M - 56320) + 65536;
          } else
            ae && (T -= 3) > -1 && ve.push(239, 191, 189);
          if (ae = null, M < 128) {
            if ((T -= 1) < 0)
              break;
            ve.push(M);
          } else if (M < 2048) {
            if ((T -= 2) < 0)
              break;
            ve.push(
              M >> 6 | 192,
              M & 63 | 128
            );
          } else if (M < 65536) {
            if ((T -= 3) < 0)
              break;
            ve.push(
              M >> 12 | 224,
              M >> 6 & 63 | 128,
              M & 63 | 128
            );
          } else if (M < 1114112) {
            if ((T -= 4) < 0)
              break;
            ve.push(
              M >> 18 | 240,
              M >> 12 & 63 | 128,
              M >> 6 & 63 | 128,
              M & 63 | 128
            );
          } else
            throw new Error("Invalid code point");
        }
        return ve;
      }
      function it($) {
        const T = [];
        for (let M = 0; M < $.length; ++M)
          T.push($.charCodeAt(M) & 255);
        return T;
      }
      function vt($, T) {
        let M, K, ae;
        const ve = [];
        for (let we = 0; we < $.length && !((T -= 2) < 0); ++we)
          M = $.charCodeAt(we), K = M >> 8, ae = M % 256, ve.push(ae), ve.push(K);
        return ve;
      }
      function Dt($) {
        return I.toByteArray(st($));
      }
      function pt($, T, M, K) {
        let ae;
        for (ae = 0; ae < K && !(ae + M >= T.length || ae >= $.length); ++ae)
          T[ae + M] = $[ae];
        return ae;
      }
      function It($, T) {
        return $ instanceof T || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === T.name;
      }
      function Vt($) {
        return $ !== $;
      }
      const Ke = function() {
        const $ = "0123456789abcdef", T = new Array(256);
        for (let M = 0; M < 16; ++M) {
          const K = M * 16;
          for (let ae = 0; ae < 16; ++ae)
            T[K + ae] = $[M] + $[ae];
        }
        return T;
      }();
      function Rt($) {
        return typeof BigInt > "u" ? zt : $;
      }
      function zt() {
        throw new Error("BigInt not supported");
      }
    })(t);
    const C = t.Buffer;
    e.Blob = t.Blob, e.BlobOptions = t.BlobOptions, e.Buffer = t.Buffer, e.File = t.File, e.FileOptions = t.FileOptions, e.INSPECT_MAX_BYTES = t.INSPECT_MAX_BYTES, e.SlowBuffer = t.SlowBuffer, e.TranscodeEncoding = t.TranscodeEncoding, e.atob = t.atob, e.btoa = t.btoa, e.constants = t.constants, e.default = C, e.isAscii = t.isAscii, e.isUtf8 = t.isUtf8, e.kMaxLength = t.kMaxLength, e.kStringMaxLength = t.kStringMaxLength, e.resolveObjectURL = t.resolveObjectURL, e.transcode = t.transcode;
  }(op)), op;
}
var gL = Nd();
const Yf = /* @__PURE__ */ Yu(gL);
var oi = {}, Qg = { exports: {} };
Qg.exports;
(function(e) {
  (function(t, r) {
    function n(L, p) {
      if (!L)
        throw new Error(p || "Assertion failed");
    }
    function i(L, p) {
      L.super_ = p;
      var d = function() {
      };
      d.prototype = p.prototype, L.prototype = new d(), L.prototype.constructor = L;
    }
    function s(L, p, d) {
      if (s.isBN(L))
        return L;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, L !== null && ((p === "le" || p === "be") && (d = p, p = 10), this._init(L || 0, p || 10, d || "be"));
    }
    typeof t == "object" ? t.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Nd().Buffer;
    } catch {
    }
    s.isBN = function(p) {
      return p instanceof s ? !0 : p !== null && typeof p == "object" && p.constructor.wordSize === s.wordSize && Array.isArray(p.words);
    }, s.max = function(p, d) {
      return p.cmp(d) > 0 ? p : d;
    }, s.min = function(p, d) {
      return p.cmp(d) < 0 ? p : d;
    }, s.prototype._init = function(p, d, m) {
      if (typeof p == "number")
        return this._initNumber(p, d, m);
      if (typeof p == "object")
        return this._initArray(p, d, m);
      d === "hex" && (d = 16), n(d === (d | 0) && d >= 2 && d <= 36), p = p.toString().replace(/\s+/g, "");
      var x = 0;
      p[0] === "-" && (x++, this.negative = 1), x < p.length && (d === 16 ? this._parseHex(p, x, m) : (this._parseBase(p, d, x), m === "le" && this._initArray(this.toArray(), d, m)));
    }, s.prototype._initNumber = function(p, d, m) {
      p < 0 && (this.negative = 1, p = -p), p < 67108864 ? (this.words = [p & 67108863], this.length = 1) : p < 4503599627370496 ? (this.words = [
        p & 67108863,
        p / 67108864 & 67108863
      ], this.length = 2) : (n(p < 9007199254740992), this.words = [
        p & 67108863,
        p / 67108864 & 67108863,
        1
      ], this.length = 3), m === "le" && this._initArray(this.toArray(), d, m);
    }, s.prototype._initArray = function(p, d, m) {
      if (n(typeof p.length == "number"), p.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(p.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var E, A, j = 0;
      if (m === "be")
        for (x = p.length - 1, E = 0; x >= 0; x -= 3)
          A = p[x] | p[x - 1] << 8 | p[x - 2] << 16, this.words[E] |= A << j & 67108863, this.words[E + 1] = A >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, E++);
      else if (m === "le")
        for (x = 0, E = 0; x < p.length; x += 3)
          A = p[x] | p[x + 1] << 8 | p[x + 2] << 16, this.words[E] |= A << j & 67108863, this.words[E + 1] = A >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, E++);
      return this._strip();
    };
    function a(L, p) {
      var d = L.charCodeAt(p);
      if (d >= 48 && d <= 57)
        return d - 48;
      if (d >= 65 && d <= 70)
        return d - 55;
      if (d >= 97 && d <= 102)
        return d - 87;
      n(!1, "Invalid character in " + L);
    }
    function c(L, p, d) {
      var m = a(L, d);
      return d - 1 >= p && (m |= a(L, d - 1) << 4), m;
    }
    s.prototype._parseHex = function(p, d, m) {
      this.length = Math.ceil((p.length - d) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var E = 0, A = 0, j;
      if (m === "be")
        for (x = p.length - 1; x >= d; x -= 2)
          j = c(p, d, x) << E, this.words[A] |= j & 67108863, E >= 18 ? (E -= 18, A += 1, this.words[A] |= j >>> 26) : E += 8;
      else {
        var k = p.length - d;
        for (x = k % 2 === 0 ? d + 1 : d; x < p.length; x += 2)
          j = c(p, d, x) << E, this.words[A] |= j & 67108863, E >= 18 ? (E -= 18, A += 1, this.words[A] |= j >>> 26) : E += 8;
      }
      this._strip();
    };
    function u(L, p, d, m) {
      for (var x = 0, E = 0, A = Math.min(L.length, d), j = p; j < A; j++) {
        var k = L.charCodeAt(j) - 48;
        x *= m, k >= 49 ? E = k - 49 + 10 : k >= 17 ? E = k - 17 + 10 : E = k, n(k >= 0 && E < m, "Invalid character"), x += E;
      }
      return x;
    }
    s.prototype._parseBase = function(p, d, m) {
      this.words = [0], this.length = 1;
      for (var x = 0, E = 1; E <= 67108863; E *= d)
        x++;
      x--, E = E / d | 0;
      for (var A = p.length - m, j = A % x, k = Math.min(A, A - j) + m, g = 0, w = m; w < k; w += x)
        g = u(p, w, w + x, d), this.imuln(E), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      if (j !== 0) {
        var P = 1;
        for (g = u(p, w, p.length, d), w = 0; w < j; w++)
          P *= d;
        this.imuln(P), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
      }
      this._strip();
    }, s.prototype.copy = function(p) {
      p.words = new Array(this.length);
      for (var d = 0; d < this.length; d++)
        p.words[d] = this.words[d];
      p.length = this.length, p.negative = this.negative, p.red = this.red;
    };
    function l(L, p) {
      L.words = p.words, L.length = p.length, L.negative = p.negative, L.red = p.red;
    }
    if (s.prototype._move = function(p) {
      l(p, this);
    }, s.prototype.clone = function() {
      var p = new s(null);
      return this.copy(p), p;
    }, s.prototype._expand = function(p) {
      for (; this.length < p; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
      } catch {
        s.prototype.inspect = f;
      }
    else
      s.prototype.inspect = f;
    function f() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var h = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], v = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], b = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(p, d) {
      p = p || 10, d = d | 0 || 1;
      var m;
      if (p === 16 || p === "hex") {
        m = "";
        for (var x = 0, E = 0, A = 0; A < this.length; A++) {
          var j = this.words[A], k = ((j << x | E) & 16777215).toString(16);
          E = j >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, A--), E !== 0 || A !== this.length - 1 ? m = h[6 - k.length] + k + m : m = k + m;
        }
        for (E !== 0 && (m = E.toString(16) + m); m.length % d !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      if (p === (p | 0) && p >= 2 && p <= 36) {
        var g = v[p], w = b[p];
        m = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var ue = P.modrn(w).toString(p);
          P = P.idivn(w), P.isZero() ? m = ue + m : m = h[g - ue.length] + ue + m;
        }
        for (this.isZero() && (m = "0" + m); m.length % d !== 0; )
          m = "0" + m;
        return this.negative !== 0 && (m = "-" + m), m;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var p = this.words[0];
      return this.length === 2 ? p += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? p += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -p : p;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(p, d) {
      return this.toArrayLike(o, p, d);
    }), s.prototype.toArray = function(p, d) {
      return this.toArrayLike(Array, p, d);
    };
    var y = function(p, d) {
      return p.allocUnsafe ? p.allocUnsafe(d) : new p(d);
    };
    s.prototype.toArrayLike = function(p, d, m) {
      this._strip();
      var x = this.byteLength(), E = m || Math.max(1, x);
      n(x <= E, "byte array longer than desired length"), n(E > 0, "Requested array length <= 0");
      var A = y(p, E), j = d === "le" ? "LE" : "BE";
      return this["_toArrayLike" + j](A, x), A;
    }, s.prototype._toArrayLikeLE = function(p, d) {
      for (var m = 0, x = 0, E = 0, A = 0; E < this.length; E++) {
        var j = this.words[E] << A | x;
        p[m++] = j & 255, m < p.length && (p[m++] = j >> 8 & 255), m < p.length && (p[m++] = j >> 16 & 255), A === 6 ? (m < p.length && (p[m++] = j >> 24 & 255), x = 0, A = 0) : (x = j >>> 24, A += 2);
      }
      if (m < p.length)
        for (p[m++] = x; m < p.length; )
          p[m++] = 0;
    }, s.prototype._toArrayLikeBE = function(p, d) {
      for (var m = p.length - 1, x = 0, E = 0, A = 0; E < this.length; E++) {
        var j = this.words[E] << A | x;
        p[m--] = j & 255, m >= 0 && (p[m--] = j >> 8 & 255), m >= 0 && (p[m--] = j >> 16 & 255), A === 6 ? (m >= 0 && (p[m--] = j >> 24 & 255), x = 0, A = 0) : (x = j >>> 24, A += 2);
      }
      if (m >= 0)
        for (p[m--] = x; m >= 0; )
          p[m--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(p) {
      return 32 - Math.clz32(p);
    } : s.prototype._countBits = function(p) {
      var d = p, m = 0;
      return d >= 4096 && (m += 13, d >>>= 13), d >= 64 && (m += 7, d >>>= 7), d >= 8 && (m += 4, d >>>= 4), d >= 2 && (m += 2, d >>>= 2), m + d;
    }, s.prototype._zeroBits = function(p) {
      if (p === 0)
        return 26;
      var d = p, m = 0;
      return d & 8191 || (m += 13, d >>>= 13), d & 127 || (m += 7, d >>>= 7), d & 15 || (m += 4, d >>>= 4), d & 3 || (m += 2, d >>>= 2), d & 1 || m++, m;
    }, s.prototype.bitLength = function() {
      var p = this.words[this.length - 1], d = this._countBits(p);
      return (this.length - 1) * 26 + d;
    };
    function S(L) {
      for (var p = new Array(L.bitLength()), d = 0; d < p.length; d++) {
        var m = d / 26 | 0, x = d % 26;
        p[d] = L.words[m] >>> x & 1;
      }
      return p;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var p = 0, d = 0; d < this.length; d++) {
        var m = this._zeroBits(this.words[d]);
        if (p += m, m !== 26)
          break;
      }
      return p;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(p) {
      return this.negative !== 0 ? this.abs().inotn(p).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(p) {
      return this.testn(p - 1) ? this.notn(p).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(p) {
      for (; this.length < p.length; )
        this.words[this.length++] = 0;
      for (var d = 0; d < p.length; d++)
        this.words[d] = this.words[d] | p.words[d];
      return this._strip();
    }, s.prototype.ior = function(p) {
      return n((this.negative | p.negative) === 0), this.iuor(p);
    }, s.prototype.or = function(p) {
      return this.length > p.length ? this.clone().ior(p) : p.clone().ior(this);
    }, s.prototype.uor = function(p) {
      return this.length > p.length ? this.clone().iuor(p) : p.clone().iuor(this);
    }, s.prototype.iuand = function(p) {
      var d;
      this.length > p.length ? d = p : d = this;
      for (var m = 0; m < d.length; m++)
        this.words[m] = this.words[m] & p.words[m];
      return this.length = d.length, this._strip();
    }, s.prototype.iand = function(p) {
      return n((this.negative | p.negative) === 0), this.iuand(p);
    }, s.prototype.and = function(p) {
      return this.length > p.length ? this.clone().iand(p) : p.clone().iand(this);
    }, s.prototype.uand = function(p) {
      return this.length > p.length ? this.clone().iuand(p) : p.clone().iuand(this);
    }, s.prototype.iuxor = function(p) {
      var d, m;
      this.length > p.length ? (d = this, m = p) : (d = p, m = this);
      for (var x = 0; x < m.length; x++)
        this.words[x] = d.words[x] ^ m.words[x];
      if (this !== d)
        for (; x < d.length; x++)
          this.words[x] = d.words[x];
      return this.length = d.length, this._strip();
    }, s.prototype.ixor = function(p) {
      return n((this.negative | p.negative) === 0), this.iuxor(p);
    }, s.prototype.xor = function(p) {
      return this.length > p.length ? this.clone().ixor(p) : p.clone().ixor(this);
    }, s.prototype.uxor = function(p) {
      return this.length > p.length ? this.clone().iuxor(p) : p.clone().iuxor(this);
    }, s.prototype.inotn = function(p) {
      n(typeof p == "number" && p >= 0);
      var d = Math.ceil(p / 26) | 0, m = p % 26;
      this._expand(d), m > 0 && d--;
      for (var x = 0; x < d; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return m > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - m), this._strip();
    }, s.prototype.notn = function(p) {
      return this.clone().inotn(p);
    }, s.prototype.setn = function(p, d) {
      n(typeof p == "number" && p >= 0);
      var m = p / 26 | 0, x = p % 26;
      return this._expand(m + 1), d ? this.words[m] = this.words[m] | 1 << x : this.words[m] = this.words[m] & ~(1 << x), this._strip();
    }, s.prototype.iadd = function(p) {
      var d;
      if (this.negative !== 0 && p.negative === 0)
        return this.negative = 0, d = this.isub(p), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && p.negative !== 0)
        return p.negative = 0, d = this.isub(p), p.negative = 1, d._normSign();
      var m, x;
      this.length > p.length ? (m = this, x = p) : (m = p, x = this);
      for (var E = 0, A = 0; A < x.length; A++)
        d = (m.words[A] | 0) + (x.words[A] | 0) + E, this.words[A] = d & 67108863, E = d >>> 26;
      for (; E !== 0 && A < m.length; A++)
        d = (m.words[A] | 0) + E, this.words[A] = d & 67108863, E = d >>> 26;
      if (this.length = m.length, E !== 0)
        this.words[this.length] = E, this.length++;
      else if (m !== this)
        for (; A < m.length; A++)
          this.words[A] = m.words[A];
      return this;
    }, s.prototype.add = function(p) {
      var d;
      return p.negative !== 0 && this.negative === 0 ? (p.negative = 0, d = this.sub(p), p.negative ^= 1, d) : p.negative === 0 && this.negative !== 0 ? (this.negative = 0, d = p.sub(this), this.negative = 1, d) : this.length > p.length ? this.clone().iadd(p) : p.clone().iadd(this);
    }, s.prototype.isub = function(p) {
      if (p.negative !== 0) {
        p.negative = 0;
        var d = this.iadd(p);
        return p.negative = 1, d._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(p), this.negative = 1, this._normSign();
      var m = this.cmp(p);
      if (m === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, E;
      m > 0 ? (x = this, E = p) : (x = p, E = this);
      for (var A = 0, j = 0; j < E.length; j++)
        d = (x.words[j] | 0) - (E.words[j] | 0) + A, A = d >> 26, this.words[j] = d & 67108863;
      for (; A !== 0 && j < x.length; j++)
        d = (x.words[j] | 0) + A, A = d >> 26, this.words[j] = d & 67108863;
      if (A === 0 && j < x.length && x !== this)
        for (; j < x.length; j++)
          this.words[j] = x.words[j];
      return this.length = Math.max(this.length, j), x !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(p) {
      return this.clone().isub(p);
    };
    function C(L, p, d) {
      d.negative = p.negative ^ L.negative;
      var m = L.length + p.length | 0;
      d.length = m, m = m - 1 | 0;
      var x = L.words[0] | 0, E = p.words[0] | 0, A = x * E, j = A & 67108863, k = A / 67108864 | 0;
      d.words[0] = j;
      for (var g = 1; g < m; g++) {
        for (var w = k >>> 26, P = k & 67108863, ue = Math.min(g, p.length - 1), ie = Math.max(0, g - L.length + 1); ie <= ue; ie++) {
          var fe = g - ie | 0;
          x = L.words[fe] | 0, E = p.words[ie] | 0, A = x * E + P, w += A / 67108864 | 0, P = A & 67108863;
        }
        d.words[g] = P | 0, k = w | 0;
      }
      return k !== 0 ? d.words[g] = k | 0 : d.length--, d._strip();
    }
    var O = function(p, d, m) {
      var x = p.words, E = d.words, A = m.words, j = 0, k, g, w, P = x[0] | 0, ue = P & 8191, ie = P >>> 13, fe = x[1] | 0, ye = fe & 8191, Te = fe >>> 13, N = x[2] | 0, F = N & 8191, G = N >>> 13, ee = x[3] | 0, Z = ee & 8191, q = ee >>> 13, he = x[4] | 0, Y = he & 8191, X = he >>> 13, B = x[5] | 0, se = B & 8191, me = B >>> 13, de = x[6] | 0, xe = de & 8191, Oe = de >>> 13, Be = x[7] | 0, Xe = Be & 8191, Re = Be >>> 13, He = x[8] | 0, rt = He & 8191, Qe = He >>> 13, Ot = x[9] | 0, $t = Ot & 8191, Ge = Ot >>> 13, ht = E[0] | 0, ct = ht & 8191, et = ht >>> 13, st = E[1] | 0, yt = st & 8191, it = st >>> 13, vt = E[2] | 0, Dt = vt & 8191, pt = vt >>> 13, It = E[3] | 0, Vt = It & 8191, Ke = It >>> 13, Rt = E[4] | 0, zt = Rt & 8191, $ = Rt >>> 13, T = E[5] | 0, M = T & 8191, K = T >>> 13, ae = E[6] | 0, ve = ae & 8191, we = ae >>> 13, nt = E[7] | 0, _t = nt & 8191, tt = nt >>> 13, Q = E[8] | 0, Se = Q & 8191, Ie = Q >>> 13, Je = E[9] | 0, lt = Je & 8191, Ze = Je >>> 13;
      m.negative = p.negative ^ d.negative, m.length = 19, k = Math.imul(ue, ct), g = Math.imul(ue, et), g = g + Math.imul(ie, ct) | 0, w = Math.imul(ie, et);
      var ot = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, k = Math.imul(ye, ct), g = Math.imul(ye, et), g = g + Math.imul(Te, ct) | 0, w = Math.imul(Te, et), k = k + Math.imul(ue, yt) | 0, g = g + Math.imul(ue, it) | 0, g = g + Math.imul(ie, yt) | 0, w = w + Math.imul(ie, it) | 0;
      var Et = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, k = Math.imul(F, ct), g = Math.imul(F, et), g = g + Math.imul(G, ct) | 0, w = Math.imul(G, et), k = k + Math.imul(ye, yt) | 0, g = g + Math.imul(ye, it) | 0, g = g + Math.imul(Te, yt) | 0, w = w + Math.imul(Te, it) | 0, k = k + Math.imul(ue, Dt) | 0, g = g + Math.imul(ue, pt) | 0, g = g + Math.imul(ie, Dt) | 0, w = w + Math.imul(ie, pt) | 0;
      var cr = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, k = Math.imul(Z, ct), g = Math.imul(Z, et), g = g + Math.imul(q, ct) | 0, w = Math.imul(q, et), k = k + Math.imul(F, yt) | 0, g = g + Math.imul(F, it) | 0, g = g + Math.imul(G, yt) | 0, w = w + Math.imul(G, it) | 0, k = k + Math.imul(ye, Dt) | 0, g = g + Math.imul(ye, pt) | 0, g = g + Math.imul(Te, Dt) | 0, w = w + Math.imul(Te, pt) | 0, k = k + Math.imul(ue, Vt) | 0, g = g + Math.imul(ue, Ke) | 0, g = g + Math.imul(ie, Vt) | 0, w = w + Math.imul(ie, Ke) | 0;
      var Kt = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, k = Math.imul(Y, ct), g = Math.imul(Y, et), g = g + Math.imul(X, ct) | 0, w = Math.imul(X, et), k = k + Math.imul(Z, yt) | 0, g = g + Math.imul(Z, it) | 0, g = g + Math.imul(q, yt) | 0, w = w + Math.imul(q, it) | 0, k = k + Math.imul(F, Dt) | 0, g = g + Math.imul(F, pt) | 0, g = g + Math.imul(G, Dt) | 0, w = w + Math.imul(G, pt) | 0, k = k + Math.imul(ye, Vt) | 0, g = g + Math.imul(ye, Ke) | 0, g = g + Math.imul(Te, Vt) | 0, w = w + Math.imul(Te, Ke) | 0, k = k + Math.imul(ue, zt) | 0, g = g + Math.imul(ue, $) | 0, g = g + Math.imul(ie, zt) | 0, w = w + Math.imul(ie, $) | 0;
      var Jt = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, k = Math.imul(se, ct), g = Math.imul(se, et), g = g + Math.imul(me, ct) | 0, w = Math.imul(me, et), k = k + Math.imul(Y, yt) | 0, g = g + Math.imul(Y, it) | 0, g = g + Math.imul(X, yt) | 0, w = w + Math.imul(X, it) | 0, k = k + Math.imul(Z, Dt) | 0, g = g + Math.imul(Z, pt) | 0, g = g + Math.imul(q, Dt) | 0, w = w + Math.imul(q, pt) | 0, k = k + Math.imul(F, Vt) | 0, g = g + Math.imul(F, Ke) | 0, g = g + Math.imul(G, Vt) | 0, w = w + Math.imul(G, Ke) | 0, k = k + Math.imul(ye, zt) | 0, g = g + Math.imul(ye, $) | 0, g = g + Math.imul(Te, zt) | 0, w = w + Math.imul(Te, $) | 0, k = k + Math.imul(ue, M) | 0, g = g + Math.imul(ue, K) | 0, g = g + Math.imul(ie, M) | 0, w = w + Math.imul(ie, K) | 0;
      var _r = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, k = Math.imul(xe, ct), g = Math.imul(xe, et), g = g + Math.imul(Oe, ct) | 0, w = Math.imul(Oe, et), k = k + Math.imul(se, yt) | 0, g = g + Math.imul(se, it) | 0, g = g + Math.imul(me, yt) | 0, w = w + Math.imul(me, it) | 0, k = k + Math.imul(Y, Dt) | 0, g = g + Math.imul(Y, pt) | 0, g = g + Math.imul(X, Dt) | 0, w = w + Math.imul(X, pt) | 0, k = k + Math.imul(Z, Vt) | 0, g = g + Math.imul(Z, Ke) | 0, g = g + Math.imul(q, Vt) | 0, w = w + Math.imul(q, Ke) | 0, k = k + Math.imul(F, zt) | 0, g = g + Math.imul(F, $) | 0, g = g + Math.imul(G, zt) | 0, w = w + Math.imul(G, $) | 0, k = k + Math.imul(ye, M) | 0, g = g + Math.imul(ye, K) | 0, g = g + Math.imul(Te, M) | 0, w = w + Math.imul(Te, K) | 0, k = k + Math.imul(ue, ve) | 0, g = g + Math.imul(ue, we) | 0, g = g + Math.imul(ie, ve) | 0, w = w + Math.imul(ie, we) | 0;
      var Jr = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, k = Math.imul(Xe, ct), g = Math.imul(Xe, et), g = g + Math.imul(Re, ct) | 0, w = Math.imul(Re, et), k = k + Math.imul(xe, yt) | 0, g = g + Math.imul(xe, it) | 0, g = g + Math.imul(Oe, yt) | 0, w = w + Math.imul(Oe, it) | 0, k = k + Math.imul(se, Dt) | 0, g = g + Math.imul(se, pt) | 0, g = g + Math.imul(me, Dt) | 0, w = w + Math.imul(me, pt) | 0, k = k + Math.imul(Y, Vt) | 0, g = g + Math.imul(Y, Ke) | 0, g = g + Math.imul(X, Vt) | 0, w = w + Math.imul(X, Ke) | 0, k = k + Math.imul(Z, zt) | 0, g = g + Math.imul(Z, $) | 0, g = g + Math.imul(q, zt) | 0, w = w + Math.imul(q, $) | 0, k = k + Math.imul(F, M) | 0, g = g + Math.imul(F, K) | 0, g = g + Math.imul(G, M) | 0, w = w + Math.imul(G, K) | 0, k = k + Math.imul(ye, ve) | 0, g = g + Math.imul(ye, we) | 0, g = g + Math.imul(Te, ve) | 0, w = w + Math.imul(Te, we) | 0, k = k + Math.imul(ue, _t) | 0, g = g + Math.imul(ue, tt) | 0, g = g + Math.imul(ie, _t) | 0, w = w + Math.imul(ie, tt) | 0;
      var Sr = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, k = Math.imul(rt, ct), g = Math.imul(rt, et), g = g + Math.imul(Qe, ct) | 0, w = Math.imul(Qe, et), k = k + Math.imul(Xe, yt) | 0, g = g + Math.imul(Xe, it) | 0, g = g + Math.imul(Re, yt) | 0, w = w + Math.imul(Re, it) | 0, k = k + Math.imul(xe, Dt) | 0, g = g + Math.imul(xe, pt) | 0, g = g + Math.imul(Oe, Dt) | 0, w = w + Math.imul(Oe, pt) | 0, k = k + Math.imul(se, Vt) | 0, g = g + Math.imul(se, Ke) | 0, g = g + Math.imul(me, Vt) | 0, w = w + Math.imul(me, Ke) | 0, k = k + Math.imul(Y, zt) | 0, g = g + Math.imul(Y, $) | 0, g = g + Math.imul(X, zt) | 0, w = w + Math.imul(X, $) | 0, k = k + Math.imul(Z, M) | 0, g = g + Math.imul(Z, K) | 0, g = g + Math.imul(q, M) | 0, w = w + Math.imul(q, K) | 0, k = k + Math.imul(F, ve) | 0, g = g + Math.imul(F, we) | 0, g = g + Math.imul(G, ve) | 0, w = w + Math.imul(G, we) | 0, k = k + Math.imul(ye, _t) | 0, g = g + Math.imul(ye, tt) | 0, g = g + Math.imul(Te, _t) | 0, w = w + Math.imul(Te, tt) | 0, k = k + Math.imul(ue, Se) | 0, g = g + Math.imul(ue, Ie) | 0, g = g + Math.imul(ie, Se) | 0, w = w + Math.imul(ie, Ie) | 0;
      var ur = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, k = Math.imul($t, ct), g = Math.imul($t, et), g = g + Math.imul(Ge, ct) | 0, w = Math.imul(Ge, et), k = k + Math.imul(rt, yt) | 0, g = g + Math.imul(rt, it) | 0, g = g + Math.imul(Qe, yt) | 0, w = w + Math.imul(Qe, it) | 0, k = k + Math.imul(Xe, Dt) | 0, g = g + Math.imul(Xe, pt) | 0, g = g + Math.imul(Re, Dt) | 0, w = w + Math.imul(Re, pt) | 0, k = k + Math.imul(xe, Vt) | 0, g = g + Math.imul(xe, Ke) | 0, g = g + Math.imul(Oe, Vt) | 0, w = w + Math.imul(Oe, Ke) | 0, k = k + Math.imul(se, zt) | 0, g = g + Math.imul(se, $) | 0, g = g + Math.imul(me, zt) | 0, w = w + Math.imul(me, $) | 0, k = k + Math.imul(Y, M) | 0, g = g + Math.imul(Y, K) | 0, g = g + Math.imul(X, M) | 0, w = w + Math.imul(X, K) | 0, k = k + Math.imul(Z, ve) | 0, g = g + Math.imul(Z, we) | 0, g = g + Math.imul(q, ve) | 0, w = w + Math.imul(q, we) | 0, k = k + Math.imul(F, _t) | 0, g = g + Math.imul(F, tt) | 0, g = g + Math.imul(G, _t) | 0, w = w + Math.imul(G, tt) | 0, k = k + Math.imul(ye, Se) | 0, g = g + Math.imul(ye, Ie) | 0, g = g + Math.imul(Te, Se) | 0, w = w + Math.imul(Te, Ie) | 0, k = k + Math.imul(ue, lt) | 0, g = g + Math.imul(ue, Ze) | 0, g = g + Math.imul(ie, lt) | 0, w = w + Math.imul(ie, Ze) | 0;
      var Kr = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, k = Math.imul($t, yt), g = Math.imul($t, it), g = g + Math.imul(Ge, yt) | 0, w = Math.imul(Ge, it), k = k + Math.imul(rt, Dt) | 0, g = g + Math.imul(rt, pt) | 0, g = g + Math.imul(Qe, Dt) | 0, w = w + Math.imul(Qe, pt) | 0, k = k + Math.imul(Xe, Vt) | 0, g = g + Math.imul(Xe, Ke) | 0, g = g + Math.imul(Re, Vt) | 0, w = w + Math.imul(Re, Ke) | 0, k = k + Math.imul(xe, zt) | 0, g = g + Math.imul(xe, $) | 0, g = g + Math.imul(Oe, zt) | 0, w = w + Math.imul(Oe, $) | 0, k = k + Math.imul(se, M) | 0, g = g + Math.imul(se, K) | 0, g = g + Math.imul(me, M) | 0, w = w + Math.imul(me, K) | 0, k = k + Math.imul(Y, ve) | 0, g = g + Math.imul(Y, we) | 0, g = g + Math.imul(X, ve) | 0, w = w + Math.imul(X, we) | 0, k = k + Math.imul(Z, _t) | 0, g = g + Math.imul(Z, tt) | 0, g = g + Math.imul(q, _t) | 0, w = w + Math.imul(q, tt) | 0, k = k + Math.imul(F, Se) | 0, g = g + Math.imul(F, Ie) | 0, g = g + Math.imul(G, Se) | 0, w = w + Math.imul(G, Ie) | 0, k = k + Math.imul(ye, lt) | 0, g = g + Math.imul(ye, Ze) | 0, g = g + Math.imul(Te, lt) | 0, w = w + Math.imul(Te, Ze) | 0;
      var li = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, k = Math.imul($t, Dt), g = Math.imul($t, pt), g = g + Math.imul(Ge, Dt) | 0, w = Math.imul(Ge, pt), k = k + Math.imul(rt, Vt) | 0, g = g + Math.imul(rt, Ke) | 0, g = g + Math.imul(Qe, Vt) | 0, w = w + Math.imul(Qe, Ke) | 0, k = k + Math.imul(Xe, zt) | 0, g = g + Math.imul(Xe, $) | 0, g = g + Math.imul(Re, zt) | 0, w = w + Math.imul(Re, $) | 0, k = k + Math.imul(xe, M) | 0, g = g + Math.imul(xe, K) | 0, g = g + Math.imul(Oe, M) | 0, w = w + Math.imul(Oe, K) | 0, k = k + Math.imul(se, ve) | 0, g = g + Math.imul(se, we) | 0, g = g + Math.imul(me, ve) | 0, w = w + Math.imul(me, we) | 0, k = k + Math.imul(Y, _t) | 0, g = g + Math.imul(Y, tt) | 0, g = g + Math.imul(X, _t) | 0, w = w + Math.imul(X, tt) | 0, k = k + Math.imul(Z, Se) | 0, g = g + Math.imul(Z, Ie) | 0, g = g + Math.imul(q, Se) | 0, w = w + Math.imul(q, Ie) | 0, k = k + Math.imul(F, lt) | 0, g = g + Math.imul(F, Ze) | 0, g = g + Math.imul(G, lt) | 0, w = w + Math.imul(G, Ze) | 0;
      var Cn = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, k = Math.imul($t, Vt), g = Math.imul($t, Ke), g = g + Math.imul(Ge, Vt) | 0, w = Math.imul(Ge, Ke), k = k + Math.imul(rt, zt) | 0, g = g + Math.imul(rt, $) | 0, g = g + Math.imul(Qe, zt) | 0, w = w + Math.imul(Qe, $) | 0, k = k + Math.imul(Xe, M) | 0, g = g + Math.imul(Xe, K) | 0, g = g + Math.imul(Re, M) | 0, w = w + Math.imul(Re, K) | 0, k = k + Math.imul(xe, ve) | 0, g = g + Math.imul(xe, we) | 0, g = g + Math.imul(Oe, ve) | 0, w = w + Math.imul(Oe, we) | 0, k = k + Math.imul(se, _t) | 0, g = g + Math.imul(se, tt) | 0, g = g + Math.imul(me, _t) | 0, w = w + Math.imul(me, tt) | 0, k = k + Math.imul(Y, Se) | 0, g = g + Math.imul(Y, Ie) | 0, g = g + Math.imul(X, Se) | 0, w = w + Math.imul(X, Ie) | 0, k = k + Math.imul(Z, lt) | 0, g = g + Math.imul(Z, Ze) | 0, g = g + Math.imul(q, lt) | 0, w = w + Math.imul(q, Ze) | 0;
      var fi = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, k = Math.imul($t, zt), g = Math.imul($t, $), g = g + Math.imul(Ge, zt) | 0, w = Math.imul(Ge, $), k = k + Math.imul(rt, M) | 0, g = g + Math.imul(rt, K) | 0, g = g + Math.imul(Qe, M) | 0, w = w + Math.imul(Qe, K) | 0, k = k + Math.imul(Xe, ve) | 0, g = g + Math.imul(Xe, we) | 0, g = g + Math.imul(Re, ve) | 0, w = w + Math.imul(Re, we) | 0, k = k + Math.imul(xe, _t) | 0, g = g + Math.imul(xe, tt) | 0, g = g + Math.imul(Oe, _t) | 0, w = w + Math.imul(Oe, tt) | 0, k = k + Math.imul(se, Se) | 0, g = g + Math.imul(se, Ie) | 0, g = g + Math.imul(me, Se) | 0, w = w + Math.imul(me, Ie) | 0, k = k + Math.imul(Y, lt) | 0, g = g + Math.imul(Y, Ze) | 0, g = g + Math.imul(X, lt) | 0, w = w + Math.imul(X, Ze) | 0;
      var ms = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, k = Math.imul($t, M), g = Math.imul($t, K), g = g + Math.imul(Ge, M) | 0, w = Math.imul(Ge, K), k = k + Math.imul(rt, ve) | 0, g = g + Math.imul(rt, we) | 0, g = g + Math.imul(Qe, ve) | 0, w = w + Math.imul(Qe, we) | 0, k = k + Math.imul(Xe, _t) | 0, g = g + Math.imul(Xe, tt) | 0, g = g + Math.imul(Re, _t) | 0, w = w + Math.imul(Re, tt) | 0, k = k + Math.imul(xe, Se) | 0, g = g + Math.imul(xe, Ie) | 0, g = g + Math.imul(Oe, Se) | 0, w = w + Math.imul(Oe, Ie) | 0, k = k + Math.imul(se, lt) | 0, g = g + Math.imul(se, Ze) | 0, g = g + Math.imul(me, lt) | 0, w = w + Math.imul(me, Ze) | 0;
      var gs = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, k = Math.imul($t, ve), g = Math.imul($t, we), g = g + Math.imul(Ge, ve) | 0, w = Math.imul(Ge, we), k = k + Math.imul(rt, _t) | 0, g = g + Math.imul(rt, tt) | 0, g = g + Math.imul(Qe, _t) | 0, w = w + Math.imul(Qe, tt) | 0, k = k + Math.imul(Xe, Se) | 0, g = g + Math.imul(Xe, Ie) | 0, g = g + Math.imul(Re, Se) | 0, w = w + Math.imul(Re, Ie) | 0, k = k + Math.imul(xe, lt) | 0, g = g + Math.imul(xe, Ze) | 0, g = g + Math.imul(Oe, lt) | 0, w = w + Math.imul(Oe, Ze) | 0;
      var di = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, k = Math.imul($t, _t), g = Math.imul($t, tt), g = g + Math.imul(Ge, _t) | 0, w = Math.imul(Ge, tt), k = k + Math.imul(rt, Se) | 0, g = g + Math.imul(rt, Ie) | 0, g = g + Math.imul(Qe, Se) | 0, w = w + Math.imul(Qe, Ie) | 0, k = k + Math.imul(Xe, lt) | 0, g = g + Math.imul(Xe, Ze) | 0, g = g + Math.imul(Re, lt) | 0, w = w + Math.imul(Re, Ze) | 0;
      var ys = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (ys >>> 26) | 0, ys &= 67108863, k = Math.imul($t, Se), g = Math.imul($t, Ie), g = g + Math.imul(Ge, Se) | 0, w = Math.imul(Ge, Ie), k = k + Math.imul(rt, lt) | 0, g = g + Math.imul(rt, Ze) | 0, g = g + Math.imul(Qe, lt) | 0, w = w + Math.imul(Qe, Ze) | 0;
      var vs = (j + k | 0) + ((g & 8191) << 13) | 0;
      j = (w + (g >>> 13) | 0) + (vs >>> 26) | 0, vs &= 67108863, k = Math.imul($t, lt), g = Math.imul($t, Ze), g = g + Math.imul(Ge, lt) | 0, w = Math.imul(Ge, Ze);
      var W = (j + k | 0) + ((g & 8191) << 13) | 0;
      return j = (w + (g >>> 13) | 0) + (W >>> 26) | 0, W &= 67108863, A[0] = ot, A[1] = Et, A[2] = cr, A[3] = Kt, A[4] = Jt, A[5] = _r, A[6] = Jr, A[7] = Sr, A[8] = ur, A[9] = Kr, A[10] = li, A[11] = Cn, A[12] = fi, A[13] = ms, A[14] = gs, A[15] = di, A[16] = ys, A[17] = vs, A[18] = W, j !== 0 && (A[19] = j, m.length++), m;
    };
    Math.imul || (O = C);
    function I(L, p, d) {
      d.negative = p.negative ^ L.negative, d.length = L.length + p.length;
      for (var m = 0, x = 0, E = 0; E < d.length - 1; E++) {
        var A = x;
        x = 0;
        for (var j = m & 67108863, k = Math.min(E, p.length - 1), g = Math.max(0, E - L.length + 1); g <= k; g++) {
          var w = E - g, P = L.words[w] | 0, ue = p.words[g] | 0, ie = P * ue, fe = ie & 67108863;
          A = A + (ie / 67108864 | 0) | 0, fe = fe + j | 0, j = fe & 67108863, A = A + (fe >>> 26) | 0, x += A >>> 26, A &= 67108863;
        }
        d.words[E] = j, m = A, A = x;
      }
      return m !== 0 ? d.words[E] = m : d.length--, d._strip();
    }
    function U(L, p, d) {
      return I(L, p, d);
    }
    s.prototype.mulTo = function(p, d) {
      var m, x = this.length + p.length;
      return this.length === 10 && p.length === 10 ? m = O(this, p, d) : x < 63 ? m = C(this, p, d) : x < 1024 ? m = I(this, p, d) : m = U(this, p, d), m;
    }, s.prototype.mul = function(p) {
      var d = new s(null);
      return d.words = new Array(this.length + p.length), this.mulTo(p, d);
    }, s.prototype.mulf = function(p) {
      var d = new s(null);
      return d.words = new Array(this.length + p.length), U(this, p, d);
    }, s.prototype.imul = function(p) {
      return this.clone().mulTo(p, this);
    }, s.prototype.imuln = function(p) {
      var d = p < 0;
      d && (p = -p), n(typeof p == "number"), n(p < 67108864);
      for (var m = 0, x = 0; x < this.length; x++) {
        var E = (this.words[x] | 0) * p, A = (E & 67108863) + (m & 67108863);
        m >>= 26, m += E / 67108864 | 0, m += A >>> 26, this.words[x] = A & 67108863;
      }
      return m !== 0 && (this.words[x] = m, this.length++), this.length = p === 0 ? 1 : this.length, d ? this.ineg() : this;
    }, s.prototype.muln = function(p) {
      return this.clone().imuln(p);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(p) {
      var d = S(p);
      if (d.length === 0)
        return new s(1);
      for (var m = this, x = 0; x < d.length && d[x] === 0; x++, m = m.sqr())
        ;
      if (++x < d.length)
        for (var E = m.sqr(); x < d.length; x++, E = E.sqr())
          d[x] !== 0 && (m = m.mul(E));
      return m;
    }, s.prototype.iushln = function(p) {
      n(typeof p == "number" && p >= 0);
      var d = p % 26, m = (p - d) / 26, x = 67108863 >>> 26 - d << 26 - d, E;
      if (d !== 0) {
        var A = 0;
        for (E = 0; E < this.length; E++) {
          var j = this.words[E] & x, k = (this.words[E] | 0) - j << d;
          this.words[E] = k | A, A = j >>> 26 - d;
        }
        A && (this.words[E] = A, this.length++);
      }
      if (m !== 0) {
        for (E = this.length - 1; E >= 0; E--)
          this.words[E + m] = this.words[E];
        for (E = 0; E < m; E++)
          this.words[E] = 0;
        this.length += m;
      }
      return this._strip();
    }, s.prototype.ishln = function(p) {
      return n(this.negative === 0), this.iushln(p);
    }, s.prototype.iushrn = function(p, d, m) {
      n(typeof p == "number" && p >= 0);
      var x;
      d ? x = (d - d % 26) / 26 : x = 0;
      var E = p % 26, A = Math.min((p - E) / 26, this.length), j = 67108863 ^ 67108863 >>> E << E, k = m;
      if (x -= A, x = Math.max(0, x), k) {
        for (var g = 0; g < A; g++)
          k.words[g] = this.words[g];
        k.length = A;
      }
      if (A !== 0)
        if (this.length > A)
          for (this.length -= A, g = 0; g < this.length; g++)
            this.words[g] = this.words[g + A];
        else
          this.words[0] = 0, this.length = 1;
      var w = 0;
      for (g = this.length - 1; g >= 0 && (w !== 0 || g >= x); g--) {
        var P = this.words[g] | 0;
        this.words[g] = w << 26 - E | P >>> E, w = P & j;
      }
      return k && w !== 0 && (k.words[k.length++] = w), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(p, d, m) {
      return n(this.negative === 0), this.iushrn(p, d, m);
    }, s.prototype.shln = function(p) {
      return this.clone().ishln(p);
    }, s.prototype.ushln = function(p) {
      return this.clone().iushln(p);
    }, s.prototype.shrn = function(p) {
      return this.clone().ishrn(p);
    }, s.prototype.ushrn = function(p) {
      return this.clone().iushrn(p);
    }, s.prototype.testn = function(p) {
      n(typeof p == "number" && p >= 0);
      var d = p % 26, m = (p - d) / 26, x = 1 << d;
      if (this.length <= m)
        return !1;
      var E = this.words[m];
      return !!(E & x);
    }, s.prototype.imaskn = function(p) {
      n(typeof p == "number" && p >= 0);
      var d = p % 26, m = (p - d) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= m)
        return this;
      if (d !== 0 && m++, this.length = Math.min(m, this.length), d !== 0) {
        var x = 67108863 ^ 67108863 >>> d << d;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, s.prototype.maskn = function(p) {
      return this.clone().imaskn(p);
    }, s.prototype.iaddn = function(p) {
      return n(typeof p == "number"), n(p < 67108864), p < 0 ? this.isubn(-p) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= p ? (this.words[0] = p - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(p), this.negative = 1, this) : this._iaddn(p);
    }, s.prototype._iaddn = function(p) {
      this.words[0] += p;
      for (var d = 0; d < this.length && this.words[d] >= 67108864; d++)
        this.words[d] -= 67108864, d === this.length - 1 ? this.words[d + 1] = 1 : this.words[d + 1]++;
      return this.length = Math.max(this.length, d + 1), this;
    }, s.prototype.isubn = function(p) {
      if (n(typeof p == "number"), n(p < 67108864), p < 0)
        return this.iaddn(-p);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(p), this.negative = 1, this;
      if (this.words[0] -= p, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var d = 0; d < this.length && this.words[d] < 0; d++)
          this.words[d] += 67108864, this.words[d + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(p) {
      return this.clone().iaddn(p);
    }, s.prototype.subn = function(p) {
      return this.clone().isubn(p);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(p, d, m) {
      var x = p.length + m, E;
      this._expand(x);
      var A, j = 0;
      for (E = 0; E < p.length; E++) {
        A = (this.words[E + m] | 0) + j;
        var k = (p.words[E] | 0) * d;
        A -= k & 67108863, j = (A >> 26) - (k / 67108864 | 0), this.words[E + m] = A & 67108863;
      }
      for (; E < this.length - m; E++)
        A = (this.words[E + m] | 0) + j, j = A >> 26, this.words[E + m] = A & 67108863;
      if (j === 0)
        return this._strip();
      for (n(j === -1), j = 0, E = 0; E < this.length; E++)
        A = -(this.words[E] | 0) + j, j = A >> 26, this.words[E] = A & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(p, d) {
      var m = this.length - p.length, x = this.clone(), E = p, A = E.words[E.length - 1] | 0, j = this._countBits(A);
      m = 26 - j, m !== 0 && (E = E.ushln(m), x.iushln(m), A = E.words[E.length - 1] | 0);
      var k = x.length - E.length, g;
      if (d !== "mod") {
        g = new s(null), g.length = k + 1, g.words = new Array(g.length);
        for (var w = 0; w < g.length; w++)
          g.words[w] = 0;
      }
      var P = x.clone()._ishlnsubmul(E, 1, k);
      P.negative === 0 && (x = P, g && (g.words[k] = 1));
      for (var ue = k - 1; ue >= 0; ue--) {
        var ie = (x.words[E.length + ue] | 0) * 67108864 + (x.words[E.length + ue - 1] | 0);
        for (ie = Math.min(ie / A | 0, 67108863), x._ishlnsubmul(E, ie, ue); x.negative !== 0; )
          ie--, x.negative = 0, x._ishlnsubmul(E, 1, ue), x.isZero() || (x.negative ^= 1);
        g && (g.words[ue] = ie);
      }
      return g && g._strip(), x._strip(), d !== "div" && m !== 0 && x.iushrn(m), {
        div: g || null,
        mod: x
      };
    }, s.prototype.divmod = function(p, d, m) {
      if (n(!p.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var x, E, A;
      return this.negative !== 0 && p.negative === 0 ? (A = this.neg().divmod(p, d), d !== "mod" && (x = A.div.neg()), d !== "div" && (E = A.mod.neg(), m && E.negative !== 0 && E.iadd(p)), {
        div: x,
        mod: E
      }) : this.negative === 0 && p.negative !== 0 ? (A = this.divmod(p.neg(), d), d !== "mod" && (x = A.div.neg()), {
        div: x,
        mod: A.mod
      }) : this.negative & p.negative ? (A = this.neg().divmod(p.neg(), d), d !== "div" && (E = A.mod.neg(), m && E.negative !== 0 && E.isub(p)), {
        div: A.div,
        mod: E
      }) : p.length > this.length || this.cmp(p) < 0 ? {
        div: new s(0),
        mod: this
      } : p.length === 1 ? d === "div" ? {
        div: this.divn(p.words[0]),
        mod: null
      } : d === "mod" ? {
        div: null,
        mod: new s(this.modrn(p.words[0]))
      } : {
        div: this.divn(p.words[0]),
        mod: new s(this.modrn(p.words[0]))
      } : this._wordDiv(p, d);
    }, s.prototype.div = function(p) {
      return this.divmod(p, "div", !1).div;
    }, s.prototype.mod = function(p) {
      return this.divmod(p, "mod", !1).mod;
    }, s.prototype.umod = function(p) {
      return this.divmod(p, "mod", !0).mod;
    }, s.prototype.divRound = function(p) {
      var d = this.divmod(p);
      if (d.mod.isZero())
        return d.div;
      var m = d.div.negative !== 0 ? d.mod.isub(p) : d.mod, x = p.ushrn(1), E = p.andln(1), A = m.cmp(x);
      return A < 0 || E === 1 && A === 0 ? d.div : d.div.negative !== 0 ? d.div.isubn(1) : d.div.iaddn(1);
    }, s.prototype.modrn = function(p) {
      var d = p < 0;
      d && (p = -p), n(p <= 67108863);
      for (var m = (1 << 26) % p, x = 0, E = this.length - 1; E >= 0; E--)
        x = (m * x + (this.words[E] | 0)) % p;
      return d ? -x : x;
    }, s.prototype.modn = function(p) {
      return this.modrn(p);
    }, s.prototype.idivn = function(p) {
      var d = p < 0;
      d && (p = -p), n(p <= 67108863);
      for (var m = 0, x = this.length - 1; x >= 0; x--) {
        var E = (this.words[x] | 0) + m * 67108864;
        this.words[x] = E / p | 0, m = E % p;
      }
      return this._strip(), d ? this.ineg() : this;
    }, s.prototype.divn = function(p) {
      return this.clone().idivn(p);
    }, s.prototype.egcd = function(p) {
      n(p.negative === 0), n(!p.isZero());
      var d = this, m = p.clone();
      d.negative !== 0 ? d = d.umod(p) : d = d.clone();
      for (var x = new s(1), E = new s(0), A = new s(0), j = new s(1), k = 0; d.isEven() && m.isEven(); )
        d.iushrn(1), m.iushrn(1), ++k;
      for (var g = m.clone(), w = d.clone(); !d.isZero(); ) {
        for (var P = 0, ue = 1; !(d.words[0] & ue) && P < 26; ++P, ue <<= 1)
          ;
        if (P > 0)
          for (d.iushrn(P); P-- > 0; )
            (x.isOdd() || E.isOdd()) && (x.iadd(g), E.isub(w)), x.iushrn(1), E.iushrn(1);
        for (var ie = 0, fe = 1; !(m.words[0] & fe) && ie < 26; ++ie, fe <<= 1)
          ;
        if (ie > 0)
          for (m.iushrn(ie); ie-- > 0; )
            (A.isOdd() || j.isOdd()) && (A.iadd(g), j.isub(w)), A.iushrn(1), j.iushrn(1);
        d.cmp(m) >= 0 ? (d.isub(m), x.isub(A), E.isub(j)) : (m.isub(d), A.isub(x), j.isub(E));
      }
      return {
        a: A,
        b: j,
        gcd: m.iushln(k)
      };
    }, s.prototype._invmp = function(p) {
      n(p.negative === 0), n(!p.isZero());
      var d = this, m = p.clone();
      d.negative !== 0 ? d = d.umod(p) : d = d.clone();
      for (var x = new s(1), E = new s(0), A = m.clone(); d.cmpn(1) > 0 && m.cmpn(1) > 0; ) {
        for (var j = 0, k = 1; !(d.words[0] & k) && j < 26; ++j, k <<= 1)
          ;
        if (j > 0)
          for (d.iushrn(j); j-- > 0; )
            x.isOdd() && x.iadd(A), x.iushrn(1);
        for (var g = 0, w = 1; !(m.words[0] & w) && g < 26; ++g, w <<= 1)
          ;
        if (g > 0)
          for (m.iushrn(g); g-- > 0; )
            E.isOdd() && E.iadd(A), E.iushrn(1);
        d.cmp(m) >= 0 ? (d.isub(m), x.isub(E)) : (m.isub(d), E.isub(x));
      }
      var P;
      return d.cmpn(1) === 0 ? P = x : P = E, P.cmpn(0) < 0 && P.iadd(p), P;
    }, s.prototype.gcd = function(p) {
      if (this.isZero())
        return p.abs();
      if (p.isZero())
        return this.abs();
      var d = this.clone(), m = p.clone();
      d.negative = 0, m.negative = 0;
      for (var x = 0; d.isEven() && m.isEven(); x++)
        d.iushrn(1), m.iushrn(1);
      do {
        for (; d.isEven(); )
          d.iushrn(1);
        for (; m.isEven(); )
          m.iushrn(1);
        var E = d.cmp(m);
        if (E < 0) {
          var A = d;
          d = m, m = A;
        } else if (E === 0 || m.cmpn(1) === 0)
          break;
        d.isub(m);
      } while (!0);
      return m.iushln(x);
    }, s.prototype.invm = function(p) {
      return this.egcd(p).a.umod(p);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(p) {
      return this.words[0] & p;
    }, s.prototype.bincn = function(p) {
      n(typeof p == "number");
      var d = p % 26, m = (p - d) / 26, x = 1 << d;
      if (this.length <= m)
        return this._expand(m + 1), this.words[m] |= x, this;
      for (var E = x, A = m; E !== 0 && A < this.length; A++) {
        var j = this.words[A] | 0;
        j += E, E = j >>> 26, j &= 67108863, this.words[A] = j;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(p) {
      var d = p < 0;
      if (this.negative !== 0 && !d)
        return -1;
      if (this.negative === 0 && d)
        return 1;
      this._strip();
      var m;
      if (this.length > 1)
        m = 1;
      else {
        d && (p = -p), n(p <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        m = x === p ? 0 : x < p ? -1 : 1;
      }
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.cmp = function(p) {
      if (this.negative !== 0 && p.negative === 0)
        return -1;
      if (this.negative === 0 && p.negative !== 0)
        return 1;
      var d = this.ucmp(p);
      return this.negative !== 0 ? -d | 0 : d;
    }, s.prototype.ucmp = function(p) {
      if (this.length > p.length)
        return 1;
      if (this.length < p.length)
        return -1;
      for (var d = 0, m = this.length - 1; m >= 0; m--) {
        var x = this.words[m] | 0, E = p.words[m] | 0;
        if (x !== E) {
          x < E ? d = -1 : x > E && (d = 1);
          break;
        }
      }
      return d;
    }, s.prototype.gtn = function(p) {
      return this.cmpn(p) === 1;
    }, s.prototype.gt = function(p) {
      return this.cmp(p) === 1;
    }, s.prototype.gten = function(p) {
      return this.cmpn(p) >= 0;
    }, s.prototype.gte = function(p) {
      return this.cmp(p) >= 0;
    }, s.prototype.ltn = function(p) {
      return this.cmpn(p) === -1;
    }, s.prototype.lt = function(p) {
      return this.cmp(p) === -1;
    }, s.prototype.lten = function(p) {
      return this.cmpn(p) <= 0;
    }, s.prototype.lte = function(p) {
      return this.cmp(p) <= 0;
    }, s.prototype.eqn = function(p) {
      return this.cmpn(p) === 0;
    }, s.prototype.eq = function(p) {
      return this.cmp(p) === 0;
    }, s.red = function(p) {
      return new ce(p);
    }, s.prototype.toRed = function(p) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), p.convertTo(this)._forceRed(p);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(p) {
      return this.red = p, this;
    }, s.prototype.forceRed = function(p) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(p);
    }, s.prototype.redAdd = function(p) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, p);
    }, s.prototype.redIAdd = function(p) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, p);
    }, s.prototype.redSub = function(p) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, p);
    }, s.prototype.redISub = function(p) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, p);
    }, s.prototype.redShl = function(p) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, p);
    }, s.prototype.redMul = function(p) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.mul(this, p);
    }, s.prototype.redIMul = function(p) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, p), this.red.imul(this, p);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(p) {
      return n(this.red && !p.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, p);
    };
    var D = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function H(L, p) {
      this.name = L, this.p = new s(p, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    H.prototype._tmp = function() {
      var p = new s(null);
      return p.words = new Array(Math.ceil(this.n / 13)), p;
    }, H.prototype.ireduce = function(p) {
      var d = p, m;
      do
        this.split(d, this.tmp), d = this.imulK(d), d = d.iadd(this.tmp), m = d.bitLength();
      while (m > this.n);
      var x = m < this.n ? -1 : d.ucmp(this.p);
      return x === 0 ? (d.words[0] = 0, d.length = 1) : x > 0 ? d.isub(this.p) : d.strip !== void 0 ? d.strip() : d._strip(), d;
    }, H.prototype.split = function(p, d) {
      p.iushrn(this.n, 0, d);
    }, H.prototype.imulK = function(p) {
      return p.imul(this.k);
    };
    function z() {
      H.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(z, H), z.prototype.split = function(p, d) {
      for (var m = 4194303, x = Math.min(p.length, 9), E = 0; E < x; E++)
        d.words[E] = p.words[E];
      if (d.length = x, p.length <= 9) {
        p.words[0] = 0, p.length = 1;
        return;
      }
      var A = p.words[9];
      for (d.words[d.length++] = A & m, E = 10; E < p.length; E++) {
        var j = p.words[E] | 0;
        p.words[E - 10] = (j & m) << 4 | A >>> 22, A = j;
      }
      A >>>= 22, p.words[E - 10] = A, A === 0 && p.length > 10 ? p.length -= 10 : p.length -= 9;
    }, z.prototype.imulK = function(p) {
      p.words[p.length] = 0, p.words[p.length + 1] = 0, p.length += 2;
      for (var d = 0, m = 0; m < p.length; m++) {
        var x = p.words[m] | 0;
        d += x * 977, p.words[m] = d & 67108863, d = x * 64 + (d / 67108864 | 0);
      }
      return p.words[p.length - 1] === 0 && (p.length--, p.words[p.length - 1] === 0 && p.length--), p;
    };
    function ne() {
      H.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(ne, H);
    function le() {
      H.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(le, H);
    function te() {
      H.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(te, H), te.prototype.imulK = function(p) {
      for (var d = 0, m = 0; m < p.length; m++) {
        var x = (p.words[m] | 0) * 19 + d, E = x & 67108863;
        x >>>= 26, p.words[m] = E, d = x;
      }
      return d !== 0 && (p.words[p.length++] = d), p;
    }, s._prime = function(p) {
      if (D[p])
        return D[p];
      var d;
      if (p === "k256")
        d = new z();
      else if (p === "p224")
        d = new ne();
      else if (p === "p192")
        d = new le();
      else if (p === "p25519")
        d = new te();
      else
        throw new Error("Unknown prime " + p);
      return D[p] = d, d;
    };
    function ce(L) {
      if (typeof L == "string") {
        var p = s._prime(L);
        this.m = p.p, this.prime = p;
      } else
        n(L.gtn(1), "modulus must be greater than 1"), this.m = L, this.prime = null;
    }
    ce.prototype._verify1 = function(p) {
      n(p.negative === 0, "red works only with positives"), n(p.red, "red works only with red numbers");
    }, ce.prototype._verify2 = function(p, d) {
      n((p.negative | d.negative) === 0, "red works only with positives"), n(
        p.red && p.red === d.red,
        "red works only with red numbers"
      );
    }, ce.prototype.imod = function(p) {
      return this.prime ? this.prime.ireduce(p)._forceRed(this) : (l(p, p.umod(this.m)._forceRed(this)), p);
    }, ce.prototype.neg = function(p) {
      return p.isZero() ? p.clone() : this.m.sub(p)._forceRed(this);
    }, ce.prototype.add = function(p, d) {
      this._verify2(p, d);
      var m = p.add(d);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m._forceRed(this);
    }, ce.prototype.iadd = function(p, d) {
      this._verify2(p, d);
      var m = p.iadd(d);
      return m.cmp(this.m) >= 0 && m.isub(this.m), m;
    }, ce.prototype.sub = function(p, d) {
      this._verify2(p, d);
      var m = p.sub(d);
      return m.cmpn(0) < 0 && m.iadd(this.m), m._forceRed(this);
    }, ce.prototype.isub = function(p, d) {
      this._verify2(p, d);
      var m = p.isub(d);
      return m.cmpn(0) < 0 && m.iadd(this.m), m;
    }, ce.prototype.shl = function(p, d) {
      return this._verify1(p), this.imod(p.ushln(d));
    }, ce.prototype.imul = function(p, d) {
      return this._verify2(p, d), this.imod(p.imul(d));
    }, ce.prototype.mul = function(p, d) {
      return this._verify2(p, d), this.imod(p.mul(d));
    }, ce.prototype.isqr = function(p) {
      return this.imul(p, p.clone());
    }, ce.prototype.sqr = function(p) {
      return this.mul(p, p);
    }, ce.prototype.sqrt = function(p) {
      if (p.isZero())
        return p.clone();
      var d = this.m.andln(3);
      if (n(d % 2 === 1), d === 3) {
        var m = this.m.add(new s(1)).iushrn(2);
        return this.pow(p, m);
      }
      for (var x = this.m.subn(1), E = 0; !x.isZero() && x.andln(1) === 0; )
        E++, x.iushrn(1);
      n(!x.isZero());
      var A = new s(1).toRed(this), j = A.redNeg(), k = this.m.subn(1).iushrn(1), g = this.m.bitLength();
      for (g = new s(2 * g * g).toRed(this); this.pow(g, k).cmp(j) !== 0; )
        g.redIAdd(j);
      for (var w = this.pow(g, x), P = this.pow(p, x.addn(1).iushrn(1)), ue = this.pow(p, x), ie = E; ue.cmp(A) !== 0; ) {
        for (var fe = ue, ye = 0; fe.cmp(A) !== 0; ye++)
          fe = fe.redSqr();
        n(ye < ie);
        var Te = this.pow(w, new s(1).iushln(ie - ye - 1));
        P = P.redMul(Te), w = Te.redSqr(), ue = ue.redMul(w), ie = ye;
      }
      return P;
    }, ce.prototype.invm = function(p) {
      var d = p._invmp(this.m);
      return d.negative !== 0 ? (d.negative = 0, this.imod(d).redNeg()) : this.imod(d);
    }, ce.prototype.pow = function(p, d) {
      if (d.isZero())
        return new s(1).toRed(this);
      if (d.cmpn(1) === 0)
        return p.clone();
      var m = 4, x = new Array(1 << m);
      x[0] = new s(1).toRed(this), x[1] = p;
      for (var E = 2; E < x.length; E++)
        x[E] = this.mul(x[E - 1], p);
      var A = x[0], j = 0, k = 0, g = d.bitLength() % 26;
      for (g === 0 && (g = 26), E = d.length - 1; E >= 0; E--) {
        for (var w = d.words[E], P = g - 1; P >= 0; P--) {
          var ue = w >> P & 1;
          if (A !== x[0] && (A = this.sqr(A)), ue === 0 && j === 0) {
            k = 0;
            continue;
          }
          j <<= 1, j |= ue, k++, !(k !== m && (E !== 0 || P !== 0)) && (A = this.mul(A, x[j]), k = 0, j = 0);
        }
        g = 26;
      }
      return A;
    }, ce.prototype.convertTo = function(p) {
      var d = p.umod(this.m);
      return d === p ? d.clone() : d;
    }, ce.prototype.convertFrom = function(p) {
      var d = p.clone();
      return d.red = null, d;
    }, s.mont = function(p) {
      return new V(p);
    };
    function V(L) {
      ce.call(this, L), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(V, ce), V.prototype.convertTo = function(p) {
      return this.imod(p.ushln(this.shift));
    }, V.prototype.convertFrom = function(p) {
      var d = this.imod(p.mul(this.rinv));
      return d.red = null, d;
    }, V.prototype.imul = function(p, d) {
      if (p.isZero() || d.isZero())
        return p.words[0] = 0, p.length = 1, p;
      var m = p.imul(d), x = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = m.isub(x).iushrn(this.shift), A = E;
      return E.cmp(this.m) >= 0 ? A = E.isub(this.m) : E.cmpn(0) < 0 && (A = E.iadd(this.m)), A._forceRed(this);
    }, V.prototype.mul = function(p, d) {
      if (p.isZero() || d.isZero())
        return new s(0)._forceRed(this);
      var m = p.mul(d), x = m.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = m.isub(x).iushrn(this.shift), A = E;
      return E.cmp(this.m) >= 0 ? A = E.isub(this.m) : E.cmpn(0) < 0 && (A = E.iadd(this.m)), A._forceRed(this);
    }, V.prototype.invm = function(p) {
      var d = this.imod(p._invmp(this.m).mul(this.r2));
      return d._forceRed(this);
    };
  })(e, Yr);
})(Qg);
var dS = Qg.exports;
const cv = /* @__PURE__ */ Yu(dS);
var yL = Yr && Yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(oi, "__esModule", { value: !0 });
oi.parseAccumulatorUpdateData = oi.sliceAccumulatorUpdateData = oi.parseTwapMessage = oi.parsePriceFeedMessage = oi.isAccumulatorUpdateData = void 0;
const Qn = yL(dS), vL = "504e4155", bL = 1, wL = 0, U0 = 20, _L = 0, xL = 1;
function e1(e) {
  return e.toString("hex").slice(0, 8) === vL && e[4] === bL && e[5] === wL;
}
oi.isAccumulatorUpdateData = e1;
function SL(e) {
  let t = 0;
  if (e.readUInt8(t) !== _L)
    throw new Error("Not a price feed message");
  t += 1;
  const n = e.subarray(t, t + 32);
  t += 32;
  const i = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const s = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const o = e.readInt32BE(t);
  t += 4;
  const a = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const c = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const u = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const l = new Qn.default(e.subarray(t, t + 8), "be");
  return t += 8, {
    feedId: n,
    price: i,
    confidence: s,
    exponent: o,
    publishTime: a,
    prevPublishTime: c,
    emaPrice: u,
    emaConf: l
  };
}
oi.parsePriceFeedMessage = SL;
function EL(e) {
  let t = 0;
  if (e.readUInt8(t) !== xL)
    throw new Error("Not a twap message");
  t += 1;
  const n = e.subarray(t, t + 32);
  t += 32;
  const i = new Qn.default(e.subarray(t, t + 16), "be");
  t += 16;
  const s = new Qn.default(e.subarray(t, t + 16), "be");
  t += 16;
  const o = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const a = e.readInt32BE(t);
  t += 4;
  const c = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const u = new Qn.default(e.subarray(t, t + 8), "be");
  t += 8;
  const l = new Qn.default(e.subarray(t, t + 8), "be");
  return t += 8, {
    feedId: n,
    cumulativePrice: i,
    cumulativeConf: s,
    numDownSlots: o,
    exponent: a,
    publishTime: c,
    prevPublishTime: u,
    publishSlot: l
  };
}
oi.parseTwapMessage = EL;
function TL(e, t, r) {
  if (!e1(e))
    throw new Error("Invalid accumulator message");
  let n = 6;
  const i = e.readUint8(n);
  n += 1 + i, n += 1;
  const s = e.readUint16BE(n);
  n += 2, n += s;
  const o = n, a = [], c = e.readUInt8(n);
  n += 1;
  for (let l = 0; l < c; l++) {
    const f = n, h = e.readUint16BE(n);
    n += 2, n += h;
    const v = e.readUInt8(n);
    n += 1, n += U0 * v, a.push(e.subarray(f, n));
  }
  if (n !== e.length)
    throw new Error("Didn't reach the end of the message");
  const u = a.slice(t, r);
  return Yf.concat([
    e.subarray(0, o),
    Yf.from([u.length]),
    ...a.slice(t, r)
  ]);
}
oi.sliceAccumulatorUpdateData = TL;
function CL(e) {
  if (!e1(e))
    throw new Error("Invalid accumulator message");
  let t = 6;
  const r = e.readUint8(t);
  t += 1 + r, t += 1;
  const n = e.readUint16BE(t);
  t += 2;
  const i = e.subarray(t, t + n);
  t += n;
  const s = e.readUInt8(t), o = [];
  t += 1;
  for (let a = 0; a < s; a++) {
    const c = e.readUint16BE(t);
    t += 2;
    const u = e.subarray(t, t + c);
    t += c;
    const l = e.readUInt8(t);
    t += 1;
    const f = [];
    for (let h = 0; h < l; h++)
      f.push(Array.from(e.subarray(t, t + U0))), t += U0;
    o.push({ message: u, proof: f });
  }
  if (t !== e.length)
    throw new Error("Didn't reach the end of the message");
  return { vaa: i, updates: o };
}
oi.parseAccumulatorUpdateData = CL;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PriceFeed = e.PriceFeedMetadata = e.Price = e.parseTwapMessage = e.parsePriceFeedMessage = e.parseAccumulatorUpdateData = e.sliceAccumulatorUpdateData = e.isAccumulatorUpdateData = void 0;
  const t = Pd;
  var r = oi;
  Object.defineProperty(e, "isAccumulatorUpdateData", { enumerable: !0, get: function() {
    return r.isAccumulatorUpdateData;
  } }), Object.defineProperty(e, "sliceAccumulatorUpdateData", { enumerable: !0, get: function() {
    return r.sliceAccumulatorUpdateData;
  } }), Object.defineProperty(e, "parseAccumulatorUpdateData", { enumerable: !0, get: function() {
    return r.parseAccumulatorUpdateData;
  } }), Object.defineProperty(e, "parsePriceFeedMessage", { enumerable: !0, get: function() {
    return r.parsePriceFeedMessage;
  } }), Object.defineProperty(e, "parseTwapMessage", { enumerable: !0, get: function() {
    return r.parseTwapMessage;
  } });
  class n {
    constructor(a) {
      Pt(this, "conf");
      Pt(this, "expo");
      Pt(this, "price");
      Pt(this, "publishTime");
      this.conf = a.conf, this.expo = a.expo, this.price = a.price, this.publishTime = a.publishTime;
    }
    /**
     * Get price as number. Warning: this conversion might result in an inaccurate number.
     * We store price and confidence values in our Oracle at 64-bit precision, but the JavaScript
     * number type can only represent numbers with 52-bit precision. So if a price or confidence
     * is larger than 52-bits, the conversion will lose the most insignificant bits.
     *
     * @returns a floating point number representing the price
     */
    getPriceAsNumberUnchecked() {
      return Number(this.price) * 10 ** this.expo;
    }
    /**
     * Get price as number. Warning: this conversion might result in an inaccurate number.
     * Explanation is the same as `priceAsNumberUnchecked()` documentation.
     *
     * @returns a floating point number representing the price
     */
    getConfAsNumberUnchecked() {
      return Number(this.conf) * 10 ** this.expo;
    }
    static fromJson(a) {
      const c = t.Convert.toPrice(a);
      return new n({
        conf: c.conf,
        expo: c.expo,
        price: c.price,
        publishTime: c.publish_time
      });
    }
    toJson() {
      const a = {
        conf: this.conf,
        expo: this.expo,
        price: this.price,
        publish_time: this.publishTime
      };
      return t.Convert.priceToJson(a);
    }
  }
  e.Price = n;
  class i {
    constructor(a) {
      /**
       * Attestation time of the price
       */
      Pt(this, "attestationTime");
      /**
       * Chain of the emitter
       */
      Pt(this, "emitterChain");
      /**
       * The time that the price service received the price
       */
      Pt(this, "priceServiceReceiveTime");
      /**
       * Sequence number of the price
       */
      Pt(this, "sequenceNumber");
      /**
       * Pythnet slot number of the price
       */
      Pt(this, "slot");
      /**
       * The time that the previous price was published
       */
      Pt(this, "prevPublishTime");
      this.attestationTime = a.attestationTime, this.emitterChain = a.emitterChain, this.priceServiceReceiveTime = a.receiveTime, this.sequenceNumber = a.sequenceNumber, this.slot = a.slot, this.prevPublishTime = a.prevPublishTime;
    }
    static fromJson(a) {
      if (a === void 0)
        return;
      const c = t.Convert.toPriceFeedMetadata(a);
      return new i({
        attestationTime: c.attestation_time,
        emitterChain: c.emitter_chain,
        receiveTime: c.price_service_receive_time,
        sequenceNumber: c.sequence_number,
        slot: c.slot,
        prevPublishTime: c.prev_publish_time
      });
    }
    toJson() {
      const a = {
        attestation_time: this.attestationTime,
        emitter_chain: this.emitterChain,
        price_service_receive_time: this.priceServiceReceiveTime,
        sequence_number: this.sequenceNumber,
        slot: this.slot,
        prev_publish_time: this.prevPublishTime
      };
      return t.Convert.priceFeedMetadataToJson(a);
    }
  }
  e.PriceFeedMetadata = i;
  let s = class hS {
    constructor(a) {
      /**
       * Exponentially-weighted moving average Price
       */
      Pt(this, "emaPrice");
      /**
       * Unique identifier for this price.
       */
      Pt(this, "id");
      /**
       * Metadata of the price
       */
      Pt(this, "metadata");
      /**
       * VAA of the price
       */
      Pt(this, "vaa");
      /**
       * Price
       */
      Pt(this, "price");
      this.emaPrice = a.emaPrice, this.id = a.id, this.metadata = a.metadata, this.vaa = a.vaa, this.price = a.price;
    }
    static fromJson(a) {
      const c = t.Convert.toPriceFeed(a);
      return new hS({
        emaPrice: n.fromJson(c.ema_price),
        id: c.id,
        metadata: i.fromJson(c.metadata),
        vaa: c.vaa,
        price: n.fromJson(c.price)
      });
    }
    toJson() {
      var c;
      const a = {
        ema_price: this.emaPrice.toJson(),
        id: this.id,
        metadata: (c = this.metadata) == null ? void 0 : c.toJson(),
        price: this.price.toJson()
      };
      return t.Convert.priceFeedToJson(a);
    }
    /**
     * Get the price and confidence interval as fixed-point numbers of the form a * 10^e.
     * This function returns the current best estimate of the price at the time that this `PriceFeed` was
     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
     * makes no guarantees that the returned price is recent or useful for any particular application.
     *
     * Users of this function should check the returned `publishTime` to ensure that the returned price is
     * sufficiently recent for their application. If you are considering using this function, it may be
     * safer / easier to use `getPriceNoOlderThan` method.
     *
     * @returns a Price that contains the price and confidence interval along with
     * the exponent for them, and publish time of the price.
     */
    getPriceUnchecked() {
      return this.price;
    }
    /**
     * Get the exponentially-weighted moving average (EMA) price and confidence interval.
     *
     * This function returns the current best estimate of the price at the time that this `PriceFeed` was
     * published (`publishTime`). The returned price can be from arbitrarily far in the past; this function
     * makes no guarantees that the returned price is recent or useful for any particular application.
     *
     * Users of this function should check the returned `publishTime` to ensure that the returned price is
     * sufficiently recent for their application. If you are considering using this function, it may be
     * safer / easier to use `getEmaPriceNoOlderThan` method.
     *
     * At the moment, the confidence interval returned by this method is computed in
     * a somewhat questionable way, so we do not recommend using it for high-value applications.
     *
     * @returns a Price that contains the EMA price and confidence interval along with
     * the exponent for them, and publish time of the price.
     */
    getEmaPriceUnchecked() {
      return this.emaPrice;
    }
    /**
     * Get the price if it was updated no older than `age` seconds of the current time.
     *
     * This function is a sanity-checked version of `getPriceUnchecked` which is useful in
     * applications that require a sufficiently-recent price. Returns `undefined` if the price
     * is not recent enough.
     *
     * @param age return a price as long as it has been updated within this number of seconds
     * @returns a Price struct containing the price, confidence interval along with the exponent for
     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
     */
    getPriceNoOlderThan(a) {
      const c = this.getPriceUnchecked(), u = Math.floor(Date.now() / 1e3);
      if (!(Math.abs(u - c.publishTime) > a))
        return c;
    }
    /**
     * Get the exponentially-weighted moving average (EMA) price if it was updated no older than
     * `age` seconds of the current time.
     *
     * This function is a sanity-checked version of `getEmaPriceUnchecked` which is useful in
     * applications that require a sufficiently-recent price. Returns `undefined` if the price
     * is not recent enough.
     *
     * At the moment, the confidence interval returned by this method is computed in
     * a somewhat questionable way, so we do not recommend using it for high-value applications.
     *
     * @param age return a price as long as it has been updated within this number of seconds
     * @returns a Price struct containing the EMA price, confidence interval along with the exponent for
     * both numbers, and its publish time, or `undefined` if no price update occurred within `age` seconds of the current time.
     */
    getEmaPriceNoOlderThan(a) {
      const c = this.getEmaPriceUnchecked(), u = Math.floor(Date.now() / 1e3);
      if (!(Math.abs(u - c.publishTime) > a))
        return c;
    }
    /**
     * Get the price feed metadata.
     *
     * @returns a struct containing the attestation time, emitter chain, and the sequence number.
     * Returns `undefined` if metadata is currently unavailable.
     */
    getMetadata() {
      return this.metadata;
    }
    /**
     * Get the price feed vaa.
     *
     * @returns vaa in base64.
     * Returns `undefined` if vaa is unavailable.
     */
    getVAA() {
      return this.vaa;
    }
  };
  e.PriceFeed = s;
})(Zg);
function pS(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: AL } = Object.prototype, { getPrototypeOf: t1 } = Object, { iterator: $d, toStringTag: mS } = Symbol, Dd = ((e) => (t) => {
  const r = AL.call(t);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Pi = (e) => (e = e.toLowerCase(), (t) => Dd(t) === e), Ld = (e) => (t) => typeof t === e, { isArray: Oc } = Array, Ru = Ld("undefined");
function al(e) {
  return e !== null && !Ru(e) && e.constructor !== null && !Ru(e.constructor) && Pn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const gS = Pi("ArrayBuffer");
function ML(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && gS(e.buffer), t;
}
const OL = Ld("string"), Pn = Ld("function"), yS = Ld("number"), cl = (e) => e !== null && typeof e == "object", IL = (e) => e === !0 || e === !1, df = (e) => {
  if (Dd(e) !== "object")
    return !1;
  const t = t1(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(mS in e) && !($d in e);
}, kL = (e) => {
  if (!cl(e) || al(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, jL = Pi("Date"), RL = Pi("File"), PL = Pi("Blob"), NL = Pi("FileList"), $L = (e) => cl(e) && Pn(e.pipe), DL = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Pn(e.append) && ((t = Dd(e)) === "formdata" || // detect form-data instance
  t === "object" && Pn(e.toString) && e.toString() === "[object FormData]"));
}, LL = Pi("URLSearchParams"), [BL, UL, FL, VL] = ["ReadableStream", "Request", "Response", "Headers"].map(Pi), zL = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ul(e, t, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let n, i;
  if (typeof e != "object" && (e = [e]), Oc(e))
    for (n = 0, i = e.length; n < i; n++)
      t.call(null, e[n], n, e);
  else {
    if (al(e))
      return;
    const s = r ? Object.getOwnPropertyNames(e) : Object.keys(e), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], t.call(null, e[a], a, e);
  }
}
function vS(e, t) {
  if (al(e))
    return null;
  t = t.toLowerCase();
  const r = Object.keys(e);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], t === i.toLowerCase())
      return i;
  return null;
}
const fa = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Yr)(), bS = (e) => !Ru(e) && e !== fa;
function F0() {
  const { caseless: e } = bS(this) && this || {}, t = {}, r = (n, i) => {
    const s = e && vS(t, i) || i;
    df(t[s]) && df(n) ? t[s] = F0(t[s], n) : df(n) ? t[s] = F0({}, n) : Oc(n) ? t[s] = n.slice() : t[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && ul(arguments[n], r);
  return t;
}
const WL = (e, t, r, { allOwnKeys: n } = {}) => (ul(t, (i, s) => {
  r && Pn(i) ? e[s] = pS(i, r) : e[s] = i;
}, { allOwnKeys: n }), e), qL = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), HL = (e, t, r, n) => {
  e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), r && Object.assign(e.prototype, r);
}, GL = (e, t, r, n) => {
  let i, s, o;
  const a = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, e, t)) && !a[o] && (t[o] = e[o], a[o] = !0);
    e = r !== !1 && t1(e);
  } while (e && (!r || r(e, t)) && e !== Object.prototype);
  return t;
}, KL = (e, t, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= t.length;
  const n = e.indexOf(t, r);
  return n !== -1 && n === r;
}, YL = (e) => {
  if (!e)
    return null;
  if (Oc(e))
    return e;
  let t = e.length;
  if (!yS(t))
    return null;
  const r = new Array(t);
  for (; t-- > 0; )
    r[t] = e[t];
  return r;
}, XL = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && t1(Uint8Array)), JL = (e, t) => {
  const n = (e && e[$d]).call(e);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    t.call(e, s[0], s[1]);
  }
}, ZL = (e, t) => {
  let r;
  const n = [];
  for (; (r = e.exec(t)) !== null; )
    n.push(r);
  return n;
}, QL = Pi("HTMLFormElement"), eB = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), uv = (({ hasOwnProperty: e }) => (t, r) => e.call(t, r))(Object.prototype), tB = Pi("RegExp"), wS = (e, t) => {
  const r = Object.getOwnPropertyDescriptors(e), n = {};
  ul(r, (i, s) => {
    let o;
    (o = t(i, s, e)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(e, n);
}, rB = (e) => {
  wS(e, (t, r) => {
    if (Pn(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = e[r];
    if (Pn(n)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, nB = (e, t) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return Oc(e) ? n(e) : n(String(e).split(t)), r;
}, iB = () => {
}, sB = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function oB(e) {
  return !!(e && Pn(e.append) && e[mS] === "FormData" && e[$d]);
}
const aB = (e) => {
  const t = new Array(10), r = (n, i) => {
    if (cl(n)) {
      if (t.indexOf(n) >= 0)
        return;
      if (al(n))
        return n;
      if (!("toJSON" in n)) {
        t[i] = n;
        const s = Oc(n) ? [] : {};
        return ul(n, (o, a) => {
          const c = r(o, i + 1);
          !Ru(c) && (s[a] = c);
        }), t[i] = void 0, s;
      }
    }
    return n;
  };
  return r(e, 0);
}, cB = Pi("AsyncFunction"), uB = (e) => e && (cl(e) || Pn(e)) && Pn(e.then) && Pn(e.catch), _S = ((e, t) => e ? setImmediate : t ? ((r, n) => (fa.addEventListener("message", ({ source: i, data: s }) => {
  i === fa && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), fa.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Pn(fa.postMessage)
), lB = typeof queueMicrotask < "u" ? queueMicrotask.bind(fa) : typeof Rn < "u" && Rn.nextTick || _S, fB = (e) => e != null && Pn(e[$d]);
var Ce = {
  isArray: Oc,
  isArrayBuffer: gS,
  isBuffer: al,
  isFormData: DL,
  isArrayBufferView: ML,
  isString: OL,
  isNumber: yS,
  isBoolean: IL,
  isObject: cl,
  isPlainObject: df,
  isEmptyObject: kL,
  isReadableStream: BL,
  isRequest: UL,
  isResponse: FL,
  isHeaders: VL,
  isUndefined: Ru,
  isDate: jL,
  isFile: RL,
  isBlob: PL,
  isRegExp: tB,
  isFunction: Pn,
  isStream: $L,
  isURLSearchParams: LL,
  isTypedArray: XL,
  isFileList: NL,
  forEach: ul,
  merge: F0,
  extend: WL,
  trim: zL,
  stripBOM: qL,
  inherits: HL,
  toFlatObject: GL,
  kindOf: Dd,
  kindOfTest: Pi,
  endsWith: KL,
  toArray: YL,
  forEachEntry: JL,
  matchAll: ZL,
  isHTMLForm: QL,
  hasOwnProperty: uv,
  hasOwnProp: uv,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: wS,
  freezeMethods: rB,
  toObjectSet: nB,
  toCamelCase: eB,
  noop: iB,
  toFiniteNumber: sB,
  findKey: vS,
  global: fa,
  isContextDefined: bS,
  isSpecCompliantForm: oB,
  toJSONObject: aB,
  isAsyncFn: cB,
  isThenable: uB,
  setImmediate: _S,
  asap: lB,
  isIterable: fB
};
function jt(e, t, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Ce.inherits(jt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Ce.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const xS = jt.prototype, SS = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  SS[e] = { value: e };
});
Object.defineProperties(jt, SS);
Object.defineProperty(xS, "isAxiosError", { value: !0 });
jt.from = (e, t, r, n, i, s) => {
  const o = Object.create(xS);
  return Ce.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (a) => a !== "isAxiosError"), jt.call(o, e.message, t, r, n, i), o.cause = e, o.name = e.name, s && Object.assign(o, s), o;
};
var dB = null;
function V0(e) {
  return Ce.isPlainObject(e) || Ce.isArray(e);
}
function ES(e) {
  return Ce.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function lv(e, t, r) {
  return e ? e.concat(t).map(function(i, s) {
    return i = ES(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : t;
}
function hB(e) {
  return Ce.isArray(e) && !e.some(V0);
}
const pB = Ce.toFlatObject(Ce, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Bd(e, t, r) {
  if (!Ce.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), r = Ce.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(y, S) {
    return !Ce.isUndefined(S[y]);
  });
  const n = r.metaTokens, i = r.visitor || l, s = r.dots, o = r.indexes, c = (r.Blob || typeof Blob < "u" && Blob) && Ce.isSpecCompliantForm(t);
  if (!Ce.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(b) {
    if (b === null)
      return "";
    if (Ce.isDate(b))
      return b.toISOString();
    if (Ce.isBoolean(b))
      return b.toString();
    if (!c && Ce.isBlob(b))
      throw new jt("Blob is not supported. Use a Buffer instead.");
    return Ce.isArrayBuffer(b) || Ce.isTypedArray(b) ? c && typeof Blob == "function" ? new Blob([b]) : Yf.from(b) : b;
  }
  function l(b, y, S) {
    let C = b;
    if (b && !S && typeof b == "object") {
      if (Ce.endsWith(y, "{}"))
        y = n ? y : y.slice(0, -2), b = JSON.stringify(b);
      else if (Ce.isArray(b) && hB(b) || (Ce.isFileList(b) || Ce.endsWith(y, "[]")) && (C = Ce.toArray(b)))
        return y = ES(y), C.forEach(function(I, U) {
          !(Ce.isUndefined(I) || I === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? lv([y], U, s) : o === null ? y : y + "[]",
            u(I)
          );
        }), !1;
    }
    return V0(b) ? !0 : (t.append(lv(S, y, s), u(b)), !1);
  }
  const f = [], h = Object.assign(pB, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: V0
  });
  function v(b, y) {
    if (!Ce.isUndefined(b)) {
      if (f.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + y.join("."));
      f.push(b), Ce.forEach(b, function(C, O) {
        (!(Ce.isUndefined(C) || C === null) && i.call(
          t,
          C,
          Ce.isString(O) ? O.trim() : O,
          y,
          h
        )) === !0 && v(C, y ? y.concat(O) : [O]);
      }), f.pop();
    }
  }
  if (!Ce.isObject(e))
    throw new TypeError("data must be an object");
  return v(e), t;
}
function fv(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(n) {
    return t[n];
  });
}
function r1(e, t) {
  this._pairs = [], e && Bd(e, this, t);
}
const TS = r1.prototype;
TS.append = function(t, r) {
  this._pairs.push([t, r]);
};
TS.toString = function(t) {
  const r = t ? function(n) {
    return t.call(this, n, fv);
  } : fv;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function mB(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function CS(e, t, r) {
  if (!t)
    return e;
  const n = r && r.encode || mB;
  Ce.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(t, r) : s = Ce.isURLSearchParams(t) ? t.toString() : new r1(t, r).toString(n), s) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class gB {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, r, n) {
    return this.handlers.push({
      fulfilled: t,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    Ce.forEach(this.handlers, function(n) {
      n !== null && t(n);
    });
  }
}
var dv = gB, AS = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, yB = typeof URLSearchParams < "u" ? URLSearchParams : r1, vB = typeof FormData < "u" ? FormData : null, bB = typeof Blob < "u" ? Blob : null, wB = {
  isBrowser: !0,
  classes: {
    URLSearchParams: yB,
    FormData: vB,
    Blob: bB
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const n1 = typeof window < "u" && typeof document < "u", z0 = typeof navigator == "object" && navigator || void 0, _B = n1 && (!z0 || ["ReactNative", "NativeScript", "NS"].indexOf(z0.product) < 0), xB = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), SB = n1 && window.location.href || "http://localhost";
var EB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hasBrowserEnv: n1,
  hasStandardBrowserWebWorkerEnv: xB,
  hasStandardBrowserEnv: _B,
  navigator: z0,
  origin: SB
}), dn = {
  ...EB,
  ...wB
};
function TB(e, t) {
  return Bd(e, new dn.classes.URLSearchParams(), {
    visitor: function(r, n, i, s) {
      return dn.isNode && Ce.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function CB(e) {
  return Ce.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function AB(e) {
  const t = {}, r = Object.keys(e);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], t[s] = e[s];
  return t;
}
function MS(e) {
  function t(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__")
      return !0;
    const a = Number.isFinite(+o), c = s >= r.length;
    return o = !o && Ce.isArray(i) ? i.length : o, c ? (Ce.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Ce.isObject(i[o])) && (i[o] = []), t(r, n, i[o], s) && Ce.isArray(i[o]) && (i[o] = AB(i[o])), !a);
  }
  if (Ce.isFormData(e) && Ce.isFunction(e.entries)) {
    const r = {};
    return Ce.forEachEntry(e, (n, i) => {
      t(CB(n), i, r, 0);
    }), r;
  }
  return null;
}
function MB(e, t, r) {
  if (Ce.isString(e))
    try {
      return (t || JSON.parse)(e), Ce.trim(e);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(e);
}
const i1 = {
  transitional: AS,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Ce.isObject(t);
    if (s && Ce.isHTMLForm(t) && (t = new FormData(t)), Ce.isFormData(t))
      return i ? JSON.stringify(MS(t)) : t;
    if (Ce.isArrayBuffer(t) || Ce.isBuffer(t) || Ce.isStream(t) || Ce.isFile(t) || Ce.isBlob(t) || Ce.isReadableStream(t))
      return t;
    if (Ce.isArrayBufferView(t))
      return t.buffer;
    if (Ce.isURLSearchParams(t))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return TB(t, this.formSerializer).toString();
      if ((a = Ce.isFileList(t)) || n.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Bd(
          a ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), MB(t)) : t;
  }],
  transformResponse: [function(t) {
    const r = this.transitional || i1.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Ce.isResponse(t) || Ce.isReadableStream(t))
      return t;
    if (t && Ce.isString(t) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? jt.from(a, jt.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: dn.classes.FormData,
    Blob: dn.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Ce.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  i1.headers[e] = {};
});
var s1 = i1;
const OB = Ce.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var IB = (e) => {
  const t = {};
  let r, n, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || t[r] && OB[r]) && (r === "set-cookie" ? t[r] ? t[r].push(n) : t[r] = [n] : t[r] = t[r] ? t[r] + ", " + n : n);
  }), t;
};
const hv = Symbol("internals");
function eu(e) {
  return e && String(e).trim().toLowerCase();
}
function hf(e) {
  return e === !1 || e == null ? e : Ce.isArray(e) ? e.map(hf) : String(e);
}
function kB(e) {
  const t = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(e); )
    t[n[1]] = n[2];
  return t;
}
const jB = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function ap(e, t, r, n, i) {
  if (Ce.isFunction(n))
    return n.call(this, t, r);
  if (i && (t = r), !!Ce.isString(t)) {
    if (Ce.isString(n))
      return t.indexOf(n) !== -1;
    if (Ce.isRegExp(n))
      return n.test(t);
  }
}
function RB(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, r, n) => r.toUpperCase() + n);
}
function PB(e, t) {
  const r = Ce.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(e, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, t, i, s, o);
      },
      configurable: !0
    });
  });
}
class Ud {
  constructor(t) {
    t && this.set(t);
  }
  set(t, r, n) {
    const i = this;
    function s(a, c, u) {
      const l = eu(c);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const f = Ce.findKey(i, l);
      (!f || i[f] === void 0 || u === !0 || u === void 0 && i[f] !== !1) && (i[f || c] = hf(a));
    }
    const o = (a, c) => Ce.forEach(a, (u, l) => s(u, l, c));
    if (Ce.isPlainObject(t) || t instanceof this.constructor)
      o(t, r);
    else if (Ce.isString(t) && (t = t.trim()) && !jB(t))
      o(IB(t), r);
    else if (Ce.isObject(t) && Ce.isIterable(t)) {
      let a = {}, c, u;
      for (const l of t) {
        if (!Ce.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        a[u = l[0]] = (c = a[u]) ? Ce.isArray(c) ? [...c, l[1]] : [c, l[1]] : l[1];
      }
      o(a, r);
    } else
      t != null && s(r, t, n);
    return this;
  }
  get(t, r) {
    if (t = eu(t), t) {
      const n = Ce.findKey(this, t);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return kB(i);
        if (Ce.isFunction(r))
          return r.call(this, i, n);
        if (Ce.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, r) {
    if (t = eu(t), t) {
      const n = Ce.findKey(this, t);
      return !!(n && this[n] !== void 0 && (!r || ap(this, this[n], n, r)));
    }
    return !1;
  }
  delete(t, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = eu(o), o) {
        const a = Ce.findKey(n, o);
        a && (!r || ap(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Ce.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!t || ap(this, this[s], s, t, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(t) {
    const r = this, n = {};
    return Ce.forEach(this, (i, s) => {
      const o = Ce.findKey(n, s);
      if (o) {
        r[o] = hf(i), delete r[s];
        return;
      }
      const a = t ? RB(s) : String(s).trim();
      a !== s && delete r[s], r[a] = hf(i), n[a] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const r = /* @__PURE__ */ Object.create(null);
    return Ce.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = t && Ce.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, r]) => t + ": " + r).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...r) {
    const n = new this(t);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(t) {
    const n = (this[hv] = this[hv] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = eu(o);
      n[a] || (PB(i, o), n[a] = !0);
    }
    return Ce.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
Ud.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Ce.reduceDescriptors(Ud.prototype, ({ value: e }, t) => {
  let r = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(n) {
      this[r] = n;
    }
  };
});
Ce.freezeMethods(Ud);
var Ai = Ud;
function cp(e, t) {
  const r = this || s1, n = t || r, i = Ai.from(n.headers);
  let s = n.data;
  return Ce.forEach(e, function(a) {
    s = a.call(r, s, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), s;
}
function OS(e) {
  return !!(e && e.__CANCEL__);
}
function Ic(e, t, r) {
  jt.call(this, e ?? "canceled", jt.ERR_CANCELED, t, r), this.name = "CanceledError";
}
Ce.inherits(Ic, jt, {
  __CANCEL__: !0
});
function IS(e, t, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? e(r) : t(new jt(
    "Request failed with status code " + r.status,
    [jt.ERR_BAD_REQUEST, jt.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function NB(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function $B(e, t) {
  e = e || 10;
  const r = new Array(e), n = new Array(e);
  let i = 0, s = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const u = Date.now(), l = n[s];
    o || (o = u), r[i] = c, n[i] = u;
    let f = s, h = 0;
    for (; f !== i; )
      h += r[f++], f = f % e;
    if (i = (i + 1) % e, i === s && (s = (s + 1) % e), u - o < t)
      return;
    const v = l && u - l;
    return v ? Math.round(h * 1e3 / v) : void 0;
  };
}
function DB(e, t) {
  let r = 0, n = 1e3 / t, i, s;
  const o = (u, l = Date.now()) => {
    r = l, i = null, s && (clearTimeout(s), s = null), e(...u);
  };
  return [(...u) => {
    const l = Date.now(), f = l - r;
    f >= n ? o(u, l) : (i = u, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - f)));
  }, () => i && o(i)];
}
const Xf = (e, t, r = 3) => {
  let n = 0;
  const i = $B(50, 250);
  return DB((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - n, u = i(c), l = o <= a;
    n = o;
    const f = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: c,
      rate: u || void 0,
      estimated: u && a && l ? (a - o) / u : void 0,
      event: s,
      lengthComputable: a != null,
      [t ? "download" : "upload"]: !0
    };
    e(f);
  }, r);
}, pv = (e, t) => {
  const r = e != null;
  return [(n) => t[0]({
    lengthComputable: r,
    total: e,
    loaded: n
  }), t[1]];
}, mv = (e) => (...t) => Ce.asap(() => e(...t));
var LB = dn.hasStandardBrowserEnv ? ((e, t) => (r) => (r = new URL(r, dn.origin), e.protocol === r.protocol && e.host === r.host && (t || e.port === r.port)))(
  new URL(dn.origin),
  dn.navigator && /(msie|trident)/i.test(dn.navigator.userAgent)
) : () => !0, BB = dn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, r, n, i, s) {
      const o = [e + "=" + encodeURIComponent(t)];
      Ce.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Ce.isString(n) && o.push("path=" + n), Ce.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function UB(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function FB(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function kS(e, t, r) {
  let n = !UB(t);
  return e && (n || r == !1) ? FB(e, t) : t;
}
const gv = (e) => e instanceof Ai ? { ...e } : e;
function _a(e, t) {
  t = t || {};
  const r = {};
  function n(u, l, f, h) {
    return Ce.isPlainObject(u) && Ce.isPlainObject(l) ? Ce.merge.call({ caseless: h }, u, l) : Ce.isPlainObject(l) ? Ce.merge({}, l) : Ce.isArray(l) ? l.slice() : l;
  }
  function i(u, l, f, h) {
    if (Ce.isUndefined(l)) {
      if (!Ce.isUndefined(u))
        return n(void 0, u, f, h);
    } else
      return n(u, l, f, h);
  }
  function s(u, l) {
    if (!Ce.isUndefined(l))
      return n(void 0, l);
  }
  function o(u, l) {
    if (Ce.isUndefined(l)) {
      if (!Ce.isUndefined(u))
        return n(void 0, u);
    } else
      return n(void 0, l);
  }
  function a(u, l, f) {
    if (f in t)
      return n(u, l);
    if (f in e)
      return n(void 0, u);
  }
  const c = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (u, l, f) => i(gv(u), gv(l), f, !0)
  };
  return Ce.forEach(Object.keys({ ...e, ...t }), function(l) {
    const f = c[l] || i, h = f(e[l], t[l], l);
    Ce.isUndefined(h) && f !== a || (r[l] = h);
  }), r;
}
var jS = (e) => {
  const t = _a({}, e);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = t;
  t.headers = o = Ai.from(o), t.url = CS(kS(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let c;
  if (Ce.isFormData(r)) {
    if (dn.hasStandardBrowserEnv || dn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((c = o.getContentType()) !== !1) {
      const [u, ...l] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
      o.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (dn.hasStandardBrowserEnv && (n && Ce.isFunction(n) && (n = n(t)), n || n !== !1 && LB(t.url))) {
    const u = i && s && BB.read(s);
    u && o.set(i, u);
  }
  return t;
};
const VB = typeof XMLHttpRequest < "u";
var zB = VB && function(e) {
  return new Promise(function(r, n) {
    const i = jS(e);
    let s = i.data;
    const o = Ai.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: c, onDownloadProgress: u } = i, l, f, h, v, b;
    function y() {
      v && v(), b && b(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let S = new XMLHttpRequest();
    S.open(i.method.toUpperCase(), i.url, !0), S.timeout = i.timeout;
    function C() {
      if (!S)
        return;
      const I = Ai.from(
        "getAllResponseHeaders" in S && S.getAllResponseHeaders()
      ), D = {
        data: !a || a === "text" || a === "json" ? S.responseText : S.response,
        status: S.status,
        statusText: S.statusText,
        headers: I,
        config: e,
        request: S
      };
      IS(function(z) {
        r(z), y();
      }, function(z) {
        n(z), y();
      }, D), S = null;
    }
    "onloadend" in S ? S.onloadend = C : S.onreadystatechange = function() {
      !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(C);
    }, S.onabort = function() {
      S && (n(new jt("Request aborted", jt.ECONNABORTED, e, S)), S = null);
    }, S.onerror = function() {
      n(new jt("Network Error", jt.ERR_NETWORK, e, S)), S = null;
    }, S.ontimeout = function() {
      let U = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const D = i.transitional || AS;
      i.timeoutErrorMessage && (U = i.timeoutErrorMessage), n(new jt(
        U,
        D.clarifyTimeoutError ? jt.ETIMEDOUT : jt.ECONNABORTED,
        e,
        S
      )), S = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in S && Ce.forEach(o.toJSON(), function(U, D) {
      S.setRequestHeader(D, U);
    }), Ce.isUndefined(i.withCredentials) || (S.withCredentials = !!i.withCredentials), a && a !== "json" && (S.responseType = i.responseType), u && ([h, b] = Xf(u, !0), S.addEventListener("progress", h)), c && S.upload && ([f, v] = Xf(c), S.upload.addEventListener("progress", f), S.upload.addEventListener("loadend", v)), (i.cancelToken || i.signal) && (l = (I) => {
      S && (n(!I || I.type ? new Ic(null, e, S) : I), S.abort(), S = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const O = NB(i.url);
    if (O && dn.protocols.indexOf(O) === -1) {
      n(new jt("Unsupported protocol " + O + ":", jt.ERR_BAD_REQUEST, e));
      return;
    }
    S.send(s || null);
  });
};
const WB = (e, t) => {
  const { length: r } = e = e ? e.filter(Boolean) : [];
  if (t || r) {
    let n = new AbortController(), i;
    const s = function(u) {
      if (!i) {
        i = !0, a();
        const l = u instanceof Error ? u : this.reason;
        n.abort(l instanceof jt ? l : new Ic(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, s(new jt(`timeout ${t} of ms exceeded`, jt.ETIMEDOUT));
    }, t);
    const a = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(s) : u.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", s));
    const { signal: c } = n;
    return c.unsubscribe = () => Ce.asap(a), c;
  }
};
var qB = WB;
const HB = function* (e, t) {
  let r = e.byteLength;
  if (!t || r < t) {
    yield e;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + t, yield e.slice(n, i), n = i;
}, GB = async function* (e, t) {
  for await (const r of KB(e))
    yield* HB(r, t);
}, KB = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await t.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await t.cancel();
  }
}, yv = (e, t, r, n) => {
  const i = GB(e, t);
  let s = 0, o, a = (c) => {
    o || (o = !0, n && n(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: u, value: l } = await i.next();
        if (u) {
          a(), c.close();
          return;
        }
        let f = l.byteLength;
        if (r) {
          let h = s += f;
          r(h);
        }
        c.enqueue(new Uint8Array(l));
      } catch (u) {
        throw a(u), u;
      }
    },
    cancel(c) {
      return a(c), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, Fd = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", RS = Fd && typeof ReadableStream == "function", YB = Fd && (typeof TextEncoder == "function" ? ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), PS = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, XB = RS && PS(() => {
  let e = !1;
  const t = new Request(dn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), vv = 64 * 1024, W0 = RS && PS(() => Ce.isReadableStream(new Response("").body)), Jf = {
  stream: W0 && ((e) => e.body)
};
Fd && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Jf[t] && (Jf[t] = Ce.isFunction(e[t]) ? (r) => r[t]() : (r, n) => {
      throw new jt(`Response type '${t}' is not supported`, jt.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const JB = async (e) => {
  if (e == null)
    return 0;
  if (Ce.isBlob(e))
    return e.size;
  if (Ce.isSpecCompliantForm(e))
    return (await new Request(dn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (Ce.isArrayBufferView(e) || Ce.isArrayBuffer(e))
    return e.byteLength;
  if (Ce.isURLSearchParams(e) && (e = e + ""), Ce.isString(e))
    return (await YB(e)).byteLength;
}, ZB = async (e, t) => {
  const r = Ce.toFiniteNumber(e.getContentLength());
  return r ?? JB(t);
};
var QB = Fd && (async (e) => {
  let {
    url: t,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: c,
    responseType: u,
    headers: l,
    withCredentials: f = "same-origin",
    fetchOptions: h
  } = jS(e);
  u = u ? (u + "").toLowerCase() : "text";
  let v = qB([i, s && s.toAbortSignal()], o), b;
  const y = v && v.unsubscribe && (() => {
    v.unsubscribe();
  });
  let S;
  try {
    if (c && XB && r !== "get" && r !== "head" && (S = await ZB(l, n)) !== 0) {
      let D = new Request(t, {
        method: "POST",
        body: n,
        duplex: "half"
      }), H;
      if (Ce.isFormData(n) && (H = D.headers.get("content-type")) && l.setContentType(H), D.body) {
        const [z, ne] = pv(
          S,
          Xf(mv(c))
        );
        n = yv(D.body, vv, z, ne);
      }
    }
    Ce.isString(f) || (f = f ? "include" : "omit");
    const C = "credentials" in Request.prototype;
    b = new Request(t, {
      ...h,
      signal: v,
      method: r.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: C ? f : void 0
    });
    let O = await fetch(b, h);
    const I = W0 && (u === "stream" || u === "response");
    if (W0 && (a || I && y)) {
      const D = {};
      ["status", "statusText", "headers"].forEach((le) => {
        D[le] = O[le];
      });
      const H = Ce.toFiniteNumber(O.headers.get("content-length")), [z, ne] = a && pv(
        H,
        Xf(mv(a), !0)
      ) || [];
      O = new Response(
        yv(O.body, vv, z, () => {
          ne && ne(), y && y();
        }),
        D
      );
    }
    u = u || "text";
    let U = await Jf[Ce.findKey(Jf, u) || "text"](O, e);
    return !I && y && y(), await new Promise((D, H) => {
      IS(D, H, {
        data: U,
        headers: Ai.from(O.headers),
        status: O.status,
        statusText: O.statusText,
        config: e,
        request: b
      });
    });
  } catch (C) {
    throw y && y(), C && C.name === "TypeError" && /Load failed|fetch/i.test(C.message) ? Object.assign(
      new jt("Network Error", jt.ERR_NETWORK, e, b),
      {
        cause: C.cause || C
      }
    ) : jt.from(C, C && C.code, e, b);
  }
});
const q0 = {
  http: dB,
  xhr: zB,
  fetch: QB
};
Ce.forEach(q0, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const bv = (e) => `- ${e}`, eU = (e) => Ce.isFunction(e) || e === null || e === !1;
var NS = {
  getAdapter: (e) => {
    e = Ce.isArray(e) ? e : [e];
    const { length: t } = e;
    let r, n;
    const i = {};
    for (let s = 0; s < t; s++) {
      r = e[s];
      let o;
      if (n = r, !eU(r) && (n = q0[(o = String(r)).toLowerCase()], n === void 0))
        throw new jt(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? s.length > 1 ? `since :
` + s.map(bv).join(`
`) : " " + bv(s[0]) : "as no adapter specified";
      throw new jt(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: q0
};
function up(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Ic(null, e);
}
function wv(e) {
  return up(e), e.headers = Ai.from(e.headers), e.data = cp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), NS.getAdapter(e.adapter || s1.adapter)(e).then(function(n) {
    return up(e), n.data = cp.call(
      e,
      e.transformResponse,
      n
    ), n.headers = Ai.from(n.headers), n;
  }, function(n) {
    return OS(n) || (up(e), n && n.response && (n.response.data = cp.call(
      e,
      e.transformResponse,
      n.response
    ), n.response.headers = Ai.from(n.response.headers))), Promise.reject(n);
  });
}
const $S = "1.11.0", Vd = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Vd[e] = function(n) {
    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const _v = {};
Vd.transitional = function(t, r, n) {
  function i(s, o) {
    return "[Axios v" + $S + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (t === !1)
      throw new jt(
        i(o, " has been removed" + (r ? " in " + r : "")),
        jt.ERR_DEPRECATED
      );
    return r && !_v[o] && (_v[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), t ? t(s, o, a) : !0;
  };
};
Vd.spelling = function(t) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${t}`), !0);
};
function tU(e, t, r) {
  if (typeof e != "object")
    throw new jt("options must be an object", jt.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(e);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = t[s];
    if (o) {
      const a = e[s], c = a === void 0 || o(a, s, e);
      if (c !== !0)
        throw new jt("option " + s + " must be " + c, jt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new jt("Unknown option " + s, jt.ERR_BAD_OPTION);
  }
}
var pf = {
  assertOptions: tU,
  validators: Vd
};
const zi = pf.validators;
class Zf {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new dv(),
      response: new dv()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, r) {
    try {
      return await this._request(t, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(t, r) {
    typeof t == "string" ? (r = r || {}, r.url = t) : r = t || {}, r = _a(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && pf.assertOptions(n, {
      silentJSONParsing: zi.transitional(zi.boolean),
      forcedJSONParsing: zi.transitional(zi.boolean),
      clarifyTimeoutError: zi.transitional(zi.boolean)
    }, !1), i != null && (Ce.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : pf.assertOptions(i, {
      encode: zi.function,
      serialize: zi.function
    }, !0)), r.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? r.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : r.allowAbsoluteUrls = !0), pf.assertOptions(r, {
      baseUrl: zi.spelling("baseURL"),
      withXsrfToken: zi.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Ce.merge(
      s.common,
      s[r.method]
    );
    s && Ce.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete s[b];
      }
    ), r.headers = Ai.concat(o, s);
    const a = [];
    let c = !0;
    this.interceptors.request.forEach(function(y) {
      typeof y.runWhen == "function" && y.runWhen(r) === !1 || (c = c && y.synchronous, a.unshift(y.fulfilled, y.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(y) {
      u.push(y.fulfilled, y.rejected);
    });
    let l, f = 0, h;
    if (!c) {
      const b = [wv.bind(this), void 0];
      for (b.unshift(...a), b.push(...u), h = b.length, l = Promise.resolve(r); f < h; )
        l = l.then(b[f++], b[f++]);
      return l;
    }
    h = a.length;
    let v = r;
    for (f = 0; f < h; ) {
      const b = a[f++], y = a[f++];
      try {
        v = b(v);
      } catch (S) {
        y.call(this, S);
        break;
      }
    }
    try {
      l = wv.call(this, v);
    } catch (b) {
      return Promise.reject(b);
    }
    for (f = 0, h = u.length; f < h; )
      l = l.then(u[f++], u[f++]);
    return l;
  }
  getUri(t) {
    t = _a(this.defaults, t);
    const r = kS(t.baseURL, t.url, t.allowAbsoluteUrls);
    return CS(r, t.params, t.paramsSerializer);
  }
}
Ce.forEach(["delete", "get", "head", "options"], function(t) {
  Zf.prototype[t] = function(r, n) {
    return this.request(_a(n || {}, {
      method: t,
      url: r,
      data: (n || {}).data
    }));
  };
});
Ce.forEach(["post", "put", "patch"], function(t) {
  function r(n) {
    return function(s, o, a) {
      return this.request(_a(a || {}, {
        method: t,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  Zf.prototype[t] = r(), Zf.prototype[t + "Form"] = r(!0);
});
var mf = Zf;
class o1 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners)
        return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, t(function(s, o, a) {
      n.reason || (n.reason = new Ic(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(t);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), r = (n) => {
      t.abort(n);
    };
    return this.subscribe(r), t.signal.unsubscribe = () => this.unsubscribe(r), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new o1(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
var rU = o1;
function nU(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function iU(e) {
  return Ce.isObject(e) && e.isAxiosError === !0;
}
const H0 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(H0).forEach(([e, t]) => {
  H0[t] = e;
});
var sU = H0;
function DS(e) {
  const t = new mf(e), r = pS(mf.prototype.request, t);
  return Ce.extend(r, mf.prototype, t, { allOwnKeys: !0 }), Ce.extend(r, t, null, { allOwnKeys: !0 }), r.create = function(i) {
    return DS(_a(e, i));
  }, r;
}
const Rr = DS(s1);
Rr.Axios = mf;
Rr.CanceledError = Ic;
Rr.CancelToken = rU;
Rr.isCancel = OS;
Rr.VERSION = $S;
Rr.toFormData = Bd;
Rr.AxiosError = jt;
Rr.Cancel = Rr.CanceledError;
Rr.all = function(t) {
  return Promise.all(t);
};
Rr.spread = nU;
Rr.isAxiosError = iU;
Rr.mergeConfig = _a;
Rr.AxiosHeaders = Ai;
Rr.formToJSON = (e) => MS(Ce.isHTMLForm(e) ? new FormData(e) : e);
Rr.getAdapter = NS.getAdapter;
Rr.HttpStatusCode = sU;
Rr.default = Rr;
var LS = Rr, a1 = { exports: {} }, qn = {}, BS = { exports: {} };
(function(e) {
  function t(r) {
    return r && r.__esModule ? r : {
      default: r
    };
  }
  e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
})(BS);
var oU = BS.exports, lp = { exports: {} }, fp = { exports: {} }, xv;
function US() {
  return xv || (xv = 1, function(e) {
    function t(r, n) {
      this.v = r, this.k = n;
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(fp)), fp.exports;
}
var dp = { exports: {} }, hp = { exports: {} }, Sv;
function FS() {
  return Sv || (Sv = 1, function(e) {
    function t(r, n, i, s) {
      var o = Object.defineProperty;
      try {
        o({}, "", {});
      } catch {
        o = 0;
      }
      e.exports = t = function(c, u, l, f) {
        function h(v, b) {
          t(c, v, function(y) {
            return this._invoke(v, b, y);
          });
        }
        u ? o ? o(c, u, {
          value: l,
          enumerable: !f,
          configurable: !f,
          writable: !f
        }) : c[u] = l : (h("next", 0), h("throw", 1), h("return", 2));
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r, n, i, s);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(hp)), hp.exports;
}
var Ev;
function VS() {
  return Ev || (Ev = 1, function(e) {
    var t = FS();
    function r() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
      var n, i, s = typeof Symbol == "function" ? Symbol : {}, o = s.iterator || "@@iterator", a = s.toStringTag || "@@toStringTag";
      function c(S, C, O, I) {
        var U = C && C.prototype instanceof l ? C : l, D = Object.create(U.prototype);
        return t(D, "_invoke", function(H, z, ne) {
          var le, te, ce, V = 0, L = ne || [], p = !1, d = {
            p: 0,
            n: 0,
            v: n,
            a: m,
            f: m.bind(n, 4),
            d: function(E, A) {
              return le = E, te = 0, ce = n, d.n = A, u;
            }
          };
          function m(x, E) {
            for (te = x, ce = E, i = 0; !p && V && !A && i < L.length; i++) {
              var A, j = L[i], k = d.p, g = j[2];
              x > 3 ? (A = g === E) && (ce = j[(te = j[4]) ? 5 : (te = 3, 3)], j[4] = j[5] = n) : j[0] <= k && ((A = x < 2 && k < j[1]) ? (te = 0, d.v = E, d.n = j[1]) : k < g && (A = x < 3 || j[0] > E || E > g) && (j[4] = x, j[5] = E, d.n = g, te = 0));
            }
            if (A || x > 1)
              return u;
            throw p = !0, E;
          }
          return function(x, E, A) {
            if (V > 1)
              throw TypeError("Generator is already running");
            for (p && E === 1 && m(E, A), te = E, ce = A; (i = te < 2 ? n : ce) || !p; ) {
              le || (te ? te < 3 ? (te > 1 && (d.n = -1), m(te, ce)) : d.n = ce : d.v = ce);
              try {
                if (V = 2, le) {
                  if (te || (x = "next"), i = le[x]) {
                    if (!(i = i.call(le, ce)))
                      throw TypeError("iterator result is not an object");
                    if (!i.done)
                      return i;
                    ce = i.value, te < 2 && (te = 0);
                  } else
                    te === 1 && (i = le.return) && i.call(le), te < 2 && (ce = TypeError("The iterator does not provide a '" + x + "' method"), te = 1);
                  le = n;
                } else if ((i = (p = d.n < 0) ? ce : H.call(z, d)) !== u)
                  break;
              } catch (j) {
                le = n, te = 1, ce = j;
              } finally {
                V = 1;
              }
            }
            return {
              value: i,
              done: p
            };
          };
        }(S, O, I), !0), D;
      }
      var u = {};
      function l() {
      }
      function f() {
      }
      function h() {
      }
      i = Object.getPrototypeOf;
      var v = [][o] ? i(i([][o]())) : (t(i = {}, o, function() {
        return this;
      }), i), b = h.prototype = l.prototype = Object.create(v);
      function y(S) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(S, h) : (S.__proto__ = h, t(S, a, "GeneratorFunction")), S.prototype = Object.create(b), S;
      }
      return f.prototype = h, t(b, "constructor", h), t(h, "constructor", f), f.displayName = "GeneratorFunction", t(h, a, "GeneratorFunction"), t(b), t(b, a, "Generator"), t(b, o, function() {
        return this;
      }), t(b, "toString", function() {
        return "[object Generator]";
      }), (e.exports = r = function() {
        return {
          w: c,
          m: y
        };
      }, e.exports.__esModule = !0, e.exports.default = e.exports)();
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(dp)), dp.exports;
}
var pp = { exports: {} }, mp = { exports: {} }, gp = { exports: {} }, Tv;
function zS() {
  return Tv || (Tv = 1, function(e) {
    var t = US(), r = FS();
    function n(i, s) {
      function o(c, u, l, f) {
        try {
          var h = i[c](u), v = h.value;
          return v instanceof t ? s.resolve(v.v).then(function(b) {
            o("next", b, l, f);
          }, function(b) {
            o("throw", b, l, f);
          }) : s.resolve(v).then(function(b) {
            h.value = b, l(h);
          }, function(b) {
            return o("throw", b, l, f);
          });
        } catch (b) {
          f(b);
        }
      }
      var a;
      this.next || (r(n.prototype), r(n.prototype, typeof Symbol == "function" && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), r(this, "_invoke", function(c, u, l) {
        function f() {
          return new s(function(h, v) {
            o(c, l, h, v);
          });
        }
        return a = a ? a.then(f, f) : f();
      }, !0);
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(gp)), gp.exports;
}
var Cv;
function WS() {
  return Cv || (Cv = 1, function(e) {
    var t = VS(), r = zS();
    function n(i, s, o, a, c) {
      return new r(t().w(i, s, o, a), c || Promise);
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(mp)), mp.exports;
}
var Av;
function aU() {
  return Av || (Av = 1, function(e) {
    var t = WS();
    function r(n, i, s, o, a) {
      var c = t(n, i, s, o, a);
      return c.next().then(function(u) {
        return u.done ? u.value : c.next();
      });
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(pp)), pp.exports;
}
var yp = { exports: {} }, Mv;
function cU() {
  return Mv || (Mv = 1, function(e) {
    function t(r) {
      var n = Object(r), i = [];
      for (var s in n)
        i.unshift(s);
      return function o() {
        for (; i.length; )
          if ((s = i.pop()) in n)
            return o.value = s, o.done = !1, o;
        return o.done = !0, o;
      };
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(yp)), yp.exports;
}
var vp = { exports: {} }, bp = { exports: {} }, Ov;
function zd() {
  return Ov || (Ov = 1, function(e) {
    function t(r) {
      "@babel/helpers - typeof";
      return e.exports = t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(n) {
        return typeof n;
      } : function(n) {
        return n && typeof Symbol == "function" && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n;
      }, e.exports.__esModule = !0, e.exports.default = e.exports, t(r);
    }
    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(bp)), bp.exports;
}
var Iv;
function uU() {
  return Iv || (Iv = 1, function(e) {
    var t = zd().default;
    function r(n) {
      if (n != null) {
        var i = n[typeof Symbol == "function" && Symbol.iterator || "@@iterator"], s = 0;
        if (i)
          return i.call(n);
        if (typeof n.next == "function")
          return n;
        if (!isNaN(n.length))
          return {
            next: function() {
              return n && s >= n.length && (n = void 0), {
                value: n && n[s++],
                done: !n
              };
            }
          };
      }
      throw new TypeError(t(n) + " is not iterable");
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(vp)), vp.exports;
}
var kv;
function lU() {
  return kv || (kv = 1, function(e) {
    var t = US(), r = VS(), n = aU(), i = WS(), s = zS(), o = cU(), a = uU();
    function c() {
      var u = r(), l = u.m(c), f = (Object.getPrototypeOf ? Object.getPrototypeOf(l) : l.__proto__).constructor;
      function h(y) {
        var S = typeof y == "function" && y.constructor;
        return !!S && (S === f || (S.displayName || S.name) === "GeneratorFunction");
      }
      var v = {
        throw: 1,
        return: 2,
        break: 3,
        continue: 3
      };
      function b(y) {
        var S, C;
        return function(O) {
          S || (S = {
            stop: function() {
              return C(O.a, 2);
            },
            catch: function() {
              return O.v;
            },
            abrupt: function(U, D) {
              return C(O.a, v[U], D);
            },
            delegateYield: function(U, D, H) {
              return S.resultName = D, C(O.d, a(U), H);
            },
            finish: function(U) {
              return C(O.f, U);
            }
          }, C = function(U, D, H) {
            O.p = S.prev, O.n = S.next;
            try {
              return U(D, H);
            } finally {
              S.next = O.n;
            }
          }), S.resultName && (S[S.resultName] = O.v, S.resultName = void 0), S.sent = O.v, S.next = O.n;
          try {
            return y.call(this, S);
          } finally {
            O.p = S.prev, O.n = S.next;
          }
        };
      }
      return (e.exports = c = function() {
        return {
          wrap: function(C, O, I, U) {
            return u.w(b(C), O, I, U && U.reverse());
          },
          isGeneratorFunction: h,
          mark: u.m,
          awrap: function(C, O) {
            return new t(C, O);
          },
          AsyncIterator: s,
          async: function(C, O, I, U, D) {
            return (h(O) ? i : n)(b(C), O, I, U, D);
          },
          keys: o,
          values: a
        };
      }, e.exports.__esModule = !0, e.exports.default = e.exports)();
    }
    e.exports = c, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(lp)), lp.exports;
}
var wp, jv;
function fU() {
  if (jv)
    return wp;
  jv = 1;
  var e = lU()();
  wp = e;
  try {
    regeneratorRuntime = e;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e);
  }
  return wp;
}
var _p = { exports: {} }, Rv;
function dU() {
  return Rv || (Rv = 1, function(e) {
    function t(n, i, s, o, a, c, u) {
      try {
        var l = n[c](u), f = l.value;
      } catch (h) {
        return void s(h);
      }
      l.done ? i(f) : Promise.resolve(f).then(o, a);
    }
    function r(n) {
      return function() {
        var i = this, s = arguments;
        return new Promise(function(o, a) {
          var c = n.apply(i, s);
          function u(f) {
            t(c, o, a, u, l, "next", f);
          }
          function l(f) {
            t(c, o, a, u, l, "throw", f);
          }
          u(void 0);
        });
      };
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(_p)), _p.exports;
}
var xp = { exports: {} }, Sp = { exports: {} }, Ep = { exports: {} }, Pv;
function hU() {
  return Pv || (Pv = 1, function(e) {
    var t = zd().default;
    function r(n, i) {
      if (t(n) != "object" || !n)
        return n;
      var s = n[Symbol.toPrimitive];
      if (s !== void 0) {
        var o = s.call(n, i || "default");
        if (t(o) != "object")
          return o;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (i === "string" ? String : Number)(n);
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Ep)), Ep.exports;
}
var Nv;
function pU() {
  return Nv || (Nv = 1, function(e) {
    var t = zd().default, r = hU();
    function n(i) {
      var s = r(i, "string");
      return t(s) == "symbol" ? s : s + "";
    }
    e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(Sp)), Sp.exports;
}
var $v;
function mU() {
  return $v || ($v = 1, function(e) {
    var t = pU();
    function r(n, i, s) {
      return (i = t(i)) in n ? Object.defineProperty(n, i, {
        value: s,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : n[i] = s, n;
    }
    e.exports = r, e.exports.__esModule = !0, e.exports.default = e.exports;
  }(xp)), xp.exports;
}
var Tp, Dv;
function gU() {
  if (Dv)
    return Tp;
  Dv = 1;
  const e = /* @__PURE__ */ new Set([
    "ENOTFOUND",
    "ENETUNREACH",
    // SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328
    "UNABLE_TO_GET_ISSUER_CERT",
    "UNABLE_TO_GET_CRL",
    "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
    "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
    "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
    "CERT_SIGNATURE_FAILURE",
    "CRL_SIGNATURE_FAILURE",
    "CERT_NOT_YET_VALID",
    "CERT_HAS_EXPIRED",
    "CRL_NOT_YET_VALID",
    "CRL_HAS_EXPIRED",
    "ERROR_IN_CERT_NOT_BEFORE_FIELD",
    "ERROR_IN_CERT_NOT_AFTER_FIELD",
    "ERROR_IN_CRL_LAST_UPDATE_FIELD",
    "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
    "OUT_OF_MEM",
    "DEPTH_ZERO_SELF_SIGNED_CERT",
    "SELF_SIGNED_CERT_IN_CHAIN",
    "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
    "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
    "CERT_CHAIN_TOO_LONG",
    "CERT_REVOKED",
    "INVALID_CA",
    "PATH_LENGTH_EXCEEDED",
    "INVALID_PURPOSE",
    "CERT_UNTRUSTED",
    "CERT_REJECTED",
    "HOSTNAME_MISMATCH"
  ]);
  return Tp = (t) => !e.has(t && t.code), Tp;
}
var ll = oU;
Object.defineProperty(qn, "__esModule", {
  value: !0
});
qn.isNetworkError = u1;
qn.isRetryableError = Wd;
qn.isSafeRequestError = GS;
qn.isIdempotentRequestError = l1;
qn.isNetworkOrIdempotentRequestError = f1;
qn.exponentialDelay = KS;
qn.default = Ia;
qn.DEFAULT_OPTIONS = qn.namespace = void 0;
var Qf = ll(fU()), yU = ll(zd()), qS = ll(dU()), vU = ll(mU()), bU = ll(gU());
function Lv(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function Cp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lv(Object(r), !0).forEach(function(n) {
      (0, vU.default)(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Lv(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
var c1 = "axios-retry";
qn.namespace = c1;
function u1(e) {
  var t = ["ERR_CANCELED", "ECONNABORTED"];
  return !e.response && !!e.code && // Prevents retrying cancelled requests
  !t.includes(e.code) && // Prevents retrying timed out & cancelled requests
  (0, bU.default)(e);
}
var HS = ["get", "head", "options"], wU = HS.concat(["put", "delete"]);
function Wd(e) {
  return e.code !== "ECONNABORTED" && (!e.response || e.response.status >= 500 && e.response.status <= 599);
}
function GS(e) {
  return e.config ? Wd(e) && HS.indexOf(e.config.method) !== -1 : !1;
}
function l1(e) {
  return e.config ? Wd(e) && wU.indexOf(e.config.method) !== -1 : !1;
}
function f1(e) {
  return u1(e) || l1(e);
}
function _U() {
  return 0;
}
function KS() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100, r = Math.pow(2, e) * t, n = r * 0.2 * Math.random();
  return r + n;
}
var YS = {
  retries: 3,
  retryCondition: f1,
  retryDelay: _U,
  shouldResetTimeout: !1,
  onRetry: function() {
  }
};
qn.DEFAULT_OPTIONS = YS;
function xU(e, t) {
  return Cp(Cp(Cp({}, YS), t), e[c1]);
}
function Bv(e, t) {
  var r = xU(e, t);
  return r.retryCount = r.retryCount || 0, e[c1] = r, r;
}
function SU(e, t) {
  e.defaults.agent === t.agent && delete t.agent, e.defaults.httpAgent === t.httpAgent && delete t.httpAgent, e.defaults.httpsAgent === t.httpsAgent && delete t.httpsAgent;
}
function EU(e, t) {
  return G0.apply(this, arguments);
}
function G0() {
  return G0 = (0, qS.default)(/* @__PURE__ */ Qf.default.mark(function e(t, r) {
    var n, i, s, o;
    return Qf.default.wrap(function(c) {
      for (; ; )
        switch (c.prev = c.next) {
          case 0:
            if (n = t.retries, i = t.retryCondition, s = t.retryCount < n && i(r), (0, yU.default)(s) !== "object") {
              c.next = 13;
              break;
            }
            return c.prev = 3, c.next = 6, s;
          case 6:
            return o = c.sent, c.abrupt("return", o !== !1);
          case 10:
            return c.prev = 10, c.t0 = c.catch(3), c.abrupt("return", !1);
          case 13:
            return c.abrupt("return", s);
          case 14:
          case "end":
            return c.stop();
        }
    }, e, null, [[3, 10]]);
  })), G0.apply(this, arguments);
}
function Ia(e, t) {
  var r = e.interceptors.request.use(function(i) {
    var s = Bv(i, t);
    return s.lastRequestTime = Date.now(), i;
  }), n = e.interceptors.response.use(null, /* @__PURE__ */ function() {
    var i = (0, qS.default)(/* @__PURE__ */ Qf.default.mark(function s(o) {
      var a, c, u, l, f, h, v, b;
      return Qf.default.wrap(function(S) {
        for (; ; )
          switch (S.prev = S.next) {
            case 0:
              if (a = o.config, a) {
                S.next = 3;
                break;
              }
              return S.abrupt("return", Promise.reject(o));
            case 3:
              return c = Bv(a, t), S.next = 6, EU(c, o);
            case 6:
              if (!S.sent) {
                S.next = 21;
                break;
              }
              if (c.retryCount += 1, u = c.retryDelay, l = c.shouldResetTimeout, f = c.onRetry, h = u(c.retryCount, o), SU(e, a), !(!l && a.timeout && c.lastRequestTime)) {
                S.next = 17;
                break;
              }
              if (v = Date.now() - c.lastRequestTime, b = a.timeout - v - h, !(b <= 0)) {
                S.next = 16;
                break;
              }
              return S.abrupt("return", Promise.reject(o));
            case 16:
              a.timeout = b;
            case 17:
              return a.transformRequest = [function(C) {
                return C;
              }], S.next = 20, f(c.retryCount, o, a);
            case 20:
              return S.abrupt("return", new Promise(function(C) {
                return setTimeout(function() {
                  return C(e(a));
                }, h);
              }));
            case 21:
              return S.abrupt("return", Promise.reject(o));
            case 22:
            case "end":
              return S.stop();
          }
      }, s);
    }));
    return function(s) {
      return i.apply(this, arguments);
    };
  }());
  return {
    requestInterceptorId: r,
    responseInterceptorId: n
  };
}
Ia.isNetworkError = u1;
Ia.isSafeRequestError = GS;
Ia.isIdempotentRequestError = l1;
Ia.isNetworkOrIdempotentRequestError = f1;
Ia.exponentialDelay = KS;
Ia.isRetryableError = Wd;
const XS = qn.default;
a1.exports = XS;
a1.exports.default = XS;
var TU = a1.exports, qd = {}, Qa = null;
typeof WebSocket < "u" ? Qa = WebSocket : typeof MozWebSocket < "u" ? Qa = MozWebSocket : typeof Yr < "u" ? Qa = Yr.WebSocket || Yr.MozWebSocket : typeof window < "u" ? Qa = window.WebSocket || window.MozWebSocket : typeof self < "u" && (Qa = self.WebSocket || self.MozWebSocket);
var CU = Qa, AU = Yr && Yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(qd, "__esModule", { value: !0 });
qd.ResilientWebSocket = void 0;
const MU = AU(CU), OU = 3e4 + 3e3;
class IU {
  constructor(t, r) {
    Pt(this, "endpoint");
    Pt(this, "wsClient");
    Pt(this, "wsUserClosed");
    Pt(this, "wsFailedAttempts");
    Pt(this, "pingTimeout");
    Pt(this, "logger");
    Pt(this, "onError");
    Pt(this, "onMessage");
    Pt(this, "onReconnect");
    this.endpoint = t, this.logger = r, this.wsFailedAttempts = 0, this.onError = (n) => {
      var i;
      (i = this.logger) == null || i.error(n);
    }, this.wsUserClosed = !0, this.onMessage = () => {
    }, this.onReconnect = () => {
    };
  }
  async send(t) {
    var r, n, i;
    (r = this.logger) == null || r.info(`Sending ${t}`), await this.waitForMaybeReadyWebSocket(), this.wsClient === void 0 ? (n = this.logger) == null || n.error("Couldn't connect to the websocket server. Error callback is called.") : (i = this.wsClient) == null || i.send(t);
  }
  async startWebSocket() {
    var t;
    this.wsClient === void 0 && ((t = this.logger) == null || t.info("Creating Web Socket client"), this.wsClient = new MU.default(this.endpoint), this.wsUserClosed = !1, this.wsClient.onopen = () => {
      this.wsFailedAttempts = 0, this.wsClient.on !== void 0 && this.heartbeat();
    }, this.wsClient.onerror = (r) => {
      this.onError(r.error);
    }, this.wsClient.onmessage = (r) => {
      this.onMessage(r.data);
    }, this.wsClient.onclose = async () => {
      var r, n;
      if (this.pingTimeout !== void 0 && clearInterval(this.pingTimeout), this.wsUserClosed === !1) {
        this.wsFailedAttempts += 1, this.wsClient = void 0;
        const i = kU(this.wsFailedAttempts);
        (r = this.logger) == null || r.error(`Connection closed unexpectedly or because of timeout. Reconnecting after ${i}ms.`), await Uv(i), this.restartUnexpectedClosedWebsocket();
      } else
        (n = this.logger) == null || n.info("The connection has been closed successfully.");
    }, this.wsClient.on !== void 0 && this.wsClient.on("ping", this.heartbeat.bind(this)));
  }
  /**
   * Heartbeat is only enabled in node clients because they support handling
   * ping-pong events.
   *
   * This approach only works when server constantly pings the clients which.
   * Otherwise you might consider sending ping and acting on pong responses
   * yourself.
   */
  heartbeat() {
    var t;
    (t = this.logger) == null || t.info("Heartbeat"), this.pingTimeout !== void 0 && clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
      var r, n;
      (r = this.logger) == null || r.warn("Connection timed out. Reconnecting..."), (n = this.wsClient) == null || n.terminate(), this.restartUnexpectedClosedWebsocket();
    }, OU);
  }
  async waitForMaybeReadyWebSocket() {
    let t = 0;
    for (; this.wsClient !== void 0 && this.wsClient.readyState !== this.wsClient.OPEN; )
      if (t > 5e3) {
        this.wsClient.close();
        return;
      } else
        t += 10, await Uv(10);
  }
  async restartUnexpectedClosedWebsocket() {
    var t;
    if (this.wsUserClosed !== !0) {
      if (await this.startWebSocket(), await this.waitForMaybeReadyWebSocket(), this.wsClient === void 0) {
        (t = this.logger) == null || t.error("Couldn't reconnect to websocket. Error callback is called.");
        return;
      }
      this.onReconnect();
    }
  }
  closeWebSocket() {
    if (this.wsClient !== void 0) {
      const t = this.wsClient;
      this.wsClient = void 0, t.close();
    }
    this.wsUserClosed = !0;
  }
}
qd.ResilientWebSocket = IU;
async function Uv(e) {
  return new Promise((t) => setTimeout(t, e));
}
function kU(e) {
  return 2 ** e * 100;
}
var yc = {};
Object.defineProperty(yc, "__esModule", { value: !0 });
yc.removeLeading0xIfExists = yc.makeWebsocketUrl = void 0;
function jU(e) {
  const t = new URL("ws", e), r = t.protocol === "https:";
  return t.protocol = r ? "wss:" : "ws:", t.toString();
}
yc.makeWebsocketUrl = jU;
function RU(e) {
  return e.startsWith("0x") ? e.substring(2) : e;
}
yc.removeLeading0xIfExists = RU;
var JS = Yr && Yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Rd, "__esModule", { value: !0 });
Rd.PriceServiceConnection = void 0;
const Ap = Zg, PU = JS(LS), Fv = JS(TU), NU = qd, Mp = yc;
class $U {
  /**
   * Constructs a new Connection.
   *
   * @param endpoint endpoint URL to the price service. Example: https://website/example/
   * @param config Optional PriceServiceConnectionConfig for custom configurations.
   */
  constructor(t, r) {
    Pt(this, "httpClient");
    Pt(this, "priceFeedCallbacks");
    Pt(this, "wsClient");
    Pt(this, "wsEndpoint");
    Pt(this, "logger");
    Pt(this, "priceFeedRequestConfig");
    /**
     * Custom handler for web socket errors (connection and message parsing).
     *
     * Default handler only logs the errors.
     */
    Pt(this, "onWsError");
    var n, i, s;
    this.httpClient = PU.default.create({
      baseURL: t,
      timeout: (r == null ? void 0 : r.timeout) || 5e3
    }), (0, Fv.default)(this.httpClient, {
      retries: (r == null ? void 0 : r.httpRetries) || 3,
      retryDelay: Fv.default.exponentialDelay
    }), this.priceFeedRequestConfig = {
      binary: (n = r == null ? void 0 : r.priceFeedRequestConfig) == null ? void 0 : n.binary,
      verbose: ((i = r == null ? void 0 : r.priceFeedRequestConfig) == null ? void 0 : i.verbose) ?? (r == null ? void 0 : r.verbose),
      allowOutOfOrder: (s = r == null ? void 0 : r.priceFeedRequestConfig) == null ? void 0 : s.allowOutOfOrder
    }, this.priceFeedCallbacks = /* @__PURE__ */ new Map(), this.logger = (r == null ? void 0 : r.logger) || {
      trace: () => {
      },
      debug: () => {
      },
      info: () => {
      },
      warn: console.warn,
      error: console.error
    }, this.onWsError = (o) => {
      this.logger.error(o), typeof Rn < "u" && typeof Rn.exit == "function" ? (this.logger.error("Halting the process due to the websocket error"), Rn.exit(1)) : this.logger.error("Cannot halt process. Please handle the websocket error.");
    }, this.wsEndpoint = (0, Mp.makeWebsocketUrl)(t);
  }
  /**
   * Fetch Latest PriceFeeds of given price ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of PriceFeeds
   */
  async getLatestPriceFeeds(t) {
    return t.length === 0 ? [] : (await this.httpClient.get("/api/latest_price_feeds", {
      params: {
        ids: t,
        verbose: this.priceFeedRequestConfig.verbose,
        binary: this.priceFeedRequestConfig.binary
      }
    })).data.map((i) => Ap.PriceFeed.fromJson(i));
  }
  /**
   * Fetch latest VAA of given price ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * This function is coupled to wormhole implemntation.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of base64 encoded VAAs.
   */
  async getLatestVaas(t) {
    return (await this.httpClient.get("/api/latest_vaas", {
      params: {
        ids: t
      }
    })).data;
  }
  /**
   * Fetch the earliest VAA of the given price id that is published since the given publish time.
   * This will throw an error if the given publish time is in the future, or if the publish time
   * is old and the price service endpoint does not have a db backend for historical requests.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
   *
   * This function is coupled to wormhole implemntation.
   *
   * @param priceId Hex-encoded price id.
   * @param publishTime Epoch timestamp in seconds.
   * @returns Tuple of VAA and publishTime.
   */
  async getVaa(t, r) {
    const n = await this.httpClient.get("/api/get_vaa", {
      params: {
        id: t,
        publish_time: r
      }
    });
    return [n.data.vaa, n.data.publishTime];
  }
  /**
   * Fetch the PriceFeed of the given price id that is published since the given publish time.
   * This will throw an error if the given publish time is in the future, or if the publish time
   * is old and the price service endpoint does not have a db backend for historical requests.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response (e.g: Invalid price id)
   *
   * @param priceId Hex-encoded price id.
   * @param publishTime Epoch timestamp in seconds.
   * @returns PriceFeed
   */
  async getPriceFeed(t, r) {
    const n = await this.httpClient.get("/api/get_price_feed", {
      params: {
        id: t,
        publish_time: r,
        verbose: this.priceFeedRequestConfig.verbose,
        binary: this.priceFeedRequestConfig.binary
      }
    });
    return Ap.PriceFeed.fromJson(n.data);
  }
  /**
   * Fetch the list of available price feed ids.
   * This will throw an axios error if there is a network problem or the price service returns a non-ok response.
   *
   * @returns Array of hex-encoded price ids.
   */
  async getPriceFeedIds() {
    return (await this.httpClient.get("/api/price_feed_ids")).data;
  }
  /**
   * Subscribe to updates for given price ids.
   *
   * It will start a websocket connection if it's not started yet.
   * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
   * it calls `connection.onWsError`. If you want to handle the errors you should set the
   * `onWsError` function to your custom error handler.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @param cb Callback function that is called with a PriceFeed upon updates to given price ids.
   */
  async subscribePriceFeedUpdates(t, r) {
    var s;
    this.wsClient === void 0 && await this.startWebSocket(), t = t.map((o) => (0, Mp.removeLeading0xIfExists)(o));
    const n = [];
    for (const o of t)
      this.priceFeedCallbacks.has(o) || (this.priceFeedCallbacks.set(o, /* @__PURE__ */ new Set()), n.push(o)), this.priceFeedCallbacks.get(o).add(r);
    const i = {
      ids: n,
      type: "subscribe",
      verbose: this.priceFeedRequestConfig.verbose,
      binary: this.priceFeedRequestConfig.binary,
      allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
    };
    await ((s = this.wsClient) == null ? void 0 : s.send(JSON.stringify(i)));
  }
  /**
   * Unsubscribe from updates for given price ids.
   *
   * It will close the websocket connection if it's not subscribed to any price feed updates anymore.
   * Also, it won't throw any exception if given price ids are invalid or connection errors. Instead,
   * it calls `connection.onWsError`. If you want to handle the errors you should set the
   * `onWsError` function to your custom error handler.
   *
   * @param priceIds Array of hex-encoded price ids.
   * @param cb Optional callback, if set it will only unsubscribe this callback from updates for given price ids.
   */
  async unsubscribePriceFeedUpdates(t, r) {
    var s;
    this.wsClient === void 0 && await this.startWebSocket(), t = t.map((o) => (0, Mp.removeLeading0xIfExists)(o));
    const n = [];
    for (const o of t)
      if (this.priceFeedCallbacks.has(o)) {
        let a = !1;
        r === void 0 ? (this.priceFeedCallbacks.delete(o), a = !0) : (this.priceFeedCallbacks.get(o).delete(r), this.priceFeedCallbacks.get(o).size === 0 && (this.priceFeedCallbacks.delete(o), a = !0)), a && n.push(o);
      }
    const i = {
      ids: n,
      type: "unsubscribe"
    };
    await ((s = this.wsClient) == null ? void 0 : s.send(JSON.stringify(i))), this.priceFeedCallbacks.size === 0 && this.closeWebSocket();
  }
  /**
   * Starts connection websocket.
   *
   * This function is called automatically upon subscribing to price feed updates.
   */
  async startWebSocket() {
    if (this.wsEndpoint === void 0)
      throw new Error("Websocket endpoint is undefined.");
    this.wsClient = new NU.ResilientWebSocket(this.wsEndpoint, this.logger), this.wsClient.onError = this.onWsError, this.wsClient.onReconnect = () => {
      var t;
      if (this.priceFeedCallbacks.size > 0) {
        const r = {
          ids: Array.from(this.priceFeedCallbacks.keys()),
          type: "subscribe",
          verbose: this.priceFeedRequestConfig.verbose,
          binary: this.priceFeedRequestConfig.binary,
          allow_out_of_order: this.priceFeedRequestConfig.allowOutOfOrder
        };
        this.logger.info("Resubscribing to existing price feeds."), (t = this.wsClient) == null || t.send(JSON.stringify(r));
      }
    }, this.wsClient.onMessage = (t) => {
      this.logger.info(`Received message ${t.toString()}`);
      let r;
      try {
        r = JSON.parse(t.toString());
      } catch (n) {
        this.logger.error(`Error parsing message ${t.toString()} as JSON.`), this.logger.error(n), this.onWsError(n);
        return;
      }
      if (r.type === "response")
        r.status === "error" && (this.logger.error(`Error response from the websocket server ${r.error}.`), this.onWsError(new Error(r.error)));
      else if (r.type === "price_update") {
        let n;
        try {
          n = Ap.PriceFeed.fromJson(r.price_feed);
        } catch (i) {
          this.logger.error(`Error parsing price feeds from message ${t.toString()}.`), this.logger.error(i), this.onWsError(i);
          return;
        }
        if (this.priceFeedCallbacks.has(n.id))
          for (const i of this.priceFeedCallbacks.get(n.id))
            i(n);
      } else
        this.logger.warn(`Ignoring unsupported server response ${t.toString()}.`);
    }, await this.wsClient.startWebSocket();
  }
  /**
   * Closes connection websocket.
   *
   * At termination, the websocket should be closed to finish the
   * process elegantly. It will automatically close when the connection
   * is subscribed to no price feeds.
   */
  closeWebSocket() {
    var t;
    (t = this.wsClient) == null || t.closeWebSocket(), this.wsClient = void 0, this.priceFeedCallbacks.clear();
  }
}
Rd.PriceServiceConnection = $U;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.parseAccumulatorUpdateData = e.isAccumulatorUpdateData = e.Price = e.PriceFeed = e.PriceFeedMetadata = e.PriceServiceConnection = void 0;
  var t = Rd;
  Object.defineProperty(e, "PriceServiceConnection", { enumerable: !0, get: function() {
    return t.PriceServiceConnection;
  } });
  var r = Zg;
  Object.defineProperty(e, "PriceFeedMetadata", { enumerable: !0, get: function() {
    return r.PriceFeedMetadata;
  } }), Object.defineProperty(e, "PriceFeed", { enumerable: !0, get: function() {
    return r.PriceFeed;
  } }), Object.defineProperty(e, "Price", { enumerable: !0, get: function() {
    return r.Price;
  } }), Object.defineProperty(e, "isAccumulatorUpdateData", { enumerable: !0, get: function() {
    return r.isAccumulatorUpdateData;
  } }), Object.defineProperty(e, "parseAccumulatorUpdateData", { enumerable: !0, get: function() {
    return r.parseAccumulatorUpdateData;
  } });
})(Jg);
Object.defineProperty(jd, "__esModule", { value: !0 });
jd.SuiPriceServiceConnection = void 0;
const DU = Jg, LU = Nd();
class BU extends DU.PriceServiceConnection {
  /**
   * Gets price update data (either batch price attestation VAAs or accumulator messages, depending on the chosen endpoint), which then
   * can be submitted to the Pyth contract to update the prices. This will throw an axios error if there is a network problem or
   * the price service returns a non-ok response (e.g: Invalid price ids)
   *
   * @param priceIds Array of hex-encoded price ids.
   * @returns Array of buffers containing the price update data.
   */
  async getPriceFeedsUpdateData(t) {
    return (await this.getLatestVaas(t)).map((n) => LU.Buffer.from(n, "base64"));
  }
}
jd.SuiPriceServiceConnection = BU;
var Hd = {};
Object.defineProperty(Hd, "__esModule", { value: !0 });
Hd.SuiPythClient = void 0;
const jl = Ox, La = Ri, UU = Nd(), Op = 16 * 1024;
class FU {
  constructor(t, r, n) {
    Pt(this, "provider");
    Pt(this, "pythStateId");
    Pt(this, "wormholeStateId");
    Pt(this, "pythPackageId");
    Pt(this, "wormholePackageId");
    Pt(this, "priceTableInfo");
    Pt(this, "priceFeedObjectIdCache", /* @__PURE__ */ new Map());
    Pt(this, "baseUpdateFee");
    this.provider = t, this.pythStateId = r, this.wormholeStateId = n, this.pythPackageId = void 0, this.wormholePackageId = void 0;
  }
  async getBaseUpdateFee() {
    if (this.baseUpdateFee === void 0) {
      const t = await this.provider.getObject({
        id: this.pythStateId,
        options: { showContent: !0 }
      });
      if (!t.data || !t.data.content || t.data.content.dataType !== "moveObject")
        throw new Error("Unable to fetch pyth state object");
      this.baseUpdateFee = t.data.content.fields.base_update_fee;
    }
    return this.baseUpdateFee;
  }
  /**
   * getPackageId returns the latest package id that the object belongs to. Use this to
   * fetch the latest package id for a given object id and handle package upgrades automatically.
   * @param objectId
   * @returns package id
   */
  async getPackageId(t) {
    const r = await this.provider.getObject({
      id: t,
      options: {
        showContent: !0
      }
    }).then((n) => {
      var i, s;
      if (((s = (i = n.data) == null ? void 0 : i.content) == null ? void 0 : s.dataType) == "moveObject")
        return n.data.content.fields;
      throw new Error(`Cannot fetch package id for object ${t}`);
    });
    if ("upgrade_cap" in r)
      return r.upgrade_cap.fields.package;
    throw new Error("upgrade_cap not found");
  }
  /**
   * Adds the commands for calling wormhole and verifying the vaas and returns the verified vaas.
   * @param vaas array of vaas to verify
   * @param tx transaction block to add commands to
   */
  async verifyVaas(t, r) {
    const n = await this.getWormholePackageId(), i = [];
    for (const s of t) {
      const [o] = r.moveCall({
        target: `${n}::vaa::parse_and_verify`,
        arguments: [
          r.object(this.wormholeStateId),
          r.pure(La.bcs.vector(La.bcs.U8).serialize(Array.from(s), {
            maxSize: Op
          }).toBytes()),
          r.object(jl.SUI_CLOCK_OBJECT_ID)
        ]
      });
      i.push(o);
    }
    return i;
  }
  async verifyVaasAndGetHotPotato(t, r, n) {
    if (r.length > 1)
      throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
    const i = this.extractVaaBytesFromAccumulatorMessage(r[0]), s = await this.verifyVaas([i], t), [o] = t.moveCall({
      target: `${n}::pyth::create_authenticated_price_infos_using_accumulator`,
      arguments: [
        t.object(this.pythStateId),
        t.pure(La.bcs.vector(La.bcs.U8).serialize(Array.from(r[0]), {
          maxSize: Op
        }).toBytes()),
        s[0],
        t.object(jl.SUI_CLOCK_OBJECT_ID)
      ]
    });
    return o;
  }
  async executePriceFeedUpdates(t, r, n, i, s) {
    const o = [];
    let a = 0;
    for (const c of n) {
      const u = await this.getPriceFeedObjectId(c);
      if (!u)
        throw new Error(`Price feed ${c} not found, please create it first`);
      o.push(u), [i] = t.moveCall({
        target: `${r}::pyth::update_single_price_feed`,
        arguments: [
          t.object(this.pythStateId),
          i,
          t.object(u),
          s[a],
          t.object(jl.SUI_CLOCK_OBJECT_ID)
        ]
      }), a++;
    }
    return t.moveCall({
      target: `${r}::hot_potato_vector::destroy`,
      arguments: [i],
      typeArguments: [`${r}::price_info::PriceInfo`]
    }), o;
  }
  /**
   * Adds the necessary commands for updating the pyth price feeds to the transaction block.
   * @param tx transaction block to add commands to
   * @param updates array of price feed updates received from the price service
   * @param feedIds array of feed ids to update (in hex format)
   */
  async updatePriceFeeds(t, r, n) {
    const i = await this.getPythPackageId(), s = await this.verifyVaasAndGetHotPotato(t, r, i), o = await this.getBaseUpdateFee(), a = t.splitCoins(t.gas, n.map(() => t.pure.u64(o)));
    return await this.executePriceFeedUpdates(t, i, n, s, a);
  }
  /**
   * Updates price feeds using the coin input for payment. Coins can be generated by calling splitCoin on tx.gas.
   * @param tx transaction block to add commands to
   * @param updates array of price feed updates received from the price service
   * @param feedIds array of feed ids to update (in hex format)
   * @param coins array of Coins for payment of update operations
   */
  async updatePriceFeedsWithCoins(t, r, n, i) {
    const s = await this.getPythPackageId(), o = await this.verifyVaasAndGetHotPotato(t, r, s);
    return await this.executePriceFeedUpdates(t, s, n, o, i);
  }
  async createPriceFeed(t, r) {
    const n = await this.getPythPackageId();
    if (r.length > 1)
      throw new Error("SDK does not support sending multiple accumulator messages in a single transaction");
    const i = this.extractVaaBytesFromAccumulatorMessage(r[0]), s = await this.verifyVaas([i], t);
    t.moveCall({
      target: `${n}::pyth::create_price_feeds_using_accumulator`,
      arguments: [
        t.object(this.pythStateId),
        t.pure(La.bcs.vector(La.bcs.U8).serialize(Array.from(r[0]), {
          maxSize: Op
        }).toBytes()),
        s[0],
        t.object(jl.SUI_CLOCK_OBJECT_ID)
      ]
    });
  }
  /**
   * Get the packageId for the wormhole package if not already cached
   */
  async getWormholePackageId() {
    return this.wormholePackageId || (this.wormholePackageId = await this.getPackageId(this.wormholeStateId)), this.wormholePackageId;
  }
  /**
   * Get the packageId for the pyth package if not already cached
   */
  async getPythPackageId() {
    return this.pythPackageId || (this.pythPackageId = await this.getPackageId(this.pythStateId)), this.pythPackageId;
  }
  /**
   * Get the priceFeedObjectId for a given feedId if not already cached
   * @param feedId
   */
  async getPriceFeedObjectId(t) {
    const r = t.replace("0x", "");
    if (!this.priceFeedObjectIdCache.has(r)) {
      const { id: n, fieldType: i } = await this.getPriceTableInfo(), s = await this.provider.getDynamicFieldObject({
        parentId: n,
        name: {
          type: `${i}::price_identifier::PriceIdentifier`,
          value: {
            bytes: Array.from(UU.Buffer.from(r, "hex"))
          }
        }
      });
      if (!s.data || !s.data.content)
        return;
      if (s.data.content.dataType !== "moveObject")
        throw new Error("Price feed type mismatch");
      this.priceFeedObjectIdCache.set(
        r,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        s.data.content.fields.value
      );
    }
    return this.priceFeedObjectIdCache.get(r);
  }
  /**
   * Fetches the price table object id for the current state id if not cached
   * @returns price table object id
   */
  async getPriceTableInfo() {
    if (this.priceTableInfo === void 0) {
      const t = await this.provider.getDynamicFieldObject({
        parentId: this.pythStateId,
        name: {
          type: "vector<u8>",
          value: "price_info"
        }
      });
      if (!t.data || !t.data.type)
        throw new Error("Price Table not found, contract may not be initialized");
      let r = t.data.type.replace("0x2::table::Table<", "");
      r = r.replace("::price_identifier::PriceIdentifier, 0x2::object::ID>", ""), this.priceTableInfo = { id: t.data.objectId, fieldType: r };
    }
    return this.priceTableInfo;
  }
  /**
   * Obtains the vaa bytes embedded in an accumulator message.
   * @param accumulatorMessage - the accumulator price update message
   * @returns vaa bytes as a uint8 array
   */
  extractVaaBytesFromAccumulatorMessage(t) {
    const n = 7 + t.readUint8(6) + // trailing payload (variable number of bytes)
    1, i = t.readUint16BE(n), s = n + 2;
    return t.subarray(s, s + i);
  }
}
Hd.SuiPythClient = FU;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PriceFeed = e.Price = e.SuiPythClient = e.SuiPriceServiceConnection = void 0;
  var t = jd;
  Object.defineProperty(e, "SuiPriceServiceConnection", { enumerable: !0, get: function() {
    return t.SuiPriceServiceConnection;
  } });
  var r = Hd;
  Object.defineProperty(e, "SuiPythClient", { enumerable: !0, get: function() {
    return r.SuiPythClient;
  } });
  var n = Jg;
  Object.defineProperty(e, "Price", { enumerable: !0, get: function() {
    return n.Price;
  } }), Object.defineProperty(e, "PriceFeed", { enumerable: !0, get: function() {
    return n.PriceFeed;
  } });
})(fS);
var Ip = ni, VU = HN, hr = Ox, Vv = fL, zv = fS;
function zU(e) {
  return e && e.__esModule ? e : { default: e };
}
var WU = /* @__PURE__ */ zU(VU), qU = Object.create, d1 = Object.defineProperty, HU = Object.defineProperties, GU = Object.getOwnPropertyDescriptor, KU = Object.getOwnPropertyDescriptors, ZS = Object.getOwnPropertyNames, Wv = Object.getOwnPropertySymbols, YU = Object.getPrototypeOf, QS = Object.prototype.hasOwnProperty, XU = Object.prototype.propertyIsEnumerable, qv = (e, t, r) => t in e ? d1(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, JU = (e, t) => {
  for (var r in t || (t = {}))
    QS.call(t, r) && qv(e, r, t[r]);
  if (Wv)
    for (var r of Wv(t))
      XU.call(t, r) && qv(e, r, t[r]);
  return e;
}, ZU = (e, t) => HU(e, KU(t)), QU = /* @__PURE__ */ ((e) => typeof Yi < "u" ? Yi : typeof Proxy < "u" ? new Proxy(e, {
  get: (t, r) => (typeof Yi < "u" ? Yi : t)[r]
}) : e)(function(e) {
  if (typeof Yi < "u")
    return Yi.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
}), eF = (e, t) => function() {
  return t || (0, e[ZS(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, tF = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of ZS(t))
      !QS.call(e, i) && i !== r && d1(e, i, { get: () => t[i], enumerable: !(n = GU(t, i)) || n.enumerable });
  return e;
}, kc = (e, t, r) => (r = e != null ? qU(YU(e)) : {}, tF(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !e || !e.__esModule ? d1(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), bn = (e, t, r) => new Promise((n, i) => {
  var s = (c) => {
    try {
      a(r.next(c));
    } catch (u) {
      i(u);
    }
  }, o = (c) => {
    try {
      a(r.throw(c));
    } catch (u) {
      i(u);
    }
  }, a = (c) => c.done ? n(c.value) : Promise.resolve(c.value).then(s, o);
  a((r = r.apply(e, t)).next());
}), jc = eF({
  "node_modules/bn.js/lib/bn.js"(e, t) {
    (function(r, n) {
      function i(p, d) {
        if (!p)
          throw new Error(d || "Assertion failed");
      }
      function s(p, d) {
        p.super_ = d;
        var m = function() {
        };
        m.prototype = d.prototype, p.prototype = new m(), p.prototype.constructor = p;
      }
      function o(p, d, m) {
        if (o.isBN(p))
          return p;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((d === "le" || d === "be") && (m = d, d = 10), this._init(p || 0, d || 10, m || "be"));
      }
      typeof r == "object" ? r.exports = o : n.BN = o, o.BN = o, o.wordSize = 26;
      var a;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = QU("buffer").Buffer;
      } catch {
      }
      o.isBN = function(d) {
        return d instanceof o ? !0 : d !== null && typeof d == "object" && d.constructor.wordSize === o.wordSize && Array.isArray(d.words);
      }, o.max = function(d, m) {
        return d.cmp(m) > 0 ? d : m;
      }, o.min = function(d, m) {
        return d.cmp(m) < 0 ? d : m;
      }, o.prototype._init = function(d, m, x) {
        if (typeof d == "number")
          return this._initNumber(d, m, x);
        if (typeof d == "object")
          return this._initArray(d, m, x);
        m === "hex" && (m = 16), i(m === (m | 0) && m >= 2 && m <= 36), d = d.toString().replace(/\s+/g, "");
        var E = 0;
        d[0] === "-" && (E++, this.negative = 1), E < d.length && (m === 16 ? this._parseHex(d, E, x) : (this._parseBase(d, m, E), x === "le" && this._initArray(this.toArray(), m, x)));
      }, o.prototype._initNumber = function(d, m, x) {
        d < 0 && (this.negative = 1, d = -d), d < 67108864 ? (this.words = [d & 67108863], this.length = 1) : d < 4503599627370496 ? (this.words = [
          d & 67108863,
          d / 67108864 & 67108863
        ], this.length = 2) : (i(d < 9007199254740992), this.words = [
          d & 67108863,
          d / 67108864 & 67108863,
          1
        ], this.length = 3), x === "le" && this._initArray(this.toArray(), m, x);
      }, o.prototype._initArray = function(d, m, x) {
        if (i(typeof d.length == "number"), d.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(d.length / 3), this.words = new Array(this.length);
        for (var E = 0; E < this.length; E++)
          this.words[E] = 0;
        var A, j, k = 0;
        if (x === "be")
          for (E = d.length - 1, A = 0; E >= 0; E -= 3)
            j = d[E] | d[E - 1] << 8 | d[E - 2] << 16, this.words[A] |= j << k & 67108863, this.words[A + 1] = j >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, A++);
        else if (x === "le")
          for (E = 0, A = 0; E < d.length; E += 3)
            j = d[E] | d[E + 1] << 8 | d[E + 2] << 16, this.words[A] |= j << k & 67108863, this.words[A + 1] = j >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, A++);
        return this._strip();
      };
      function c(p, d) {
        var m = p.charCodeAt(d);
        if (m >= 48 && m <= 57)
          return m - 48;
        if (m >= 65 && m <= 70)
          return m - 55;
        if (m >= 97 && m <= 102)
          return m - 87;
        i(!1, "Invalid character in " + p);
      }
      function u(p, d, m) {
        var x = c(p, m);
        return m - 1 >= d && (x |= c(p, m - 1) << 4), x;
      }
      o.prototype._parseHex = function(d, m, x) {
        this.length = Math.ceil((d.length - m) / 6), this.words = new Array(this.length);
        for (var E = 0; E < this.length; E++)
          this.words[E] = 0;
        var A = 0, j = 0, k;
        if (x === "be")
          for (E = d.length - 1; E >= m; E -= 2)
            k = u(d, m, E) << A, this.words[j] |= k & 67108863, A >= 18 ? (A -= 18, j += 1, this.words[j] |= k >>> 26) : A += 8;
        else {
          var g = d.length - m;
          for (E = g % 2 === 0 ? m + 1 : m; E < d.length; E += 2)
            k = u(d, m, E) << A, this.words[j] |= k & 67108863, A >= 18 ? (A -= 18, j += 1, this.words[j] |= k >>> 26) : A += 8;
        }
        this._strip();
      };
      function l(p, d, m, x) {
        for (var E = 0, A = 0, j = Math.min(p.length, m), k = d; k < j; k++) {
          var g = p.charCodeAt(k) - 48;
          E *= x, g >= 49 ? A = g - 49 + 10 : g >= 17 ? A = g - 17 + 10 : A = g, i(g >= 0 && A < x, "Invalid character"), E += A;
        }
        return E;
      }
      o.prototype._parseBase = function(d, m, x) {
        this.words = [0], this.length = 1;
        for (var E = 0, A = 1; A <= 67108863; A *= m)
          E++;
        E--, A = A / m | 0;
        for (var j = d.length - x, k = j % E, g = Math.min(j, j - k) + x, w = 0, P = x; P < g; P += E)
          w = l(d, P, P + E, m), this.imuln(A), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        if (k !== 0) {
          var ue = 1;
          for (w = l(d, P, d.length, m), P = 0; P < k; P++)
            ue *= m;
          this.imuln(ue), this.words[0] + w < 67108864 ? this.words[0] += w : this._iaddn(w);
        }
        this._strip();
      }, o.prototype.copy = function(d) {
        d.words = new Array(this.length);
        for (var m = 0; m < this.length; m++)
          d.words[m] = this.words[m];
        d.length = this.length, d.negative = this.negative, d.red = this.red;
      };
      function f(p, d) {
        p.words = d.words, p.length = d.length, p.negative = d.negative, p.red = d.red;
      }
      if (o.prototype._move = function(d) {
        f(d, this);
      }, o.prototype.clone = function() {
        var d = new o(null);
        return this.copy(d), d;
      }, o.prototype._expand = function(d) {
        for (; this.length < d; )
          this.words[this.length++] = 0;
        return this;
      }, o.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, o.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          o.prototype[Symbol.for("nodejs.util.inspect.custom")] = h;
        } catch {
          o.prototype.inspect = h;
        }
      else
        o.prototype.inspect = h;
      function h() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var v = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], b = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], y = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      o.prototype.toString = function(d, m) {
        d = d || 10, m = m | 0 || 1;
        var x;
        if (d === 16 || d === "hex") {
          x = "";
          for (var E = 0, A = 0, j = 0; j < this.length; j++) {
            var k = this.words[j], g = ((k << E | A) & 16777215).toString(16);
            A = k >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, j--), A !== 0 || j !== this.length - 1 ? x = v[6 - g.length] + g + x : x = g + x;
          }
          for (A !== 0 && (x = A.toString(16) + x); x.length % m !== 0; )
            x = "0" + x;
          return this.negative !== 0 && (x = "-" + x), x;
        }
        if (d === (d | 0) && d >= 2 && d <= 36) {
          var w = b[d], P = y[d];
          x = "";
          var ue = this.clone();
          for (ue.negative = 0; !ue.isZero(); ) {
            var ie = ue.modrn(P).toString(d);
            ue = ue.idivn(P), ue.isZero() ? x = ie + x : x = v[w - ie.length] + ie + x;
          }
          for (this.isZero() && (x = "0" + x); x.length % m !== 0; )
            x = "0" + x;
          return this.negative !== 0 && (x = "-" + x), x;
        }
        i(!1, "Base should be between 2 and 36");
      }, o.prototype.toNumber = function() {
        var d = this.words[0];
        return this.length === 2 ? d += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? d += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -d : d;
      }, o.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, a && (o.prototype.toBuffer = function(d, m) {
        return this.toArrayLike(a, d, m);
      }), o.prototype.toArray = function(d, m) {
        return this.toArrayLike(Array, d, m);
      };
      var S = function(d, m) {
        return d.allocUnsafe ? d.allocUnsafe(m) : new d(m);
      };
      o.prototype.toArrayLike = function(d, m, x) {
        this._strip();
        var E = this.byteLength(), A = x || Math.max(1, E);
        i(E <= A, "byte array longer than desired length"), i(A > 0, "Requested array length <= 0");
        var j = S(d, A), k = m === "le" ? "LE" : "BE";
        return this["_toArrayLike" + k](j, E), j;
      }, o.prototype._toArrayLikeLE = function(d, m) {
        for (var x = 0, E = 0, A = 0, j = 0; A < this.length; A++) {
          var k = this.words[A] << j | E;
          d[x++] = k & 255, x < d.length && (d[x++] = k >> 8 & 255), x < d.length && (d[x++] = k >> 16 & 255), j === 6 ? (x < d.length && (d[x++] = k >> 24 & 255), E = 0, j = 0) : (E = k >>> 24, j += 2);
        }
        if (x < d.length)
          for (d[x++] = E; x < d.length; )
            d[x++] = 0;
      }, o.prototype._toArrayLikeBE = function(d, m) {
        for (var x = d.length - 1, E = 0, A = 0, j = 0; A < this.length; A++) {
          var k = this.words[A] << j | E;
          d[x--] = k & 255, x >= 0 && (d[x--] = k >> 8 & 255), x >= 0 && (d[x--] = k >> 16 & 255), j === 6 ? (x >= 0 && (d[x--] = k >> 24 & 255), E = 0, j = 0) : (E = k >>> 24, j += 2);
        }
        if (x >= 0)
          for (d[x--] = E; x >= 0; )
            d[x--] = 0;
      }, Math.clz32 ? o.prototype._countBits = function(d) {
        return 32 - Math.clz32(d);
      } : o.prototype._countBits = function(d) {
        var m = d, x = 0;
        return m >= 4096 && (x += 13, m >>>= 13), m >= 64 && (x += 7, m >>>= 7), m >= 8 && (x += 4, m >>>= 4), m >= 2 && (x += 2, m >>>= 2), x + m;
      }, o.prototype._zeroBits = function(d) {
        if (d === 0)
          return 26;
        var m = d, x = 0;
        return m & 8191 || (x += 13, m >>>= 13), m & 127 || (x += 7, m >>>= 7), m & 15 || (x += 4, m >>>= 4), m & 3 || (x += 2, m >>>= 2), m & 1 || x++, x;
      }, o.prototype.bitLength = function() {
        var d = this.words[this.length - 1], m = this._countBits(d);
        return (this.length - 1) * 26 + m;
      };
      function C(p) {
        for (var d = new Array(p.bitLength()), m = 0; m < d.length; m++) {
          var x = m / 26 | 0, E = m % 26;
          d[m] = p.words[x] >>> E & 1;
        }
        return d;
      }
      o.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var d = 0, m = 0; m < this.length; m++) {
          var x = this._zeroBits(this.words[m]);
          if (d += x, x !== 26)
            break;
        }
        return d;
      }, o.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, o.prototype.toTwos = function(d) {
        return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();
      }, o.prototype.fromTwos = function(d) {
        return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();
      }, o.prototype.isNeg = function() {
        return this.negative !== 0;
      }, o.prototype.neg = function() {
        return this.clone().ineg();
      }, o.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, o.prototype.iuor = function(d) {
        for (; this.length < d.length; )
          this.words[this.length++] = 0;
        for (var m = 0; m < d.length; m++)
          this.words[m] = this.words[m] | d.words[m];
        return this._strip();
      }, o.prototype.ior = function(d) {
        return i((this.negative | d.negative) === 0), this.iuor(d);
      }, o.prototype.or = function(d) {
        return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);
      }, o.prototype.uor = function(d) {
        return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);
      }, o.prototype.iuand = function(d) {
        var m;
        this.length > d.length ? m = d : m = this;
        for (var x = 0; x < m.length; x++)
          this.words[x] = this.words[x] & d.words[x];
        return this.length = m.length, this._strip();
      }, o.prototype.iand = function(d) {
        return i((this.negative | d.negative) === 0), this.iuand(d);
      }, o.prototype.and = function(d) {
        return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);
      }, o.prototype.uand = function(d) {
        return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);
      }, o.prototype.iuxor = function(d) {
        var m, x;
        this.length > d.length ? (m = this, x = d) : (m = d, x = this);
        for (var E = 0; E < x.length; E++)
          this.words[E] = m.words[E] ^ x.words[E];
        if (this !== m)
          for (; E < m.length; E++)
            this.words[E] = m.words[E];
        return this.length = m.length, this._strip();
      }, o.prototype.ixor = function(d) {
        return i((this.negative | d.negative) === 0), this.iuxor(d);
      }, o.prototype.xor = function(d) {
        return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);
      }, o.prototype.uxor = function(d) {
        return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);
      }, o.prototype.inotn = function(d) {
        i(typeof d == "number" && d >= 0);
        var m = Math.ceil(d / 26) | 0, x = d % 26;
        this._expand(m), x > 0 && m--;
        for (var E = 0; E < m; E++)
          this.words[E] = ~this.words[E] & 67108863;
        return x > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - x), this._strip();
      }, o.prototype.notn = function(d) {
        return this.clone().inotn(d);
      }, o.prototype.setn = function(d, m) {
        i(typeof d == "number" && d >= 0);
        var x = d / 26 | 0, E = d % 26;
        return this._expand(x + 1), m ? this.words[x] = this.words[x] | 1 << E : this.words[x] = this.words[x] & ~(1 << E), this._strip();
      }, o.prototype.iadd = function(d) {
        var m;
        if (this.negative !== 0 && d.negative === 0)
          return this.negative = 0, m = this.isub(d), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && d.negative !== 0)
          return d.negative = 0, m = this.isub(d), d.negative = 1, m._normSign();
        var x, E;
        this.length > d.length ? (x = this, E = d) : (x = d, E = this);
        for (var A = 0, j = 0; j < E.length; j++)
          m = (x.words[j] | 0) + (E.words[j] | 0) + A, this.words[j] = m & 67108863, A = m >>> 26;
        for (; A !== 0 && j < x.length; j++)
          m = (x.words[j] | 0) + A, this.words[j] = m & 67108863, A = m >>> 26;
        if (this.length = x.length, A !== 0)
          this.words[this.length] = A, this.length++;
        else if (x !== this)
          for (; j < x.length; j++)
            this.words[j] = x.words[j];
        return this;
      }, o.prototype.add = function(d) {
        var m;
        return d.negative !== 0 && this.negative === 0 ? (d.negative = 0, m = this.sub(d), d.negative ^= 1, m) : d.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = d.sub(this), this.negative = 1, m) : this.length > d.length ? this.clone().iadd(d) : d.clone().iadd(this);
      }, o.prototype.isub = function(d) {
        if (d.negative !== 0) {
          d.negative = 0;
          var m = this.iadd(d);
          return d.negative = 1, m._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(d), this.negative = 1, this._normSign();
        var x = this.cmp(d);
        if (x === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var E, A;
        x > 0 ? (E = this, A = d) : (E = d, A = this);
        for (var j = 0, k = 0; k < A.length; k++)
          m = (E.words[k] | 0) - (A.words[k] | 0) + j, j = m >> 26, this.words[k] = m & 67108863;
        for (; j !== 0 && k < E.length; k++)
          m = (E.words[k] | 0) + j, j = m >> 26, this.words[k] = m & 67108863;
        if (j === 0 && k < E.length && E !== this)
          for (; k < E.length; k++)
            this.words[k] = E.words[k];
        return this.length = Math.max(this.length, k), E !== this && (this.negative = 1), this._strip();
      }, o.prototype.sub = function(d) {
        return this.clone().isub(d);
      };
      function O(p, d, m) {
        m.negative = d.negative ^ p.negative;
        var x = p.length + d.length | 0;
        m.length = x, x = x - 1 | 0;
        var E = p.words[0] | 0, A = d.words[0] | 0, j = E * A, k = j & 67108863, g = j / 67108864 | 0;
        m.words[0] = k;
        for (var w = 1; w < x; w++) {
          for (var P = g >>> 26, ue = g & 67108863, ie = Math.min(w, d.length - 1), fe = Math.max(0, w - p.length + 1); fe <= ie; fe++) {
            var ye = w - fe | 0;
            E = p.words[ye] | 0, A = d.words[fe] | 0, j = E * A + ue, P += j / 67108864 | 0, ue = j & 67108863;
          }
          m.words[w] = ue | 0, g = P | 0;
        }
        return g !== 0 ? m.words[w] = g | 0 : m.length--, m._strip();
      }
      var I = function(d, m, x) {
        var E = d.words, A = m.words, j = x.words, k = 0, g, w, P, ue = E[0] | 0, ie = ue & 8191, fe = ue >>> 13, ye = E[1] | 0, Te = ye & 8191, N = ye >>> 13, F = E[2] | 0, G = F & 8191, ee = F >>> 13, Z = E[3] | 0, q = Z & 8191, he = Z >>> 13, Y = E[4] | 0, X = Y & 8191, B = Y >>> 13, se = E[5] | 0, me = se & 8191, de = se >>> 13, xe = E[6] | 0, Oe = xe & 8191, Be = xe >>> 13, Xe = E[7] | 0, Re = Xe & 8191, He = Xe >>> 13, rt = E[8] | 0, Qe = rt & 8191, Ot = rt >>> 13, $t = E[9] | 0, Ge = $t & 8191, ht = $t >>> 13, ct = A[0] | 0, et = ct & 8191, st = ct >>> 13, yt = A[1] | 0, it = yt & 8191, vt = yt >>> 13, Dt = A[2] | 0, pt = Dt & 8191, It = Dt >>> 13, Vt = A[3] | 0, Ke = Vt & 8191, Rt = Vt >>> 13, zt = A[4] | 0, $ = zt & 8191, T = zt >>> 13, M = A[5] | 0, K = M & 8191, ae = M >>> 13, ve = A[6] | 0, we = ve & 8191, nt = ve >>> 13, _t = A[7] | 0, tt = _t & 8191, Q = _t >>> 13, Se = A[8] | 0, Ie = Se & 8191, Je = Se >>> 13, lt = A[9] | 0, Ze = lt & 8191, ot = lt >>> 13;
        x.negative = d.negative ^ m.negative, x.length = 19, g = Math.imul(ie, et), w = Math.imul(ie, st), w = w + Math.imul(fe, et) | 0, P = Math.imul(fe, st);
        var Et = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, g = Math.imul(Te, et), w = Math.imul(Te, st), w = w + Math.imul(N, et) | 0, P = Math.imul(N, st), g = g + Math.imul(ie, it) | 0, w = w + Math.imul(ie, vt) | 0, w = w + Math.imul(fe, it) | 0, P = P + Math.imul(fe, vt) | 0;
        var cr = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, g = Math.imul(G, et), w = Math.imul(G, st), w = w + Math.imul(ee, et) | 0, P = Math.imul(ee, st), g = g + Math.imul(Te, it) | 0, w = w + Math.imul(Te, vt) | 0, w = w + Math.imul(N, it) | 0, P = P + Math.imul(N, vt) | 0, g = g + Math.imul(ie, pt) | 0, w = w + Math.imul(ie, It) | 0, w = w + Math.imul(fe, pt) | 0, P = P + Math.imul(fe, It) | 0;
        var Kt = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, g = Math.imul(q, et), w = Math.imul(q, st), w = w + Math.imul(he, et) | 0, P = Math.imul(he, st), g = g + Math.imul(G, it) | 0, w = w + Math.imul(G, vt) | 0, w = w + Math.imul(ee, it) | 0, P = P + Math.imul(ee, vt) | 0, g = g + Math.imul(Te, pt) | 0, w = w + Math.imul(Te, It) | 0, w = w + Math.imul(N, pt) | 0, P = P + Math.imul(N, It) | 0, g = g + Math.imul(ie, Ke) | 0, w = w + Math.imul(ie, Rt) | 0, w = w + Math.imul(fe, Ke) | 0, P = P + Math.imul(fe, Rt) | 0;
        var Jt = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, g = Math.imul(X, et), w = Math.imul(X, st), w = w + Math.imul(B, et) | 0, P = Math.imul(B, st), g = g + Math.imul(q, it) | 0, w = w + Math.imul(q, vt) | 0, w = w + Math.imul(he, it) | 0, P = P + Math.imul(he, vt) | 0, g = g + Math.imul(G, pt) | 0, w = w + Math.imul(G, It) | 0, w = w + Math.imul(ee, pt) | 0, P = P + Math.imul(ee, It) | 0, g = g + Math.imul(Te, Ke) | 0, w = w + Math.imul(Te, Rt) | 0, w = w + Math.imul(N, Ke) | 0, P = P + Math.imul(N, Rt) | 0, g = g + Math.imul(ie, $) | 0, w = w + Math.imul(ie, T) | 0, w = w + Math.imul(fe, $) | 0, P = P + Math.imul(fe, T) | 0;
        var _r = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, g = Math.imul(me, et), w = Math.imul(me, st), w = w + Math.imul(de, et) | 0, P = Math.imul(de, st), g = g + Math.imul(X, it) | 0, w = w + Math.imul(X, vt) | 0, w = w + Math.imul(B, it) | 0, P = P + Math.imul(B, vt) | 0, g = g + Math.imul(q, pt) | 0, w = w + Math.imul(q, It) | 0, w = w + Math.imul(he, pt) | 0, P = P + Math.imul(he, It) | 0, g = g + Math.imul(G, Ke) | 0, w = w + Math.imul(G, Rt) | 0, w = w + Math.imul(ee, Ke) | 0, P = P + Math.imul(ee, Rt) | 0, g = g + Math.imul(Te, $) | 0, w = w + Math.imul(Te, T) | 0, w = w + Math.imul(N, $) | 0, P = P + Math.imul(N, T) | 0, g = g + Math.imul(ie, K) | 0, w = w + Math.imul(ie, ae) | 0, w = w + Math.imul(fe, K) | 0, P = P + Math.imul(fe, ae) | 0;
        var Jr = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, g = Math.imul(Oe, et), w = Math.imul(Oe, st), w = w + Math.imul(Be, et) | 0, P = Math.imul(Be, st), g = g + Math.imul(me, it) | 0, w = w + Math.imul(me, vt) | 0, w = w + Math.imul(de, it) | 0, P = P + Math.imul(de, vt) | 0, g = g + Math.imul(X, pt) | 0, w = w + Math.imul(X, It) | 0, w = w + Math.imul(B, pt) | 0, P = P + Math.imul(B, It) | 0, g = g + Math.imul(q, Ke) | 0, w = w + Math.imul(q, Rt) | 0, w = w + Math.imul(he, Ke) | 0, P = P + Math.imul(he, Rt) | 0, g = g + Math.imul(G, $) | 0, w = w + Math.imul(G, T) | 0, w = w + Math.imul(ee, $) | 0, P = P + Math.imul(ee, T) | 0, g = g + Math.imul(Te, K) | 0, w = w + Math.imul(Te, ae) | 0, w = w + Math.imul(N, K) | 0, P = P + Math.imul(N, ae) | 0, g = g + Math.imul(ie, we) | 0, w = w + Math.imul(ie, nt) | 0, w = w + Math.imul(fe, we) | 0, P = P + Math.imul(fe, nt) | 0;
        var Sr = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, g = Math.imul(Re, et), w = Math.imul(Re, st), w = w + Math.imul(He, et) | 0, P = Math.imul(He, st), g = g + Math.imul(Oe, it) | 0, w = w + Math.imul(Oe, vt) | 0, w = w + Math.imul(Be, it) | 0, P = P + Math.imul(Be, vt) | 0, g = g + Math.imul(me, pt) | 0, w = w + Math.imul(me, It) | 0, w = w + Math.imul(de, pt) | 0, P = P + Math.imul(de, It) | 0, g = g + Math.imul(X, Ke) | 0, w = w + Math.imul(X, Rt) | 0, w = w + Math.imul(B, Ke) | 0, P = P + Math.imul(B, Rt) | 0, g = g + Math.imul(q, $) | 0, w = w + Math.imul(q, T) | 0, w = w + Math.imul(he, $) | 0, P = P + Math.imul(he, T) | 0, g = g + Math.imul(G, K) | 0, w = w + Math.imul(G, ae) | 0, w = w + Math.imul(ee, K) | 0, P = P + Math.imul(ee, ae) | 0, g = g + Math.imul(Te, we) | 0, w = w + Math.imul(Te, nt) | 0, w = w + Math.imul(N, we) | 0, P = P + Math.imul(N, nt) | 0, g = g + Math.imul(ie, tt) | 0, w = w + Math.imul(ie, Q) | 0, w = w + Math.imul(fe, tt) | 0, P = P + Math.imul(fe, Q) | 0;
        var ur = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, g = Math.imul(Qe, et), w = Math.imul(Qe, st), w = w + Math.imul(Ot, et) | 0, P = Math.imul(Ot, st), g = g + Math.imul(Re, it) | 0, w = w + Math.imul(Re, vt) | 0, w = w + Math.imul(He, it) | 0, P = P + Math.imul(He, vt) | 0, g = g + Math.imul(Oe, pt) | 0, w = w + Math.imul(Oe, It) | 0, w = w + Math.imul(Be, pt) | 0, P = P + Math.imul(Be, It) | 0, g = g + Math.imul(me, Ke) | 0, w = w + Math.imul(me, Rt) | 0, w = w + Math.imul(de, Ke) | 0, P = P + Math.imul(de, Rt) | 0, g = g + Math.imul(X, $) | 0, w = w + Math.imul(X, T) | 0, w = w + Math.imul(B, $) | 0, P = P + Math.imul(B, T) | 0, g = g + Math.imul(q, K) | 0, w = w + Math.imul(q, ae) | 0, w = w + Math.imul(he, K) | 0, P = P + Math.imul(he, ae) | 0, g = g + Math.imul(G, we) | 0, w = w + Math.imul(G, nt) | 0, w = w + Math.imul(ee, we) | 0, P = P + Math.imul(ee, nt) | 0, g = g + Math.imul(Te, tt) | 0, w = w + Math.imul(Te, Q) | 0, w = w + Math.imul(N, tt) | 0, P = P + Math.imul(N, Q) | 0, g = g + Math.imul(ie, Ie) | 0, w = w + Math.imul(ie, Je) | 0, w = w + Math.imul(fe, Ie) | 0, P = P + Math.imul(fe, Je) | 0;
        var Kr = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Kr >>> 26) | 0, Kr &= 67108863, g = Math.imul(Ge, et), w = Math.imul(Ge, st), w = w + Math.imul(ht, et) | 0, P = Math.imul(ht, st), g = g + Math.imul(Qe, it) | 0, w = w + Math.imul(Qe, vt) | 0, w = w + Math.imul(Ot, it) | 0, P = P + Math.imul(Ot, vt) | 0, g = g + Math.imul(Re, pt) | 0, w = w + Math.imul(Re, It) | 0, w = w + Math.imul(He, pt) | 0, P = P + Math.imul(He, It) | 0, g = g + Math.imul(Oe, Ke) | 0, w = w + Math.imul(Oe, Rt) | 0, w = w + Math.imul(Be, Ke) | 0, P = P + Math.imul(Be, Rt) | 0, g = g + Math.imul(me, $) | 0, w = w + Math.imul(me, T) | 0, w = w + Math.imul(de, $) | 0, P = P + Math.imul(de, T) | 0, g = g + Math.imul(X, K) | 0, w = w + Math.imul(X, ae) | 0, w = w + Math.imul(B, K) | 0, P = P + Math.imul(B, ae) | 0, g = g + Math.imul(q, we) | 0, w = w + Math.imul(q, nt) | 0, w = w + Math.imul(he, we) | 0, P = P + Math.imul(he, nt) | 0, g = g + Math.imul(G, tt) | 0, w = w + Math.imul(G, Q) | 0, w = w + Math.imul(ee, tt) | 0, P = P + Math.imul(ee, Q) | 0, g = g + Math.imul(Te, Ie) | 0, w = w + Math.imul(Te, Je) | 0, w = w + Math.imul(N, Ie) | 0, P = P + Math.imul(N, Je) | 0, g = g + Math.imul(ie, Ze) | 0, w = w + Math.imul(ie, ot) | 0, w = w + Math.imul(fe, Ze) | 0, P = P + Math.imul(fe, ot) | 0;
        var li = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, g = Math.imul(Ge, it), w = Math.imul(Ge, vt), w = w + Math.imul(ht, it) | 0, P = Math.imul(ht, vt), g = g + Math.imul(Qe, pt) | 0, w = w + Math.imul(Qe, It) | 0, w = w + Math.imul(Ot, pt) | 0, P = P + Math.imul(Ot, It) | 0, g = g + Math.imul(Re, Ke) | 0, w = w + Math.imul(Re, Rt) | 0, w = w + Math.imul(He, Ke) | 0, P = P + Math.imul(He, Rt) | 0, g = g + Math.imul(Oe, $) | 0, w = w + Math.imul(Oe, T) | 0, w = w + Math.imul(Be, $) | 0, P = P + Math.imul(Be, T) | 0, g = g + Math.imul(me, K) | 0, w = w + Math.imul(me, ae) | 0, w = w + Math.imul(de, K) | 0, P = P + Math.imul(de, ae) | 0, g = g + Math.imul(X, we) | 0, w = w + Math.imul(X, nt) | 0, w = w + Math.imul(B, we) | 0, P = P + Math.imul(B, nt) | 0, g = g + Math.imul(q, tt) | 0, w = w + Math.imul(q, Q) | 0, w = w + Math.imul(he, tt) | 0, P = P + Math.imul(he, Q) | 0, g = g + Math.imul(G, Ie) | 0, w = w + Math.imul(G, Je) | 0, w = w + Math.imul(ee, Ie) | 0, P = P + Math.imul(ee, Je) | 0, g = g + Math.imul(Te, Ze) | 0, w = w + Math.imul(Te, ot) | 0, w = w + Math.imul(N, Ze) | 0, P = P + Math.imul(N, ot) | 0;
        var Cn = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, g = Math.imul(Ge, pt), w = Math.imul(Ge, It), w = w + Math.imul(ht, pt) | 0, P = Math.imul(ht, It), g = g + Math.imul(Qe, Ke) | 0, w = w + Math.imul(Qe, Rt) | 0, w = w + Math.imul(Ot, Ke) | 0, P = P + Math.imul(Ot, Rt) | 0, g = g + Math.imul(Re, $) | 0, w = w + Math.imul(Re, T) | 0, w = w + Math.imul(He, $) | 0, P = P + Math.imul(He, T) | 0, g = g + Math.imul(Oe, K) | 0, w = w + Math.imul(Oe, ae) | 0, w = w + Math.imul(Be, K) | 0, P = P + Math.imul(Be, ae) | 0, g = g + Math.imul(me, we) | 0, w = w + Math.imul(me, nt) | 0, w = w + Math.imul(de, we) | 0, P = P + Math.imul(de, nt) | 0, g = g + Math.imul(X, tt) | 0, w = w + Math.imul(X, Q) | 0, w = w + Math.imul(B, tt) | 0, P = P + Math.imul(B, Q) | 0, g = g + Math.imul(q, Ie) | 0, w = w + Math.imul(q, Je) | 0, w = w + Math.imul(he, Ie) | 0, P = P + Math.imul(he, Je) | 0, g = g + Math.imul(G, Ze) | 0, w = w + Math.imul(G, ot) | 0, w = w + Math.imul(ee, Ze) | 0, P = P + Math.imul(ee, ot) | 0;
        var fi = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, g = Math.imul(Ge, Ke), w = Math.imul(Ge, Rt), w = w + Math.imul(ht, Ke) | 0, P = Math.imul(ht, Rt), g = g + Math.imul(Qe, $) | 0, w = w + Math.imul(Qe, T) | 0, w = w + Math.imul(Ot, $) | 0, P = P + Math.imul(Ot, T) | 0, g = g + Math.imul(Re, K) | 0, w = w + Math.imul(Re, ae) | 0, w = w + Math.imul(He, K) | 0, P = P + Math.imul(He, ae) | 0, g = g + Math.imul(Oe, we) | 0, w = w + Math.imul(Oe, nt) | 0, w = w + Math.imul(Be, we) | 0, P = P + Math.imul(Be, nt) | 0, g = g + Math.imul(me, tt) | 0, w = w + Math.imul(me, Q) | 0, w = w + Math.imul(de, tt) | 0, P = P + Math.imul(de, Q) | 0, g = g + Math.imul(X, Ie) | 0, w = w + Math.imul(X, Je) | 0, w = w + Math.imul(B, Ie) | 0, P = P + Math.imul(B, Je) | 0, g = g + Math.imul(q, Ze) | 0, w = w + Math.imul(q, ot) | 0, w = w + Math.imul(he, Ze) | 0, P = P + Math.imul(he, ot) | 0;
        var ms = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (ms >>> 26) | 0, ms &= 67108863, g = Math.imul(Ge, $), w = Math.imul(Ge, T), w = w + Math.imul(ht, $) | 0, P = Math.imul(ht, T), g = g + Math.imul(Qe, K) | 0, w = w + Math.imul(Qe, ae) | 0, w = w + Math.imul(Ot, K) | 0, P = P + Math.imul(Ot, ae) | 0, g = g + Math.imul(Re, we) | 0, w = w + Math.imul(Re, nt) | 0, w = w + Math.imul(He, we) | 0, P = P + Math.imul(He, nt) | 0, g = g + Math.imul(Oe, tt) | 0, w = w + Math.imul(Oe, Q) | 0, w = w + Math.imul(Be, tt) | 0, P = P + Math.imul(Be, Q) | 0, g = g + Math.imul(me, Ie) | 0, w = w + Math.imul(me, Je) | 0, w = w + Math.imul(de, Ie) | 0, P = P + Math.imul(de, Je) | 0, g = g + Math.imul(X, Ze) | 0, w = w + Math.imul(X, ot) | 0, w = w + Math.imul(B, Ze) | 0, P = P + Math.imul(B, ot) | 0;
        var gs = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (gs >>> 26) | 0, gs &= 67108863, g = Math.imul(Ge, K), w = Math.imul(Ge, ae), w = w + Math.imul(ht, K) | 0, P = Math.imul(ht, ae), g = g + Math.imul(Qe, we) | 0, w = w + Math.imul(Qe, nt) | 0, w = w + Math.imul(Ot, we) | 0, P = P + Math.imul(Ot, nt) | 0, g = g + Math.imul(Re, tt) | 0, w = w + Math.imul(Re, Q) | 0, w = w + Math.imul(He, tt) | 0, P = P + Math.imul(He, Q) | 0, g = g + Math.imul(Oe, Ie) | 0, w = w + Math.imul(Oe, Je) | 0, w = w + Math.imul(Be, Ie) | 0, P = P + Math.imul(Be, Je) | 0, g = g + Math.imul(me, Ze) | 0, w = w + Math.imul(me, ot) | 0, w = w + Math.imul(de, Ze) | 0, P = P + Math.imul(de, ot) | 0;
        var di = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, g = Math.imul(Ge, we), w = Math.imul(Ge, nt), w = w + Math.imul(ht, we) | 0, P = Math.imul(ht, nt), g = g + Math.imul(Qe, tt) | 0, w = w + Math.imul(Qe, Q) | 0, w = w + Math.imul(Ot, tt) | 0, P = P + Math.imul(Ot, Q) | 0, g = g + Math.imul(Re, Ie) | 0, w = w + Math.imul(Re, Je) | 0, w = w + Math.imul(He, Ie) | 0, P = P + Math.imul(He, Je) | 0, g = g + Math.imul(Oe, Ze) | 0, w = w + Math.imul(Oe, ot) | 0, w = w + Math.imul(Be, Ze) | 0, P = P + Math.imul(Be, ot) | 0;
        var ys = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (ys >>> 26) | 0, ys &= 67108863, g = Math.imul(Ge, tt), w = Math.imul(Ge, Q), w = w + Math.imul(ht, tt) | 0, P = Math.imul(ht, Q), g = g + Math.imul(Qe, Ie) | 0, w = w + Math.imul(Qe, Je) | 0, w = w + Math.imul(Ot, Ie) | 0, P = P + Math.imul(Ot, Je) | 0, g = g + Math.imul(Re, Ze) | 0, w = w + Math.imul(Re, ot) | 0, w = w + Math.imul(He, Ze) | 0, P = P + Math.imul(He, ot) | 0;
        var vs = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (vs >>> 26) | 0, vs &= 67108863, g = Math.imul(Ge, Ie), w = Math.imul(Ge, Je), w = w + Math.imul(ht, Ie) | 0, P = Math.imul(ht, Je), g = g + Math.imul(Qe, Ze) | 0, w = w + Math.imul(Qe, ot) | 0, w = w + Math.imul(Ot, Ze) | 0, P = P + Math.imul(Ot, ot) | 0;
        var W = (k + g | 0) + ((w & 8191) << 13) | 0;
        k = (P + (w >>> 13) | 0) + (W >>> 26) | 0, W &= 67108863, g = Math.imul(Ge, Ze), w = Math.imul(Ge, ot), w = w + Math.imul(ht, Ze) | 0, P = Math.imul(ht, ot);
        var oe = (k + g | 0) + ((w & 8191) << 13) | 0;
        return k = (P + (w >>> 13) | 0) + (oe >>> 26) | 0, oe &= 67108863, j[0] = Et, j[1] = cr, j[2] = Kt, j[3] = Jt, j[4] = _r, j[5] = Jr, j[6] = Sr, j[7] = ur, j[8] = Kr, j[9] = li, j[10] = Cn, j[11] = fi, j[12] = ms, j[13] = gs, j[14] = di, j[15] = ys, j[16] = vs, j[17] = W, j[18] = oe, k !== 0 && (j[19] = k, x.length++), x;
      };
      Math.imul || (I = O);
      function U(p, d, m) {
        m.negative = d.negative ^ p.negative, m.length = p.length + d.length;
        for (var x = 0, E = 0, A = 0; A < m.length - 1; A++) {
          var j = E;
          E = 0;
          for (var k = x & 67108863, g = Math.min(A, d.length - 1), w = Math.max(0, A - p.length + 1); w <= g; w++) {
            var P = A - w, ue = p.words[P] | 0, ie = d.words[w] | 0, fe = ue * ie, ye = fe & 67108863;
            j = j + (fe / 67108864 | 0) | 0, ye = ye + k | 0, k = ye & 67108863, j = j + (ye >>> 26) | 0, E += j >>> 26, j &= 67108863;
          }
          m.words[A] = k, x = j, j = E;
        }
        return x !== 0 ? m.words[A] = x : m.length--, m._strip();
      }
      function D(p, d, m) {
        return U(p, d, m);
      }
      o.prototype.mulTo = function(d, m) {
        var x, E = this.length + d.length;
        return this.length === 10 && d.length === 10 ? x = I(this, d, m) : E < 63 ? x = O(this, d, m) : E < 1024 ? x = U(this, d, m) : x = D(this, d, m), x;
      }, o.prototype.mul = function(d) {
        var m = new o(null);
        return m.words = new Array(this.length + d.length), this.mulTo(d, m);
      }, o.prototype.mulf = function(d) {
        var m = new o(null);
        return m.words = new Array(this.length + d.length), D(this, d, m);
      }, o.prototype.imul = function(d) {
        return this.clone().mulTo(d, this);
      }, o.prototype.imuln = function(d) {
        var m = d < 0;
        m && (d = -d), i(typeof d == "number"), i(d < 67108864);
        for (var x = 0, E = 0; E < this.length; E++) {
          var A = (this.words[E] | 0) * d, j = (A & 67108863) + (x & 67108863);
          x >>= 26, x += A / 67108864 | 0, x += j >>> 26, this.words[E] = j & 67108863;
        }
        return x !== 0 && (this.words[E] = x, this.length++), this.length = d === 0 ? 1 : this.length, m ? this.ineg() : this;
      }, o.prototype.muln = function(d) {
        return this.clone().imuln(d);
      }, o.prototype.sqr = function() {
        return this.mul(this);
      }, o.prototype.isqr = function() {
        return this.imul(this.clone());
      }, o.prototype.pow = function(d) {
        var m = C(d);
        if (m.length === 0)
          return new o(1);
        for (var x = this, E = 0; E < m.length && m[E] === 0; E++, x = x.sqr())
          ;
        if (++E < m.length)
          for (var A = x.sqr(); E < m.length; E++, A = A.sqr())
            m[E] !== 0 && (x = x.mul(A));
        return x;
      }, o.prototype.iushln = function(d) {
        i(typeof d == "number" && d >= 0);
        var m = d % 26, x = (d - m) / 26, E = 67108863 >>> 26 - m << 26 - m, A;
        if (m !== 0) {
          var j = 0;
          for (A = 0; A < this.length; A++) {
            var k = this.words[A] & E, g = (this.words[A] | 0) - k << m;
            this.words[A] = g | j, j = k >>> 26 - m;
          }
          j && (this.words[A] = j, this.length++);
        }
        if (x !== 0) {
          for (A = this.length - 1; A >= 0; A--)
            this.words[A + x] = this.words[A];
          for (A = 0; A < x; A++)
            this.words[A] = 0;
          this.length += x;
        }
        return this._strip();
      }, o.prototype.ishln = function(d) {
        return i(this.negative === 0), this.iushln(d);
      }, o.prototype.iushrn = function(d, m, x) {
        i(typeof d == "number" && d >= 0);
        var E;
        m ? E = (m - m % 26) / 26 : E = 0;
        var A = d % 26, j = Math.min((d - A) / 26, this.length), k = 67108863 ^ 67108863 >>> A << A, g = x;
        if (E -= j, E = Math.max(0, E), g) {
          for (var w = 0; w < j; w++)
            g.words[w] = this.words[w];
          g.length = j;
        }
        if (j !== 0)
          if (this.length > j)
            for (this.length -= j, w = 0; w < this.length; w++)
              this.words[w] = this.words[w + j];
          else
            this.words[0] = 0, this.length = 1;
        var P = 0;
        for (w = this.length - 1; w >= 0 && (P !== 0 || w >= E); w--) {
          var ue = this.words[w] | 0;
          this.words[w] = P << 26 - A | ue >>> A, P = ue & k;
        }
        return g && P !== 0 && (g.words[g.length++] = P), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, o.prototype.ishrn = function(d, m, x) {
        return i(this.negative === 0), this.iushrn(d, m, x);
      }, o.prototype.shln = function(d) {
        return this.clone().ishln(d);
      }, o.prototype.ushln = function(d) {
        return this.clone().iushln(d);
      }, o.prototype.shrn = function(d) {
        return this.clone().ishrn(d);
      }, o.prototype.ushrn = function(d) {
        return this.clone().iushrn(d);
      }, o.prototype.testn = function(d) {
        i(typeof d == "number" && d >= 0);
        var m = d % 26, x = (d - m) / 26, E = 1 << m;
        if (this.length <= x)
          return !1;
        var A = this.words[x];
        return !!(A & E);
      }, o.prototype.imaskn = function(d) {
        i(typeof d == "number" && d >= 0);
        var m = d % 26, x = (d - m) / 26;
        if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= x)
          return this;
        if (m !== 0 && x++, this.length = Math.min(x, this.length), m !== 0) {
          var E = 67108863 ^ 67108863 >>> m << m;
          this.words[this.length - 1] &= E;
        }
        return this._strip();
      }, o.prototype.maskn = function(d) {
        return this.clone().imaskn(d);
      }, o.prototype.iaddn = function(d) {
        return i(typeof d == "number"), i(d < 67108864), d < 0 ? this.isubn(-d) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= d ? (this.words[0] = d - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(d), this.negative = 1, this) : this._iaddn(d);
      }, o.prototype._iaddn = function(d) {
        this.words[0] += d;
        for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
          this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
        return this.length = Math.max(this.length, m + 1), this;
      }, o.prototype.isubn = function(d) {
        if (i(typeof d == "number"), i(d < 67108864), d < 0)
          return this.iaddn(-d);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(d), this.negative = 1, this;
        if (this.words[0] -= d, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var m = 0; m < this.length && this.words[m] < 0; m++)
            this.words[m] += 67108864, this.words[m + 1] -= 1;
        return this._strip();
      }, o.prototype.addn = function(d) {
        return this.clone().iaddn(d);
      }, o.prototype.subn = function(d) {
        return this.clone().isubn(d);
      }, o.prototype.iabs = function() {
        return this.negative = 0, this;
      }, o.prototype.abs = function() {
        return this.clone().iabs();
      }, o.prototype._ishlnsubmul = function(d, m, x) {
        var E = d.length + x, A;
        this._expand(E);
        var j, k = 0;
        for (A = 0; A < d.length; A++) {
          j = (this.words[A + x] | 0) + k;
          var g = (d.words[A] | 0) * m;
          j -= g & 67108863, k = (j >> 26) - (g / 67108864 | 0), this.words[A + x] = j & 67108863;
        }
        for (; A < this.length - x; A++)
          j = (this.words[A + x] | 0) + k, k = j >> 26, this.words[A + x] = j & 67108863;
        if (k === 0)
          return this._strip();
        for (i(k === -1), k = 0, A = 0; A < this.length; A++)
          j = -(this.words[A] | 0) + k, k = j >> 26, this.words[A] = j & 67108863;
        return this.negative = 1, this._strip();
      }, o.prototype._wordDiv = function(d, m) {
        var x = this.length - d.length, E = this.clone(), A = d, j = A.words[A.length - 1] | 0, k = this._countBits(j);
        x = 26 - k, x !== 0 && (A = A.ushln(x), E.iushln(x), j = A.words[A.length - 1] | 0);
        var g = E.length - A.length, w;
        if (m !== "mod") {
          w = new o(null), w.length = g + 1, w.words = new Array(w.length);
          for (var P = 0; P < w.length; P++)
            w.words[P] = 0;
        }
        var ue = E.clone()._ishlnsubmul(A, 1, g);
        ue.negative === 0 && (E = ue, w && (w.words[g] = 1));
        for (var ie = g - 1; ie >= 0; ie--) {
          var fe = (E.words[A.length + ie] | 0) * 67108864 + (E.words[A.length + ie - 1] | 0);
          for (fe = Math.min(fe / j | 0, 67108863), E._ishlnsubmul(A, fe, ie); E.negative !== 0; )
            fe--, E.negative = 0, E._ishlnsubmul(A, 1, ie), E.isZero() || (E.negative ^= 1);
          w && (w.words[ie] = fe);
        }
        return w && w._strip(), E._strip(), m !== "div" && x !== 0 && E.iushrn(x), {
          div: w || null,
          mod: E
        };
      }, o.prototype.divmod = function(d, m, x) {
        if (i(!d.isZero()), this.isZero())
          return {
            div: new o(0),
            mod: new o(0)
          };
        var E, A, j;
        return this.negative !== 0 && d.negative === 0 ? (j = this.neg().divmod(d, m), m !== "mod" && (E = j.div.neg()), m !== "div" && (A = j.mod.neg(), x && A.negative !== 0 && A.iadd(d)), {
          div: E,
          mod: A
        }) : this.negative === 0 && d.negative !== 0 ? (j = this.divmod(d.neg(), m), m !== "mod" && (E = j.div.neg()), {
          div: E,
          mod: j.mod
        }) : this.negative & d.negative ? (j = this.neg().divmod(d.neg(), m), m !== "div" && (A = j.mod.neg(), x && A.negative !== 0 && A.isub(d)), {
          div: j.div,
          mod: A
        }) : d.length > this.length || this.cmp(d) < 0 ? {
          div: new o(0),
          mod: this
        } : d.length === 1 ? m === "div" ? {
          div: this.divn(d.words[0]),
          mod: null
        } : m === "mod" ? {
          div: null,
          mod: new o(this.modrn(d.words[0]))
        } : {
          div: this.divn(d.words[0]),
          mod: new o(this.modrn(d.words[0]))
        } : this._wordDiv(d, m);
      }, o.prototype.div = function(d) {
        return this.divmod(d, "div", !1).div;
      }, o.prototype.mod = function(d) {
        return this.divmod(d, "mod", !1).mod;
      }, o.prototype.umod = function(d) {
        return this.divmod(d, "mod", !0).mod;
      }, o.prototype.divRound = function(d) {
        var m = this.divmod(d);
        if (m.mod.isZero())
          return m.div;
        var x = m.div.negative !== 0 ? m.mod.isub(d) : m.mod, E = d.ushrn(1), A = d.andln(1), j = x.cmp(E);
        return j < 0 || A === 1 && j === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
      }, o.prototype.modrn = function(d) {
        var m = d < 0;
        m && (d = -d), i(d <= 67108863);
        for (var x = (1 << 26) % d, E = 0, A = this.length - 1; A >= 0; A--)
          E = (x * E + (this.words[A] | 0)) % d;
        return m ? -E : E;
      }, o.prototype.modn = function(d) {
        return this.modrn(d);
      }, o.prototype.idivn = function(d) {
        var m = d < 0;
        m && (d = -d), i(d <= 67108863);
        for (var x = 0, E = this.length - 1; E >= 0; E--) {
          var A = (this.words[E] | 0) + x * 67108864;
          this.words[E] = A / d | 0, x = A % d;
        }
        return this._strip(), m ? this.ineg() : this;
      }, o.prototype.divn = function(d) {
        return this.clone().idivn(d);
      }, o.prototype.egcd = function(d) {
        i(d.negative === 0), i(!d.isZero());
        var m = this, x = d.clone();
        m.negative !== 0 ? m = m.umod(d) : m = m.clone();
        for (var E = new o(1), A = new o(0), j = new o(0), k = new o(1), g = 0; m.isEven() && x.isEven(); )
          m.iushrn(1), x.iushrn(1), ++g;
        for (var w = x.clone(), P = m.clone(); !m.isZero(); ) {
          for (var ue = 0, ie = 1; !(m.words[0] & ie) && ue < 26; ++ue, ie <<= 1)
            ;
          if (ue > 0)
            for (m.iushrn(ue); ue-- > 0; )
              (E.isOdd() || A.isOdd()) && (E.iadd(w), A.isub(P)), E.iushrn(1), A.iushrn(1);
          for (var fe = 0, ye = 1; !(x.words[0] & ye) && fe < 26; ++fe, ye <<= 1)
            ;
          if (fe > 0)
            for (x.iushrn(fe); fe-- > 0; )
              (j.isOdd() || k.isOdd()) && (j.iadd(w), k.isub(P)), j.iushrn(1), k.iushrn(1);
          m.cmp(x) >= 0 ? (m.isub(x), E.isub(j), A.isub(k)) : (x.isub(m), j.isub(E), k.isub(A));
        }
        return {
          a: j,
          b: k,
          gcd: x.iushln(g)
        };
      }, o.prototype._invmp = function(d) {
        i(d.negative === 0), i(!d.isZero());
        var m = this, x = d.clone();
        m.negative !== 0 ? m = m.umod(d) : m = m.clone();
        for (var E = new o(1), A = new o(0), j = x.clone(); m.cmpn(1) > 0 && x.cmpn(1) > 0; ) {
          for (var k = 0, g = 1; !(m.words[0] & g) && k < 26; ++k, g <<= 1)
            ;
          if (k > 0)
            for (m.iushrn(k); k-- > 0; )
              E.isOdd() && E.iadd(j), E.iushrn(1);
          for (var w = 0, P = 1; !(x.words[0] & P) && w < 26; ++w, P <<= 1)
            ;
          if (w > 0)
            for (x.iushrn(w); w-- > 0; )
              A.isOdd() && A.iadd(j), A.iushrn(1);
          m.cmp(x) >= 0 ? (m.isub(x), E.isub(A)) : (x.isub(m), A.isub(E));
        }
        var ue;
        return m.cmpn(1) === 0 ? ue = E : ue = A, ue.cmpn(0) < 0 && ue.iadd(d), ue;
      }, o.prototype.gcd = function(d) {
        if (this.isZero())
          return d.abs();
        if (d.isZero())
          return this.abs();
        var m = this.clone(), x = d.clone();
        m.negative = 0, x.negative = 0;
        for (var E = 0; m.isEven() && x.isEven(); E++)
          m.iushrn(1), x.iushrn(1);
        do {
          for (; m.isEven(); )
            m.iushrn(1);
          for (; x.isEven(); )
            x.iushrn(1);
          var A = m.cmp(x);
          if (A < 0) {
            var j = m;
            m = x, x = j;
          } else if (A === 0 || x.cmpn(1) === 0)
            break;
          m.isub(x);
        } while (!0);
        return x.iushln(E);
      }, o.prototype.invm = function(d) {
        return this.egcd(d).a.umod(d);
      }, o.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, o.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, o.prototype.andln = function(d) {
        return this.words[0] & d;
      }, o.prototype.bincn = function(d) {
        i(typeof d == "number");
        var m = d % 26, x = (d - m) / 26, E = 1 << m;
        if (this.length <= x)
          return this._expand(x + 1), this.words[x] |= E, this;
        for (var A = E, j = x; A !== 0 && j < this.length; j++) {
          var k = this.words[j] | 0;
          k += A, A = k >>> 26, k &= 67108863, this.words[j] = k;
        }
        return A !== 0 && (this.words[j] = A, this.length++), this;
      }, o.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, o.prototype.cmpn = function(d) {
        var m = d < 0;
        if (this.negative !== 0 && !m)
          return -1;
        if (this.negative === 0 && m)
          return 1;
        this._strip();
        var x;
        if (this.length > 1)
          x = 1;
        else {
          m && (d = -d), i(d <= 67108863, "Number is too big");
          var E = this.words[0] | 0;
          x = E === d ? 0 : E < d ? -1 : 1;
        }
        return this.negative !== 0 ? -x | 0 : x;
      }, o.prototype.cmp = function(d) {
        if (this.negative !== 0 && d.negative === 0)
          return -1;
        if (this.negative === 0 && d.negative !== 0)
          return 1;
        var m = this.ucmp(d);
        return this.negative !== 0 ? -m | 0 : m;
      }, o.prototype.ucmp = function(d) {
        if (this.length > d.length)
          return 1;
        if (this.length < d.length)
          return -1;
        for (var m = 0, x = this.length - 1; x >= 0; x--) {
          var E = this.words[x] | 0, A = d.words[x] | 0;
          if (E !== A) {
            E < A ? m = -1 : E > A && (m = 1);
            break;
          }
        }
        return m;
      }, o.prototype.gtn = function(d) {
        return this.cmpn(d) === 1;
      }, o.prototype.gt = function(d) {
        return this.cmp(d) === 1;
      }, o.prototype.gten = function(d) {
        return this.cmpn(d) >= 0;
      }, o.prototype.gte = function(d) {
        return this.cmp(d) >= 0;
      }, o.prototype.ltn = function(d) {
        return this.cmpn(d) === -1;
      }, o.prototype.lt = function(d) {
        return this.cmp(d) === -1;
      }, o.prototype.lten = function(d) {
        return this.cmpn(d) <= 0;
      }, o.prototype.lte = function(d) {
        return this.cmp(d) <= 0;
      }, o.prototype.eqn = function(d) {
        return this.cmpn(d) === 0;
      }, o.prototype.eq = function(d) {
        return this.cmp(d) === 0;
      }, o.red = function(d) {
        return new V(d);
      }, o.prototype.toRed = function(d) {
        return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), d.convertTo(this)._forceRed(d);
      }, o.prototype.fromRed = function() {
        return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, o.prototype._forceRed = function(d) {
        return this.red = d, this;
      }, o.prototype.forceRed = function(d) {
        return i(!this.red, "Already a number in reduction context"), this._forceRed(d);
      }, o.prototype.redAdd = function(d) {
        return i(this.red, "redAdd works only with red numbers"), this.red.add(this, d);
      }, o.prototype.redIAdd = function(d) {
        return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, d);
      }, o.prototype.redSub = function(d) {
        return i(this.red, "redSub works only with red numbers"), this.red.sub(this, d);
      }, o.prototype.redISub = function(d) {
        return i(this.red, "redISub works only with red numbers"), this.red.isub(this, d);
      }, o.prototype.redShl = function(d) {
        return i(this.red, "redShl works only with red numbers"), this.red.shl(this, d);
      }, o.prototype.redMul = function(d) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.mul(this, d);
      }, o.prototype.redIMul = function(d) {
        return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.imul(this, d);
      }, o.prototype.redSqr = function() {
        return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, o.prototype.redISqr = function() {
        return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, o.prototype.redSqrt = function() {
        return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, o.prototype.redInvm = function() {
        return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, o.prototype.redNeg = function() {
        return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, o.prototype.redPow = function(d) {
        return i(this.red && !d.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, d);
      };
      var H = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function z(p, d) {
        this.name = p, this.p = new o(d, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      z.prototype._tmp = function() {
        var d = new o(null);
        return d.words = new Array(Math.ceil(this.n / 13)), d;
      }, z.prototype.ireduce = function(d) {
        var m = d, x;
        do
          this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), x = m.bitLength();
        while (x > this.n);
        var E = x < this.n ? -1 : m.ucmp(this.p);
        return E === 0 ? (m.words[0] = 0, m.length = 1) : E > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
      }, z.prototype.split = function(d, m) {
        d.iushrn(this.n, 0, m);
      }, z.prototype.imulK = function(d) {
        return d.imul(this.k);
      };
      function ne() {
        z.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      s(ne, z), ne.prototype.split = function(d, m) {
        for (var x = 4194303, E = Math.min(d.length, 9), A = 0; A < E; A++)
          m.words[A] = d.words[A];
        if (m.length = E, d.length <= 9) {
          d.words[0] = 0, d.length = 1;
          return;
        }
        var j = d.words[9];
        for (m.words[m.length++] = j & x, A = 10; A < d.length; A++) {
          var k = d.words[A] | 0;
          d.words[A - 10] = (k & x) << 4 | j >>> 22, j = k;
        }
        j >>>= 22, d.words[A - 10] = j, j === 0 && d.length > 10 ? d.length -= 10 : d.length -= 9;
      }, ne.prototype.imulK = function(d) {
        d.words[d.length] = 0, d.words[d.length + 1] = 0, d.length += 2;
        for (var m = 0, x = 0; x < d.length; x++) {
          var E = d.words[x] | 0;
          m += E * 977, d.words[x] = m & 67108863, m = E * 64 + (m / 67108864 | 0);
        }
        return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;
      };
      function le() {
        z.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      s(le, z);
      function te() {
        z.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      s(te, z);
      function ce() {
        z.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      s(ce, z), ce.prototype.imulK = function(d) {
        for (var m = 0, x = 0; x < d.length; x++) {
          var E = (d.words[x] | 0) * 19 + m, A = E & 67108863;
          E >>>= 26, d.words[x] = A, m = E;
        }
        return m !== 0 && (d.words[d.length++] = m), d;
      }, o._prime = function(d) {
        if (H[d])
          return H[d];
        var m;
        if (d === "k256")
          m = new ne();
        else if (d === "p224")
          m = new le();
        else if (d === "p192")
          m = new te();
        else if (d === "p25519")
          m = new ce();
        else
          throw new Error("Unknown prime " + d);
        return H[d] = m, m;
      };
      function V(p) {
        if (typeof p == "string") {
          var d = o._prime(p);
          this.m = d.p, this.prime = d;
        } else
          i(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
      }
      V.prototype._verify1 = function(d) {
        i(d.negative === 0, "red works only with positives"), i(d.red, "red works only with red numbers");
      }, V.prototype._verify2 = function(d, m) {
        i((d.negative | m.negative) === 0, "red works only with positives"), i(
          d.red && d.red === m.red,
          "red works only with red numbers"
        );
      }, V.prototype.imod = function(d) {
        return this.prime ? this.prime.ireduce(d)._forceRed(this) : (f(d, d.umod(this.m)._forceRed(this)), d);
      }, V.prototype.neg = function(d) {
        return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);
      }, V.prototype.add = function(d, m) {
        this._verify2(d, m);
        var x = d.add(m);
        return x.cmp(this.m) >= 0 && x.isub(this.m), x._forceRed(this);
      }, V.prototype.iadd = function(d, m) {
        this._verify2(d, m);
        var x = d.iadd(m);
        return x.cmp(this.m) >= 0 && x.isub(this.m), x;
      }, V.prototype.sub = function(d, m) {
        this._verify2(d, m);
        var x = d.sub(m);
        return x.cmpn(0) < 0 && x.iadd(this.m), x._forceRed(this);
      }, V.prototype.isub = function(d, m) {
        this._verify2(d, m);
        var x = d.isub(m);
        return x.cmpn(0) < 0 && x.iadd(this.m), x;
      }, V.prototype.shl = function(d, m) {
        return this._verify1(d), this.imod(d.ushln(m));
      }, V.prototype.imul = function(d, m) {
        return this._verify2(d, m), this.imod(d.imul(m));
      }, V.prototype.mul = function(d, m) {
        return this._verify2(d, m), this.imod(d.mul(m));
      }, V.prototype.isqr = function(d) {
        return this.imul(d, d.clone());
      }, V.prototype.sqr = function(d) {
        return this.mul(d, d);
      }, V.prototype.sqrt = function(d) {
        if (d.isZero())
          return d.clone();
        var m = this.m.andln(3);
        if (i(m % 2 === 1), m === 3) {
          var x = this.m.add(new o(1)).iushrn(2);
          return this.pow(d, x);
        }
        for (var E = this.m.subn(1), A = 0; !E.isZero() && E.andln(1) === 0; )
          A++, E.iushrn(1);
        i(!E.isZero());
        var j = new o(1).toRed(this), k = j.redNeg(), g = this.m.subn(1).iushrn(1), w = this.m.bitLength();
        for (w = new o(2 * w * w).toRed(this); this.pow(w, g).cmp(k) !== 0; )
          w.redIAdd(k);
        for (var P = this.pow(w, E), ue = this.pow(d, E.addn(1).iushrn(1)), ie = this.pow(d, E), fe = A; ie.cmp(j) !== 0; ) {
          for (var ye = ie, Te = 0; ye.cmp(j) !== 0; Te++)
            ye = ye.redSqr();
          i(Te < fe);
          var N = this.pow(P, new o(1).iushln(fe - Te - 1));
          ue = ue.redMul(N), P = N.redSqr(), ie = ie.redMul(P), fe = Te;
        }
        return ue;
      }, V.prototype.invm = function(d) {
        var m = d._invmp(this.m);
        return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
      }, V.prototype.pow = function(d, m) {
        if (m.isZero())
          return new o(1).toRed(this);
        if (m.cmpn(1) === 0)
          return d.clone();
        var x = 4, E = new Array(1 << x);
        E[0] = new o(1).toRed(this), E[1] = d;
        for (var A = 2; A < E.length; A++)
          E[A] = this.mul(E[A - 1], d);
        var j = E[0], k = 0, g = 0, w = m.bitLength() % 26;
        for (w === 0 && (w = 26), A = m.length - 1; A >= 0; A--) {
          for (var P = m.words[A], ue = w - 1; ue >= 0; ue--) {
            var ie = P >> ue & 1;
            if (j !== E[0] && (j = this.sqr(j)), ie === 0 && k === 0) {
              g = 0;
              continue;
            }
            k <<= 1, k |= ie, g++, !(g !== x && (A !== 0 || ue !== 0)) && (j = this.mul(j, E[k]), g = 0, k = 0);
          }
          w = 26;
        }
        return j;
      }, V.prototype.convertTo = function(d) {
        var m = d.umod(this.m);
        return m === d ? m.clone() : m;
      }, V.prototype.convertFrom = function(d) {
        var m = d.clone();
        return m.red = null, m;
      }, o.mont = function(d) {
        return new L(d);
      };
      function L(p) {
        V.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      s(L, V), L.prototype.convertTo = function(d) {
        return this.imod(d.ushln(this.shift));
      }, L.prototype.convertFrom = function(d) {
        var m = this.imod(d.mul(this.rinv));
        return m.red = null, m;
      }, L.prototype.imul = function(d, m) {
        if (d.isZero() || m.isZero())
          return d.words[0] = 0, d.length = 1, d;
        var x = d.imul(m), E = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = x.isub(E).iushrn(this.shift), j = A;
        return A.cmp(this.m) >= 0 ? j = A.isub(this.m) : A.cmpn(0) < 0 && (j = A.iadd(this.m)), j._forceRed(this);
      }, L.prototype.mul = function(d, m) {
        if (d.isZero() || m.isZero())
          return new o(0)._forceRed(this);
        var x = d.mul(m), E = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = x.isub(E).iushrn(this.shift), j = A;
        return A.cmp(this.m) >= 0 ? j = A.isub(this.m) : A.cmpn(0) < 0 && (j = A.iadd(this.m)), j._forceRed(this);
      }, L.prototype.invm = function(d) {
        var m = this.imod(d._invmp(this.m).mul(this.r2));
        return m._forceRed(this);
      };
    })(typeof t > "u" || t, e);
  }
}), pr = kc(jc()), rc = kc(jc());
function kp(e) {
  switch (e) {
    case 1e3:
      return "Number too large";
    case 1001:
      return "Rate limit exceeded";
    case 1002:
      return "Insufficient liquidity";
    case 1003:
      return "HoneyPot scam detected";
    default:
      return "Unknown error";
  }
}
function Hv(e, ...t) {
  const r = Array.isArray(t[t.length - 1]) ? t.pop() : [];
  let i = [e, ...t].filter(Boolean).join("::");
  return r && r.length && (i += `<${r.join(", ")}>`), i;
}
function rF(e) {
  return e.split("::")[0];
}
function uc(e) {
  var t;
  try {
    let r = e.replace(/\s/g, "");
    const n = r.match(/(<.+>)$/), i = (t = n == null ? void 0 : n[0]) == null ? void 0 : t.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
    if (i) {
      r = r.slice(0, r.indexOf("<"));
      const c = uc(r), u = ZU(JU({}, c), {
        type_arguments: i.map((l) => uc(l).source_address)
      });
      return u.type_arguments = u.type_arguments.map((l) => t5.isSuiCoin(l) ? l : uc(l).source_address), u.source_address = Hv(u.full_address, u.type_arguments), u;
    }
    const s = r.split("::"), a = {
      full_address: r,
      address: r === e5 || r === sF ? "0x2" : hr.normalizeSuiObjectId(s[0]),
      module: s[1],
      name: s[2],
      type_arguments: [],
      source_address: ""
    };
    return a.full_address = `${a.address}::${a.module}::${a.name}`, a.source_address = Hv(a.full_address, a.type_arguments), a;
  } catch {
    return {
      full_address: e,
      address: "",
      module: "",
      name: "",
      type_arguments: [],
      source_address: e
    };
  }
}
function Gv(e) {
  return uc(e).source_address;
}
var nF = "0x2::coin::Coin", iF = /^0x2::coin::Coin<(.+)>$/, e5 = "0x2::sui::SUI", sF = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI", t5 = class uo {
  /**
   * Get the coin type argument from a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the coin type argument from.
   * @returns The coin type argument, or null if it is not found.
   */
  static getCoinTypeArg(t) {
    const r = t.type.match(iF);
    return r ? r[1] : null;
  }
  /**
   * Get whether a SuiMoveObject is a SUI coin.
   *
   * @param obj The SuiMoveObject to check.
   * @returns Whether the SuiMoveObject is a SUI coin.
   */
  static isSUI(t) {
    const r = uo.getCoinTypeArg(t);
    return r ? uo.getCoinSymbol(r) === "SUI" : !1;
  }
  /**
   * Get the coin symbol from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the symbol from.
   * @returns The coin symbol.
   */
  static getCoinSymbol(t) {
    return t.substring(t.lastIndexOf(":") + 1);
  }
  /**
   * Get the balance of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the balance from.
   * @returns The balance of the SuiMoveObject.
   */
  static getBalance(t) {
    return BigInt(t.fields.balance);
  }
  /**
   * Get the total balance of a list of CoinAsset objects for a given coin address.
   *
   * @param objs The list of CoinAsset objects to get the total balance for.
   * @param coinAddress The coin address to get the total balance for.
   * @returns The total balance of the CoinAsset objects for the given coin address.
   */
  static totalBalance(t, r) {
    let n = BigInt(0);
    return t.forEach((i) => {
      r === i.coinAddress && (n += BigInt(i.balance));
    }), n;
  }
  /**
   * Get the ID of a SuiMoveObject.
   *
   * @param obj The SuiMoveObject to get the ID from.
   * @returns The ID of the SuiMoveObject.
   */
  static getID(t) {
    return t.fields.id.id;
  }
  /**
   * Get the coin type from a coin type argument.
   *
   * @param coinTypeArg The coin type argument to get the coin type from.
   * @returns The coin type.
   */
  static getCoinTypeFromArg(t) {
    return `${nF}<${t}>`;
  }
  /**
   * Get the CoinAsset objects for a given coin type.
   *
   * @param coinType The coin type to get the CoinAsset objects for.
   * @param allSuiObjects The list of all SuiMoveObjects.
   * @returns The CoinAsset objects for the given coin type.
   */
  static getCoinAssets(t, r) {
    const n = [];
    return r.forEach((i) => {
      Gv(i.coinAddress) === Gv(t) && n.push(i);
    }), n;
  }
  /**
   * Get whether a coin address is a SUI coin.
   *
   * @param coinAddress The coin address to check.
   * @returns Whether the coin address is a SUI coin.
   */
  static isSuiCoin(t) {
    return uc(t).full_address === e5;
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinObjectIdGreaterThanOrEqual(t, r, n = []) {
    const i = uo.selectCoinAssetGreaterThanOrEqual(t, r, n), s = i.selectedCoins.map((c) => c.coinObjectId), o = i.remainingCoins, a = i.selectedCoins.map((c) => c.balance.toString());
    return { objectArray: s, remainCoins: o, amountArray: a };
  }
  /**
   * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
   *
   * @param coins The list of CoinAsset objects to select from.
   * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
   * @param exclude A list of CoinAsset objects to exclude from the selection.
   * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
   */
  static selectCoinAssetGreaterThanOrEqual(t, r, n = []) {
    const i = uo.sortByBalance(t.filter((u) => !n.includes(u.coinObjectId))), s = uo.calculateTotalBalance(i);
    if (s < r)
      return { selectedCoins: [], remainingCoins: i };
    if (s === r)
      return { selectedCoins: i, remainingCoins: [] };
    let o = BigInt(0);
    const a = [], c = [...i];
    for (; o < s; ) {
      const u = r - o, l = c.findIndex((h) => h.balance >= u);
      if (l !== -1) {
        a.push(c[l]), c.splice(l, 1);
        break;
      }
      const f = c.pop();
      f.balance > 0 && (a.push(f), o += f.balance);
    }
    return { selectedCoins: uo.sortByBalance(a), remainingCoins: uo.sortByBalance(c) };
  }
  /**
   * Sort the CoinAsset objects by their balance.
   *
   * @param coins The CoinAsset objects to sort.
   * @returns The sorted CoinAsset objects.
   */
  static sortByBalance(t) {
    return t.sort((r, n) => r.balance < n.balance ? -1 : r.balance > n.balance ? 1 : 0);
  }
  static sortByBalanceDes(t) {
    return t.sort((r, n) => r.balance > n.balance ? -1 : r.balance < n.balance ? 0 : 1);
  }
  /**
   * Calculate the total balance of a list of CoinAsset objects.
   *
   * @param coins The list of CoinAsset objects to calculate the total balance for.
   * @returns The total balance of the CoinAsset objects.
   */
  static calculateTotalBalance(t) {
    return t.reduce((r, n) => r + n.balance, BigInt(0));
  }
};
function jo(e) {
  const t = e.indexOf("::");
  if (t === -1)
    return e;
  const r = e.substring(0, t), n = e.substring(t);
  if (!r.startsWith("0x"))
    return e;
  const i = r.substring(2);
  return i.length > 64 ? e : `0x${i.padStart(64, "0")}${n}`;
}
function oF(e, t) {
  e = jo(e), t = jo(t);
  const r = Math.min(e.length, t.length);
  for (let n = 0; n < r; n++) {
    if (e[n] > t[n])
      return !0;
    if (e[n] < t[n])
      return !1;
  }
  return !0;
}
var fl = kc(jc()), Ba = new fl.default(0);
new fl.default(1);
var aF = new fl.default(2);
aF.pow(new fl.default(128));
new fl.default("18446744073709551615");
var K0 = "18446744073709551615", cF = "0xd7b0cfc33a3b46c0ae0e2584c44028385da11724d4c94ec5b21a78117c5c1ab9", ed = {
  AGGREGATOR_V3: "aggregator_v3"
}, td = {
  Mainnet: "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
  Testnet: "0x36dbef866a1d62bf7328989a10fb2f07d769f4ee587c0de4a0a256e57e0a58a8::deep::DEEP"
}, yi = {
  DEFAULT_PYTH_URL: "https://hermes.pyth.network",
  PYTH_TIMEOUT: 3e3,
  MAX_OVERLAY_FEE_RATE: 0.1,
  MAX_OVERLAY_FEE_RATE_NUMERATOR: 1e5,
  FEE_RATE_MULTIPLIER: 1e6,
  DEFAULT_OVERLAY_FEE_RECEIVER: "0x0",
  // Error Messages
  ERRORS: {
    SIGNER_REQUIRED: "Signer is required, but not provided.",
    INVALID_OVERLAY_FEE_RATE: "Overlay fee rate must be between 0 and 0.1",
    INVALID_SLIPPAGE: "Invalid slippage value. Must be between 0 and 1 (e.g., 0.01 represents 1% slippage)",
    NO_ROUTER_FOUND: "No router found",
    EMPTY_PATH: "Empty path",
    UNSUPPORTED_DEX: "Unsupported dex",
    PYTH_UNAVAILABLE: "All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes",
    QUOTE_ID_REQUIRED: "Quote ID is required",
    AGGREGATOR_V3_PACKAGE_REQUIRED: "Aggregator V3 package is required",
    PACKAGES_REQUIRED: "Packages are required",
    OVERLAY_FEE_RECEIVER_REQUIRED: "Overlay fee rate is set, but overlay fee receiver is not set"
  }
}, Xt = {
  FEE_DENOMINATOR: 1e6,
  MAX_FEE_RATE: 1e5,
  // 10%
  MAX_AMOUNT_IN: K0,
  DEFAULT_PUBLISHED_AT: {
    Mainnet: "0x33ec64e9bb369bf045ddc198c81adbf2acab424da37465d95296ee02045d2b17",
    Testnet: "0x0"
  }
}, r5 = 1010200;
function uF(e, t) {
  let r = /* @__PURE__ */ new Map();
  return e.packages && (e.packages instanceof Map ? r = e.packages : typeof e.packages == "object" && Object.entries(e.packages).forEach(([n, i]) => {
    r.set(n, i);
  })), {
    quoteID: e.request_id || "",
    amountIn: new rc.default(e.amount_in.toString()),
    amountOut: new rc.default(e.amount_out.toString()),
    byAmountIn: t,
    insufficientLiquidity: !1,
    deviationRatio: e.deviation_ratio,
    packages: r,
    paths: e.paths.map((n) => ({
      id: n.id,
      direction: n.direction,
      provider: n.provider,
      from: n.from,
      target: n.target,
      feeRate: n.fee_rate,
      amountIn: n.amount_in.toString(),
      amountOut: n.amount_out.toString(),
      version: n.version,
      publishedAt: n.published_at,
      extendedDetails: n.extended_details
    }))
  };
}
function lF(e, t, r, n, i) {
  return bn(this, null, function* () {
    let s;
    if (r.liquidityChanges && r.liquidityChanges.length > 0 ? s = yield dF(e, r) : s = yield fF(e, t, r), !s)
      return null;
    if (!s.ok) {
      let c = 1e3;
      return s.status === 429 && (c = 1001), {
        quoteID: "",
        amountIn: Ba,
        amountOut: Ba,
        paths: [],
        byAmountIn: r.byAmountIn,
        insufficientLiquidity: !1,
        deviationRatio: 0,
        error: {
          code: c,
          msg: kp(c)
        }
      };
    }
    const o = WU.default.parse(yield s.text()), a = o.msg === "liquidity is not enough";
    if (o.msg && o.msg.indexOf("HoneyPot scam") > -1)
      return {
        quoteID: "",
        amountIn: Ba,
        amountOut: Ba,
        paths: [],
        byAmountIn: r.byAmountIn,
        insufficientLiquidity: a,
        deviationRatio: 0,
        error: {
          code: 1003,
          msg: kp(
            1003
            /* HoneyPot */
          )
        }
      };
    if (o.data != null) {
      const c = uF(o.data, r.byAmountIn);
      if (n > 0 && i !== "0x0")
        if (r.byAmountIn) {
          const u = c.amountOut.mul(new rc.default(n)).div(new rc.default(1e6));
          c.overlayFee = Number(u.toString()), c.amountOut = c.amountOut.sub(u);
        } else {
          const u = c.amountIn.mul(new rc.default(n)).div(new rc.default(1e6));
          c.overlayFee = Number(u.toString()), c.amountIn = c.amountIn.add(u);
        }
      return c.packages || (c.packages = /* @__PURE__ */ new Map()), c.packages.has("aggregator_v3") || c.packages.set(
        "aggregator_v3",
        "0x3864c7c59a4889fec05d1aae4bc9dba5a0e0940594b424fbed44cb3f6ac4c032"
      ), c;
    }
    return {
      quoteID: "",
      amountIn: Ba,
      amountOut: Ba,
      paths: [],
      insufficientLiquidity: a,
      byAmountIn: r.byAmountIn,
      deviationRatio: 0,
      error: {
        code: 1002,
        msg: kp(
          1002
          /* InsufficientLiquidity */
        )
      }
    };
  });
}
function fF(e, t, r) {
  return bn(this, null, function* () {
    try {
      const {
        from: n,
        target: i,
        amount: s,
        byAmountIn: o,
        depth: a,
        splitAlgorithm: c,
        splitFactor: u,
        splitCount: l,
        providers: f
      } = r, h = jo(n), v = jo(i);
      let b = `${e}/find_routes?from=${h}&target=${v}&amount=${s.toString()}&by_amount_in=${o}`;
      return a && (b += `&depth=${a}`), c && (b += `&split_algorithm=${c}`), u && (b += `&split_factor=${u}`), l && (b += `&split_count=${l}`), f && f.length > 0 && (b += `&providers=${f.join(",")}`), t.length > 0 && (b += `&apiKey=${t}`), b += `&v=${r5}`, yield fetch(b);
    } catch (n) {
      return console.error(n), null;
    }
  });
}
function dF(e, t) {
  return bn(this, null, function* () {
    const {
      from: r,
      target: n,
      amount: i,
      byAmountIn: s,
      depth: o,
      splitAlgorithm: a,
      splitFactor: c,
      splitCount: u,
      providers: l,
      liquidityChanges: f
    } = t, h = jo(r), v = jo(n), b = `${e}/find_routes`, y = l == null ? void 0 : l.join(","), S = {
      from: h,
      target: v,
      amount: Number(i.toString()),
      by_amount_in: s,
      depth: o,
      split_algorithm: a,
      split_factor: c,
      split_count: u,
      providers: y,
      liquidity_changes: f.map((C) => ({
        pool: C.poolID,
        tick_lower: C.ticklower,
        tick_upper: C.tickUpper,
        delta_liquidity: C.deltaLiquidity
      })),
      v: r5
    };
    try {
      return yield fetch(b, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(S)
      });
    } catch (C) {
      return console.error("Error:", C), null;
    }
  });
}
function hF(e) {
  return bn(this, null, function* () {
    const t = `${e}/deepbookv3_config`;
    try {
      return (yield fetch(t)).json();
    } catch (r) {
      return console.error("Error:", r), null;
    }
  });
}
function Kv(e) {
  const t = e.paths, r = t[0].from, n = t[t.length - 1].target, i = [];
  for (const o of t)
    i.push({
      path: o,
      isLastUseOfIntermediateToken: !1
    });
  const s = /* @__PURE__ */ new Map();
  for (let o = i.length - 1; o >= 0; o--) {
    const { from: a } = i[o].path;
    s.has(a) || (s.set(a, !0), i[o].isLastUseOfIntermediateToken = !0);
  }
  return {
    quoteID: e.quoteID || "",
    amountIn: e.amountIn,
    amountOut: e.amountOut,
    byAmountIn: e.byAmountIn,
    flattenedPaths: i,
    fromCoinType: r,
    targetCoinType: n,
    packages: e.packages,
    totalDeepFee: e.totalDeepFee,
    error: e.error,
    overlayFee: e.overlayFee
  };
}
var n5 = /* @__PURE__ */ ((e) => (e[e.Mainnet = 0] = "Mainnet", e[e.Testnet = 1] = "Testnet", e))(n5 || {}), pF = kc(jc()), nc = 9e15, Bo = 1e9, Y0 = "0123456789abcdef", rd = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", nd = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", X0 = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -nc,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: nc,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, i5, Ns, Ct = !0, Gd = "[DecimalError] ", Ro = Gd + "Invalid argument: ", s5 = Gd + "Precision limit exceeded", o5 = Gd + "crypto unavailable", a5 = "[object Decimal]", hn = Math.floor, Br = Math.pow, mF = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, gF = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, yF = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, c5 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Mi = 1e7, bt = 7, vF = 9007199254740991, bF = rd.length - 1, J0 = nd.length - 1, Pe = { toStringTag: a5 };
Pe.absoluteValue = Pe.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), ft(e);
};
Pe.ceil = function() {
  return ft(new this.constructor(this), this.e + 1, 2);
};
Pe.clampedTo = Pe.clamp = function(e, t) {
  var r, n = this, i = n.constructor;
  if (e = new i(e), t = new i(t), !e.s || !t.s)
    return new i(NaN);
  if (e.gt(t))
    throw Error(Ro + t);
  return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
};
Pe.comparedTo = Pe.cmp = function(e) {
  var t, r, n, i, s = this, o = s.d, a = (e = new s.constructor(e)).d, c = s.s, u = e.s;
  if (!o || !a)
    return !c || !u ? NaN : c !== u ? c : o === a ? 0 : !o ^ c < 0 ? 1 : -1;
  if (!o[0] || !a[0])
    return o[0] ? c : a[0] ? -u : 0;
  if (c !== u)
    return c;
  if (s.e !== e.e)
    return s.e > e.e ^ c < 0 ? 1 : -1;
  for (n = o.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o[t] !== a[t])
      return o[t] > a[t] ^ c < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ c < 0 ? 1 : -1;
};
Pe.cosine = Pe.cos = function() {
  var e, t, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + bt, n.rounding = 1, r = wF(n, h5(n, r)), n.precision = e, n.rounding = t, ft(Ns == 2 || Ns == 3 ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN);
};
Pe.cubeRoot = Pe.cbrt = function() {
  var e, t, r, n, i, s, o, a, c, u, l = this, f = l.constructor;
  if (!l.isFinite() || l.isZero())
    return new f(l);
  for (Ct = !1, s = l.s * Br(l.s * l, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = tn(l.d), e = l.e, (s = (e - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Br(r, 1 / 3), e = hn((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + e : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new f(r), n.s = l.s) : n = new f(s.toString()), o = (e = f.precision) + 3; ; )
    if (a = n, c = a.times(a).times(a), u = c.plus(l), n = tr(u.plus(l).times(a), u.plus(c), o + 2, 1), tn(a.d).slice(0, o) === (r = tn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (ft(a, e + 1, 0), a.times(a).times(a).eq(l))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (ft(n, e + 1, 1), t = !n.times(n).times(n).eq(l));
        break;
      }
  return Ct = !0, ft(n, e, f.rounding, t);
};
Pe.decimalPlaces = Pe.dp = function() {
  var e, t = this.d, r = NaN;
  if (t) {
    if (e = t.length - 1, r = (e - hn(this.e / bt)) * bt, e = t[e], e)
      for (; e % 10 == 0; e /= 10)
        r--;
    r < 0 && (r = 0);
  }
  return r;
};
Pe.dividedBy = Pe.div = function(e) {
  return tr(this, new this.constructor(e));
};
Pe.dividedToIntegerBy = Pe.divToInt = function(e) {
  var t = this, r = t.constructor;
  return ft(tr(t, new r(e), 0, 1, 1), r.precision, r.rounding);
};
Pe.equals = Pe.eq = function(e) {
  return this.cmp(e) === 0;
};
Pe.floor = function() {
  return ft(new this.constructor(this), this.e + 1, 3);
};
Pe.greaterThan = Pe.gt = function(e) {
  return this.cmp(e) > 0;
};
Pe.greaterThanOrEqualTo = Pe.gte = function(e) {
  var t = this.cmp(e);
  return t == 1 || t === 0;
};
Pe.hyperbolicCosine = Pe.cosh = function() {
  var e, t, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite())
    return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero())
    return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Yd(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), s = vc(o, 1, s.times(t), new o(1), !0);
  for (var c, u = e, l = new o(8); u--; )
    c = s.times(s), s = a.minus(c.times(l.minus(c.times(l))));
  return ft(s, o.precision = r, o.rounding = n, !0);
};
Pe.hyperbolicSine = Pe.sinh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero())
    return new s(i);
  if (t = s.precision, r = s.rounding, s.precision = t + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = vc(s, 2, i, i, !0);
  else {
    e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Yd(5, e)), i = vc(s, 2, i, i, !0);
    for (var o, a = new s(5), c = new s(16), u = new s(20); e--; )
      o = i.times(i), i = i.times(a.plus(o.times(c.times(o).plus(u))));
  }
  return s.precision = t, s.rounding = r, ft(i, t, r, !0);
};
Pe.hyperbolicTangent = Pe.tanh = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, tr(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
};
Pe.inverseCosine = Pe.acos = function() {
  var e = this, t = e.constructor, r = e.abs().cmp(1), n = t.precision, i = t.rounding;
  return r !== -1 ? r === 0 ? e.isNeg() ? Qi(t, n, i) : new t(0) : new t(NaN) : e.isZero() ? Qi(t, n + 4, i).times(0.5) : (t.precision = n + 6, t.rounding = 1, e = new t(1).minus(e).div(e.plus(1)).sqrt().atan(), t.precision = n, t.rounding = i, e.times(2));
};
Pe.inverseHyperbolicCosine = Pe.acosh = function() {
  var e, t, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, Ct = !1, r = r.times(r).minus(1).sqrt().plus(r), Ct = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r);
};
Pe.inverseHyperbolicSine = Pe.asinh = function() {
  var e, t, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, Ct = !1, r = r.times(r).plus(1).sqrt().plus(r), Ct = !0, n.precision = e, n.rounding = t, r.ln());
};
Pe.inverseHyperbolicTangent = Pe.atanh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = s.precision, t = s.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? ft(new s(i), e, t, !0) : (s.precision = r = n - i.e, i = tr(i.plus(1), new s(1).minus(i), r + e, 1), s.precision = e + 4, s.rounding = 1, i = i.ln(), s.precision = e, s.rounding = t, i.times(0.5))) : new s(NaN);
};
Pe.inverseSine = Pe.asin = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (t = i.abs().cmp(1), r = s.precision, n = s.rounding, t !== -1 ? t === 0 ? (e = Qi(s, r + 4, n).times(0.5), e.s = i.s, e) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Pe.inverseTangent = Pe.atan = function() {
  var e, t, r, n, i, s, o, a, c, u = this, l = u.constructor, f = l.precision, h = l.rounding;
  if (u.isFinite()) {
    if (u.isZero())
      return new l(u);
    if (u.abs().eq(1) && f + 4 <= J0)
      return o = Qi(l, f + 4, h).times(0.25), o.s = u.s, o;
  } else {
    if (!u.s)
      return new l(NaN);
    if (f + 4 <= J0)
      return o = Qi(l, f + 4, h).times(0.5), o.s = u.s, o;
  }
  for (l.precision = a = f + 10, l.rounding = 1, r = Math.min(28, a / bt + 2 | 0), e = r; e; --e)
    u = u.div(u.times(u).plus(1).sqrt().plus(1));
  for (Ct = !1, t = Math.ceil(a / bt), n = 1, c = u.times(u), o = new l(u), i = u; e !== -1; )
    if (i = i.times(c), s = o.minus(i.div(n += 2)), i = i.times(c), o = s.plus(i.div(n += 2)), o.d[t] !== void 0)
      for (e = t; o.d[e] === s.d[e] && e--; )
        ;
  return r && (o = o.times(2 << r - 1)), Ct = !0, ft(o, l.precision = f, l.rounding = h, !0);
};
Pe.isFinite = function() {
  return !!this.d;
};
Pe.isInteger = Pe.isInt = function() {
  return !!this.d && hn(this.e / bt) > this.d.length - 2;
};
Pe.isNaN = function() {
  return !this.s;
};
Pe.isNegative = Pe.isNeg = function() {
  return this.s < 0;
};
Pe.isPositive = Pe.isPos = function() {
  return this.s > 0;
};
Pe.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Pe.lessThan = Pe.lt = function(e) {
  return this.cmp(e) < 0;
};
Pe.lessThanOrEqualTo = Pe.lte = function(e) {
  return this.cmp(e) < 1;
};
Pe.logarithm = Pe.log = function(e) {
  var t, r, n, i, s, o, a, c, u = this, l = u.constructor, f = l.precision, h = l.rounding, v = 5;
  if (e == null)
    e = new l(10), t = !0;
  else {
    if (e = new l(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
      return new l(NaN);
    t = e.eq(10);
  }
  if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
    return new l(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (t)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; )
        i /= 10;
      s = i !== 1;
    }
  if (Ct = !1, a = f + v, o = So(u, a), n = t ? id(l, a + 10) : So(e, a), c = tr(o, n, a, 1), Pu(c.d, i = f, h))
    do
      if (a += 10, o = So(u, a), n = t ? id(l, a + 10) : So(e, a), c = tr(o, n, a, 1), !s) {
        +tn(c.d).slice(i + 1, i + 15) + 1 == 1e14 && (c = ft(c, f + 1, 0));
        break;
      }
    while (Pu(c.d, i += 10, h));
  return Ct = !0, ft(c, f, h);
};
Pe.minus = Pe.sub = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f, h, v = this, b = v.constructor;
  if (e = new b(e), !v.d || !e.d)
    return !v.s || !e.s ? e = new b(NaN) : v.d ? e.s = -e.s : e = new b(e.d || v.s !== e.s ? v : NaN), e;
  if (v.s != e.s)
    return e.s = -e.s, v.plus(e);
  if (u = v.d, h = e.d, a = b.precision, c = b.rounding, !u[0] || !h[0]) {
    if (h[0])
      e.s = -e.s;
    else if (u[0])
      e = new b(v);
    else
      return new b(c === 3 ? -0 : 0);
    return Ct ? ft(e, a, c) : e;
  }
  if (r = hn(e.e / bt), l = hn(v.e / bt), u = u.slice(), s = l - r, s) {
    for (f = s < 0, f ? (t = u, s = -s, o = h.length) : (t = h, r = l, o = u.length), n = Math.max(Math.ceil(a / bt), o) + 2, s > n && (s = n, t.length = 1), t.reverse(), n = s; n--; )
      t.push(0);
    t.reverse();
  } else {
    for (n = u.length, o = h.length, f = n < o, f && (o = n), n = 0; n < o; n++)
      if (u[n] != h[n]) {
        f = u[n] < h[n];
        break;
      }
    s = 0;
  }
  for (f && (t = u, u = h, h = t, e.s = -e.s), o = u.length, n = h.length - o; n > 0; --n)
    u[o++] = 0;
  for (n = h.length; n > s; ) {
    if (u[--n] < h[n]) {
      for (i = n; i && u[--i] === 0; )
        u[i] = Mi - 1;
      --u[i], u[n] += Mi;
    }
    u[n] -= h[n];
  }
  for (; u[--o] === 0; )
    u.pop();
  for (; u[0] === 0; u.shift())
    --r;
  return u[0] ? (e.d = u, e.e = Kd(u, r), Ct ? ft(e, a, c) : e) : new b(c === 3 ? -0 : 0);
};
Pe.modulo = Pe.mod = function(e) {
  var t, r = this, n = r.constructor;
  return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? ft(new n(r), n.precision, n.rounding) : (Ct = !1, n.modulo == 9 ? (t = tr(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = tr(r, e, 0, n.modulo, 1), t = t.times(e), Ct = !0, r.minus(t));
};
Pe.naturalExponential = Pe.exp = function() {
  return Z0(this);
};
Pe.naturalLogarithm = Pe.ln = function() {
  return So(this);
};
Pe.negated = Pe.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, ft(e);
};
Pe.plus = Pe.add = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f = this, h = f.constructor;
  if (e = new h(e), !f.d || !e.d)
    return !f.s || !e.s ? e = new h(NaN) : f.d || (e = new h(e.d || f.s === e.s ? f : NaN)), e;
  if (f.s != e.s)
    return e.s = -e.s, f.minus(e);
  if (u = f.d, l = e.d, a = h.precision, c = h.rounding, !u[0] || !l[0])
    return l[0] || (e = new h(f)), Ct ? ft(e, a, c) : e;
  if (s = hn(f.e / bt), n = hn(e.e / bt), u = u.slice(), i = s - n, i) {
    for (i < 0 ? (r = u, i = -i, o = l.length) : (r = l, n = s, o = u.length), s = Math.ceil(a / bt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; )
      r.push(0);
    r.reverse();
  }
  for (o = u.length, i = l.length, o - i < 0 && (i = o, r = l, l = u, u = r), t = 0; i; )
    t = (u[--i] = u[i] + l[i] + t) / Mi | 0, u[i] %= Mi;
  for (t && (u.unshift(t), ++n), o = u.length; u[--o] == 0; )
    u.pop();
  return e.d = u, e.e = Kd(u, n), Ct ? ft(e, a, c) : e;
};
Pe.precision = Pe.sd = function(e) {
  var t, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)
    throw Error(Ro + e);
  return r.d ? (t = u5(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
};
Pe.round = function() {
  var e = this, t = e.constructor;
  return ft(new t(e), e.e + 1, t.rounding);
};
Pe.sine = Pe.sin = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + bt, n.rounding = 1, r = xF(n, h5(n, r)), n.precision = e, n.rounding = t, ft(Ns > 2 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Pe.squareRoot = Pe.sqrt = function() {
  var e, t, r, n, i, s, o = this, a = o.d, c = o.e, u = o.s, l = o.constructor;
  if (u !== 1 || !a || !a[0])
    return new l(!u || u < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (Ct = !1, u = Math.sqrt(+o), u == 0 || u == 1 / 0 ? (t = tn(a), (t.length + c) % 2 == 0 && (t += "0"), u = Math.sqrt(t), c = hn((c + 1) / 2) - (c < 0 || c % 2), u == 1 / 0 ? t = "5e" + c : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + c), n = new l(t)) : n = new l(u.toString()), r = (c = l.precision) + 3; ; )
    if (s = n, n = s.plus(tr(o, s, r + 2, 1)).times(0.5), tn(s.d).slice(0, r) === (t = tn(n.d)).slice(0, r))
      if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
        if (!i && (ft(s, c + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (ft(n, c + 1, 1), e = !n.times(n).eq(o));
        break;
      }
  return Ct = !0, ft(n, c, l.rounding, e);
};
Pe.tangent = Pe.tan = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = tr(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, ft(Ns == 2 || Ns == 4 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Pe.times = Pe.mul = function(e) {
  var t, r, n, i, s, o, a, c, u, l = this, f = l.constructor, h = l.d, v = (e = new f(e)).d;
  if (e.s *= l.s, !h || !h[0] || !v || !v[0])
    return new f(!e.s || h && !h[0] && !v || v && !v[0] && !h ? NaN : !h || !v ? e.s / 0 : e.s * 0);
  for (r = hn(l.e / bt) + hn(e.e / bt), c = h.length, u = v.length, c < u && (s = h, h = v, v = s, o = c, c = u, u = o), s = [], o = c + u, n = o; n--; )
    s.push(0);
  for (n = u; --n >= 0; ) {
    for (t = 0, i = c + n; i > n; )
      a = s[i] + v[n] * h[i - n - 1] + t, s[i--] = a % Mi | 0, t = a / Mi | 0;
    s[i] = (s[i] + t) % Mi | 0;
  }
  for (; !s[--o]; )
    s.pop();
  return t ? ++r : s.shift(), e.d = s, e.e = Kd(s, r), Ct ? ft(e, f.precision, f.rounding) : e;
};
Pe.toBinary = function(e, t) {
  return h1(this, 2, e, t);
};
Pe.toDecimalPlaces = Pe.toDP = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : ($n(e, 0, Bo), t === void 0 ? t = n.rounding : $n(t, 0, 8), ft(r, e + r.e + 1, t));
};
Pe.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = cs(n, !0) : ($n(e, 0, Bo), t === void 0 ? t = i.rounding : $n(t, 0, 8), n = ft(new i(n), e + 1, t), r = cs(n, !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Pe.toFixed = function(e, t) {
  var r, n, i = this, s = i.constructor;
  return e === void 0 ? r = cs(i) : ($n(e, 0, Bo), t === void 0 ? t = s.rounding : $n(t, 0, 8), n = ft(new s(i), e + i.e + 1, t), r = cs(n, !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Pe.toFraction = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f, h, v = this, b = v.d, y = v.constructor;
  if (!b)
    return new y(v);
  if (u = r = new y(1), n = c = new y(0), t = new y(n), s = t.e = u5(b) - v.e - 1, o = s % bt, t.d[0] = Br(10, o < 0 ? bt + o : o), e == null)
    e = s > 0 ? t : u;
  else {
    if (a = new y(e), !a.isInt() || a.lt(u))
      throw Error(Ro + a);
    e = a.gt(t) ? s > 0 ? t : u : a;
  }
  for (Ct = !1, a = new y(tn(b)), l = y.precision, y.precision = s = b.length * bt * 2; f = tr(a, t, 0, 1, 1), i = r.plus(f.times(n)), i.cmp(e) != 1; )
    r = n, n = i, i = u, u = c.plus(f.times(i)), c = i, i = t, t = a.minus(f.times(i)), a = i;
  return i = tr(e.minus(r), n, 0, 1, 1), c = c.plus(i.times(u)), r = r.plus(i.times(n)), c.s = u.s = v.s, h = tr(u, n, s, 1).minus(v).abs().cmp(tr(c, r, s, 1).minus(v).abs()) < 1 ? [u, n] : [c, r], y.precision = l, Ct = !0, h;
};
Pe.toHexadecimal = Pe.toHex = function(e, t) {
  return h1(this, 16, e, t);
};
Pe.toNearest = function(e, t) {
  var r = this, n = r.constructor;
  if (r = new n(r), e == null) {
    if (!r.d)
      return r;
    e = new n(1), t = n.rounding;
  } else {
    if (e = new n(e), t === void 0 ? t = n.rounding : $n(t, 0, 8), !r.d)
      return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (Ct = !1, r = tr(r, e, 0, t, 1).times(e), Ct = !0, ft(r)) : (e.s = r.s, r = e), r;
};
Pe.toNumber = function() {
  return +this;
};
Pe.toOctal = function(e, t) {
  return h1(this, 8, e, t);
};
Pe.toPower = Pe.pow = function(e) {
  var t, r, n, i, s, o, a = this, c = a.constructor, u = +(e = new c(e));
  if (!a.d || !e.d || !a.d[0] || !e.d[0])
    return new c(Br(+a, u));
  if (a = new c(a), a.eq(1))
    return a;
  if (n = c.precision, s = c.rounding, e.eq(1))
    return ft(a, n, s);
  if (t = hn(e.e / bt), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= vF)
    return i = l5(c, a, r, n), e.s < 0 ? new c(1).div(i) : ft(i, n, s);
  if (o = a.s, o < 0) {
    if (t < e.d.length - 1)
      return new c(NaN);
    if (e.d[t] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Br(+a, u), t = r == 0 || !isFinite(r) ? hn(u * (Math.log("0." + tn(a.d)) / Math.LN10 + a.e + 1)) : new c(r + "").e, t > c.maxE + 1 || t < c.minE - 1 ? new c(t > 0 ? o / 0 : 0) : (Ct = !1, c.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = Z0(e.times(So(a, n + r)), n), i.d && (i = ft(i, n + 5, 1), Pu(i.d, n, s) && (t = n + 10, i = ft(Z0(e.times(So(a, t + r)), t), t + 5, 1), +tn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = ft(i, n + 1, 0)))), i.s = o, Ct = !0, c.rounding = s, ft(i, n, s));
};
Pe.toPrecision = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = cs(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : ($n(e, 1, Bo), t === void 0 ? t = i.rounding : $n(t, 0, 8), n = ft(new i(n), e, t), r = cs(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Pe.toSignificantDigits = Pe.toSD = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : ($n(e, 1, Bo), t === void 0 ? t = n.rounding : $n(t, 0, 8)), ft(new n(r), e, t);
};
Pe.toString = function() {
  var e = this, t = e.constructor, r = cs(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
Pe.truncated = Pe.trunc = function() {
  return ft(new this.constructor(this), this.e + 1, 1);
};
Pe.valueOf = Pe.toJSON = function() {
  var e = this, t = e.constructor, r = cs(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function tn(e) {
  var t, r, n, i = e.length - 1, s = "", o = e[0];
  if (i > 0) {
    for (s += o, t = 1; t < i; t++)
      n = e[t] + "", r = bt - n.length, r && (s += po(r)), s += n;
    o = e[t], n = o + "", r = bt - n.length, r && (s += po(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; )
    o /= 10;
  return s + o;
}
function $n(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(Ro + e);
}
function Pu(e, t, r, n) {
  var i, s, o, a;
  for (s = e[0]; s >= 10; s /= 10)
    --t;
  return --t < 0 ? (t += bt, i = 0) : (i = Math.ceil((t + 1) / bt), t %= bt), s = Br(10, bt - t), a = e[i] % s | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 100 | 0) == Br(10, t - 2) - 1 || (a == s / 2 || a == 0) && (e[i + 1] / s / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 1e3 | 0) == Br(10, t - 3) - 1, o;
}
function gf(e, t, r) {
  for (var n, i = [0], s, o = 0, a = e.length; o < a; ) {
    for (s = i.length; s--; )
      i[s] *= t;
    for (i[0] += Y0.indexOf(e.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function wF(e, t) {
  var r, n, i;
  if (t.isZero())
    return t;
  n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Yd(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = vc(e, 1, t.times(i), new e(1));
  for (var s = r; s--; ) {
    var o = t.times(t);
    t = o.times(o).minus(o).times(8).plus(1);
  }
  return e.precision -= r, t;
}
var tr = /* @__PURE__ */ function() {
  function e(n, i, s) {
    var o, a = 0, c = n.length;
    for (n = n.slice(); c--; )
      o = n[c] * i + a, n[c] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function t(n, i, s, o) {
    var a, c;
    if (s != o)
      c = s > o ? 1 : -1;
    else
      for (a = c = 0; a < s; a++)
        if (n[a] != i[a]) {
          c = n[a] > i[a] ? 1 : -1;
          break;
        }
    return c;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; )
      n.shift();
  }
  return function(n, i, s, o, a, c) {
    var u, l, f, h, v, b, y, S, C, O, I, U, D, H, z, ne, le, te, ce, V, L = n.constructor, p = n.s == i.s ? 1 : -1, d = n.d, m = i.d;
    if (!d || !d[0] || !m || !m[0])
      return new L(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (d ? m && d[0] == m[0] : !m) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          d && d[0] == 0 || !m ? p * 0 : p / 0
        )
      );
    for (c ? (v = 1, l = n.e - i.e) : (c = Mi, v = bt, l = hn(n.e / v) - hn(i.e / v)), ce = m.length, le = d.length, C = new L(p), O = C.d = [], f = 0; m[f] == (d[f] || 0); f++)
      ;
    if (m[f] > (d[f] || 0) && l--, s == null ? (H = s = L.precision, o = L.rounding) : a ? H = s + (n.e - i.e) + 1 : H = s, H < 0)
      O.push(1), b = !0;
    else {
      if (H = H / v + 2 | 0, f = 0, ce == 1) {
        for (h = 0, m = m[0], H++; (f < le || h) && H--; f++)
          z = h * c + (d[f] || 0), O[f] = z / m | 0, h = z % m | 0;
        b = h || f < le;
      } else {
        for (h = c / (m[0] + 1) | 0, h > 1 && (m = e(m, h, c), d = e(d, h, c), ce = m.length, le = d.length), ne = ce, I = d.slice(0, ce), U = I.length; U < ce; )
          I[U++] = 0;
        V = m.slice(), V.unshift(0), te = m[0], m[1] >= c / 2 && ++te;
        do
          h = 0, u = t(m, I, ce, U), u < 0 ? (D = I[0], ce != U && (D = D * c + (I[1] || 0)), h = D / te | 0, h > 1 ? (h >= c && (h = c - 1), y = e(m, h, c), S = y.length, U = I.length, u = t(y, I, S, U), u == 1 && (h--, r(y, ce < S ? V : m, S, c))) : (h == 0 && (u = h = 1), y = m.slice()), S = y.length, S < U && y.unshift(0), r(I, y, U, c), u == -1 && (U = I.length, u = t(m, I, ce, U), u < 1 && (h++, r(I, ce < U ? V : m, U, c))), U = I.length) : u === 0 && (h++, I = [0]), O[f++] = h, u && I[0] ? I[U++] = d[ne] || 0 : (I = [d[ne]], U = 1);
        while ((ne++ < le || I[0] !== void 0) && H--);
        b = I[0] !== void 0;
      }
      O[0] || O.shift();
    }
    if (v == 1)
      C.e = l, i5 = b;
    else {
      for (f = 1, h = O[0]; h >= 10; h /= 10)
        f++;
      C.e = f + l * v - 1, ft(C, a ? s + C.e + 1 : s, o, b);
    }
    return C;
  };
}();
function ft(e, t, r, n) {
  var i, s, o, a, c, u, l, f, h, v = e.constructor;
  e:
    if (t != null) {
      if (f = e.d, !f)
        return e;
      for (i = 1, a = f[0]; a >= 10; a /= 10)
        i++;
      if (s = t - i, s < 0)
        s += bt, o = t, l = f[h = 0], c = l / Br(10, i - o - 1) % 10 | 0;
      else if (h = Math.ceil((s + 1) / bt), a = f.length, h >= a)
        if (n) {
          for (; a++ <= h; )
            f.push(0);
          l = c = 0, i = 1, s %= bt, o = s - bt + 1;
        } else
          break e;
      else {
        for (l = a = f[h], i = 1; a >= 10; a /= 10)
          i++;
        s %= bt, o = s - bt + i, c = o < 0 ? 0 : l / Br(10, i - o - 1) % 10 | 0;
      }
      if (n = n || t < 0 || f[h + 1] !== void 0 || (o < 0 ? l : l % Br(10, i - o - 1)), u = r < 4 ? (c || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : c > 5 || c == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (s > 0 ? o > 0 ? l / Br(10, i - o) : 0 : f[h - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !f[0])
        return f.length = 0, u ? (t -= e.e + 1, f[0] = Br(10, (bt - t % bt) % bt), e.e = -t || 0) : f[0] = e.e = 0, e;
      if (s == 0 ? (f.length = h, a = 1, h--) : (f.length = h + 1, a = Br(10, bt - s), f[h] = o > 0 ? (l / Br(10, i - o) % Br(10, o) | 0) * a : 0), u)
        for (; ; )
          if (h == 0) {
            for (s = 1, o = f[0]; o >= 10; o /= 10)
              s++;
            for (o = f[0] += a, a = 1; o >= 10; o /= 10)
              a++;
            s != a && (e.e++, f[0] == Mi && (f[0] = 1));
            break;
          } else {
            if (f[h] += a, f[h] != Mi)
              break;
            f[h--] = 0, a = 1;
          }
      for (s = f.length; f[--s] === 0; )
        f.pop();
    }
  return Ct && (e.e > v.maxE ? (e.d = null, e.e = NaN) : e.e < v.minE && (e.e = 0, e.d = [0])), e;
}
function cs(e, t, r) {
  if (!e.isFinite())
    return d5(e);
  var n, i = e.e, s = tn(e.d), o = s.length;
  return t ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + po(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (s = "0." + po(-i - 1) + s, r && (n = r - o) > 0 && (s += po(n))) : i >= o ? (s += po(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + po(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += po(n))), s;
}
function Kd(e, t) {
  var r = e[0];
  for (t *= bt; r >= 10; r /= 10)
    t++;
  return t;
}
function id(e, t, r) {
  if (t > bF)
    throw Ct = !0, r && (e.precision = r), Error(s5);
  return ft(new e(rd), t, 1, !0);
}
function Qi(e, t, r) {
  if (t > J0)
    throw Error(s5);
  return ft(new e(nd), t, r, !0);
}
function u5(e) {
  var t = e.length - 1, r = t * bt + 1;
  if (t = e[t], t) {
    for (; t % 10 == 0; t /= 10)
      r--;
    for (t = e[0]; t >= 10; t /= 10)
      r++;
  }
  return r;
}
function po(e) {
  for (var t = ""; e--; )
    t += "0";
  return t;
}
function l5(e, t, r, n) {
  var i, s = new e(1), o = Math.ceil(n / bt + 4);
  for (Ct = !1; ; ) {
    if (r % 2 && (s = s.times(t), Xv(s.d, o) && (i = !0)), r = hn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    t = t.times(t), Xv(t.d, o);
  }
  return Ct = !0, s;
}
function Yv(e) {
  return e.d[e.d.length - 1] & 1;
}
function f5(e, t, r) {
  for (var n, i, s = new e(t[0]), o = 0; ++o < t.length; ) {
    if (i = new e(t[o]), !i.s) {
      s = i;
      break;
    }
    n = s.cmp(i), (n === r || n === 0 && s.s === r) && (s = i);
  }
  return s;
}
function Z0(e, t) {
  var r, n, i, s, o, a, c, u = 0, l = 0, f = 0, h = e.constructor, v = h.rounding, b = h.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new h(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
  for (t == null ? (Ct = !1, c = b) : c = t, a = new h(0.03125); e.e > -2; )
    e = e.times(a), f += 5;
  for (n = Math.log(Br(2, f)) / Math.LN10 * 2 + 5 | 0, c += n, r = s = o = new h(1), h.precision = c; ; ) {
    if (s = ft(s.times(e), c, 1), r = r.times(++l), a = o.plus(tr(s, r, c, 1)), tn(a.d).slice(0, c) === tn(o.d).slice(0, c)) {
      for (i = f; i--; )
        o = ft(o.times(o), c, 1);
      if (t == null)
        if (u < 3 && Pu(o.d, c - n, v, u))
          h.precision = c += 10, r = s = a = new h(1), l = 0, u++;
        else
          return ft(o, h.precision = b, v, Ct = !0);
      else
        return h.precision = b, o;
    }
    o = a;
  }
}
function So(e, t) {
  var r, n, i, s, o, a, c, u, l, f, h, v = 1, b = 10, y = e, S = y.d, C = y.constructor, O = C.rounding, I = C.precision;
  if (y.s < 0 || !S || !S[0] || !y.e && S[0] == 1 && S.length == 1)
    return new C(S && !S[0] ? -1 / 0 : y.s != 1 ? NaN : S ? 0 : y);
  if (t == null ? (Ct = !1, l = I) : l = t, C.precision = l += b, r = tn(S), n = r.charAt(0), Math.abs(s = y.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      y = y.times(e), r = tn(y.d), n = r.charAt(0), v++;
    s = y.e, n > 1 ? (y = new C("0." + r), s++) : y = new C(n + "." + r.slice(1));
  } else
    return u = id(C, l + 2, I).times(s + ""), y = So(new C(n + "." + r.slice(1)), l - b).plus(u), C.precision = I, t == null ? ft(y, I, O, Ct = !0) : y;
  for (f = y, c = o = y = tr(y.minus(1), y.plus(1), l, 1), h = ft(y.times(y), l, 1), i = 3; ; ) {
    if (o = ft(o.times(h), l, 1), u = c.plus(tr(o, new C(i), l, 1)), tn(u.d).slice(0, l) === tn(c.d).slice(0, l))
      if (c = c.times(2), s !== 0 && (c = c.plus(id(C, l + 2, I).times(s + ""))), c = tr(c, new C(v), l, 1), t == null)
        if (Pu(c.d, l - b, O, a))
          C.precision = l += b, u = o = y = tr(f.minus(1), f.plus(1), l, 1), h = ft(y.times(y), l, 1), i = a = 1;
        else
          return ft(c, C.precision = I, O, Ct = !0);
      else
        return C.precision = I, c;
    c = u, i += 2;
  }
}
function d5(e) {
  return String(e.s * e.s / 0);
}
function yf(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++)
    ;
  for (i = t.length; t.charCodeAt(i - 1) === 48; --i)
    ;
  if (t = t.slice(n, i), t) {
    if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % bt, r < 0 && (n += bt), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= bt; n < i; )
        e.d.push(+t.slice(n, n += bt));
      t = t.slice(n), n = bt - t.length;
    } else
      n -= i;
    for (; n--; )
      t += "0";
    e.d.push(+t), Ct && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function _F(e, t) {
  var r, n, i, s, o, a, c, u, l;
  if (t.indexOf("_") > -1) {
    if (t = t.replace(/(\d)_(?=\d)/g, "$1"), c5.test(t))
      return yf(e, t);
  } else if (t === "Infinity" || t === "NaN")
    return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (gF.test(t))
    r = 16, t = t.toLowerCase();
  else if (mF.test(t))
    r = 2;
  else if (yF.test(t))
    r = 8;
  else
    throw Error(Ro + t);
  for (s = t.search(/p/i), s > 0 ? (c = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), s = t.indexOf("."), o = s >= 0, n = e.constructor, o && (t = t.replace(".", ""), a = t.length, s = a - s, i = l5(n, new n(r), s, s * 2)), u = gf(t, r, Mi), l = u.length - 1, s = l; u[s] === 0; --s)
    u.pop();
  return s < 0 ? new n(e.s * 0) : (e.e = Kd(u, l), e.d = u, Ct = !1, o && (e = tr(e, i, a * 4)), c && (e = e.times(Math.abs(c) < 54 ? Br(2, c) : dl.pow(2, c))), Ct = !0, e);
}
function xF(e, t) {
  var r, n = t.d.length;
  if (n < 3)
    return t.isZero() ? t : vc(e, 2, t, t);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Yd(5, r)), t = vc(e, 2, t, t);
  for (var i, s = new e(5), o = new e(16), a = new e(20); r--; )
    i = t.times(t), t = t.times(s.plus(i.times(o.times(i).minus(a))));
  return t;
}
function vc(e, t, r, n, i) {
  var s, o, a, c, u = e.precision, l = Math.ceil(u / bt);
  for (Ct = !1, c = r.times(r), a = new e(n); ; ) {
    if (o = tr(a.times(c), new e(t++ * t++), u, 1), a = i ? n.plus(o) : n.minus(o), n = tr(o.times(c), new e(t++ * t++), u, 1), o = a.plus(n), o.d[l] !== void 0) {
      for (s = l; o.d[s] === a.d[s] && s--; )
        ;
      if (s == -1)
        break;
    }
    s = a, a = n, n = o, o = s;
  }
  return Ct = !0, o.d.length = l + 1, o;
}
function Yd(e, t) {
  for (var r = e; --t; )
    r *= e;
  return r;
}
function h5(e, t) {
  var r, n = t.s < 0, i = Qi(e, e.precision, 1), s = i.times(0.5);
  if (t = t.abs(), t.lte(s))
    return Ns = n ? 4 : 1, t;
  if (r = t.divToInt(i), r.isZero())
    Ns = n ? 3 : 2;
  else {
    if (t = t.minus(r.times(i)), t.lte(s))
      return Ns = Yv(r) ? n ? 2 : 3 : n ? 4 : 1, t;
    Ns = Yv(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return t.minus(i).abs();
}
function h1(e, t, r, n) {
  var i, s, o, a, c, u, l, f, h, v = e.constructor, b = r !== void 0;
  if (b ? ($n(r, 1, Bo), n === void 0 ? n = v.rounding : $n(n, 0, 8)) : (r = v.precision, n = v.rounding), !e.isFinite())
    l = d5(e);
  else {
    for (l = cs(e), o = l.indexOf("."), b ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (l = l.replace(".", ""), h = new v(1), h.e = l.length - o, h.d = gf(cs(h), 10, i), h.e = h.d.length), f = gf(l, 10, i), s = c = f.length; f[--c] == 0; )
      f.pop();
    if (!f[0])
      l = b ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e = new v(e), e.d = f, e.e = s, e = tr(e, h, r, n, 0, i), f = e.d, s = e.e, u = i5), o = f[r], a = i / 2, u = u || f[r + 1] !== void 0, u = n < 4 ? (o !== void 0 || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || u || n === 6 && f[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), f.length = r, u)
        for (; ++f[--r] > i - 1; )
          f[r] = 0, r || (++s, f.unshift(1));
      for (c = f.length; !f[c - 1]; --c)
        ;
      for (o = 0, l = ""; o < c; o++)
        l += Y0.charAt(f[o]);
      if (b) {
        if (c > 1)
          if (t == 16 || t == 8) {
            for (o = t == 16 ? 4 : 3, --c; c % o; c++)
              l += "0";
            for (f = gf(l, i, t), c = f.length; !f[c - 1]; --c)
              ;
            for (o = 1, l = "1."; o < c; o++)
              l += Y0.charAt(f[o]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; )
          l = "0" + l;
        l = "0." + l;
      } else if (++s > c)
        for (s -= c; s--; )
          l += "0";
      else
        s < c && (l = l.slice(0, s) + "." + l.slice(s));
    }
    l = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + l;
  }
  return e.s < 0 ? "-" + l : l;
}
function Xv(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function SF(e) {
  return new this(e).abs();
}
function EF(e) {
  return new this(e).acos();
}
function TF(e) {
  return new this(e).acosh();
}
function CF(e, t) {
  return new this(e).plus(t);
}
function AF(e) {
  return new this(e).asin();
}
function MF(e) {
  return new this(e).asinh();
}
function OF(e) {
  return new this(e).atan();
}
function IF(e) {
  return new this(e).atanh();
}
function kF(e, t) {
  e = new this(e), t = new this(t);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = Qi(this, s, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? Qi(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = Qi(this, s, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(tr(e, t, s, 1)), t = Qi(this, s, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(tr(e, t, s, 1)), r;
}
function jF(e) {
  return new this(e).cbrt();
}
function RF(e) {
  return ft(e = new this(e), e.e + 1, 2);
}
function PF(e, t, r) {
  return new this(e).clamp(t, r);
}
function NF(e) {
  if (!e || typeof e != "object")
    throw Error(Gd + "Object expected");
  var t, r, n, i = e.defaults === !0, s = [
    "precision",
    1,
    Bo,
    "rounding",
    0,
    8,
    "toExpNeg",
    -nc,
    0,
    "toExpPos",
    0,
    nc,
    "maxE",
    0,
    nc,
    "minE",
    -nc,
    0,
    "modulo",
    0,
    9
  ];
  for (t = 0; t < s.length; t += 3)
    if (r = s[t], i && (this[r] = X0[r]), (n = e[r]) !== void 0)
      if (hn(n) === n && n >= s[t + 1] && n <= s[t + 2])
        this[r] = n;
      else
        throw Error(Ro + r + ": " + n);
  if (r = "crypto", i && (this[r] = X0[r]), (n = e[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(o5);
      else
        this[r] = !1;
    else
      throw Error(Ro + r + ": " + n);
  return this;
}
function $F(e) {
  return new this(e).cos();
}
function DF(e) {
  return new this(e).cosh();
}
function p5(e) {
  var t, r, n;
  function i(s) {
    var o, a, c, u = this;
    if (!(u instanceof i))
      return new i(s);
    if (u.constructor = i, Jv(s)) {
      u.s = s.s, Ct ? !s.d || s.e > i.maxE ? (u.e = NaN, u.d = null) : s.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s.e, u.d = s.d.slice()) : (u.e = s.e, u.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (c = typeof s, c === "number") {
      if (s === 0) {
        u.s = 1 / s < 0 ? -1 : 1, u.e = 0, u.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, u.s = -1) : u.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10)
          o++;
        Ct ? o > i.maxE ? (u.e = NaN, u.d = null) : o < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o, u.d = [s]) : (u.e = o, u.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (u.s = NaN), u.e = NaN, u.d = null;
        return;
      }
      return yf(u, s.toString());
    }
    if (c === "string")
      return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), u.s = -1) : (a === 43 && (s = s.slice(1)), u.s = 1), c5.test(s) ? yf(u, s) : _F(u, s);
    if (c === "bigint")
      return s < 0 ? (s = -s, u.s = -1) : u.s = 1, yf(u, s.toString());
    throw Error(Ro + s);
  }
  if (i.prototype = Pe, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = NF, i.clone = p5, i.isDecimal = Jv, i.abs = SF, i.acos = EF, i.acosh = TF, i.add = CF, i.asin = AF, i.asinh = MF, i.atan = OF, i.atanh = IF, i.atan2 = kF, i.cbrt = jF, i.ceil = RF, i.clamp = PF, i.cos = $F, i.cosh = DF, i.div = LF, i.exp = BF, i.floor = UF, i.hypot = FF, i.ln = VF, i.log = zF, i.log10 = qF, i.log2 = WF, i.max = HF, i.min = GF, i.mod = KF, i.mul = YF, i.pow = XF, i.random = JF, i.round = ZF, i.sign = QF, i.sin = eV, i.sinh = tV, i.sqrt = rV, i.sub = nV, i.sum = iV, i.tan = sV, i.tanh = oV, i.trunc = aV, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; )
      e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function LF(e, t) {
  return new this(e).div(t);
}
function BF(e) {
  return new this(e).exp();
}
function UF(e) {
  return ft(e = new this(e), e.e + 1, 3);
}
function FF() {
  var e, t, r = new this(0);
  for (Ct = !1, e = 0; e < arguments.length; )
    if (t = new this(arguments[e++]), t.d)
      r.d && (r = r.plus(t.times(t)));
    else {
      if (t.s)
        return Ct = !0, new this(1 / 0);
      r = t;
    }
  return Ct = !0, r.sqrt();
}
function Jv(e) {
  return e instanceof dl || e && e.toStringTag === a5 || !1;
}
function VF(e) {
  return new this(e).ln();
}
function zF(e, t) {
  return new this(e).log(t);
}
function WF(e) {
  return new this(e).log(2);
}
function qF(e) {
  return new this(e).log(10);
}
function HF() {
  return f5(this, arguments, -1);
}
function GF() {
  return f5(this, arguments, 1);
}
function KF(e, t) {
  return new this(e).mod(t);
}
function YF(e, t) {
  return new this(e).mul(t);
}
function XF(e, t) {
  return new this(e).pow(t);
}
function JF(e) {
  var t, r, n, i, s = 0, o = new this(1), a = [];
  if (e === void 0 ? e = this.precision : $n(e, 1, Bo), n = Math.ceil(e / bt), this.crypto)
    if (crypto.getRandomValues)
      for (t = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = t[s], i >= 429e7 ? t[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (t = crypto.randomBytes(n *= 4); s < n; )
        i = t[s] + (t[s + 1] << 8) + (t[s + 2] << 16) + ((t[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(o5);
  else
    for (; s < n; )
      a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], e %= bt, n && e && (i = Br(10, bt - e), a[s] = (n / i | 0) * i); a[s] === 0; s--)
    a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= bt)
      a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10)
      n++;
    n < bt && (r -= bt - n);
  }
  return o.e = r, o.d = a, o;
}
function ZF(e) {
  return ft(e = new this(e), e.e + 1, this.rounding);
}
function QF(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function eV(e) {
  return new this(e).sin();
}
function tV(e) {
  return new this(e).sinh();
}
function rV(e) {
  return new this(e).sqrt();
}
function nV(e, t) {
  return new this(e).sub(t);
}
function iV() {
  var e = 0, t = arguments, r = new this(t[e]);
  for (Ct = !1; r.s && ++e < t.length; )
    r = r.plus(t[e]);
  return Ct = !0, ft(r, this.precision, this.rounding);
}
function sV(e) {
  return new this(e).tan();
}
function oV(e) {
  return new this(e).tanh();
}
function aV(e) {
  return ft(e = new this(e), e.e + 1, 1);
}
Pe[Symbol.for("nodejs.util.inspect.custom")] = Pe.toString;
Pe[Symbol.toStringTag] = "Decimal";
var dl = Pe.constructor = p5(X0);
rd = new dl(rd);
nd = new dl(nd);
var m5 = dl;
function cV(e, t, r) {
  return Number(
    g5(
      new m5(e.toString()),
      t,
      r
    ).toFixed(0)
  );
}
function Zv(e, t, r) {
  const n = g5(
    new m5(e.toString()),
    t,
    r
  );
  return new pF.default(n.toFixed(0));
}
function g5(e, t, r) {
  return t ? e.mul(1 - r) : e.mul(1 + r);
}
var Qv = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("CetusRouter only supported on mainnet");
    this.globalConfig = e === 0 ? "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f" : "0x9774e359588ead122af1c7e7f64e14ade261cfeecdb5d0eb4a5b3b4c8ab8bd3e", this.partner = t ?? (e === 0 ? "0x639b5e433da31739e800cd085f356e64cae222966d0f1b11bd9dc76b322ff58b" : "0x1f5fa5c820f40d43fc47815ad06d95e40a1942ff72a732a92e8ef4aa8cde70a5");
  }
  // By amount in
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("Cetus not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.globalConfig),
      e.object(t.poolId),
      e.object(this.partner),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::cetus::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
  // By amount out
  flashSwapFixedOutput(e, t, r, n) {
    const i = [
      n,
      e.object(this.globalConfig),
      e.object(t.id),
      e.object(this.partner),
      r,
      e.pure.bool(t.direction),
      e.pure.bool(!1),
      // isExactIn
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ], [s, o] = t.direction ? [t.from, t.target] : [t.target, t.from], [a, c] = e.moveCall({
      target: `${t.publishedAt}::cetus::flash_swap_fixed_output`,
      typeArguments: [s, o],
      arguments: i
    });
    return {
      flashReceipt: a,
      repayAmount: c
    };
  }
  repayFlashSwapFixedOutput(e, t, r, n) {
    const i = [
      r,
      e.object(this.globalConfig),
      e.object(t.id),
      e.object(this.partner),
      e.pure.bool(t.direction),
      n
    ], [s, o] = t.direction ? [t.from, t.target] : [t.target, t.from];
    e.moveCall({
      target: `${t.publishedAt}::cetus::repay_flash_swap_fixed_output`,
      typeArguments: [s, o],
      arguments: i
    });
  }
  add(e, t, r, n) {
    const i = [t, r];
    return e.moveCall({
      target: `${n}::cetus::add`,
      typeArguments: [],
      arguments: i
    });
  }
  sub(e, t, r, n) {
    const i = [t, r];
    return e.moveCall({
      target: `${n}::cetus::sub`,
      typeArguments: [],
      arguments: i
    });
  }
}, uV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Kriya V3 only supported on mainnet");
    this.version = "0xf5145a7ac345ca8736cf8c76047d00d6d378f30e81be6f6eb557184d9de93c78";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("Kriya V3 not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object(this.version),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::kriya_clmm::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, lV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("FlowX V3 only supported on mainnet");
    this.poolRegistry = "0x27565d24a4cd51127ac90e4074a841bbe356cca7bf5759ddc14a975be1632abc", this.versioned = "0x67624a1533b5aff5d0dfcf5e598684350efd38134d2d245f475524c03a64e656";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("FlowX V3 not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, s = t.feeRate * 1e6;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id,
      feeRate: s
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.poolRegistry),
      e.object(this.versioned),
      e.pure.u64(t.feeRate),
      e.pure.u64(t.amountIn),
      e.pure.bool(t.direction),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::flowx_clmm::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, fV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Turbos only supported on mainnet");
    this.versioned = "0xf1cf0e81048df168ebeb1b8030fad24b3e0b53ae827c25053fff0779c1445b6f";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("Turbos not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    if (t.extendedDetails == null)
      throw new Error("Extended details not supported");
    if (t.extendedDetails.turbos_fee_type == null)
      throw new Error("Turbos fee type not supported");
    const s = t.extendedDetails.turbos_fee_type;
    return {
      coinAType: r,
      coinBType: n,
      feeType: s,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object(this.versioned),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::turbos::swap`,
      typeArguments: [t.coinAType, t.coinBType, t.feeType],
      arguments: n
    });
  }
}, dV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Bluefin only supported on mainnet");
    this.globalConfig = "0x03db251ba509a8d5d8777b6338836082335d93eecbdd09a11e190a1cff51c352";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("Bluefin not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.globalConfig),
      e.object(t.poolId),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::bluefin::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, hV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Momentum only supported on mainnet");
    this.version = "0x2375a0b1ec12010aaea3b2545acfa2ad34cfbba03ce4b59f4c39e1e25eed1b2a";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Momentum not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(this.version),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::momentum::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, pV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Magma only supported on mainnet");
    this.globalConfig = "0x4c4e1402401f72c7d8533d0ed8d5f8949da363c7a3319ccef261ffe153d32f8a";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Magma not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.globalConfig),
      e.object(t.poolId),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::magma::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, mV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Kriya V2 only supported on mainnet");
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Kriya V2 not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::kriya_amm::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, gV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("FlowX V2 only supported on mainnet");
    this.container = "0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("FlowX V2 not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.container),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::flowx_amm::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, yV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("BlueMove only supported on mainnet");
    this.dexInfo = "0x3f2d9f724f4a1ce5e71676448dc452be9a6243dac9c5b975a588c8c867066e92";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("BlueMove not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.dexInfo),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::bluemove::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, vV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("DeepBook V3 only supported on mainnet");
    this.env = e, this.globalConfig = "0x699d455ab8c5e02075b4345ea1f91be55bf46064ae6026cc2528e701ce3ac135";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r, n);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("DeepBook V3 not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r, n) {
    const i = (n == null ? void 0 : n.deepbookv3DeepFee) || e.moveCall({
      target: "0x2::coin::zero",
      typeArguments: [this.getDeepFeeType()]
    }), s = [
      r,
      e.object(this.globalConfig),
      e.object(t.poolId),
      e.pure.u64(t.amountIn),
      e.pure.bool(t.direction),
      i,
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::deepbookv3::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: s
    });
  }
  getDeepFeeType() {
    return this.env === 0 ? td.Mainnet : td.Testnet;
  }
}, bV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Aftermath only supported on mainnet");
    this.poolRegistry = "0xfcc774493db2c45c79f688f88d28023a3e7d98e4ee9f48bbf5c7990f651577ae", this.protocolFeeVault = "0xf194d9b1bcad972e45a7dd67dd49b3ee1e3357a00a50850c52cd51bb450e13b4", this.treasury = "0x28e499dff5e864a2eafe476269a4f5035f1c16f338da7be18b103499abf271ce", this.insuranceFund = "0xf0c40d67b078000e18032334c3325c47b9ec9f3d9ae4128be820d54663d14e3b", this.referralVault = "0x35d35b0e5b177593d8c3a801462485572fc30861e6ce96a55af6dc4730709278";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    var t, r;
    if (e.path.publishedAt == null)
      throw new Error("Aftermath not set publishedAt");
    const n = e.path, [i, s] = n.direction ? [n.from, n.target] : [n.target, n.from], o = e.isLastUseOfIntermediateToken ? "18446744073709551615" : n.amountIn;
    return {
      coinAType: i,
      coinBType: s,
      feeType: ((t = n.extendedDetails) == null ? void 0 : t.aftermath_lp_supply_type) || ((r = n.extendedDetails) == null ? void 0 : r.aftermath_lp_supply_type) || "0x2::sui::SUI",
      // Use LP supply type from path (handle both camelCase and snake_case)
      direction: n.direction,
      amountIn: o,
      expectAmountOut: n.amountOut,
      // For amount-in swaps, expect_amount_out is 0
      publishedAt: n.publishedAt,
      poolId: n.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      // swap_ctx
      e.object(t.poolId),
      // pool
      e.object(this.poolRegistry),
      // pool_registry
      e.object(this.protocolFeeVault),
      // vault
      e.object(this.treasury),
      // treasury
      e.object(this.insuranceFund),
      // insurance_fund
      e.object(this.referralVault),
      // referral_vault
      e.pure.bool(t.direction),
      // a2b
      e.pure.u64(t.amountIn),
      // amount_in
      e.pure.u64(t.expectAmountOut)
      // expect_amount_out
    ];
    e.moveCall({
      target: `${t.publishedAt}::aftermath::swap`,
      typeArguments: [t.coinAType, t.coinBType, t.feeType],
      arguments: n
    });
  }
}, wV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Steamm CPMM only supported on mainnet");
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  validateExtendedDetails(e) {
    const t = [
      "steamm_bank_a",
      "steamm_bank_b",
      "steamm_lending_market",
      "steamm_lending_market_type",
      "steamm_btoken_a_type",
      "steamm_btoken_b_type",
      "steamm_lp_token_type"
    ];
    for (const r of t)
      if (e[r] == null)
        throw new Error(`Steamm CPMM ${r} not supported`);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Steamm CPMM not set publishedAt");
    if (!t.extendedDetails)
      throw new Error("Extended details not found for Steamm CPMM");
    this.validateExtendedDetails(t.extendedDetails);
    const { direction: r, from: n, target: i } = t, [s, o] = r ? [n, i] : [i, n], a = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: s,
      coinBType: o,
      direction: r,
      amountIn: a,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: t.extendedDetails
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object(t.extendedDetails.steamm_bank_a),
      e.object(t.extendedDetails.steamm_bank_b),
      e.object(t.extendedDetails.steamm_lending_market),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::steamm_cpmm::swap`,
      typeArguments: [
        t.extendedDetails.steamm_lending_market_type,
        t.coinAType,
        t.coinBType,
        t.extendedDetails.steamm_btoken_a_type,
        t.extendedDetails.steamm_btoken_b_type,
        t.extendedDetails.steamm_lp_token_type
      ],
      arguments: n
    });
  }
}, _V = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Scallop only supported on mainnet");
    this.version = "0x07871c4b3c847a0f674510d4978d5cf6f960452795e8ff6f189fd2088a3f6ac7", this.marketData = "0xa757975255146dc9686aa823b7838b507f315d704f428cbadad2f4ea061939d9";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Scallop not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.from, t.target], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    if (t.extendedDetails == null)
      throw new Error("Extended details not supported");
    const s = t.extendedDetails.scallopScoinTreasury || t.extendedDetails.scallop_scoin_treasury;
    if (s == null)
      throw new Error("Scallop scoin treasury not supported");
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id,
      scallopScoinTreasury: s
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.version),
      e.object(this.marketData),
      e.object(t.scallopScoinTreasury),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ], i = t.direction ? "swap_a2b" : "swap_b2a";
    e.moveCall({
      target: `${t.publishedAt}::scallop::${i}`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, eb = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Springsui only supported on mainnet");
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Springsui not set publishedAt");
    const r = t.direction ? t.target : t.from, n = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      springSUICoinType: r,
      direction: t.direction,
      amountIn: n,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object("0x5"),
      e.pure.u64(t.amountIn),
      e.pure.bool(t.direction)
    ];
    e.moveCall({
      target: `${t.publishedAt}::springsui::swap`,
      typeArguments: [t.springSUICoinType],
      arguments: n
    });
  }
}, xV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Haedal PMM only supported on mainnet");
    this.pythPriceIDs = t;
  }
  swap(e, t, r, n) {
    const i = t.path;
    if (!i.extendedDetails)
      throw new Error("Extended details not found for Haedal PMM");
    this.validateExtendedDetails(i.extendedDetails);
    const s = this.prepareSwapData(t);
    this.executeSwapContract(e, s, r);
  }
  validateExtendedDetails(e) {
    if (!e.haedal_pmm_base_price_seed)
      throw new Error("Haedal PMM base price seed not supported");
    if (!e.haedal_pmm_quote_price_seed)
      throw new Error("Haedal PMM quote price seed not supported");
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Haedal PMM not set publishedAt");
    const r = t.extendedDetails, [n, i] = t.direction ? [t.from, t.target] : [t.target, t.from], s = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, o = r.haedal_pmm_base_price_seed, a = r.haedal_pmm_quote_price_seed, c = this.pythPriceIDs.get(o), u = this.pythPriceIDs.get(a);
    if (!c || !u)
      throw new Error("Haedal HMM requires oracle price IDs for both coins");
    return {
      coinAType: n,
      coinBType: i,
      basePriceId: c,
      quotePriceId: u,
      a2b: t.direction,
      amountIn: s,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      // swap_ctx
      e.object(t.poolId),
      // pool
      e.object(t.basePriceId),
      // base_price_pair_obj
      e.object(t.quotePriceId),
      // quote_price_pair_obj
      e.pure.u64(t.amountIn),
      // amount_in
      e.pure.bool(t.a2b),
      // a2b
      e.object(hr.SUI_CLOCK_OBJECT_ID)
      // clock
    ];
    e.moveCall({
      target: `${t.publishedAt}::haedal_hmm::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, SV = class {
  constructor(e, t) {
    if (e === 1)
      throw new Error("Obric is not supported on testnet");
    this.pythStateObjectId = "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8", this.pythPriceIDs = t;
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Obric not set publishedAt");
    if (!t.extendedDetails)
      throw new Error("Extended details not supported in obric");
    const { direction: r, from: n, target: i } = t, [s, o] = r ? [n, i] : [i, n], a = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    let c, u;
    if (t.extendedDetails.obric_coin_a_price_seed && t.extendedDetails.obric_coin_b_price_seed)
      c = this.pythPriceIDs.get(
        t.extendedDetails.obric_coin_a_price_seed
      ), u = this.pythPriceIDs.get(
        t.extendedDetails.obric_coin_b_price_seed
      );
    else if (t.extendedDetails.obric_coin_a_price_id && t.extendedDetails.obric_coin_b_price_id)
      c = t.extendedDetails.obric_coin_a_price_id, u = t.extendedDetails.obric_coin_b_price_id;
    else
      throw new Error("Base price id or quote price id not supported");
    return {
      coinAType: s,
      coinBType: o,
      coinAPriceInfoObjectId: c,
      coinBPriceInfoObjectId: u,
      direction: r,
      amountIn: a,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: t.extendedDetails
    };
  }
  executeSwapContract(e, t, r) {
    if (!t.coinAPriceInfoObjectId || !t.coinBPriceInfoObjectId)
      throw new Error(
        "Base price info object id or quote price info object id not found"
      );
    const n = [
      r,
      e.object(t.poolId),
      e.pure.u64(t.amountIn),
      e.pure.bool(t.direction),
      e.object(this.pythStateObjectId),
      e.object(t.coinAPriceInfoObjectId),
      e.object(t.coinBPriceInfoObjectId),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::obric::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, EV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Sevenk only supported on mainnet");
    this.oraclePublishedAt = "0x8c36ea167c5e6da8c3d60b4fc897416105dcb986471bd81cfbfd38720a4487c0", this.pythPriceIDs = t;
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r, n);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Sevenk not set publishedAt");
    if (!t.extendedDetails)
      throw new Error("Extended details not found for Sevenk");
    const { direction: r, from: n, target: i } = t, [s, o, a] = r ? ["swap_a2b", n, i] : ["swap_b2a", i, n], c = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, u = t.extendedDetails;
    if (!u.sevenk_coin_a_price_seed || !u.sevenk_coin_b_price_seed || !u.sevenk_oracle_config_a || !u.sevenk_oracle_config_b || !u.sevenk_lp_cap_type)
      throw new Error("Required Sevenk extended details not found");
    const l = u.sevenk_coin_a_price_seed, f = u.sevenk_coin_b_price_seed, h = u.sevenk_oracle_config_a, v = u.sevenk_oracle_config_b, b = u.sevenk_lp_cap_type, y = this.pythPriceIDs.get(l), S = this.pythPriceIDs.get(f);
    if (!y || !S)
      throw new Error("Sevenk price info object IDs not found");
    return {
      func: s,
      coinAType: o,
      coinBType: a,
      coinAPriceId: y,
      coinBPriceId: S,
      coinAOracleId: h,
      coinBOracleId: v,
      lpCapType: b,
      direction: r,
      amountIn: c,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: t.extendedDetails
    };
  }
  executeSwapContract(e, t, r, n) {
    const i = e.moveCall({
      target: `${this.oraclePublishedAt}::oracle::new_holder`,
      typeArguments: [],
      arguments: []
    });
    e.moveCall({
      target: `${this.oraclePublishedAt}::pyth::get_price`,
      typeArguments: [],
      arguments: [
        e.object(t.coinAOracleId),
        i,
        e.object(t.coinAPriceId),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    }), e.moveCall({
      target: `${this.oraclePublishedAt}::pyth::get_price`,
      typeArguments: [],
      arguments: [
        e.object(t.coinBOracleId),
        i,
        e.object(t.coinBPriceId),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    });
    const s = [
      r,
      e.object(t.poolId),
      i,
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::sevenk::${t.func}`,
      typeArguments: [t.coinAType, t.coinBType, t.lpCapType],
      arguments: s
    });
  }
}, TV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Steamm OMM only supported on mainnet");
    this.pythPriceIDs = t, this.oraclePackageId = "0xe84b649199654d18c38e727212f5d8dacfc3cf78d60d0a7fc85fd589f280eb2b";
  }
  swap(e, t, r, n) {
    const i = t.path;
    if (!i.extendedDetails)
      throw new Error("Extended details not found for Steamm OMM");
    this.validateExtendedDetails(i.extendedDetails);
    const s = this.prepareSwapData(t);
    this.executeSwapContract(e, s, r);
  }
  validateExtendedDetails(e) {
    const t = [
      "steamm_bank_a",
      "steamm_bank_b",
      "steamm_lending_market",
      "steamm_lending_market_type",
      "steamm_btoken_a_type",
      "steamm_btoken_b_type",
      "steamm_lp_token_type",
      "steammOracleRegistryId",
      "steammOracleIndexA",
      "steammOracleIndexB",
      "steammOraclePythPriceSeedA",
      "steammOraclePythPriceSeedB"
    ];
    for (const r of t)
      if (e[r] == null)
        throw new Error(`Steamm ${r} not supported`);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Steamm OMM not set publishedAt");
    const r = t.extendedDetails, { direction: n, from: i, target: s } = t, [o, a, c] = n ? ["swap_a2b_v2", i, s] : ["swap_b2a_v2", s, i], u = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, l = r.steamm_oracle_pyth_price_seed_a, f = r.steamm_oracle_pyth_price_seed_b;
    if (!l || !f)
      throw new Error("Steamm oracle price seeds not found");
    const h = this.pythPriceIDs.get(l), v = this.pythPriceIDs.get(f);
    if (!h || !v)
      throw new Error(
        "Base price info object id or quote price info object id not found"
      );
    return {
      func: o,
      coinAType: a,
      coinBType: c,
      direction: n,
      amountIn: u,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: r,
      priceInfoObjectIdA: h,
      priceInfoObjectIdB: v
    };
  }
  executeSwapContract(e, t, r) {
    const n = t.extendedDetails, i = e.moveCall({
      target: `${this.oraclePackageId}::oracles::get_pyth_price`,
      typeArguments: [],
      arguments: [
        e.object(n.steammOracleRegistryId),
        e.object(t.priceInfoObjectIdA),
        e.pure.u64(n.steammOracleIndexA),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    }), s = e.moveCall({
      target: `${this.oraclePackageId}::oracles::get_pyth_price`,
      typeArguments: [],
      arguments: [
        e.object(n.steammOracleRegistryId),
        e.object(t.priceInfoObjectIdB),
        e.pure.u64(n.steammOracleIndexB),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    }), o = [
      r,
      e.object(t.poolId),
      e.object(n.steamm_bank_a),
      e.object(n.steamm_bank_b),
      e.object(n.steamm_lending_market),
      i,
      s,
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::steamm_omm::${t.func}`,
      typeArguments: [
        n.steamm_lending_market_type,
        t.coinAType,
        t.coinBType,
        n.steamm_btoken_a_type,
        n.steamm_btoken_b_type,
        n.steamm_lp_token_type
      ],
      arguments: o
    });
  }
}, CV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Steamm OMM V2 only supported on mainnet");
    this.pythPriceIDs = t, this.oraclePackageId = "0xe84b649199654d18c38e727212f5d8dacfc3cf78d60d0a7fc85fd589f280eb2b";
  }
  swap(e, t, r, n) {
    const i = t.path;
    if (!i.extendedDetails)
      throw new Error("Extended details not found for Steamm OMM V2");
    this.validateExtendedDetails(i.extendedDetails);
    const s = this.prepareSwapData(t);
    this.executeSwapContract(e, s, r);
  }
  validateExtendedDetails(e) {
    const t = [
      "steamm_bank_a",
      "steamm_bank_b",
      "steamm_lending_market",
      "steamm_lending_market_type",
      "steamm_btoken_a_type",
      "steamm_btoken_b_type",
      "steamm_lp_token_type",
      "steamm_oracle_registry_id",
      "steamm_oracle_index_a",
      "steamm_oracle_index_b",
      "steamm_oracle_pyth_price_seed_a",
      "steamm_oracle_pyth_price_seed_b"
    ];
    for (const r of t)
      if (e[r] == null)
        throw new Error(`Steamm OMM V2 ${r} not supported`);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Steamm OMM V2 not set publishedAt");
    const r = t.extendedDetails, { direction: n, from: i, target: s } = t, [o, a] = n ? [i, s] : [s, i], c = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, u = r.steamm_oracle_pyth_price_seed_a, l = r.steamm_oracle_pyth_price_seed_b;
    if (!u || !l)
      throw new Error("Steamm OMM V2 oracle price seeds not found");
    const f = this.pythPriceIDs.get(u), h = this.pythPriceIDs.get(l);
    if (!f || !h)
      throw new Error(
        "Base price info object id or quote price info object id not found"
      );
    return {
      coinAType: o,
      coinBType: a,
      direction: n,
      amountIn: c,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: r,
      priceInfoObjectIdA: f,
      priceInfoObjectIdB: h
    };
  }
  executeSwapContract(e, t, r) {
    const n = t.extendedDetails, i = e.moveCall({
      target: `${this.oraclePackageId}::oracles::get_pyth_price`,
      typeArguments: [],
      arguments: [
        e.object(n.steamm_oracle_registry_id),
        e.object(t.priceInfoObjectIdA),
        e.pure.u64(n.steamm_oracle_index_a),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    }), s = e.moveCall({
      target: `${this.oraclePackageId}::oracles::get_pyth_price`,
      typeArguments: [],
      arguments: [
        e.object(n.steamm_oracle_registry_id),
        e.object(t.priceInfoObjectIdB),
        e.pure.u64(n.steamm_oracle_index_b),
        e.object(hr.SUI_CLOCK_OBJECT_ID)
      ]
    }), o = [
      r,
      e.object(t.poolId),
      e.object(n.steamm_bank_a),
      e.object(n.steamm_bank_b),
      e.object(n.steamm_lending_market),
      i,
      s,
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::steamm_omm_v2::swap`,
      typeArguments: [
        n.steamm_lending_market_type,
        t.coinAType,
        t.coinBType,
        n.steamm_btoken_a_type,
        n.steamm_btoken_b_type,
        n.steamm_lp_token_type
      ],
      arguments: o
    });
  }
}, AV = "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI", MV = "0xe44df51c0b21a27ab915fa1fe2ca610cd3eaa6d9666fe5e62b988bf7f0bd8722::musd::MUSD", OV = "0xccd628c2334c5ed33e6c47d6c21bb664f8b6307b2ac32c2462a61f69a31ebcee::meth::METH", IV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Metastable only supported on mainnet");
    this.versionID = "0x4696559327b35ff2ab26904e7426a1646312e9c836d5c6cff6709a5ccc30915c", this.pythPriceIDs = t;
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t), s = this.createDepositCap(e, i);
    this.executeSwapContract(e, i, r, s);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Metastable not set publishedAt");
    if (!t.extendedDetails)
      throw new Error("Extended details not found for Metastable");
    const { direction: r, from: n, target: i } = t, [s, o] = r ? [n, i] : [i, n], [a, c] = r ? ["swap_a2b", "create_deposit_cap"] : ["swap_b2a", "create_withdraw_cap"];
    if (!t.extendedDetails.metastable_create_cap_pkg_id || !t.extendedDetails.metastable_create_cap_module || !t.extendedDetails.metastable_whitelisted_app_id)
      throw new Error(
        "CreateCapPkgId or CreateCapModule or WhitelistedAppId not found in extended details"
      );
    const u = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinType: s,
      metaCoinType: o,
      func: a,
      createCapFunc: c,
      direction: r,
      amountIn: u,
      publishedAt: t.publishedAt,
      poolId: t.id,
      extendedDetails: t.extendedDetails
    };
  }
  createDepositCap(e, t) {
    const r = [t.metaCoinType];
    t.extendedDetails.metastable_create_cap_all_type_params && r.push(t.coinType);
    const n = [
      e.object(t.extendedDetails.metastable_whitelisted_app_id),
      e.object(t.poolId)
    ];
    switch (t.metaCoinType) {
      case AV: {
        if (!t.extendedDetails.metastable_registry_id)
          throw new Error("Not found registry id for super sui");
        n.push(
          e.object(t.extendedDetails.metastable_registry_id)
        );
        break;
      }
      case MV:
      case OV: {
        if (t.extendedDetails.metastable_price_seed != null) {
          const i = this.pythPriceIDs.get(
            t.extendedDetails.metastable_price_seed
          );
          if (i == null)
            throw new Error(
              "Invalid Pyth price feed: " + t.extendedDetails.metastable_price_seed
            );
          n.push(e.object(i));
        }
        if (t.extendedDetails.metastable_eth_price_seed != null) {
          const i = this.pythPriceIDs.get(
            t.extendedDetails.metastable_eth_price_seed
          );
          if (i == null)
            throw new Error(
              "Invalid Pyth price feed: " + t.extendedDetails.metastable_eth_price_seed
            );
          n.push(e.object(i));
        }
        n.push(e.object(hr.SUI_CLOCK_OBJECT_ID));
        break;
      }
      default:
        throw new Error("Invalid Metacoin: " + t.metaCoinType);
    }
    return e.moveCall({
      target: `${t.extendedDetails.metastable_create_cap_pkg_id}::${t.extendedDetails.metastable_create_cap_module}::${t.createCapFunc}`,
      typeArguments: r,
      arguments: n
    });
  }
  executeSwapContract(e, t, r, n) {
    const i = [
      r,
      e.object(t.poolId),
      e.object(this.versionID),
      n,
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::metastable::${t.func}`,
      typeArguments: [t.coinType, t.metaCoinType],
      arguments: i
    });
  }
}, kV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Alphafi only supported on mainnet");
    this.suiSystemState = "0x0000000000000000000000000000000000000000000000000000000000000005";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("Alphafi not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object(this.suiSystemState),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::alphafi::swap`,
      typeArguments: [t.coinBType],
      arguments: n
    });
  }
}, jV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Volo only supported on mainnet");
    this.stakePool = "0x2d914e23d82fedef1b5f56a32d5c64bdcc3087ccfea2b4d6ea51a71f587840e5", this.metadata = "0x680cd26af32b2bde8d3361e804c53ec1d1cfe24c7f039eb7f549e8dfde389a60";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Volo not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.stakePool),
      e.object(this.metadata),
      e.object("0x5"),
      // SuiSystemState
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::volo::swap`,
      typeArguments: [],
      arguments: n
    });
  }
}, RV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("afSUI only supported on mainnet");
    this.stakedSuiVault = "0x2f8f6d5da7f13ea37daa397724280483ed062769813b6f31e9788e59cc88994d", this.safe = "0xeb685899830dd5837b47007809c76d91a098d52aabbf61e8ac467c59e5cc4610", this.referVault = "0x4ce9a19b594599536c53edb25d22532f82f18038dc8ef618afd00fbbfb9845ef", this.validator = "0xd30018ec3f5ff1a3c75656abf927a87d7f0529e6dc89c7ddd1bd27ecb05e3db2";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    if (e.path.publishedAt == null)
      throw new Error("AFSUI not set publishedAt");
    const t = e.path, [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    if (!t.direction)
      throw new Error("AFSUI not support b2a swap");
    const n = [
      r,
      e.object(this.stakedSuiVault),
      e.object(this.safe),
      e.object("0x5"),
      // SuiSystemState
      e.object(this.referVault),
      e.object(this.validator),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::afsui::swap`,
      typeArguments: [],
      arguments: n
    });
  }
}, PV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Haedal only supported on mainnet");
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Haedal not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(t.poolId),
      e.object("0x5"),
      // SuiSystemState
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::hasui::swap`,
      typeArguments: [],
      arguments: n
    });
  }
}, NV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Hawal only supported on mainnet");
    this.staking = "0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904", this.validator = "0x7b3ba6de2ae58283f60d5b8dc04bb9e90e4796b3b2e0dea75569f491275242e7";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Hawal not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.staking),
      e.object(t.poolId),
      e.object(this.validator),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn)
    ];
    e.moveCall({
      target: `${t.publishedAt}::hawal::swap`,
      typeArguments: [],
      arguments: n
    });
  }
}, $V = Xt.DEFAULT_PUBLISHED_AT.Mainnet;
function hl(e, t) {
  return e && e.has(ed.AGGREGATOR_V3) ? e.get(ed.AGGREGATOR_V3) : t || $V;
}
function tb(e, t) {
  const {
    quoteID: r,
    fromCoinType: n,
    targetCoinType: i,
    expectAmountOut: s,
    amountOutLimit: o,
    inputCoin: a,
    feeRate: c,
    feeRecipient: u,
    aggregatorPublishedAt: l,
    packages: f
  } = e, h = hl(f, l), v = [
    t.pure.string(r),
    t.pure.u64(s.toString()),
    t.pure.u64(o.toString()),
    a,
    t.pure.u32(Number(c.toString())),
    t.pure.address(u)
  ];
  return t.moveCall({
    target: `${h}::router::new_swap_context`,
    typeArguments: [n, i],
    arguments: v
  });
}
function rb(e, t) {
  const { swapContext: r, targetCoinType: n, aggregatorPublishedAt: i, packages: s } = e, o = hl(s, i);
  return t.moveCall({
    target: `${o}::router::confirm_swap`,
    typeArguments: [n],
    arguments: [r]
  });
}
function DV(e, t) {
  const { coinType: r, amount: n, swapCtx: i, aggregatorPublishedAt: s, packages: o } = e, a = hl(o, s), c = [i, t.pure.u64(n.toString())];
  return t.moveCall({
    target: `${a}::router::take_balance`,
    typeArguments: [r],
    arguments: c
  });
}
function LV(e, t) {
  const { balance: r, coinType: n, recipient: i, aggregatorPublishedAt: s, packages: o } = e, a = hl(o, s), c = [r, t.pure.address(i)];
  t.moveCall({
    target: `${a}::router::transfer_balance`,
    typeArguments: [n],
    arguments: c
  });
}
function BV(e, t) {
  const { coin: r, coinType: n, aggregatorPublishedAt: i, packages: s } = e, o = hl(s, i);
  t.moveCall({
    target: `${o}::router::transfer_or_destroy_coin`,
    typeArguments: [n],
    arguments: [r]
  });
}
function UV(e) {
  return e.endsWith("/find_routes") ? e.replace("/find_routes", "") : e;
}
kc(jc());
kc(jc());
var FV = class {
  constructor(e, t) {
    if (e !== 0)
      throw new Error("Haedal HMM V2 only supported on mainnet");
    this.pythPriceIDs = t;
  }
  swap(e, t, r, n) {
    const i = t.path;
    if (!i.extendedDetails)
      throw new Error("Extended details not found for Haedal HMM V2");
    this.validateExtendedDetails(i.extendedDetails);
    const s = this.prepareSwapData(t);
    this.executeSwapContract(e, s, r);
  }
  validateExtendedDetails(e) {
    if (!e.haedalhmmv2_base_price_seed)
      throw new Error("Haedal HMM V2 base price seed not supported");
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Haedal HMM V2 not set publishedAt");
    const r = t.extendedDetails, [n, i] = t.direction ? [t.from, t.target] : [t.target, t.from], s = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn, o = r.haedalhmmv2_base_price_seed, a = this.pythPriceIDs.get(o);
    if (!a)
      throw new Error("Haedal HMM V2 requires oracle price IDs for base coin");
    return {
      coinAType: n,
      coinBType: i,
      basePriceId: a,
      a2b: t.direction,
      amountIn: s,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      // swap_ctx
      e.object(t.poolId),
      // pool
      e.object(t.basePriceId),
      // base_price_pair_obj
      e.pure.u64(t.amountIn),
      // amount_in
      e.pure.bool(t.a2b),
      // a2b
      e.object(hr.SUI_CLOCK_OBJECT_ID)
      // clock
    ];
    e.moveCall({
      target: `${t.publishedAt}::haedal_hmm_v2::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, VV = class {
  constructor(e) {
    if (e !== 0)
      throw new Error("Fullsail only supported on mainnet");
    this.globalConfig = "0xe93baa80cb570b3a494cbf0621b2ba96bc993926d34dc92508c9446f9a05d615", this.vault = "0xfb971d3a2fb98bde74e1c30ba15a3d8bef60a02789e59ae0b91660aeed3e64e1", this.stats = "0x6822a33d1d971e040c32f7cc74507010d1fe786f7d06ab89135083ddb07d2dc2", this.price_provider = "0x854b2d2c0381bb656ec962f8b443eb082654384cf97885359d1956c7d76e33c9";
  }
  swap(e, t, r, n) {
    const i = this.prepareSwapData(t);
    this.executeSwapContract(e, i, r);
  }
  prepareSwapData(e) {
    const t = e.path;
    if (e.path.publishedAt == null)
      throw new Error("Fullsail not set publishedAt");
    const [r, n] = t.direction ? [t.from, t.target] : [t.target, t.from], i = e.isLastUseOfIntermediateToken ? Xt.MAX_AMOUNT_IN : t.amountIn;
    return {
      coinAType: r,
      coinBType: n,
      direction: t.direction,
      amountIn: i,
      publishedAt: t.publishedAt,
      poolId: t.id
    };
  }
  executeSwapContract(e, t, r) {
    const n = [
      r,
      e.object(this.globalConfig),
      e.object(this.vault),
      e.object(this.stats),
      e.object(this.price_provider),
      e.object(t.poolId),
      e.pure.bool(t.direction),
      e.pure.u64(t.amountIn),
      e.object(hr.SUI_CLOCK_OBJECT_ID)
    ];
    e.moveCall({
      target: `${t.publishedAt}::fullsail::swap`,
      typeArguments: [t.coinAType, t.coinBType],
      arguments: n
    });
  }
}, nb = "CETUS", zV = "KRIYA", WV = "FLOWX", qV = "FLOWXV3", HV = "KRIYAV3", GV = "TURBOS", KV = "AFTERMATH", YV = "HAEDAL", XV = "VOLO", JV = "AFSUI", ZV = "BLUEMOVE", QV = "DEEPBOOKV3", ez = "SCALLOP", tz = "SUILEND", rz = "BLUEFIN", y5 = "HAEDALPMM", nz = "ALPHAFI", iz = "SPRINGSUI", sz = "STEAMM", v5 = "METASTABLE", b5 = "OBRIC", oz = "HAWAL", w5 = "STEAMM_OMM", az = "MOMENTUM", _5 = "STEAMM_OMM_V2", cz = "MAGMA", x5 = "SEVENK", S5 = "HAEDALHMMV2", uz = "FULLSAIL", lz = "https://api-sui.cetus.zone/router_v3";
function ib(e) {
  const t = /* @__PURE__ */ new Set();
  for (const r of e) {
    if (r.provider === y5 && r.extendedDetails && r.extendedDetails.haedal_pmm_base_price_seed && r.extendedDetails.haedal_pmm_quote_price_seed && (t.add(r.extendedDetails.haedal_pmm_base_price_seed), t.add(r.extendedDetails.haedal_pmm_quote_price_seed)), r.provider === v5 && (r.extendedDetails && r.extendedDetails.metastable_price_seed && t.add(r.extendedDetails.metastable_price_seed), r.extendedDetails && r.extendedDetails.metastable_eth_price_seed && t.add(r.extendedDetails.metastable_eth_price_seed)), r.provider === b5 && (r.extendedDetails && r.extendedDetails.obric_coin_a_price_seed && t.add(r.extendedDetails.obric_coin_a_price_seed), r.extendedDetails && r.extendedDetails.obric_coin_b_price_seed && t.add(r.extendedDetails.obric_coin_b_price_seed)), (r.provider === w5 || r.provider === _5) && (r.extendedDetails && r.extendedDetails.steamm_oracle_pyth_price_seed_a && t.add(r.extendedDetails.steamm_oracle_pyth_price_seed_a), r.extendedDetails && r.extendedDetails.steamm_oracle_pyth_price_seed_b && t.add(r.extendedDetails.steamm_oracle_pyth_price_seed_b)), r.provider === x5 && r.extendedDetails) {
      const n = r.extendedDetails;
      n.sevenk_coin_a_price_seed && t.add(n.sevenk_coin_a_price_seed), n.sevenk_coin_b_price_seed && t.add(n.sevenk_coin_b_price_seed);
    }
    r.provider === S5 && r.extendedDetails && r.extendedDetails.haedalhmmv2_base_price_seed && t.add(r.extendedDetails.haedalhmmv2_base_price_seed);
  }
  return Array.from(t);
}
var E5 = class T5 {
  constructor(t) {
    var r, n;
    this.endpoint = t.endpoint ? UV(t.endpoint) : lz, this.client = t.client || new Vv.SuiClient({ url: Vv.getFullnodeUrl("mainnet") }), this.signer = t.signer || "", this.env = t.env || 0;
    const i = T5.CONFIG[this.env];
    if (this.pythConnections = this.newPythClients((r = t.pythUrls) != null ? r : []), this.pythClient = new zv.SuiPythClient(
      this.client,
      i.pythStateId,
      i.wormholeStateId
    ), this.apiKey = t.apiKey || "", this.partner = t.partner, t.overlayFeeRate)
      if (t.overlayFeeRate > 0 && t.overlayFeeRate <= yi.MAX_OVERLAY_FEE_RATE) {
        if (this.overlayFeeRate = t.overlayFeeRate * Xt.FEE_DENOMINATOR, this.overlayFeeRate > Xt.MAX_FEE_RATE)
          throw new Error(
            yi.ERRORS.INVALID_OVERLAY_FEE_RATE
          );
      } else
        throw new Error(yi.ERRORS.INVALID_OVERLAY_FEE_RATE);
    else
      this.overlayFeeRate = 0;
    this.overlayFeeReceiver = (n = t.overlayFeeReceiver) != null ? n : yi.DEFAULT_OVERLAY_FEE_RECEIVER;
  }
  newPythClients(t) {
    return t.includes("https://hermes.pyth.network") || t.push("https://hermes.pyth.network"), t.map(
      (n) => new zv.SuiPriceServiceConnection(n, { timeout: 3e3 })
    );
  }
  deepbookv3DeepFeeType() {
    return this.env === 0 ? td.Mainnet : td.Testnet;
  }
  getDeepbookV3Config() {
    return bn(this, null, function* () {
      return yield hF(this.endpoint);
    });
  }
  getOneCoinUsedToMerge(t) {
    return bn(this, null, function* () {
      try {
        const r = yield this.client.getCoins({
          owner: this.signer,
          coinType: t,
          limit: 1
        });
        return r.data.length === 1 ? r.data[0].coinObjectId : null;
      } catch {
        return null;
      }
    });
  }
  findRouters(t) {
    return bn(this, null, function* () {
      return lF(
        this.endpoint,
        this.apiKey,
        t,
        this.overlayFeeRate,
        this.overlayFeeReceiver
      );
    });
  }
  executeFlexibleInputSwap(t, r, n, i, s, o, a, c, u) {
    return bn(this, null, function* () {
    });
  }
  newDexRouterV3(t, r, n) {
    switch (t) {
      case nb:
        return new Qv(this.env, n);
      case HV:
        return new uV(this.env);
      case qV:
        return new lV(this.env);
      case GV:
        return new fV(this.env);
      case rz:
        return new dV(this.env);
      case az:
        return new hV(this.env);
      case cz:
        return new pV(this.env);
      case zV:
        return new mV(this.env);
      case WV:
        return new gV(this.env);
      case ZV:
        return new yV(this.env);
      case QV:
        return new vV(this.env);
      case KV:
        return new bV(this.env);
      case sz:
        return new wV(this.env);
      case ez:
        return new _V(this.env);
      case tz:
        return new eb(this.env);
      case iz:
        return new eb(this.env);
      case y5:
        return new xV(this.env, r);
      case b5:
        return new SV(this.env, r);
      case x5:
        return new EV(this.env, r);
      case w5:
        return new TV(this.env, r);
      case _5:
        return new CV(this.env, r);
      case v5:
        return new IV(this.env, r);
      case nz:
        return new kV(this.env);
      case XV:
        return new jV(this.env);
      case JV:
        return new RV(this.env);
      case YV:
        return new PV(this.env);
      case oz:
        return new NV(this.env);
      case S5:
        return new FV(this.env, r);
      case uz:
        return new VV(this.env);
      default:
        throw new Error(
          `${yi.ERRORS.UNSUPPORTED_DEX} ${t}`
        );
    }
  }
  expectInputSwapV3(t, r, n, i, s, o, a) {
    if (n.quoteID == null)
      throw new Error(yi.ERRORS.QUOTE_ID_REQUIRED);
    const c = Kv(n), u = tb(
      {
        quoteID: c.quoteID,
        fromCoinType: c.fromCoinType,
        targetCoinType: c.targetCoinType,
        expectAmountOut: i,
        amountOutLimit: s,
        inputCoin: r,
        feeRate: this.overlayFeeRate,
        feeRecipient: this.overlayFeeReceiver,
        packages: c.packages
      },
      t
    );
    let l = /* @__PURE__ */ new Map();
    for (const h of c.flattenedPaths) {
      const v = h.path;
      l.has(v.provider) || l.set(
        v.provider,
        this.newDexRouterV3(v.provider, o, a)
      ), l.get(v.provider).swap(t, h, u, { pythPriceIDs: o });
    }
    return rb(
      {
        swapContext: u,
        targetCoinType: c.targetCoinType,
        packages: c.packages
      },
      t
    );
  }
  expectOutputSwapV3(t, r, n, i, s, o) {
    const a = [], c = new Qv(this.env, o), u = Kv(n), l = tb(
      {
        quoteID: u.quoteID,
        fromCoinType: u.fromCoinType,
        targetCoinType: u.targetCoinType,
        expectAmountOut: i,
        amountOutLimit: i,
        // amountOutLimit equals expectAmountOut when fix amout out
        inputCoin: r,
        feeRate: this.overlayFeeRate,
        feeRecipient: this.overlayFeeReceiver,
        packages: u.packages
      },
      t
    ), f = hz(n.paths);
    let h = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
    for (let S = n.paths.length - 1; S >= 0; S--) {
      const C = n.paths[S], O = f.get(C.from);
      let I;
      if (S !== O || C.target === u.targetCoinType) {
        if (C.target !== u.targetCoinType) {
          let D = BigInt(C.amountOut);
          v.has(C.target) && (D = v.get(C.target) + D), v.set(C.target, D);
        }
        I = t.pure.u64(
          C.amountOut.toString()
        );
      } else {
        if (!h.has(C.target))
          throw Error("no need repay record");
        if (v.has(C.target)) {
          const D = v.get(C.target), H = h.get(C.target);
          I = c.sub(
            t,
            H,
            t.pure.u64(D),
            C.publishedAt
          );
        } else
          I = h.get(C.target);
      }
      const U = c.flashSwapFixedOutput(
        t,
        C,
        I,
        l
      );
      if (a.unshift(U.flashReceipt), h.has(C.from)) {
        const D = h.get(C.from);
        h.set(
          C.from,
          c.add(
            t,
            D,
            U.repayAmount,
            C.publishedAt
          )
        );
      } else
        h.set(C.from, U.repayAmount);
    }
    for (let S = 0; S < n.paths.length; S++) {
      const C = n.paths[S];
      c.repayFlashSwapFixedOutput(t, C, l, a[S]);
    }
    const b = DV(
      {
        coinType: u.fromCoinType,
        amount: K0,
        swapCtx: l,
        packages: u.packages
      },
      t
    );
    return LV(
      {
        balance: b,
        coinType: u.fromCoinType,
        recipient: this.signer,
        packages: u.packages
      },
      t
    ), rb(
      {
        swapContext: l,
        targetCoinType: u.targetCoinType,
        packages: u.packages
      },
      t
    );
  }
  routerSwap(t) {
    return bn(this, null, function* () {
      const { router: r, inputCoin: n, slippage: i, txb: s, partner: o } = t;
      if (i > 1 || i < 0)
        throw new Error(yi.ERRORS.INVALID_SLIPPAGE);
      if (!t.router.packages || !t.router.packages.get(ed.AGGREGATOR_V3))
        throw new Error(yi.ERRORS.PACKAGES_REQUIRED);
      const a = t.router.byAmountIn, c = r.amountIn, u = r.amountOut;
      jp(this.overlayFeeRate, this.overlayFeeReceiver);
      let l = new pr.default(0);
      a ? l = u.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6)) : l = c.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6));
      const f = a ? u.sub(l) : u, h = a ? c : c.add(l), v = Zv(
        a ? f : h,
        a,
        i
      ), b = ib(r.paths), y = b.length > 0 ? yield this.updatePythPriceIDs(b, s) : /* @__PURE__ */ new Map();
      return a ? this.expectInputSwapV3(
        s,
        n,
        r,
        u.toString(),
        v.toString(),
        y,
        o ?? this.partner
      ) : this.expectOutputSwapV3(
        s,
        n,
        r,
        u.toString(),
        v.toString(),
        o ?? this.partner
      );
    });
  }
  // auto build input coin
  // auto merge, transfer or destory target coin.
  fastRouterSwap(t) {
    return bn(this, null, function* () {
      const { router: r, slippage: n, txb: i, partner: s, payDeepFeeAmount: o } = t, a = r.paths[0].from, c = r.paths[r.paths.length - 1].target, u = r.byAmountIn;
      jp(this.overlayFeeRate, this.overlayFeeReceiver);
      let l = 0;
      u ? l = Number(
        r.amountOut.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6)).toString()
      ) : l = Number(
        r.amountIn.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6)).toString()
      );
      const f = u ? r.amountOut.sub(new pr.default(l)) : r.amountOut, h = u ? r.amountIn : r.amountIn.add(new pr.default(l)), v = cV(
        u ? f : h,
        u,
        n
      ), b = u ? h : v;
      let y = Ip.coinWithBalance({
        balance: BigInt(b.toString()),
        useGasCoin: !0,
        type: a
      }), S;
      o && o > 0 && (S = Ip.coinWithBalance({
        balance: BigInt(o),
        type: this.deepbookv3DeepFeeType()
      }));
      const C = {
        router: r,
        inputCoin: y,
        slippage: n,
        txb: i,
        partner: s ?? this.partner,
        deepbookv3DeepFee: S
      }, O = yield this.routerSwap(C);
      if (t5.isSuiCoin(c))
        i.mergeCoins(i.gas, [O]);
      else {
        const I = yield this.getOneCoinUsedToMerge(c);
        I != null ? i.mergeCoins(i.object(I), [O]) : BV(
          {
            coin: O,
            coinType: c,
            packages: r.packages
          },
          i
        );
      }
    });
  }
  fixableRouterSwapV3(t) {
    return bn(this, null, function* () {
      const { router: r, inputCoin: n, slippage: i, txb: s, partner: o } = t;
      jp(this.overlayFeeRate, this.overlayFeeReceiver);
      let a = 0;
      r.byAmountIn ? a = Number(
        r.amountOut.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6)).toString()
      ) : a = Number(
        r.amountIn.mul(new pr.default(this.overlayFeeRate)).div(new pr.default(1e6)).toString()
      );
      const c = r.byAmountIn ? r.amountOut.sub(new pr.default(a)) : r.amountOut, u = r.byAmountIn ? r.amountIn : r.amountIn.add(new pr.default(a)), l = Zv(
        r.byAmountIn ? c : u,
        r.byAmountIn,
        i
      ), f = ib(r.paths), h = f.length > 0 ? yield this.updatePythPriceIDs(f, s) : /* @__PURE__ */ new Map();
      return r.byAmountIn ? this.expectInputSwapV3(
        s,
        n,
        r,
        c.toString(),
        l.toString(),
        h,
        o ?? this.partner
      ) : this.expectOutputSwapV3(
        s,
        n,
        r,
        c.toString(),
        l.toString(),
        o ?? this.partner
      );
    });
  }
  swapInPools(t) {
    return bn(this, null, function* () {
      var r, n, i, s;
      const { from: o, target: a, amount: c, byAmountIn: u, pools: l } = t, f = jo(o), h = jo(a), v = new Ip.Transaction(), b = oF(f, h), y = b ? f : h, S = b ? h : f, C = [y, S], O = this.env === 0 ? "0x5bcd02f33d65c7ce98cd1ffb88174629210e59230b41c4b4572de1541f94946e" : "0x4f920e1ef6318cfba77e20a0538a419a5a504c14230169438b99aba485db40a6";
      for (let m = 0; m < l.length; m++) {
        const x = [
          v.object(l[m]),
          v.pure.bool(b),
          v.pure.bool(u),
          v.pure.u64(c.toString())
        ];
        v.moveCall({
          target: `${O}::fetcher_script::calculate_swap_result`,
          arguments: x,
          typeArguments: C
        });
      }
      this.signer || (this.signer = "0x0");
      const I = yield this.client.devInspectTransactionBlock({
        transactionBlock: v,
        sender: this.signer
      });
      if (I.error != null)
        throw new Error("Simulation error: " + I.error);
      const U = (r = I.events) == null ? void 0 : r.filter((m) => m.type.includes("CalculatedSwapResultEvent"));
      if (U.length === 0 || U.length !== l.length)
        throw new Error("Simulate event result error");
      let D = u ? new pr.default(0) : new pr.default(K0), H = 0;
      for (let m = 0; m < U.length; m += 1)
        if (!U[m].parsedJson.data.is_exceed)
          if (t.byAmountIn) {
            const x = new pr.default(U[m].parsedJson.data.amount_out);
            x.gt(D) && (H = m, D = x);
          } else {
            const x = new pr.default(U[m].parsedJson.data.amount_out);
            x.lt(D) && (H = m, D = x);
          }
      const z = U[H].parsedJson.data, [ne, le] = yield Promise.all([
        this.client.getCoinMetadata({ coinType: y }).then((m) => m == null ? void 0 : m.decimals),
        this.client.getCoinMetadata({ coinType: S }).then((m) => m == null ? void 0 : m.decimals)
      ]);
      if (ne == null || le == null)
        throw new Error("Cannot get coin decimals");
      const te = Number(z.fee_rate) / 1e6, ce = new pr.default((n = z.amount_in) != null ? n : 0), V = new pr.default((i = z.fee_amount) != null ? i : 0), L = ce.add(V), p = {
        amountIn: L,
        amountOut: new pr.default((s = z.amount_out) != null ? s : 0),
        deviationRatio: 0,
        paths: [
          {
            id: l[H],
            direction: b,
            provider: nb,
            from: f,
            target: h,
            feeRate: te,
            amountIn: L.toString(),
            amountOut: z.amount_out,
            publishedAt: cF,
            extendedDetails: {
              afterSqrtPrice: z.after_sqrt_price
            }
          }
        ],
        insufficientLiquidity: !1,
        byAmountIn: t.byAmountIn,
        quoteID: `degraded-${dz()}`,
        packages: /* @__PURE__ */ new Map([
          [
            ed.AGGREGATOR_V3,
            Xt.DEFAULT_PUBLISHED_AT.Mainnet
          ]
        ])
      };
      return {
        isExceed: z.is_exceed,
        routeData: p
      };
    });
  }
  updatePythPriceIDs(t, r) {
    return bn(this, null, function* () {
      let n = null, i = null;
      for (const a of this.pythConnections)
        try {
          n = yield a.getPriceFeedsUpdateData(t);
          break;
        } catch (c) {
          i = c;
          continue;
        }
      if (n == null)
        throw new Error(
          `All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes. Detailed error: ${i == null ? void 0 : i.message}`
        );
      let s = [];
      try {
        s = yield this.pythClient.updatePriceFeeds(
          r,
          n,
          t
        );
      } catch (a) {
        throw new Error(
          `All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes in the pythUrls parameter when initializing AggregatorClient, for example: new AggregatorClient({ pythUrls: ["https://your-pyth-node-url"] }). Detailed error: ${a}`
        );
      }
      let o = /* @__PURE__ */ new Map();
      for (let a = 0; a < t.length; a++)
        o.set(t[a], s[a]);
      return o;
    });
  }
  devInspectTransactionBlock(t) {
    return bn(this, null, function* () {
      return yield this.client.devInspectTransactionBlock({
        transactionBlock: t,
        sender: this.signer
      });
    });
  }
  sendTransaction(t, r) {
    return bn(this, null, function* () {
      return yield this.client.signAndExecuteTransaction({
        transaction: t,
        signer: r
      });
    });
  }
};
E5.CONFIG = {
  1: {
    wormholeStateId: "0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790",
    pythStateId: "0x243759059f4c3111179da5878c12f68d612c21a8d54d85edc86164bb18be1c7c"
  },
  0: {
    wormholeStateId: "0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c",
    pythStateId: "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8"
  }
};
var fz = E5;
function dz() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    const t = Math.random() * 16 | 0;
    return (e === "x" ? t : t & 3 | 8).toString(16);
  });
}
function hz(e) {
  let t = /* @__PURE__ */ new Map();
  for (let r = 0; r < e.length; r++)
    t.has(e[r].from) || t.set(e[r].from, r);
  return t;
}
function jp(e, t) {
  if (e > yi.MAX_OVERLAY_FEE_RATE_NUMERATOR)
    throw new Error(yi.ERRORS.INVALID_OVERLAY_FEE_RATE);
  if (t === "0x0" && e > 0)
    throw new Error(
      yi.ERRORS.OVERLAY_FEE_RECEIVER_REQUIRED
    );
}
var C5 = fz, A5 = n5, sb = rF, ga = uc;
const M5 = "0x2::sui::SUI", pz = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
function Q0(e) {
  return jr(e).full_address === M5;
}
function ob(e, ...t) {
  const r = Array.isArray(t[t.length - 1]) ? t.pop() : [];
  let i = [e, ...t].filter(Boolean).join("::");
  return r && r.length && (i += `<${r.join(", ")}>`), i;
}
function jr(e) {
  var t;
  try {
    let r = e.replace(/\s/g, "");
    const n = r.match(/(<.+>)$/), i = (t = n == null ? void 0 : n[0]) == null ? void 0 : t.match(
      /(\w+::\w+::\w+)(?:<.*?>(?!>))?/g
    );
    if (i) {
      r = r.slice(0, r.indexOf("<"));
      const u = {
        ...jr(r),
        type_arguments: i.map(
          (l) => jr(l).source_address
        )
      };
      return u.type_arguments = u.type_arguments.map((l) => Q0(l) ? l : jr(l).source_address), u.source_address = ob(
        u.full_address,
        u.type_arguments
      ), u;
    }
    const s = r.split("::"), a = {
      full_address: r,
      address: r === M5 || r === pz ? "0x2" : ai(s[0]),
      module: s[1],
      name: s[2],
      type_arguments: [],
      source_address: ""
    };
    return a.full_address = `${a.address}::${a.module}::${a.name}`, a.source_address = ob(
      a.full_address,
      a.type_arguments
    ), a;
  } catch {
    return {
      full_address: e,
      address: "",
      module: "",
      name: "",
      type_arguments: [],
      source_address: e
    };
  }
}
function mz(e) {
  return e.startsWith("0x") ? `${e.slice(2)}` : e;
}
const Hs = (e, t = !0) => {
  const r = e.split("::"), n = r.shift();
  let i = ai(n);
  return t && (i = mz(i)), `${i}::${r.join("::")}`;
};
/*!
 *  decimal.js v10.6.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var ic = 9e15, Uo = 1e9, em = "0123456789abcdef", sd = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", od = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", tm = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -ic,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: ic,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: !1
  // true/false
}, O5, $s, At = !0, Xd = "[DecimalError] ", Po = Xd + "Invalid argument: ", I5 = Xd + "Precision limit exceeded", k5 = Xd + "crypto unavailable", j5 = "[object Decimal]", pn = Math.floor, Ur = Math.pow, gz = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, yz = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, vz = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, R5 = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Oi = 1e7, wt = 7, bz = 9007199254740991, wz = sd.length - 1, rm = od.length - 1, Ne = { toStringTag: j5 };
Ne.absoluteValue = Ne.abs = function() {
  var e = new this.constructor(this);
  return e.s < 0 && (e.s = 1), dt(e);
};
Ne.ceil = function() {
  return dt(new this.constructor(this), this.e + 1, 2);
};
Ne.clampedTo = Ne.clamp = function(e, t) {
  var r, n = this, i = n.constructor;
  if (e = new i(e), t = new i(t), !e.s || !t.s)
    return new i(NaN);
  if (e.gt(t))
    throw Error(Po + t);
  return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
};
Ne.comparedTo = Ne.cmp = function(e) {
  var t, r, n, i, s = this, o = s.d, a = (e = new s.constructor(e)).d, c = s.s, u = e.s;
  if (!o || !a)
    return !c || !u ? NaN : c !== u ? c : o === a ? 0 : !o ^ c < 0 ? 1 : -1;
  if (!o[0] || !a[0])
    return o[0] ? c : a[0] ? -u : 0;
  if (c !== u)
    return c;
  if (s.e !== e.e)
    return s.e > e.e ^ c < 0 ? 1 : -1;
  for (n = o.length, i = a.length, t = 0, r = n < i ? n : i; t < r; ++t)
    if (o[t] !== a[t])
      return o[t] > a[t] ^ c < 0 ? 1 : -1;
  return n === i ? 0 : n > i ^ c < 0 ? 1 : -1;
};
Ne.cosine = Ne.cos = function() {
  var e, t, r = this, n = r.constructor;
  return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = _z(n, L5(n, r)), n.precision = e, n.rounding = t, dt($s == 2 || $s == 3 ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN);
};
Ne.cubeRoot = Ne.cbrt = function() {
  var e, t, r, n, i, s, o, a, c, u, l = this, f = l.constructor;
  if (!l.isFinite() || l.isZero())
    return new f(l);
  for (At = !1, s = l.s * Ur(l.s * l, 1 / 3), !s || Math.abs(s) == 1 / 0 ? (r = rn(l.d), e = l.e, (s = (e - r.length + 1) % 3) && (r += s == 1 || s == -2 ? "0" : "00"), s = Ur(r, 1 / 3), e = pn((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s == 1 / 0 ? r = "5e" + e : (r = s.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new f(r), n.s = l.s) : n = new f(s.toString()), o = (e = f.precision) + 3; ; )
    if (a = n, c = a.times(a).times(a), u = c.plus(l), n = rr(u.plus(l).times(a), u.plus(c), o + 2, 1), rn(a.d).slice(0, o) === (r = rn(n.d)).slice(0, o))
      if (r = r.slice(o - 3, o + 1), r == "9999" || !i && r == "4999") {
        if (!i && (dt(a, e + 1, 0), a.times(a).times(a).eq(l))) {
          n = a;
          break;
        }
        o += 4, i = 1;
      } else {
        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (dt(n, e + 1, 1), t = !n.times(n).times(n).eq(l));
        break;
      }
  return At = !0, dt(n, e, f.rounding, t);
};
Ne.decimalPlaces = Ne.dp = function() {
  var e, t = this.d, r = NaN;
  if (t) {
    if (e = t.length - 1, r = (e - pn(this.e / wt)) * wt, e = t[e], e)
      for (; e % 10 == 0; e /= 10)
        r--;
    r < 0 && (r = 0);
  }
  return r;
};
Ne.dividedBy = Ne.div = function(e) {
  return rr(this, new this.constructor(e));
};
Ne.dividedToIntegerBy = Ne.divToInt = function(e) {
  var t = this, r = t.constructor;
  return dt(rr(t, new r(e), 0, 1, 1), r.precision, r.rounding);
};
Ne.equals = Ne.eq = function(e) {
  return this.cmp(e) === 0;
};
Ne.floor = function() {
  return dt(new this.constructor(this), this.e + 1, 3);
};
Ne.greaterThan = Ne.gt = function(e) {
  return this.cmp(e) > 0;
};
Ne.greaterThanOrEqualTo = Ne.gte = function(e) {
  var t = this.cmp(e);
  return t == 1 || t === 0;
};
Ne.hyperbolicCosine = Ne.cosh = function() {
  var e, t, r, n, i, s = this, o = s.constructor, a = new o(1);
  if (!s.isFinite())
    return new o(s.s ? 1 / 0 : NaN);
  if (s.isZero())
    return a;
  r = o.precision, n = o.rounding, o.precision = r + Math.max(s.e, s.sd()) + 4, o.rounding = 1, i = s.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Zd(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), s = bc(o, 1, s.times(t), new o(1), !0);
  for (var c, u = e, l = new o(8); u--; )
    c = s.times(s), s = a.minus(c.times(l.minus(c.times(l))));
  return dt(s, o.precision = r, o.rounding = n, !0);
};
Ne.hyperbolicSine = Ne.sinh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  if (!i.isFinite() || i.isZero())
    return new s(i);
  if (t = s.precision, r = s.rounding, s.precision = t + Math.max(i.e, i.sd()) + 4, s.rounding = 1, n = i.d.length, n < 3)
    i = bc(s, 2, i, i, !0);
  else {
    e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Zd(5, e)), i = bc(s, 2, i, i, !0);
    for (var o, a = new s(5), c = new s(16), u = new s(20); e--; )
      o = i.times(i), i = i.times(a.plus(o.times(c.times(o).plus(u))));
  }
  return s.precision = t, s.rounding = r, dt(i, t, r, !0);
};
Ne.hyperbolicTangent = Ne.tanh = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, rr(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
};
Ne.inverseCosine = Ne.acos = function() {
  var e = this, t = e.constructor, r = e.abs().cmp(1), n = t.precision, i = t.rounding;
  return r !== -1 ? r === 0 ? e.isNeg() ? es(t, n, i) : new t(0) : new t(NaN) : e.isZero() ? es(t, n + 4, i).times(0.5) : (t.precision = n + 6, t.rounding = 1, e = new t(1).minus(e).div(e.plus(1)).sqrt().atan(), t.precision = n, t.rounding = i, e.times(2));
};
Ne.inverseHyperbolicCosine = Ne.acosh = function() {
  var e, t, r = this, n = r.constructor;
  return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, At = !1, r = r.times(r).minus(1).sqrt().plus(r), At = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r);
};
Ne.inverseHyperbolicSine = Ne.asinh = function() {
  var e, t, r = this, n = r.constructor;
  return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, At = !1, r = r.times(r).plus(1).sqrt().plus(r), At = !0, n.precision = e, n.rounding = t, r.ln());
};
Ne.inverseHyperbolicTangent = Ne.atanh = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isFinite() ? i.e >= 0 ? new s(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = s.precision, t = s.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? dt(new s(i), e, t, !0) : (s.precision = r = n - i.e, i = rr(i.plus(1), new s(1).minus(i), r + e, 1), s.precision = e + 4, s.rounding = 1, i = i.ln(), s.precision = e, s.rounding = t, i.times(0.5))) : new s(NaN);
};
Ne.inverseSine = Ne.asin = function() {
  var e, t, r, n, i = this, s = i.constructor;
  return i.isZero() ? new s(i) : (t = i.abs().cmp(1), r = s.precision, n = s.rounding, t !== -1 ? t === 0 ? (e = es(s, r + 4, n).times(0.5), e.s = i.s, e) : new s(NaN) : (s.precision = r + 6, s.rounding = 1, i = i.div(new s(1).minus(i.times(i)).sqrt().plus(1)).atan(), s.precision = r, s.rounding = n, i.times(2)));
};
Ne.inverseTangent = Ne.atan = function() {
  var e, t, r, n, i, s, o, a, c, u = this, l = u.constructor, f = l.precision, h = l.rounding;
  if (u.isFinite()) {
    if (u.isZero())
      return new l(u);
    if (u.abs().eq(1) && f + 4 <= rm)
      return o = es(l, f + 4, h).times(0.25), o.s = u.s, o;
  } else {
    if (!u.s)
      return new l(NaN);
    if (f + 4 <= rm)
      return o = es(l, f + 4, h).times(0.5), o.s = u.s, o;
  }
  for (l.precision = a = f + 10, l.rounding = 1, r = Math.min(28, a / wt + 2 | 0), e = r; e; --e)
    u = u.div(u.times(u).plus(1).sqrt().plus(1));
  for (At = !1, t = Math.ceil(a / wt), n = 1, c = u.times(u), o = new l(u), i = u; e !== -1; )
    if (i = i.times(c), s = o.minus(i.div(n += 2)), i = i.times(c), o = s.plus(i.div(n += 2)), o.d[t] !== void 0)
      for (e = t; o.d[e] === s.d[e] && e--; )
        ;
  return r && (o = o.times(2 << r - 1)), At = !0, dt(o, l.precision = f, l.rounding = h, !0);
};
Ne.isFinite = function() {
  return !!this.d;
};
Ne.isInteger = Ne.isInt = function() {
  return !!this.d && pn(this.e / wt) > this.d.length - 2;
};
Ne.isNaN = function() {
  return !this.s;
};
Ne.isNegative = Ne.isNeg = function() {
  return this.s < 0;
};
Ne.isPositive = Ne.isPos = function() {
  return this.s > 0;
};
Ne.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
Ne.lessThan = Ne.lt = function(e) {
  return this.cmp(e) < 0;
};
Ne.lessThanOrEqualTo = Ne.lte = function(e) {
  return this.cmp(e) < 1;
};
Ne.logarithm = Ne.log = function(e) {
  var t, r, n, i, s, o, a, c, u = this, l = u.constructor, f = l.precision, h = l.rounding, v = 5;
  if (e == null)
    e = new l(10), t = !0;
  else {
    if (e = new l(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
      return new l(NaN);
    t = e.eq(10);
  }
  if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
    return new l(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
  if (t)
    if (r.length > 1)
      s = !0;
    else {
      for (i = r[0]; i % 10 === 0; )
        i /= 10;
      s = i !== 1;
    }
  if (At = !1, a = f + v, o = Eo(u, a), n = t ? ad(l, a + 10) : Eo(e, a), c = rr(o, n, a, 1), Nu(c.d, i = f, h))
    do
      if (a += 10, o = Eo(u, a), n = t ? ad(l, a + 10) : Eo(e, a), c = rr(o, n, a, 1), !s) {
        +rn(c.d).slice(i + 1, i + 15) + 1 == 1e14 && (c = dt(c, f + 1, 0));
        break;
      }
    while (Nu(c.d, i += 10, h));
  return At = !0, dt(c, f, h);
};
Ne.minus = Ne.sub = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f, h, v = this, b = v.constructor;
  if (e = new b(e), !v.d || !e.d)
    return !v.s || !e.s ? e = new b(NaN) : v.d ? e.s = -e.s : e = new b(e.d || v.s !== e.s ? v : NaN), e;
  if (v.s != e.s)
    return e.s = -e.s, v.plus(e);
  if (u = v.d, h = e.d, a = b.precision, c = b.rounding, !u[0] || !h[0]) {
    if (h[0])
      e.s = -e.s;
    else if (u[0])
      e = new b(v);
    else
      return new b(c === 3 ? -0 : 0);
    return At ? dt(e, a, c) : e;
  }
  if (r = pn(e.e / wt), l = pn(v.e / wt), u = u.slice(), s = l - r, s) {
    for (f = s < 0, f ? (t = u, s = -s, o = h.length) : (t = h, r = l, o = u.length), n = Math.max(Math.ceil(a / wt), o) + 2, s > n && (s = n, t.length = 1), t.reverse(), n = s; n--; )
      t.push(0);
    t.reverse();
  } else {
    for (n = u.length, o = h.length, f = n < o, f && (o = n), n = 0; n < o; n++)
      if (u[n] != h[n]) {
        f = u[n] < h[n];
        break;
      }
    s = 0;
  }
  for (f && (t = u, u = h, h = t, e.s = -e.s), o = u.length, n = h.length - o; n > 0; --n)
    u[o++] = 0;
  for (n = h.length; n > s; ) {
    if (u[--n] < h[n]) {
      for (i = n; i && u[--i] === 0; )
        u[i] = Oi - 1;
      --u[i], u[n] += Oi;
    }
    u[n] -= h[n];
  }
  for (; u[--o] === 0; )
    u.pop();
  for (; u[0] === 0; u.shift())
    --r;
  return u[0] ? (e.d = u, e.e = Jd(u, r), At ? dt(e, a, c) : e) : new b(c === 3 ? -0 : 0);
};
Ne.modulo = Ne.mod = function(e) {
  var t, r = this, n = r.constructor;
  return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? dt(new n(r), n.precision, n.rounding) : (At = !1, n.modulo == 9 ? (t = rr(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = rr(r, e, 0, n.modulo, 1), t = t.times(e), At = !0, r.minus(t));
};
Ne.naturalExponential = Ne.exp = function() {
  return nm(this);
};
Ne.naturalLogarithm = Ne.ln = function() {
  return Eo(this);
};
Ne.negated = Ne.neg = function() {
  var e = new this.constructor(this);
  return e.s = -e.s, dt(e);
};
Ne.plus = Ne.add = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f = this, h = f.constructor;
  if (e = new h(e), !f.d || !e.d)
    return !f.s || !e.s ? e = new h(NaN) : f.d || (e = new h(e.d || f.s === e.s ? f : NaN)), e;
  if (f.s != e.s)
    return e.s = -e.s, f.minus(e);
  if (u = f.d, l = e.d, a = h.precision, c = h.rounding, !u[0] || !l[0])
    return l[0] || (e = new h(f)), At ? dt(e, a, c) : e;
  if (s = pn(f.e / wt), n = pn(e.e / wt), u = u.slice(), i = s - n, i) {
    for (i < 0 ? (r = u, i = -i, o = l.length) : (r = l, n = s, o = u.length), s = Math.ceil(a / wt), o = s > o ? s + 1 : o + 1, i > o && (i = o, r.length = 1), r.reverse(); i--; )
      r.push(0);
    r.reverse();
  }
  for (o = u.length, i = l.length, o - i < 0 && (i = o, r = l, l = u, u = r), t = 0; i; )
    t = (u[--i] = u[i] + l[i] + t) / Oi | 0, u[i] %= Oi;
  for (t && (u.unshift(t), ++n), o = u.length; u[--o] == 0; )
    u.pop();
  return e.d = u, e.e = Jd(u, n), At ? dt(e, a, c) : e;
};
Ne.precision = Ne.sd = function(e) {
  var t, r = this;
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0)
    throw Error(Po + e);
  return r.d ? (t = P5(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
};
Ne.round = function() {
  var e = this, t = e.constructor;
  return dt(new t(e), e.e + 1, t.rounding);
};
Ne.sine = Ne.sin = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + wt, n.rounding = 1, r = Sz(n, L5(n, r)), n.precision = e, n.rounding = t, dt($s > 2 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Ne.squareRoot = Ne.sqrt = function() {
  var e, t, r, n, i, s, o = this, a = o.d, c = o.e, u = o.s, l = o.constructor;
  if (u !== 1 || !a || !a[0])
    return new l(!u || u < 0 && (!a || a[0]) ? NaN : a ? o : 1 / 0);
  for (At = !1, u = Math.sqrt(+o), u == 0 || u == 1 / 0 ? (t = rn(a), (t.length + c) % 2 == 0 && (t += "0"), u = Math.sqrt(t), c = pn((c + 1) / 2) - (c < 0 || c % 2), u == 1 / 0 ? t = "5e" + c : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + c), n = new l(t)) : n = new l(u.toString()), r = (c = l.precision) + 3; ; )
    if (s = n, n = s.plus(rr(o, s, r + 2, 1)).times(0.5), rn(s.d).slice(0, r) === (t = rn(n.d)).slice(0, r))
      if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
        if (!i && (dt(s, c + 1, 0), s.times(s).eq(o))) {
          n = s;
          break;
        }
        r += 4, i = 1;
      } else {
        (!+t || !+t.slice(1) && t.charAt(0) == "5") && (dt(n, c + 1, 1), e = !n.times(n).eq(o));
        break;
      }
  return At = !0, dt(n, c, l.rounding, e);
};
Ne.tangent = Ne.tan = function() {
  var e, t, r = this, n = r.constructor;
  return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = rr(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, dt($s == 2 || $s == 4 ? r.neg() : r, e, t, !0)) : new n(NaN);
};
Ne.times = Ne.mul = function(e) {
  var t, r, n, i, s, o, a, c, u, l = this, f = l.constructor, h = l.d, v = (e = new f(e)).d;
  if (e.s *= l.s, !h || !h[0] || !v || !v[0])
    return new f(!e.s || h && !h[0] && !v || v && !v[0] && !h ? NaN : !h || !v ? e.s / 0 : e.s * 0);
  for (r = pn(l.e / wt) + pn(e.e / wt), c = h.length, u = v.length, c < u && (s = h, h = v, v = s, o = c, c = u, u = o), s = [], o = c + u, n = o; n--; )
    s.push(0);
  for (n = u; --n >= 0; ) {
    for (t = 0, i = c + n; i > n; )
      a = s[i] + v[n] * h[i - n - 1] + t, s[i--] = a % Oi | 0, t = a / Oi | 0;
    s[i] = (s[i] + t) % Oi | 0;
  }
  for (; !s[--o]; )
    s.pop();
  return t ? ++r : s.shift(), e.d = s, e.e = Jd(s, r), At ? dt(e, f.precision, f.rounding) : e;
};
Ne.toBinary = function(e, t) {
  return p1(this, 2, e, t);
};
Ne.toDecimalPlaces = Ne.toDP = function(e, t) {
  var r = this, n = r.constructor;
  return r = new n(r), e === void 0 ? r : (Dn(e, 0, Uo), t === void 0 ? t = n.rounding : Dn(t, 0, 8), dt(r, e + r.e + 1, t));
};
Ne.toExponential = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = us(n, !0) : (Dn(e, 0, Uo), t === void 0 ? t = i.rounding : Dn(t, 0, 8), n = dt(new i(n), e + 1, t), r = us(n, !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ne.toFixed = function(e, t) {
  var r, n, i = this, s = i.constructor;
  return e === void 0 ? r = us(i) : (Dn(e, 0, Uo), t === void 0 ? t = s.rounding : Dn(t, 0, 8), n = dt(new s(i), e + i.e + 1, t), r = us(n, !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
};
Ne.toFraction = function(e) {
  var t, r, n, i, s, o, a, c, u, l, f, h, v = this, b = v.d, y = v.constructor;
  if (!b)
    return new y(v);
  if (u = r = new y(1), n = c = new y(0), t = new y(n), s = t.e = P5(b) - v.e - 1, o = s % wt, t.d[0] = Ur(10, o < 0 ? wt + o : o), e == null)
    e = s > 0 ? t : u;
  else {
    if (a = new y(e), !a.isInt() || a.lt(u))
      throw Error(Po + a);
    e = a.gt(t) ? s > 0 ? t : u : a;
  }
  for (At = !1, a = new y(rn(b)), l = y.precision, y.precision = s = b.length * wt * 2; f = rr(a, t, 0, 1, 1), i = r.plus(f.times(n)), i.cmp(e) != 1; )
    r = n, n = i, i = u, u = c.plus(f.times(i)), c = i, i = t, t = a.minus(f.times(i)), a = i;
  return i = rr(e.minus(r), n, 0, 1, 1), c = c.plus(i.times(u)), r = r.plus(i.times(n)), c.s = u.s = v.s, h = rr(u, n, s, 1).minus(v).abs().cmp(rr(c, r, s, 1).minus(v).abs()) < 1 ? [u, n] : [c, r], y.precision = l, At = !0, h;
};
Ne.toHexadecimal = Ne.toHex = function(e, t) {
  return p1(this, 16, e, t);
};
Ne.toNearest = function(e, t) {
  var r = this, n = r.constructor;
  if (r = new n(r), e == null) {
    if (!r.d)
      return r;
    e = new n(1), t = n.rounding;
  } else {
    if (e = new n(e), t === void 0 ? t = n.rounding : Dn(t, 0, 8), !r.d)
      return e.s ? r : e;
    if (!e.d)
      return e.s && (e.s = r.s), e;
  }
  return e.d[0] ? (At = !1, r = rr(r, e, 0, t, 1).times(e), At = !0, dt(r)) : (e.s = r.s, r = e), r;
};
Ne.toNumber = function() {
  return +this;
};
Ne.toOctal = function(e, t) {
  return p1(this, 8, e, t);
};
Ne.toPower = Ne.pow = function(e) {
  var t, r, n, i, s, o, a = this, c = a.constructor, u = +(e = new c(e));
  if (!a.d || !e.d || !a.d[0] || !e.d[0])
    return new c(Ur(+a, u));
  if (a = new c(a), a.eq(1))
    return a;
  if (n = c.precision, s = c.rounding, e.eq(1))
    return dt(a, n, s);
  if (t = pn(e.e / wt), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= bz)
    return i = N5(c, a, r, n), e.s < 0 ? new c(1).div(i) : dt(i, n, s);
  if (o = a.s, o < 0) {
    if (t < e.d.length - 1)
      return new c(NaN);
    if (e.d[t] & 1 || (o = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
      return a.s = o, a;
  }
  return r = Ur(+a, u), t = r == 0 || !isFinite(r) ? pn(u * (Math.log("0." + rn(a.d)) / Math.LN10 + a.e + 1)) : new c(r + "").e, t > c.maxE + 1 || t < c.minE - 1 ? new c(t > 0 ? o / 0 : 0) : (At = !1, c.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = nm(e.times(Eo(a, n + r)), n), i.d && (i = dt(i, n + 5, 1), Nu(i.d, n, s) && (t = n + 10, i = dt(nm(e.times(Eo(a, t + r)), t), t + 5, 1), +rn(i.d).slice(n + 1, n + 15) + 1 == 1e14 && (i = dt(i, n + 1, 0)))), i.s = o, At = !0, c.rounding = s, dt(i, n, s));
};
Ne.toPrecision = function(e, t) {
  var r, n = this, i = n.constructor;
  return e === void 0 ? r = us(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (Dn(e, 1, Uo), t === void 0 ? t = i.rounding : Dn(t, 0, 8), n = dt(new i(n), e, t), r = us(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
};
Ne.toSignificantDigits = Ne.toSD = function(e, t) {
  var r = this, n = r.constructor;
  return e === void 0 ? (e = n.precision, t = n.rounding) : (Dn(e, 1, Uo), t === void 0 ? t = n.rounding : Dn(t, 0, 8)), dt(new n(r), e, t);
};
Ne.toString = function() {
  var e = this, t = e.constructor, r = us(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() && !e.isZero() ? "-" + r : r;
};
Ne.truncated = Ne.trunc = function() {
  return dt(new this.constructor(this), this.e + 1, 1);
};
Ne.valueOf = Ne.toJSON = function() {
  var e = this, t = e.constructor, r = us(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
  return e.isNeg() ? "-" + r : r;
};
function rn(e) {
  var t, r, n, i = e.length - 1, s = "", o = e[0];
  if (i > 0) {
    for (s += o, t = 1; t < i; t++)
      n = e[t] + "", r = wt - n.length, r && (s += mo(r)), s += n;
    o = e[t], n = o + "", r = wt - n.length, r && (s += mo(r));
  } else if (o === 0)
    return "0";
  for (; o % 10 === 0; )
    o /= 10;
  return s + o;
}
function Dn(e, t, r) {
  if (e !== ~~e || e < t || e > r)
    throw Error(Po + e);
}
function Nu(e, t, r, n) {
  var i, s, o, a;
  for (s = e[0]; s >= 10; s /= 10)
    --t;
  return --t < 0 ? (t += wt, i = 0) : (i = Math.ceil((t + 1) / wt), t %= wt), s = Ur(10, wt - t), a = e[i] % s | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), o = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 5e4 || a == 0) : o = (r < 4 && a + 1 == s || r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 100 | 0) == Ur(10, t - 2) - 1 || (a == s / 2 || a == 0) && (e[i + 1] / s / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1e3 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), o = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : o = ((n || r < 4) && a + 1 == s || !n && r > 3 && a + 1 == s / 2) && (e[i + 1] / s / 1e3 | 0) == Ur(10, t - 3) - 1, o;
}
function vf(e, t, r) {
  for (var n, i = [0], s, o = 0, a = e.length; o < a; ) {
    for (s = i.length; s--; )
      i[s] *= t;
    for (i[0] += em.indexOf(e.charAt(o++)), n = 0; n < i.length; n++)
      i[n] > r - 1 && (i[n + 1] === void 0 && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
  }
  return i.reverse();
}
function _z(e, t) {
  var r, n, i;
  if (t.isZero())
    return t;
  n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Zd(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = bc(e, 1, t.times(i), new e(1));
  for (var s = r; s--; ) {
    var o = t.times(t);
    t = o.times(o).minus(o).times(8).plus(1);
  }
  return e.precision -= r, t;
}
var rr = function() {
  function e(n, i, s) {
    var o, a = 0, c = n.length;
    for (n = n.slice(); c--; )
      o = n[c] * i + a, n[c] = o % s | 0, a = o / s | 0;
    return a && n.unshift(a), n;
  }
  function t(n, i, s, o) {
    var a, c;
    if (s != o)
      c = s > o ? 1 : -1;
    else
      for (a = c = 0; a < s; a++)
        if (n[a] != i[a]) {
          c = n[a] > i[a] ? 1 : -1;
          break;
        }
    return c;
  }
  function r(n, i, s, o) {
    for (var a = 0; s--; )
      n[s] -= a, a = n[s] < i[s] ? 1 : 0, n[s] = a * o + n[s] - i[s];
    for (; !n[0] && n.length > 1; )
      n.shift();
  }
  return function(n, i, s, o, a, c) {
    var u, l, f, h, v, b, y, S, C, O, I, U, D, H, z, ne, le, te, ce, V, L = n.constructor, p = n.s == i.s ? 1 : -1, d = n.d, m = i.d;
    if (!d || !d[0] || !m || !m[0])
      return new L(
        // Return NaN if either NaN, or both Infinity or 0.
        !n.s || !i.s || (d ? m && d[0] == m[0] : !m) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          d && d[0] == 0 || !m ? p * 0 : p / 0
        )
      );
    for (c ? (v = 1, l = n.e - i.e) : (c = Oi, v = wt, l = pn(n.e / v) - pn(i.e / v)), ce = m.length, le = d.length, C = new L(p), O = C.d = [], f = 0; m[f] == (d[f] || 0); f++)
      ;
    if (m[f] > (d[f] || 0) && l--, s == null ? (H = s = L.precision, o = L.rounding) : a ? H = s + (n.e - i.e) + 1 : H = s, H < 0)
      O.push(1), b = !0;
    else {
      if (H = H / v + 2 | 0, f = 0, ce == 1) {
        for (h = 0, m = m[0], H++; (f < le || h) && H--; f++)
          z = h * c + (d[f] || 0), O[f] = z / m | 0, h = z % m | 0;
        b = h || f < le;
      } else {
        for (h = c / (m[0] + 1) | 0, h > 1 && (m = e(m, h, c), d = e(d, h, c), ce = m.length, le = d.length), ne = ce, I = d.slice(0, ce), U = I.length; U < ce; )
          I[U++] = 0;
        V = m.slice(), V.unshift(0), te = m[0], m[1] >= c / 2 && ++te;
        do
          h = 0, u = t(m, I, ce, U), u < 0 ? (D = I[0], ce != U && (D = D * c + (I[1] || 0)), h = D / te | 0, h > 1 ? (h >= c && (h = c - 1), y = e(m, h, c), S = y.length, U = I.length, u = t(y, I, S, U), u == 1 && (h--, r(y, ce < S ? V : m, S, c))) : (h == 0 && (u = h = 1), y = m.slice()), S = y.length, S < U && y.unshift(0), r(I, y, U, c), u == -1 && (U = I.length, u = t(m, I, ce, U), u < 1 && (h++, r(I, ce < U ? V : m, U, c))), U = I.length) : u === 0 && (h++, I = [0]), O[f++] = h, u && I[0] ? I[U++] = d[ne] || 0 : (I = [d[ne]], U = 1);
        while ((ne++ < le || I[0] !== void 0) && H--);
        b = I[0] !== void 0;
      }
      O[0] || O.shift();
    }
    if (v == 1)
      C.e = l, O5 = b;
    else {
      for (f = 1, h = O[0]; h >= 10; h /= 10)
        f++;
      C.e = f + l * v - 1, dt(C, a ? s + C.e + 1 : s, o, b);
    }
    return C;
  };
}();
function dt(e, t, r, n) {
  var i, s, o, a, c, u, l, f, h, v = e.constructor;
  e:
    if (t != null) {
      if (f = e.d, !f)
        return e;
      for (i = 1, a = f[0]; a >= 10; a /= 10)
        i++;
      if (s = t - i, s < 0)
        s += wt, o = t, l = f[h = 0], c = l / Ur(10, i - o - 1) % 10 | 0;
      else if (h = Math.ceil((s + 1) / wt), a = f.length, h >= a)
        if (n) {
          for (; a++ <= h; )
            f.push(0);
          l = c = 0, i = 1, s %= wt, o = s - wt + 1;
        } else
          break e;
      else {
        for (l = a = f[h], i = 1; a >= 10; a /= 10)
          i++;
        s %= wt, o = s - wt + i, c = o < 0 ? 0 : l / Ur(10, i - o - 1) % 10 | 0;
      }
      if (n = n || t < 0 || f[h + 1] !== void 0 || (o < 0 ? l : l % Ur(10, i - o - 1)), u = r < 4 ? (c || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : c > 5 || c == 5 && (r == 4 || n || r == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (s > 0 ? o > 0 ? l / Ur(10, i - o) : 0 : f[h - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !f[0])
        return f.length = 0, u ? (t -= e.e + 1, f[0] = Ur(10, (wt - t % wt) % wt), e.e = -t || 0) : f[0] = e.e = 0, e;
      if (s == 0 ? (f.length = h, a = 1, h--) : (f.length = h + 1, a = Ur(10, wt - s), f[h] = o > 0 ? (l / Ur(10, i - o) % Ur(10, o) | 0) * a : 0), u)
        for (; ; )
          if (h == 0) {
            for (s = 1, o = f[0]; o >= 10; o /= 10)
              s++;
            for (o = f[0] += a, a = 1; o >= 10; o /= 10)
              a++;
            s != a && (e.e++, f[0] == Oi && (f[0] = 1));
            break;
          } else {
            if (f[h] += a, f[h] != Oi)
              break;
            f[h--] = 0, a = 1;
          }
      for (s = f.length; f[--s] === 0; )
        f.pop();
    }
  return At && (e.e > v.maxE ? (e.d = null, e.e = NaN) : e.e < v.minE && (e.e = 0, e.d = [0])), e;
}
function us(e, t, r) {
  if (!e.isFinite())
    return D5(e);
  var n, i = e.e, s = rn(e.d), o = s.length;
  return t ? (r && (n = r - o) > 0 ? s = s.charAt(0) + "." + s.slice(1) + mo(n) : o > 1 && (s = s.charAt(0) + "." + s.slice(1)), s = s + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (s = "0." + mo(-i - 1) + s, r && (n = r - o) > 0 && (s += mo(n))) : i >= o ? (s += mo(i + 1 - o), r && (n = r - i - 1) > 0 && (s = s + "." + mo(n))) : ((n = i + 1) < o && (s = s.slice(0, n) + "." + s.slice(n)), r && (n = r - o) > 0 && (i + 1 === o && (s += "."), s += mo(n))), s;
}
function Jd(e, t) {
  var r = e[0];
  for (t *= wt; r >= 10; r /= 10)
    t++;
  return t;
}
function ad(e, t, r) {
  if (t > wz)
    throw At = !0, r && (e.precision = r), Error(I5);
  return dt(new e(sd), t, 1, !0);
}
function es(e, t, r) {
  if (t > rm)
    throw Error(I5);
  return dt(new e(od), t, r, !0);
}
function P5(e) {
  var t = e.length - 1, r = t * wt + 1;
  if (t = e[t], t) {
    for (; t % 10 == 0; t /= 10)
      r--;
    for (t = e[0]; t >= 10; t /= 10)
      r++;
  }
  return r;
}
function mo(e) {
  for (var t = ""; e--; )
    t += "0";
  return t;
}
function N5(e, t, r, n) {
  var i, s = new e(1), o = Math.ceil(n / wt + 4);
  for (At = !1; ; ) {
    if (r % 2 && (s = s.times(t), cb(s.d, o) && (i = !0)), r = pn(r / 2), r === 0) {
      r = s.d.length - 1, i && s.d[r] === 0 && ++s.d[r];
      break;
    }
    t = t.times(t), cb(t.d, o);
  }
  return At = !0, s;
}
function ab(e) {
  return e.d[e.d.length - 1] & 1;
}
function $5(e, t, r) {
  for (var n, i, s = new e(t[0]), o = 0; ++o < t.length; ) {
    if (i = new e(t[o]), !i.s) {
      s = i;
      break;
    }
    n = s.cmp(i), (n === r || n === 0 && s.s === r) && (s = i);
  }
  return s;
}
function nm(e, t) {
  var r, n, i, s, o, a, c, u = 0, l = 0, f = 0, h = e.constructor, v = h.rounding, b = h.precision;
  if (!e.d || !e.d[0] || e.e > 17)
    return new h(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
  for (t == null ? (At = !1, c = b) : c = t, a = new h(0.03125); e.e > -2; )
    e = e.times(a), f += 5;
  for (n = Math.log(Ur(2, f)) / Math.LN10 * 2 + 5 | 0, c += n, r = s = o = new h(1), h.precision = c; ; ) {
    if (s = dt(s.times(e), c, 1), r = r.times(++l), a = o.plus(rr(s, r, c, 1)), rn(a.d).slice(0, c) === rn(o.d).slice(0, c)) {
      for (i = f; i--; )
        o = dt(o.times(o), c, 1);
      if (t == null)
        if (u < 3 && Nu(o.d, c - n, v, u))
          h.precision = c += 10, r = s = a = new h(1), l = 0, u++;
        else
          return dt(o, h.precision = b, v, At = !0);
      else
        return h.precision = b, o;
    }
    o = a;
  }
}
function Eo(e, t) {
  var r, n, i, s, o, a, c, u, l, f, h, v = 1, b = 10, y = e, S = y.d, C = y.constructor, O = C.rounding, I = C.precision;
  if (y.s < 0 || !S || !S[0] || !y.e && S[0] == 1 && S.length == 1)
    return new C(S && !S[0] ? -1 / 0 : y.s != 1 ? NaN : S ? 0 : y);
  if (t == null ? (At = !1, l = I) : l = t, C.precision = l += b, r = rn(S), n = r.charAt(0), Math.abs(s = y.e) < 15e14) {
    for (; n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
      y = y.times(e), r = rn(y.d), n = r.charAt(0), v++;
    s = y.e, n > 1 ? (y = new C("0." + r), s++) : y = new C(n + "." + r.slice(1));
  } else
    return u = ad(C, l + 2, I).times(s + ""), y = Eo(new C(n + "." + r.slice(1)), l - b).plus(u), C.precision = I, t == null ? dt(y, I, O, At = !0) : y;
  for (f = y, c = o = y = rr(y.minus(1), y.plus(1), l, 1), h = dt(y.times(y), l, 1), i = 3; ; ) {
    if (o = dt(o.times(h), l, 1), u = c.plus(rr(o, new C(i), l, 1)), rn(u.d).slice(0, l) === rn(c.d).slice(0, l))
      if (c = c.times(2), s !== 0 && (c = c.plus(ad(C, l + 2, I).times(s + ""))), c = rr(c, new C(v), l, 1), t == null)
        if (Nu(c.d, l - b, O, a))
          C.precision = l += b, u = o = y = rr(f.minus(1), f.plus(1), l, 1), h = dt(y.times(y), l, 1), i = a = 1;
        else
          return dt(c, C.precision = I, O, At = !0);
      else
        return C.precision = I, c;
    c = u, i += 2;
  }
}
function D5(e) {
  return String(e.s * e.s / 0);
}
function bf(e, t) {
  var r, n, i;
  for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; t.charCodeAt(n) === 48; n++)
    ;
  for (i = t.length; t.charCodeAt(i - 1) === 48; --i)
    ;
  if (t = t.slice(n, i), t) {
    if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % wt, r < 0 && (n += wt), n < i) {
      for (n && e.d.push(+t.slice(0, n)), i -= wt; n < i; )
        e.d.push(+t.slice(n, n += wt));
      t = t.slice(n), n = wt - t.length;
    } else
      n -= i;
    for (; n--; )
      t += "0";
    e.d.push(+t), At && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
  } else
    e.e = 0, e.d = [0];
  return e;
}
function xz(e, t) {
  var r, n, i, s, o, a, c, u, l;
  if (t.indexOf("_") > -1) {
    if (t = t.replace(/(\d)_(?=\d)/g, "$1"), R5.test(t))
      return bf(e, t);
  } else if (t === "Infinity" || t === "NaN")
    return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
  if (yz.test(t))
    r = 16, t = t.toLowerCase();
  else if (gz.test(t))
    r = 2;
  else if (vz.test(t))
    r = 8;
  else
    throw Error(Po + t);
  for (s = t.search(/p/i), s > 0 ? (c = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), s = t.indexOf("."), o = s >= 0, n = e.constructor, o && (t = t.replace(".", ""), a = t.length, s = a - s, i = N5(n, new n(r), s, s * 2)), u = vf(t, r, Oi), l = u.length - 1, s = l; u[s] === 0; --s)
    u.pop();
  return s < 0 ? new n(e.s * 0) : (e.e = Jd(u, l), e.d = u, At = !1, o && (e = rr(e, i, a * 4)), c && (e = e.times(Math.abs(c) < 54 ? Ur(2, c) : nn.pow(2, c))), At = !0, e);
}
function Sz(e, t) {
  var r, n = t.d.length;
  if (n < 3)
    return t.isZero() ? t : bc(e, 2, t, t);
  r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Zd(5, r)), t = bc(e, 2, t, t);
  for (var i, s = new e(5), o = new e(16), a = new e(20); r--; )
    i = t.times(t), t = t.times(s.plus(i.times(o.times(i).minus(a))));
  return t;
}
function bc(e, t, r, n, i) {
  var s, o, a, c, u = e.precision, l = Math.ceil(u / wt);
  for (At = !1, c = r.times(r), a = new e(n); ; ) {
    if (o = rr(a.times(c), new e(t++ * t++), u, 1), a = i ? n.plus(o) : n.minus(o), n = rr(o.times(c), new e(t++ * t++), u, 1), o = a.plus(n), o.d[l] !== void 0) {
      for (s = l; o.d[s] === a.d[s] && s--; )
        ;
      if (s == -1)
        break;
    }
    s = a, a = n, n = o, o = s;
  }
  return At = !0, o.d.length = l + 1, o;
}
function Zd(e, t) {
  for (var r = e; --t; )
    r *= e;
  return r;
}
function L5(e, t) {
  var r, n = t.s < 0, i = es(e, e.precision, 1), s = i.times(0.5);
  if (t = t.abs(), t.lte(s))
    return $s = n ? 4 : 1, t;
  if (r = t.divToInt(i), r.isZero())
    $s = n ? 3 : 2;
  else {
    if (t = t.minus(r.times(i)), t.lte(s))
      return $s = ab(r) ? n ? 2 : 3 : n ? 4 : 1, t;
    $s = ab(r) ? n ? 1 : 4 : n ? 3 : 2;
  }
  return t.minus(i).abs();
}
function p1(e, t, r, n) {
  var i, s, o, a, c, u, l, f, h, v = e.constructor, b = r !== void 0;
  if (b ? (Dn(r, 1, Uo), n === void 0 ? n = v.rounding : Dn(n, 0, 8)) : (r = v.precision, n = v.rounding), !e.isFinite())
    l = D5(e);
  else {
    for (l = us(e), o = l.indexOf("."), b ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, o >= 0 && (l = l.replace(".", ""), h = new v(1), h.e = l.length - o, h.d = vf(us(h), 10, i), h.e = h.d.length), f = vf(l, 10, i), s = c = f.length; f[--c] == 0; )
      f.pop();
    if (!f[0])
      l = b ? "0p+0" : "0";
    else {
      if (o < 0 ? s-- : (e = new v(e), e.d = f, e.e = s, e = rr(e, h, r, n, 0, i), f = e.d, s = e.e, u = O5), o = f[r], a = i / 2, u = u || f[r + 1] !== void 0, u = n < 4 ? (o !== void 0 || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : o > a || o === a && (n === 4 || u || n === 6 && f[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), f.length = r, u)
        for (; ++f[--r] > i - 1; )
          f[r] = 0, r || (++s, f.unshift(1));
      for (c = f.length; !f[c - 1]; --c)
        ;
      for (o = 0, l = ""; o < c; o++)
        l += em.charAt(f[o]);
      if (b) {
        if (c > 1)
          if (t == 16 || t == 8) {
            for (o = t == 16 ? 4 : 3, --c; c % o; c++)
              l += "0";
            for (f = vf(l, i, t), c = f.length; !f[c - 1]; --c)
              ;
            for (o = 1, l = "1."; o < c; o++)
              l += em.charAt(f[o]);
          } else
            l = l.charAt(0) + "." + l.slice(1);
        l = l + (s < 0 ? "p" : "p+") + s;
      } else if (s < 0) {
        for (; ++s; )
          l = "0" + l;
        l = "0." + l;
      } else if (++s > c)
        for (s -= c; s--; )
          l += "0";
      else
        s < c && (l = l.slice(0, s) + "." + l.slice(s));
    }
    l = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + l;
  }
  return e.s < 0 ? "-" + l : l;
}
function cb(e, t) {
  if (e.length > t)
    return e.length = t, !0;
}
function Ez(e) {
  return new this(e).abs();
}
function Tz(e) {
  return new this(e).acos();
}
function Cz(e) {
  return new this(e).acosh();
}
function Az(e, t) {
  return new this(e).plus(t);
}
function Mz(e) {
  return new this(e).asin();
}
function Oz(e) {
  return new this(e).asinh();
}
function Iz(e) {
  return new this(e).atan();
}
function kz(e) {
  return new this(e).atanh();
}
function jz(e, t) {
  e = new this(e), t = new this(t);
  var r, n = this.precision, i = this.rounding, s = n + 4;
  return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = es(this, s, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? es(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = es(this, s, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = s, this.rounding = 1, r = this.atan(rr(e, t, s, 1)), t = es(this, s, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(rr(e, t, s, 1)), r;
}
function Rz(e) {
  return new this(e).cbrt();
}
function Pz(e) {
  return dt(e = new this(e), e.e + 1, 2);
}
function Nz(e, t, r) {
  return new this(e).clamp(t, r);
}
function $z(e) {
  if (!e || typeof e != "object")
    throw Error(Xd + "Object expected");
  var t, r, n, i = e.defaults === !0, s = [
    "precision",
    1,
    Uo,
    "rounding",
    0,
    8,
    "toExpNeg",
    -ic,
    0,
    "toExpPos",
    0,
    ic,
    "maxE",
    0,
    ic,
    "minE",
    -ic,
    0,
    "modulo",
    0,
    9
  ];
  for (t = 0; t < s.length; t += 3)
    if (r = s[t], i && (this[r] = tm[r]), (n = e[r]) !== void 0)
      if (pn(n) === n && n >= s[t + 1] && n <= s[t + 2])
        this[r] = n;
      else
        throw Error(Po + r + ": " + n);
  if (r = "crypto", i && (this[r] = tm[r]), (n = e[r]) !== void 0)
    if (n === !0 || n === !1 || n === 0 || n === 1)
      if (n)
        if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
          this[r] = !0;
        else
          throw Error(k5);
      else
        this[r] = !1;
    else
      throw Error(Po + r + ": " + n);
  return this;
}
function Dz(e) {
  return new this(e).cos();
}
function Lz(e) {
  return new this(e).cosh();
}
function B5(e) {
  var t, r, n;
  function i(s) {
    var o, a, c, u = this;
    if (!(u instanceof i))
      return new i(s);
    if (u.constructor = i, ub(s)) {
      u.s = s.s, At ? !s.d || s.e > i.maxE ? (u.e = NaN, u.d = null) : s.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s.e, u.d = s.d.slice()) : (u.e = s.e, u.d = s.d ? s.d.slice() : s.d);
      return;
    }
    if (c = typeof s, c === "number") {
      if (s === 0) {
        u.s = 1 / s < 0 ? -1 : 1, u.e = 0, u.d = [0];
        return;
      }
      if (s < 0 ? (s = -s, u.s = -1) : u.s = 1, s === ~~s && s < 1e7) {
        for (o = 0, a = s; a >= 10; a /= 10)
          o++;
        At ? o > i.maxE ? (u.e = NaN, u.d = null) : o < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o, u.d = [s]) : (u.e = o, u.d = [s]);
        return;
      }
      if (s * 0 !== 0) {
        s || (u.s = NaN), u.e = NaN, u.d = null;
        return;
      }
      return bf(u, s.toString());
    }
    if (c === "string")
      return (a = s.charCodeAt(0)) === 45 ? (s = s.slice(1), u.s = -1) : (a === 43 && (s = s.slice(1)), u.s = 1), R5.test(s) ? bf(u, s) : xz(u, s);
    if (c === "bigint")
      return s < 0 ? (s = -s, u.s = -1) : u.s = 1, bf(u, s.toString());
    throw Error(Po + s);
  }
  if (i.prototype = Ne, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = $z, i.clone = B5, i.isDecimal = ub, i.abs = Ez, i.acos = Tz, i.acosh = Cz, i.add = Az, i.asin = Mz, i.asinh = Oz, i.atan = Iz, i.atanh = kz, i.atan2 = jz, i.cbrt = Rz, i.ceil = Pz, i.clamp = Nz, i.cos = Dz, i.cosh = Lz, i.div = Bz, i.exp = Uz, i.floor = Fz, i.hypot = Vz, i.ln = zz, i.log = Wz, i.log10 = Hz, i.log2 = qz, i.max = Gz, i.min = Kz, i.mod = Yz, i.mul = Xz, i.pow = Jz, i.random = Zz, i.round = Qz, i.sign = eW, i.sin = tW, i.sinh = rW, i.sqrt = nW, i.sub = iW, i.sum = sW, i.tan = oW, i.tanh = aW, i.trunc = cW, e === void 0 && (e = {}), e && e.defaults !== !0)
    for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0; t < n.length; )
      e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
  return i.config(e), i;
}
function Bz(e, t) {
  return new this(e).div(t);
}
function Uz(e) {
  return new this(e).exp();
}
function Fz(e) {
  return dt(e = new this(e), e.e + 1, 3);
}
function Vz() {
  var e, t, r = new this(0);
  for (At = !1, e = 0; e < arguments.length; )
    if (t = new this(arguments[e++]), t.d)
      r.d && (r = r.plus(t.times(t)));
    else {
      if (t.s)
        return At = !0, new this(1 / 0);
      r = t;
    }
  return At = !0, r.sqrt();
}
function ub(e) {
  return e instanceof nn || e && e.toStringTag === j5 || !1;
}
function zz(e) {
  return new this(e).ln();
}
function Wz(e, t) {
  return new this(e).log(t);
}
function qz(e) {
  return new this(e).log(2);
}
function Hz(e) {
  return new this(e).log(10);
}
function Gz() {
  return $5(this, arguments, -1);
}
function Kz() {
  return $5(this, arguments, 1);
}
function Yz(e, t) {
  return new this(e).mod(t);
}
function Xz(e, t) {
  return new this(e).mul(t);
}
function Jz(e, t) {
  return new this(e).pow(t);
}
function Zz(e) {
  var t, r, n, i, s = 0, o = new this(1), a = [];
  if (e === void 0 ? e = this.precision : Dn(e, 1, Uo), n = Math.ceil(e / wt), this.crypto)
    if (crypto.getRandomValues)
      for (t = crypto.getRandomValues(new Uint32Array(n)); s < n; )
        i = t[s], i >= 429e7 ? t[s] = crypto.getRandomValues(new Uint32Array(1))[0] : a[s++] = i % 1e7;
    else if (crypto.randomBytes) {
      for (t = crypto.randomBytes(n *= 4); s < n; )
        i = t[s] + (t[s + 1] << 8) + (t[s + 2] << 16) + ((t[s + 3] & 127) << 24), i >= 214e7 ? crypto.randomBytes(4).copy(t, s) : (a.push(i % 1e7), s += 4);
      s = n / 4;
    } else
      throw Error(k5);
  else
    for (; s < n; )
      a[s++] = Math.random() * 1e7 | 0;
  for (n = a[--s], e %= wt, n && e && (i = Ur(10, wt - e), a[s] = (n / i | 0) * i); a[s] === 0; s--)
    a.pop();
  if (s < 0)
    r = 0, a = [0];
  else {
    for (r = -1; a[0] === 0; r -= wt)
      a.shift();
    for (n = 1, i = a[0]; i >= 10; i /= 10)
      n++;
    n < wt && (r -= wt - n);
  }
  return o.e = r, o.d = a, o;
}
function Qz(e) {
  return dt(e = new this(e), e.e + 1, this.rounding);
}
function eW(e) {
  return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
}
function tW(e) {
  return new this(e).sin();
}
function rW(e) {
  return new this(e).sinh();
}
function nW(e) {
  return new this(e).sqrt();
}
function iW(e, t) {
  return new this(e).sub(t);
}
function sW() {
  var e = 0, t = arguments, r = new this(t[e]);
  for (At = !1; r.s && ++e < t.length; )
    r = r.plus(t[e]);
  return At = !0, dt(r, this.precision, this.rounding);
}
function oW(e) {
  return new this(e).tan();
}
function aW(e) {
  return new this(e).tanh();
}
function cW(e) {
  return dt(e = new this(e), e.e + 1, 1);
}
Ne[Symbol.for("nodejs.util.inspect.custom")] = Ne.toString;
Ne[Symbol.toStringTag] = "Decimal";
var nn = Ne.constructor = B5(tm);
sd = new nn(sd);
od = new nn(od);
nn.config({
  precision: 256,
  rounding: nn.ROUND_DOWN,
  toExpNeg: -256,
  toExpPos: 256
});
const jn = (e, t, r, n = nn.ROUND_HALF_DOWN) => {
  if (e === "")
    return "";
  if (e !== "0" && !e || Ue(e).equals(0))
    return "0";
  if (t !== void 0) {
    const u = lo(e, t, n);
    if (!Ue(u).equals(0))
      return r ? u : No(u);
  }
  const i = Ue(e).toString(), s = i.split("."), o = s[0], a = s[1];
  let c;
  if (Ue(o).gt(0))
    !a || Ue(o.length).gte(9) ? c = lo(i, 0, n) : Ue(o.length).gte(4) ? c = lo(i, 2, n) : c = lo(i, 4, n);
  else {
    lo(i, 6, n);
    const u = F5(a);
    if (u < 6)
      c = lo(i, u + 6, n);
    else {
      if (u > 30)
        return "0";
      c = lo(i, 9 + (u - 6), n);
    }
  }
  return r || Ue(o).lt(1) ? c : No(c);
}, U5 = (e, t, r, n) => {
  try {
    if (e === void 0 || e === "--")
      return "$--";
    const i = jn(
      e,
      t,
      !0,
      nn.ROUND_DOWN
    ).toString();
    if (Ue(i).equals(0))
      return "$0";
    const s = i.startsWith("-");
    let o = n ? i : No(i).toString();
    return o.includes("e") && (o = n ? i : No(i).toString()), !r && Number(i) < Math.pow(10, -t) ? s ? `-$${o.slice(1)}` : `<$${Math.pow(10, -t).toFixed(t)}` : s ? `-$${o.slice(1)}` : `$${o}`;
  } catch {
    return "$--";
  }
}, uW = (e, t, r = !0) => {
  if (`${e}` == "0")
    return !parseFloat(t) || !r ? "0" : "0.".padEnd(t + 2, "0");
  if (!e)
    return "--";
  const n = parseFloat(e), i = e.toString(), s = n < 0;
  let o = i;
  if (i.toLowerCase().includes("e")) {
    const a = i.match(/(\d+?)(?:\.(\d*))?e([+-])(\d+)/), c = a[1], u = a[2], l = a[3], f = a[4];
    let h = "", v = u ? u.substr(f) : "";
    if (v && (v = `.${v}`), l !== "-") {
      for (let b = 0; b < f; b += 1) {
        const y = u[b] || "0";
        h += y;
      }
      o = c + h + v;
    } else {
      let b = "0";
      for (let y = 0; y < f; y += 1)
        h = (c[c.length - y - 1] || "0") + h;
      c.length > f && (b = c.substr(0, c.length - f)), o = `${b}.${h}${u}`;
    }
  }
  if (t && r) {
    let a = `${o.split(".")[0]}.`;
    const c = o.split(".")[1] || "";
    for (let u = 0; u < t; u += 1)
      a += c[u] || "0";
    o = a;
  }
  if (o.length > 14) {
    const a = o.split(".");
    a[0].length > 14 ? o = `${a[0].slice(0, 14)}+` : (o = o.slice(0, 13), o.indexOf(".") === 12 && (o = o.slice(0, 12)));
  }
  return `${s ? "-" : ""}${o}`;
}, lW = (e, t = 2) => {
  if (e === "")
    return "";
  if (e !== "0" && !e)
    return "0";
  if (Ue(e).gte(0.01))
    return e;
  if (e = z5(e.toString(), t), Ue(e).equals(0))
    return "0";
  const r = Ue(e).toString(), i = r.split(".")[1], s = F5(i);
  return lo(r, s + t, nn.ROUND_HALF_DOWN);
}, fW = (e) => `${Ue(e).mul(100).toString()}%`, Ue = (e) => nn.isDecimal(e) ? e : new nn(
  typeof e > "u" || e === "undefined" || !e ? 0 : e
);
function dW(e, t) {
  return t === void 0 ? "" : Ue(e == null ? void 0 : e.toString()).div(Math.pow(10, t)).toString();
}
const lo = (e, t, r) => Ue(e).toDP(t, r).toString(), wf = (e, t) => {
  try {
    return Ue(e).toDP(t, nn.ROUND_DOWN).toString();
  } catch {
    return String(e);
  }
}, No = (e) => {
  const [t, r] = e.split(".");
  let n = "";
  for (let i = t.length - 1, s = 0; i >= 0; i--, s++)
    n = t[i] + n, s % 3 === 2 && i !== 0 && (n = "," + n);
  return r ? `${n}.${r}` : n;
};
function F5(e) {
  let t = 0;
  if (e)
    for (; t < e.length; ) {
      if (Ue(e[t]).gt(0))
        return t + 1;
      t++;
    }
  return 0;
}
function hW(e, t) {
  const r = V5(Ue(t));
  return Number(Ue(e).mul(r));
}
function pW(e, t) {
  const r = V5(Ue(t));
  return Number(Ue(e).div(r));
}
function V5(e) {
  return Ue(10).pow(Ue(e).abs());
}
function im(e, t) {
  const r = pW(e, t);
  return z5(r.toString(), Number(t));
}
function z5(e, t = 9) {
  if (e === void 0)
    return "";
  const r = e.toLowerCase();
  if (r.includes("e")) {
    if (r.includes("+"))
      return uW(r, t);
    const [n, i] = r.split("e");
    let s = n;
    const o = Math.abs(parseInt(i, 10));
    let a = "", c = s.length;
    if (n.includes(".")) {
      const [u, l] = n.split(".");
      s = u + l, c = u.length;
    }
    for (let u = 0; u < o - c; u++)
      a += "0";
    return `0.${a}${s}`.slice(0, t + 2);
  }
  return e;
}
function Qd(e) {
  e.stopPropagation(), e.nativeEvent.stopImmediatePropagation();
}
const xa = (e, t = "") => t == "long" ? e && e.length > 40 ? e.substring(0, 40) + "..." : e && e.length < 40 ? e : "" : e ? e.substring(0, 6) + "..." + e.substring(e.length - 4) : "", m1 = (e, t) => {
  if (e === t)
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (const i of r)
    if (!m1(e[i], t[i]))
      return !1;
  return !0;
};
function lb(e) {
  return !e || Object.keys(e).length === 0;
}
function W5(e) {
  var t;
  return ((t = e.split("::")) == null ? void 0 : t.length) === 3;
}
const fb = async (e) => new Promise((t) => {
  setTimeout(() => {
    t(1);
  }, e);
});
function mW(e, t, r = !1) {
  var a;
  const n = e.balanceChanges, i = (a = e.effects) == null ? void 0 : a.gasUsed, s = {};
  let o = "0";
  return i && (o = Ue(i.computationCost).add(i.storageCost).sub(i.storageRebate).mul(-1).toFixed(0)), n && n.forEach((c) => {
    const u = ga(c.coinType).full_address;
    if (c.owner.AddressOwner === t) {
      const l = ga(u).full_address === Id;
      let f = c.amount;
      l && (f = r ? f : Ue(f).sub(o).toFixed(0));
      const h = {
        coinType: u,
        amount: f
      };
      s[u] = h;
    }
  }), s;
}
function db(e, t) {
  if (t) {
    const r = e[ga(t.coin_type).full_address];
    if (r)
      return im(
        Ue(r.amount).abs().toFixed(0),
        t.decimals
      );
  }
}
function Lt(e) {
  return `https://archive.cetus.zone/assets/terminal${e}`;
}
const sn = (e, t = 10) => e && (e == null ? void 0 : e.length) > t && Ue(t).gt(0) ? `${e.slice(0, t)}...` : e, Rl = (e, t) => Hs(e || "") === Hs(t || ""), gW = (e) => e === null || typeof e != "object" || Array.isArray(e) ? !1 : Object.keys(e).length > 0;
function hb(e) {
  return ga(e).source_address;
}
function _f(e) {
  if (e.length === 0)
    return e;
  const t = e.filter((c) => c > 0);
  if (t.length === 0)
    return e;
  const r = t.map((c) => Math.round(c));
  let n = r.reduce((c, u) => c + u, 0);
  if (n === 100)
    return r;
  if (n < 100) {
    const c = 100 - n, u = Math.max(...r), f = r.reduce((h, v, b) => (v === u && h.push(b), h), [])[0];
    return r[f] += c, r;
  }
  let i = n;
  const s = 1e3;
  let o = 0;
  for (; i > 100 && o < s; ) {
    o++;
    const c = i - 100;
    let u = -1 / 0;
    const l = [];
    if (r.forEach((S, C) => {
      S > u ? (u = S, l.length = 0, l.push(C)) : S === u && l.push(C);
    }), u <= 0)
      break;
    const f = l.length, h = u * f, v = Math.min(c, h), b = l[0], y = Math.min(v, r[b]);
    r[b] -= y, i -= y;
  }
  const a = r.reduce((c, u) => c + u, 0);
  if (a !== 100) {
    const c = r.findIndex((u) => u > 0);
    c !== -1 && (r[c] += 100 - a);
  }
  return r;
}
function pb(e) {
  var s;
  const t = e.split("::"), r = (s = t[0]) == null ? void 0 : s.trim(), n = r.startsWith("0x") ? r.slice(2) : r;
  if (!/^[0-9a-fA-F]+$/.test(n))
    throw new Error("Invalid Sui address: not a valid hex string");
  return `0x${n.padStart(64, "0")}::${t[1]}::${t[2]}`;
}
const yW = async function(e, t, r = 3e4) {
  const n = [];
  let i = "";
  if (t) {
    for (const c in t) {
      const u = `${c}=${t[c]}`;
      n.push(u);
    }
    const a = n.join("&");
    i = `${e}?${a}`;
  } else
    i = e;
  const s = new AbortController(), o = setTimeout(() => {
    s.abort();
  }, r);
  try {
    const a = await fetch(i, { signal: s.signal });
    if (clearTimeout(o), !a.ok)
      throw new Error("Request failed");
    const c = await a.json();
    return (c == null ? void 0 : c.data) || c;
  } catch (a) {
    throw clearTimeout(o), a.name === "AbortError" ? new Error("request time out") : a;
  }
}, vW = async function(e, t, r = 3e4) {
  const n = new AbortController(), i = setTimeout(() => {
    n.abort();
  }, r);
  try {
    const s = await fetch(e, {
      body: JSON.stringify(t),
      method: "POST",
      signal: n.signal
    });
    if (clearTimeout(i), !s.ok)
      throw new Error("Request failed");
    return s.json();
  } catch (s) {
    throw clearTimeout(i), s.name === "AbortError" ? new Error("request time out") : s;
  }
}, sm = "tokenMap", q5 = "trustedTokenList", H5 = "collectTokenMap", G5 = "importTokenList";
var K5 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(e, t) {
  (function(r) {
    e.exports = r();
  })(function() {
    return function r(n, i, s) {
      function o(u, l) {
        if (!i[u]) {
          if (!n[u]) {
            var f = typeof Yi == "function" && Yi;
            if (!l && f)
              return f(u, !0);
            if (a)
              return a(u, !0);
            var h = new Error("Cannot find module '" + u + "'");
            throw h.code = "MODULE_NOT_FOUND", h;
          }
          var v = i[u] = { exports: {} };
          n[u][0].call(v.exports, function(b) {
            var y = n[u][1][b];
            return o(y || b);
          }, v, v.exports, r, n, i, s);
        }
        return i[u].exports;
      }
      for (var a = typeof Yi == "function" && Yi, c = 0; c < s.length; c++)
        o(s[c]);
      return o;
    }({ 1: [function(r, n, i) {
      (function(s) {
        var o = s.MutationObserver || s.WebKitMutationObserver, a;
        if (o) {
          var c = 0, u = new o(b), l = s.document.createTextNode("");
          u.observe(l, {
            characterData: !0
          }), a = function() {
            l.data = c = ++c % 2;
          };
        } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
          var f = new s.MessageChannel();
          f.port1.onmessage = b, a = function() {
            f.port2.postMessage(0);
          };
        } else
          "document" in s && "onreadystatechange" in s.document.createElement("script") ? a = function() {
            var S = s.document.createElement("script");
            S.onreadystatechange = function() {
              b(), S.onreadystatechange = null, S.parentNode.removeChild(S), S = null;
            }, s.document.documentElement.appendChild(S);
          } : a = function() {
            setTimeout(b, 0);
          };
        var h, v = [];
        function b() {
          h = !0;
          for (var S, C, O = v.length; O; ) {
            for (C = v, v = [], S = -1; ++S < O; )
              C[S]();
            O = v.length;
          }
          h = !1;
        }
        n.exports = y;
        function y(S) {
          v.push(S) === 1 && !h && a();
        }
      }).call(this, typeof Yr < "u" ? Yr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 2: [function(r, n, i) {
      var s = r(1);
      function o() {
      }
      var a = {}, c = ["REJECTED"], u = ["FULFILLED"], l = ["PENDING"];
      n.exports = f;
      function f(D) {
        if (typeof D != "function")
          throw new TypeError("resolver must be a function");
        this.state = l, this.queue = [], this.outcome = void 0, D !== o && y(this, D);
      }
      f.prototype.catch = function(D) {
        return this.then(null, D);
      }, f.prototype.then = function(D, H) {
        if (typeof D != "function" && this.state === u || typeof H != "function" && this.state === c)
          return this;
        var z = new this.constructor(o);
        if (this.state !== l) {
          var ne = this.state === u ? D : H;
          v(z, ne, this.outcome);
        } else
          this.queue.push(new h(z, D, H));
        return z;
      };
      function h(D, H, z) {
        this.promise = D, typeof H == "function" && (this.onFulfilled = H, this.callFulfilled = this.otherCallFulfilled), typeof z == "function" && (this.onRejected = z, this.callRejected = this.otherCallRejected);
      }
      h.prototype.callFulfilled = function(D) {
        a.resolve(this.promise, D);
      }, h.prototype.otherCallFulfilled = function(D) {
        v(this.promise, this.onFulfilled, D);
      }, h.prototype.callRejected = function(D) {
        a.reject(this.promise, D);
      }, h.prototype.otherCallRejected = function(D) {
        v(this.promise, this.onRejected, D);
      };
      function v(D, H, z) {
        s(function() {
          var ne;
          try {
            ne = H(z);
          } catch (le) {
            return a.reject(D, le);
          }
          ne === D ? a.reject(D, new TypeError("Cannot resolve promise with itself")) : a.resolve(D, ne);
        });
      }
      a.resolve = function(D, H) {
        var z = S(b, H);
        if (z.status === "error")
          return a.reject(D, z.value);
        var ne = z.value;
        if (ne)
          y(D, ne);
        else {
          D.state = u, D.outcome = H;
          for (var le = -1, te = D.queue.length; ++le < te; )
            D.queue[le].callFulfilled(H);
        }
        return D;
      }, a.reject = function(D, H) {
        D.state = c, D.outcome = H;
        for (var z = -1, ne = D.queue.length; ++z < ne; )
          D.queue[z].callRejected(H);
        return D;
      };
      function b(D) {
        var H = D && D.then;
        if (D && (typeof D == "object" || typeof D == "function") && typeof H == "function")
          return function() {
            H.apply(D, arguments);
          };
      }
      function y(D, H) {
        var z = !1;
        function ne(V) {
          z || (z = !0, a.reject(D, V));
        }
        function le(V) {
          z || (z = !0, a.resolve(D, V));
        }
        function te() {
          H(le, ne);
        }
        var ce = S(te);
        ce.status === "error" && ne(ce.value);
      }
      function S(D, H) {
        var z = {};
        try {
          z.value = D(H), z.status = "success";
        } catch (ne) {
          z.status = "error", z.value = ne;
        }
        return z;
      }
      f.resolve = C;
      function C(D) {
        return D instanceof this ? D : a.resolve(new this(o), D);
      }
      f.reject = O;
      function O(D) {
        var H = new this(o);
        return a.reject(H, D);
      }
      f.all = I;
      function I(D) {
        var H = this;
        if (Object.prototype.toString.call(D) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var z = D.length, ne = !1;
        if (!z)
          return this.resolve([]);
        for (var le = new Array(z), te = 0, ce = -1, V = new this(o); ++ce < z; )
          L(D[ce], ce);
        return V;
        function L(p, d) {
          H.resolve(p).then(m, function(x) {
            ne || (ne = !0, a.reject(V, x));
          });
          function m(x) {
            le[d] = x, ++te === z && !ne && (ne = !0, a.resolve(V, le));
          }
        }
      }
      f.race = U;
      function U(D) {
        var H = this;
        if (Object.prototype.toString.call(D) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var z = D.length, ne = !1;
        if (!z)
          return this.resolve([]);
        for (var le = -1, te = new this(o); ++le < z; )
          ce(D[le]);
        return te;
        function ce(V) {
          H.resolve(V).then(function(L) {
            ne || (ne = !0, a.resolve(te, L));
          }, function(L) {
            ne || (ne = !0, a.reject(te, L));
          });
        }
      }
    }, { 1: 1 }], 3: [function(r, n, i) {
      (function(s) {
        typeof s.Promise != "function" && (s.Promise = r(2));
      }).call(this, typeof Yr < "u" ? Yr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { 2: 2 }], 4: [function(r, n, i) {
      var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(W) {
        return typeof W;
      } : function(W) {
        return W && typeof Symbol == "function" && W.constructor === Symbol && W !== Symbol.prototype ? "symbol" : typeof W;
      };
      function o(W, oe) {
        if (!(W instanceof oe))
          throw new TypeError("Cannot call a class as a function");
      }
      function a() {
        try {
          if (typeof indexedDB < "u")
            return indexedDB;
          if (typeof webkitIndexedDB < "u")
            return webkitIndexedDB;
          if (typeof mozIndexedDB < "u")
            return mozIndexedDB;
          if (typeof OIndexedDB < "u")
            return OIndexedDB;
          if (typeof msIndexedDB < "u")
            return msIndexedDB;
        } catch {
          return;
        }
      }
      var c = a();
      function u() {
        try {
          if (!c || !c.open)
            return !1;
          var W = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), oe = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!W || oe) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange < "u";
        } catch {
          return !1;
        }
      }
      function l(W, oe) {
        W = W || [], oe = oe || {};
        try {
          return new Blob(W, oe);
        } catch (pe) {
          if (pe.name !== "TypeError")
            throw pe;
          for (var J = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, ge = new J(), be = 0; be < W.length; be += 1)
            ge.append(W[be]);
          return ge.getBlob(oe.type);
        }
      }
      typeof Promise > "u" && r(3);
      var f = Promise;
      function h(W, oe) {
        oe && W.then(function(J) {
          oe(null, J);
        }, function(J) {
          oe(J);
        });
      }
      function v(W, oe, J) {
        typeof oe == "function" && W.then(oe), typeof J == "function" && W.catch(J);
      }
      function b(W) {
        return typeof W != "string" && (console.warn(W + " used as a key, but it is not a string."), W = String(W)), W;
      }
      function y() {
        if (arguments.length && typeof arguments[arguments.length - 1] == "function")
          return arguments[arguments.length - 1];
      }
      var S = "local-forage-detect-blob-support", C = void 0, O = {}, I = Object.prototype.toString, U = "readonly", D = "readwrite";
      function H(W) {
        for (var oe = W.length, J = new ArrayBuffer(oe), ge = new Uint8Array(J), be = 0; be < oe; be++)
          ge[be] = W.charCodeAt(be);
        return J;
      }
      function z(W) {
        return new f(function(oe) {
          var J = W.transaction(S, D), ge = l([""]);
          J.objectStore(S).put(ge, "key"), J.onabort = function(be) {
            be.preventDefault(), be.stopPropagation(), oe(!1);
          }, J.oncomplete = function() {
            var be = navigator.userAgent.match(/Chrome\/(\d+)/), pe = navigator.userAgent.match(/Edge\//);
            oe(pe || !be || parseInt(be[1], 10) >= 43);
          };
        }).catch(function() {
          return !1;
        });
      }
      function ne(W) {
        return typeof C == "boolean" ? f.resolve(C) : z(W).then(function(oe) {
          return C = oe, C;
        });
      }
      function le(W) {
        var oe = O[W.name], J = {};
        J.promise = new f(function(ge, be) {
          J.resolve = ge, J.reject = be;
        }), oe.deferredOperations.push(J), oe.dbReady ? oe.dbReady = oe.dbReady.then(function() {
          return J.promise;
        }) : oe.dbReady = J.promise;
      }
      function te(W) {
        var oe = O[W.name], J = oe.deferredOperations.pop();
        if (J)
          return J.resolve(), J.promise;
      }
      function ce(W, oe) {
        var J = O[W.name], ge = J.deferredOperations.pop();
        if (ge)
          return ge.reject(oe), ge.promise;
      }
      function V(W, oe) {
        return new f(function(J, ge) {
          if (O[W.name] = O[W.name] || g(), W.db)
            if (oe)
              le(W), W.db.close();
            else
              return J(W.db);
          var be = [W.name];
          oe && be.push(W.version);
          var pe = c.open.apply(c, be);
          oe && (pe.onupgradeneeded = function(ke) {
            var $e = pe.result;
            try {
              $e.createObjectStore(W.storeName), ke.oldVersion <= 1 && $e.createObjectStore(S);
            } catch (De) {
              if (De.name === "ConstraintError")
                console.warn('The database "' + W.name + '" has been upgraded from version ' + ke.oldVersion + " to version " + ke.newVersion + ', but the storage "' + W.storeName + '" already exists.');
              else
                throw De;
            }
          }), pe.onerror = function(ke) {
            ke.preventDefault(), ge(pe.error);
          }, pe.onsuccess = function() {
            var ke = pe.result;
            ke.onversionchange = function($e) {
              $e.target.close();
            }, J(ke), te(W);
          };
        });
      }
      function L(W) {
        return V(W, !1);
      }
      function p(W) {
        return V(W, !0);
      }
      function d(W, oe) {
        if (!W.db)
          return !0;
        var J = !W.db.objectStoreNames.contains(W.storeName), ge = W.version < W.db.version, be = W.version > W.db.version;
        if (ge && (W.version !== oe && console.warn('The database "' + W.name + `" can't be downgraded from version ` + W.db.version + " to version " + W.version + "."), W.version = W.db.version), be || J) {
          if (J) {
            var pe = W.db.version + 1;
            pe > W.version && (W.version = pe);
          }
          return !0;
        }
        return !1;
      }
      function m(W) {
        return new f(function(oe, J) {
          var ge = new FileReader();
          ge.onerror = J, ge.onloadend = function(be) {
            var pe = btoa(be.target.result || "");
            oe({
              __local_forage_encoded_blob: !0,
              data: pe,
              type: W.type
            });
          }, ge.readAsBinaryString(W);
        });
      }
      function x(W) {
        var oe = H(atob(W.data));
        return l([oe], { type: W.type });
      }
      function E(W) {
        return W && W.__local_forage_encoded_blob;
      }
      function A(W) {
        var oe = this, J = oe._initReady().then(function() {
          var ge = O[oe._dbInfo.name];
          if (ge && ge.dbReady)
            return ge.dbReady;
        });
        return v(J, W, W), J;
      }
      function j(W) {
        le(W);
        for (var oe = O[W.name], J = oe.forages, ge = 0; ge < J.length; ge++) {
          var be = J[ge];
          be._dbInfo.db && (be._dbInfo.db.close(), be._dbInfo.db = null);
        }
        return W.db = null, L(W).then(function(pe) {
          return W.db = pe, d(W) ? p(W) : pe;
        }).then(function(pe) {
          W.db = oe.db = pe;
          for (var ke = 0; ke < J.length; ke++)
            J[ke]._dbInfo.db = pe;
        }).catch(function(pe) {
          throw ce(W, pe), pe;
        });
      }
      function k(W, oe, J, ge) {
        ge === void 0 && (ge = 1);
        try {
          var be = W.db.transaction(W.storeName, oe);
          J(null, be);
        } catch (pe) {
          if (ge > 0 && (!W.db || pe.name === "InvalidStateError" || pe.name === "NotFoundError"))
            return f.resolve().then(function() {
              if (!W.db || pe.name === "NotFoundError" && !W.db.objectStoreNames.contains(W.storeName) && W.version <= W.db.version)
                return W.db && (W.version = W.db.version + 1), p(W);
            }).then(function() {
              return j(W).then(function() {
                k(W, oe, J, ge - 1);
              });
            }).catch(J);
          J(pe);
        }
      }
      function g() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function w(W) {
        var oe = this, J = {
          db: null
        };
        if (W)
          for (var ge in W)
            J[ge] = W[ge];
        var be = O[J.name];
        be || (be = g(), O[J.name] = be), be.forages.push(oe), oe._initReady || (oe._initReady = oe.ready, oe.ready = A);
        var pe = [];
        function ke() {
          return f.resolve();
        }
        for (var $e = 0; $e < be.forages.length; $e++) {
          var De = be.forages[$e];
          De !== oe && pe.push(De._initReady().catch(ke));
        }
        var Le = be.forages.slice(0);
        return f.all(pe).then(function() {
          return J.db = be.db, L(J);
        }).then(function(ze) {
          return J.db = ze, d(J, oe._defaultConfig.version) ? p(J) : ze;
        }).then(function(ze) {
          J.db = be.db = ze, oe._dbInfo = J;
          for (var at = 0; at < Le.length; at++) {
            var Ut = Le[at];
            Ut !== oe && (Ut._dbInfo.db = J.db, Ut._dbInfo.version = J.version);
          }
        });
      }
      function P(W, oe) {
        var J = this;
        W = b(W);
        var ge = new f(function(be, pe) {
          J.ready().then(function() {
            k(J._dbInfo, U, function(ke, $e) {
              if (ke)
                return pe(ke);
              try {
                var De = $e.objectStore(J._dbInfo.storeName), Le = De.get(W);
                Le.onsuccess = function() {
                  var ze = Le.result;
                  ze === void 0 && (ze = null), E(ze) && (ze = x(ze)), be(ze);
                }, Le.onerror = function() {
                  pe(Le.error);
                };
              } catch (ze) {
                pe(ze);
              }
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function ue(W, oe) {
        var J = this, ge = new f(function(be, pe) {
          J.ready().then(function() {
            k(J._dbInfo, U, function(ke, $e) {
              if (ke)
                return pe(ke);
              try {
                var De = $e.objectStore(J._dbInfo.storeName), Le = De.openCursor(), ze = 1;
                Le.onsuccess = function() {
                  var at = Le.result;
                  if (at) {
                    var Ut = at.value;
                    E(Ut) && (Ut = x(Ut));
                    var Zt = W(Ut, at.key, ze++);
                    Zt !== void 0 ? be(Zt) : at.continue();
                  } else
                    be();
                }, Le.onerror = function() {
                  pe(Le.error);
                };
              } catch (at) {
                pe(at);
              }
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function ie(W, oe, J) {
        var ge = this;
        W = b(W);
        var be = new f(function(pe, ke) {
          var $e;
          ge.ready().then(function() {
            return $e = ge._dbInfo, I.call(oe) === "[object Blob]" ? ne($e.db).then(function(De) {
              return De ? oe : m(oe);
            }) : oe;
          }).then(function(De) {
            k(ge._dbInfo, D, function(Le, ze) {
              if (Le)
                return ke(Le);
              try {
                var at = ze.objectStore(ge._dbInfo.storeName);
                De === null && (De = void 0);
                var Ut = at.put(De, W);
                ze.oncomplete = function() {
                  De === void 0 && (De = null), pe(De);
                }, ze.onabort = ze.onerror = function() {
                  var Zt = Ut.error ? Ut.error : Ut.transaction.error;
                  ke(Zt);
                };
              } catch (Zt) {
                ke(Zt);
              }
            });
          }).catch(ke);
        });
        return h(be, J), be;
      }
      function fe(W, oe) {
        var J = this;
        W = b(W);
        var ge = new f(function(be, pe) {
          J.ready().then(function() {
            k(J._dbInfo, D, function(ke, $e) {
              if (ke)
                return pe(ke);
              try {
                var De = $e.objectStore(J._dbInfo.storeName), Le = De.delete(W);
                $e.oncomplete = function() {
                  be();
                }, $e.onerror = function() {
                  pe(Le.error);
                }, $e.onabort = function() {
                  var ze = Le.error ? Le.error : Le.transaction.error;
                  pe(ze);
                };
              } catch (ze) {
                pe(ze);
              }
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function ye(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            k(oe._dbInfo, D, function(pe, ke) {
              if (pe)
                return be(pe);
              try {
                var $e = ke.objectStore(oe._dbInfo.storeName), De = $e.clear();
                ke.oncomplete = function() {
                  ge();
                }, ke.onabort = ke.onerror = function() {
                  var Le = De.error ? De.error : De.transaction.error;
                  be(Le);
                };
              } catch (Le) {
                be(Le);
              }
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function Te(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            k(oe._dbInfo, U, function(pe, ke) {
              if (pe)
                return be(pe);
              try {
                var $e = ke.objectStore(oe._dbInfo.storeName), De = $e.count();
                De.onsuccess = function() {
                  ge(De.result);
                }, De.onerror = function() {
                  be(De.error);
                };
              } catch (Le) {
                be(Le);
              }
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function N(W, oe) {
        var J = this, ge = new f(function(be, pe) {
          if (W < 0) {
            be(null);
            return;
          }
          J.ready().then(function() {
            k(J._dbInfo, U, function(ke, $e) {
              if (ke)
                return pe(ke);
              try {
                var De = $e.objectStore(J._dbInfo.storeName), Le = !1, ze = De.openKeyCursor();
                ze.onsuccess = function() {
                  var at = ze.result;
                  if (!at) {
                    be(null);
                    return;
                  }
                  W === 0 || Le ? be(at.key) : (Le = !0, at.advance(W));
                }, ze.onerror = function() {
                  pe(ze.error);
                };
              } catch (at) {
                pe(at);
              }
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function F(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            k(oe._dbInfo, U, function(pe, ke) {
              if (pe)
                return be(pe);
              try {
                var $e = ke.objectStore(oe._dbInfo.storeName), De = $e.openKeyCursor(), Le = [];
                De.onsuccess = function() {
                  var ze = De.result;
                  if (!ze) {
                    ge(Le);
                    return;
                  }
                  Le.push(ze.key), ze.continue();
                }, De.onerror = function() {
                  be(De.error);
                };
              } catch (ze) {
                be(ze);
              }
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function G(W, oe) {
        oe = y.apply(this, arguments);
        var J = this.config();
        W = typeof W != "function" && W || {}, W.name || (W.name = W.name || J.name, W.storeName = W.storeName || J.storeName);
        var ge = this, be;
        if (!W.name)
          be = f.reject("Invalid arguments");
        else {
          var pe = W.name === J.name && ge._dbInfo.db, ke = pe ? f.resolve(ge._dbInfo.db) : L(W).then(function($e) {
            var De = O[W.name], Le = De.forages;
            De.db = $e;
            for (var ze = 0; ze < Le.length; ze++)
              Le[ze]._dbInfo.db = $e;
            return $e;
          });
          W.storeName ? be = ke.then(function($e) {
            if ($e.objectStoreNames.contains(W.storeName)) {
              var De = $e.version + 1;
              le(W);
              var Le = O[W.name], ze = Le.forages;
              $e.close();
              for (var at = 0; at < ze.length; at++) {
                var Ut = ze[at];
                Ut._dbInfo.db = null, Ut._dbInfo.version = De;
              }
              var Zt = new f(function(Qt, Or) {
                var Er = c.open(W.name, De);
                Er.onerror = function(Hn) {
                  var Vc = Er.result;
                  Vc.close(), Or(Hn);
                }, Er.onupgradeneeded = function() {
                  var Hn = Er.result;
                  Hn.deleteObjectStore(W.storeName);
                }, Er.onsuccess = function() {
                  var Hn = Er.result;
                  Hn.close(), Qt(Hn);
                };
              });
              return Zt.then(function(Qt) {
                Le.db = Qt;
                for (var Or = 0; Or < ze.length; Or++) {
                  var Er = ze[Or];
                  Er._dbInfo.db = Qt, te(Er._dbInfo);
                }
              }).catch(function(Qt) {
                throw (ce(W, Qt) || f.resolve()).catch(function() {
                }), Qt;
              });
            }
          }) : be = ke.then(function($e) {
            le(W);
            var De = O[W.name], Le = De.forages;
            $e.close();
            for (var ze = 0; ze < Le.length; ze++) {
              var at = Le[ze];
              at._dbInfo.db = null;
            }
            var Ut = new f(function(Zt, Qt) {
              var Or = c.deleteDatabase(W.name);
              Or.onerror = function() {
                var Er = Or.result;
                Er && Er.close(), Qt(Or.error);
              }, Or.onblocked = function() {
                console.warn('dropInstance blocked for database "' + W.name + '" until all open connections are closed');
              }, Or.onsuccess = function() {
                var Er = Or.result;
                Er && Er.close(), Zt(Er);
              };
            });
            return Ut.then(function(Zt) {
              De.db = Zt;
              for (var Qt = 0; Qt < Le.length; Qt++) {
                var Or = Le[Qt];
                te(Or._dbInfo);
              }
            }).catch(function(Zt) {
              throw (ce(W, Zt) || f.resolve()).catch(function() {
              }), Zt;
            });
          });
        }
        return h(be, oe), be;
      }
      var ee = {
        _driver: "asyncStorage",
        _initStorage: w,
        _support: u(),
        iterate: ue,
        getItem: P,
        setItem: ie,
        removeItem: fe,
        clear: ye,
        length: Te,
        key: N,
        keys: F,
        dropInstance: G
      };
      function Z() {
        return typeof openDatabase == "function";
      }
      var q = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", he = "~~local_forage_type~", Y = /^~~local_forage_type~([^~]+)~/, X = "__lfsc__:", B = X.length, se = "arbf", me = "blob", de = "si08", xe = "ui08", Oe = "uic8", Be = "si16", Xe = "si32", Re = "ur16", He = "ui32", rt = "fl32", Qe = "fl64", Ot = B + se.length, $t = Object.prototype.toString;
      function Ge(W) {
        var oe = W.length * 0.75, J = W.length, ge, be = 0, pe, ke, $e, De;
        W[W.length - 1] === "=" && (oe--, W[W.length - 2] === "=" && oe--);
        var Le = new ArrayBuffer(oe), ze = new Uint8Array(Le);
        for (ge = 0; ge < J; ge += 4)
          pe = q.indexOf(W[ge]), ke = q.indexOf(W[ge + 1]), $e = q.indexOf(W[ge + 2]), De = q.indexOf(W[ge + 3]), ze[be++] = pe << 2 | ke >> 4, ze[be++] = (ke & 15) << 4 | $e >> 2, ze[be++] = ($e & 3) << 6 | De & 63;
        return Le;
      }
      function ht(W) {
        var oe = new Uint8Array(W), J = "", ge;
        for (ge = 0; ge < oe.length; ge += 3)
          J += q[oe[ge] >> 2], J += q[(oe[ge] & 3) << 4 | oe[ge + 1] >> 4], J += q[(oe[ge + 1] & 15) << 2 | oe[ge + 2] >> 6], J += q[oe[ge + 2] & 63];
        return oe.length % 3 === 2 ? J = J.substring(0, J.length - 1) + "=" : oe.length % 3 === 1 && (J = J.substring(0, J.length - 2) + "=="), J;
      }
      function ct(W, oe) {
        var J = "";
        if (W && (J = $t.call(W)), W && (J === "[object ArrayBuffer]" || W.buffer && $t.call(W.buffer) === "[object ArrayBuffer]")) {
          var ge, be = X;
          W instanceof ArrayBuffer ? (ge = W, be += se) : (ge = W.buffer, J === "[object Int8Array]" ? be += de : J === "[object Uint8Array]" ? be += xe : J === "[object Uint8ClampedArray]" ? be += Oe : J === "[object Int16Array]" ? be += Be : J === "[object Uint16Array]" ? be += Re : J === "[object Int32Array]" ? be += Xe : J === "[object Uint32Array]" ? be += He : J === "[object Float32Array]" ? be += rt : J === "[object Float64Array]" ? be += Qe : oe(new Error("Failed to get type for BinaryArray"))), oe(be + ht(ge));
        } else if (J === "[object Blob]") {
          var pe = new FileReader();
          pe.onload = function() {
            var ke = he + W.type + "~" + ht(this.result);
            oe(X + me + ke);
          }, pe.readAsArrayBuffer(W);
        } else
          try {
            oe(JSON.stringify(W));
          } catch (ke) {
            console.error("Couldn't convert value into a JSON string: ", W), oe(null, ke);
          }
      }
      function et(W) {
        if (W.substring(0, B) !== X)
          return JSON.parse(W);
        var oe = W.substring(Ot), J = W.substring(B, Ot), ge;
        if (J === me && Y.test(oe)) {
          var be = oe.match(Y);
          ge = be[1], oe = oe.substring(be[0].length);
        }
        var pe = Ge(oe);
        switch (J) {
          case se:
            return pe;
          case me:
            return l([pe], { type: ge });
          case de:
            return new Int8Array(pe);
          case xe:
            return new Uint8Array(pe);
          case Oe:
            return new Uint8ClampedArray(pe);
          case Be:
            return new Int16Array(pe);
          case Re:
            return new Uint16Array(pe);
          case Xe:
            return new Int32Array(pe);
          case He:
            return new Uint32Array(pe);
          case rt:
            return new Float32Array(pe);
          case Qe:
            return new Float64Array(pe);
          default:
            throw new Error("Unkown type: " + J);
        }
      }
      var st = {
        serialize: ct,
        deserialize: et,
        stringToBuffer: Ge,
        bufferToString: ht
      };
      function yt(W, oe, J, ge) {
        W.executeSql("CREATE TABLE IF NOT EXISTS " + oe.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], J, ge);
      }
      function it(W) {
        var oe = this, J = {
          db: null
        };
        if (W)
          for (var ge in W)
            J[ge] = typeof W[ge] != "string" ? W[ge].toString() : W[ge];
        var be = new f(function(pe, ke) {
          try {
            J.db = openDatabase(J.name, String(J.version), J.description, J.size);
          } catch ($e) {
            return ke($e);
          }
          J.db.transaction(function($e) {
            yt($e, J, function() {
              oe._dbInfo = J, pe();
            }, function(De, Le) {
              ke(Le);
            });
          }, ke);
        });
        return J.serializer = st, be;
      }
      function vt(W, oe, J, ge, be, pe) {
        W.executeSql(J, ge, be, function(ke, $e) {
          $e.code === $e.SYNTAX_ERR ? ke.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [oe.storeName], function(De, Le) {
            Le.rows.length ? pe(De, $e) : yt(De, oe, function() {
              De.executeSql(J, ge, be, pe);
            }, pe);
          }, pe) : pe(ke, $e);
        }, pe);
      }
      function Dt(W, oe) {
        var J = this;
        W = b(W);
        var ge = new f(function(be, pe) {
          J.ready().then(function() {
            var ke = J._dbInfo;
            ke.db.transaction(function($e) {
              vt($e, ke, "SELECT * FROM " + ke.storeName + " WHERE key = ? LIMIT 1", [W], function(De, Le) {
                var ze = Le.rows.length ? Le.rows.item(0).value : null;
                ze && (ze = ke.serializer.deserialize(ze)), be(ze);
              }, function(De, Le) {
                pe(Le);
              });
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function pt(W, oe) {
        var J = this, ge = new f(function(be, pe) {
          J.ready().then(function() {
            var ke = J._dbInfo;
            ke.db.transaction(function($e) {
              vt($e, ke, "SELECT * FROM " + ke.storeName, [], function(De, Le) {
                for (var ze = Le.rows, at = ze.length, Ut = 0; Ut < at; Ut++) {
                  var Zt = ze.item(Ut), Qt = Zt.value;
                  if (Qt && (Qt = ke.serializer.deserialize(Qt)), Qt = W(Qt, Zt.key, Ut + 1), Qt !== void 0) {
                    be(Qt);
                    return;
                  }
                }
                be();
              }, function(De, Le) {
                pe(Le);
              });
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function It(W, oe, J, ge) {
        var be = this;
        W = b(W);
        var pe = new f(function(ke, $e) {
          be.ready().then(function() {
            oe === void 0 && (oe = null);
            var De = oe, Le = be._dbInfo;
            Le.serializer.serialize(oe, function(ze, at) {
              at ? $e(at) : Le.db.transaction(function(Ut) {
                vt(Ut, Le, "INSERT OR REPLACE INTO " + Le.storeName + " (key, value) VALUES (?, ?)", [W, ze], function() {
                  ke(De);
                }, function(Zt, Qt) {
                  $e(Qt);
                });
              }, function(Ut) {
                if (Ut.code === Ut.QUOTA_ERR) {
                  if (ge > 0) {
                    ke(It.apply(be, [W, De, J, ge - 1]));
                    return;
                  }
                  $e(Ut);
                }
              });
            });
          }).catch($e);
        });
        return h(pe, J), pe;
      }
      function Vt(W, oe, J) {
        return It.apply(this, [W, oe, J, 1]);
      }
      function Ke(W, oe) {
        var J = this;
        W = b(W);
        var ge = new f(function(be, pe) {
          J.ready().then(function() {
            var ke = J._dbInfo;
            ke.db.transaction(function($e) {
              vt($e, ke, "DELETE FROM " + ke.storeName + " WHERE key = ?", [W], function() {
                be();
              }, function(De, Le) {
                pe(Le);
              });
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function Rt(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            var pe = oe._dbInfo;
            pe.db.transaction(function(ke) {
              vt(ke, pe, "DELETE FROM " + pe.storeName, [], function() {
                ge();
              }, function($e, De) {
                be(De);
              });
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function zt(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            var pe = oe._dbInfo;
            pe.db.transaction(function(ke) {
              vt(ke, pe, "SELECT COUNT(key) as c FROM " + pe.storeName, [], function($e, De) {
                var Le = De.rows.item(0).c;
                ge(Le);
              }, function($e, De) {
                be(De);
              });
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function $(W, oe) {
        var J = this, ge = new f(function(be, pe) {
          J.ready().then(function() {
            var ke = J._dbInfo;
            ke.db.transaction(function($e) {
              vt($e, ke, "SELECT key FROM " + ke.storeName + " WHERE id = ? LIMIT 1", [W + 1], function(De, Le) {
                var ze = Le.rows.length ? Le.rows.item(0).key : null;
                be(ze);
              }, function(De, Le) {
                pe(Le);
              });
            });
          }).catch(pe);
        });
        return h(ge, oe), ge;
      }
      function T(W) {
        var oe = this, J = new f(function(ge, be) {
          oe.ready().then(function() {
            var pe = oe._dbInfo;
            pe.db.transaction(function(ke) {
              vt(ke, pe, "SELECT key FROM " + pe.storeName, [], function($e, De) {
                for (var Le = [], ze = 0; ze < De.rows.length; ze++)
                  Le.push(De.rows.item(ze).key);
                ge(Le);
              }, function($e, De) {
                be(De);
              });
            });
          }).catch(be);
        });
        return h(J, W), J;
      }
      function M(W) {
        return new f(function(oe, J) {
          W.transaction(function(ge) {
            ge.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(be, pe) {
              for (var ke = [], $e = 0; $e < pe.rows.length; $e++)
                ke.push(pe.rows.item($e).name);
              oe({
                db: W,
                storeNames: ke
              });
            }, function(be, pe) {
              J(pe);
            });
          }, function(ge) {
            J(ge);
          });
        });
      }
      function K(W, oe) {
        oe = y.apply(this, arguments);
        var J = this.config();
        W = typeof W != "function" && W || {}, W.name || (W.name = W.name || J.name, W.storeName = W.storeName || J.storeName);
        var ge = this, be;
        return W.name ? be = new f(function(pe) {
          var ke;
          W.name === J.name ? ke = ge._dbInfo.db : ke = openDatabase(W.name, "", "", 0), W.storeName ? pe({
            db: ke,
            storeNames: [W.storeName]
          }) : pe(M(ke));
        }).then(function(pe) {
          return new f(function(ke, $e) {
            pe.db.transaction(function(De) {
              function Le(Zt) {
                return new f(function(Qt, Or) {
                  De.executeSql("DROP TABLE IF EXISTS " + Zt, [], function() {
                    Qt();
                  }, function(Er, Hn) {
                    Or(Hn);
                  });
                });
              }
              for (var ze = [], at = 0, Ut = pe.storeNames.length; at < Ut; at++)
                ze.push(Le(pe.storeNames[at]));
              f.all(ze).then(function() {
                ke();
              }).catch(function(Zt) {
                $e(Zt);
              });
            }, function(De) {
              $e(De);
            });
          });
        }) : be = f.reject("Invalid arguments"), h(be, oe), be;
      }
      var ae = {
        _driver: "webSQLStorage",
        _initStorage: it,
        _support: Z(),
        iterate: pt,
        getItem: Dt,
        setItem: Vt,
        removeItem: Ke,
        clear: Rt,
        length: zt,
        key: $,
        keys: T,
        dropInstance: K
      };
      function ve() {
        try {
          return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch {
          return !1;
        }
      }
      function we(W, oe) {
        var J = W.name + "/";
        return W.storeName !== oe.storeName && (J += W.storeName + "/"), J;
      }
      function nt() {
        var W = "_localforage_support_test";
        try {
          return localStorage.setItem(W, !0), localStorage.removeItem(W), !1;
        } catch {
          return !0;
        }
      }
      function _t() {
        return !nt() || localStorage.length > 0;
      }
      function tt(W) {
        var oe = this, J = {};
        if (W)
          for (var ge in W)
            J[ge] = W[ge];
        return J.keyPrefix = we(W, oe._defaultConfig), _t() ? (oe._dbInfo = J, J.serializer = st, f.resolve()) : f.reject();
      }
      function Q(W) {
        var oe = this, J = oe.ready().then(function() {
          for (var ge = oe._dbInfo.keyPrefix, be = localStorage.length - 1; be >= 0; be--) {
            var pe = localStorage.key(be);
            pe.indexOf(ge) === 0 && localStorage.removeItem(pe);
          }
        });
        return h(J, W), J;
      }
      function Se(W, oe) {
        var J = this;
        W = b(W);
        var ge = J.ready().then(function() {
          var be = J._dbInfo, pe = localStorage.getItem(be.keyPrefix + W);
          return pe && (pe = be.serializer.deserialize(pe)), pe;
        });
        return h(ge, oe), ge;
      }
      function Ie(W, oe) {
        var J = this, ge = J.ready().then(function() {
          for (var be = J._dbInfo, pe = be.keyPrefix, ke = pe.length, $e = localStorage.length, De = 1, Le = 0; Le < $e; Le++) {
            var ze = localStorage.key(Le);
            if (ze.indexOf(pe) === 0) {
              var at = localStorage.getItem(ze);
              if (at && (at = be.serializer.deserialize(at)), at = W(at, ze.substring(ke), De++), at !== void 0)
                return at;
            }
          }
        });
        return h(ge, oe), ge;
      }
      function Je(W, oe) {
        var J = this, ge = J.ready().then(function() {
          var be = J._dbInfo, pe;
          try {
            pe = localStorage.key(W);
          } catch {
            pe = null;
          }
          return pe && (pe = pe.substring(be.keyPrefix.length)), pe;
        });
        return h(ge, oe), ge;
      }
      function lt(W) {
        var oe = this, J = oe.ready().then(function() {
          for (var ge = oe._dbInfo, be = localStorage.length, pe = [], ke = 0; ke < be; ke++) {
            var $e = localStorage.key(ke);
            $e.indexOf(ge.keyPrefix) === 0 && pe.push($e.substring(ge.keyPrefix.length));
          }
          return pe;
        });
        return h(J, W), J;
      }
      function Ze(W) {
        var oe = this, J = oe.keys().then(function(ge) {
          return ge.length;
        });
        return h(J, W), J;
      }
      function ot(W, oe) {
        var J = this;
        W = b(W);
        var ge = J.ready().then(function() {
          var be = J._dbInfo;
          localStorage.removeItem(be.keyPrefix + W);
        });
        return h(ge, oe), ge;
      }
      function Et(W, oe, J) {
        var ge = this;
        W = b(W);
        var be = ge.ready().then(function() {
          oe === void 0 && (oe = null);
          var pe = oe;
          return new f(function(ke, $e) {
            var De = ge._dbInfo;
            De.serializer.serialize(oe, function(Le, ze) {
              if (ze)
                $e(ze);
              else
                try {
                  localStorage.setItem(De.keyPrefix + W, Le), ke(pe);
                } catch (at) {
                  (at.name === "QuotaExceededError" || at.name === "NS_ERROR_DOM_QUOTA_REACHED") && $e(at), $e(at);
                }
            });
          });
        });
        return h(be, J), be;
      }
      function cr(W, oe) {
        if (oe = y.apply(this, arguments), W = typeof W != "function" && W || {}, !W.name) {
          var J = this.config();
          W.name = W.name || J.name, W.storeName = W.storeName || J.storeName;
        }
        var ge = this, be;
        return W.name ? be = new f(function(pe) {
          W.storeName ? pe(we(W, ge._defaultConfig)) : pe(W.name + "/");
        }).then(function(pe) {
          for (var ke = localStorage.length - 1; ke >= 0; ke--) {
            var $e = localStorage.key(ke);
            $e.indexOf(pe) === 0 && localStorage.removeItem($e);
          }
        }) : be = f.reject("Invalid arguments"), h(be, oe), be;
      }
      var Kt = {
        _driver: "localStorageWrapper",
        _initStorage: tt,
        _support: ve(),
        iterate: Ie,
        getItem: Se,
        setItem: Et,
        removeItem: ot,
        clear: Q,
        length: Ze,
        key: Je,
        keys: lt,
        dropInstance: cr
      }, Jt = function(oe, J) {
        return oe === J || typeof oe == "number" && typeof J == "number" && isNaN(oe) && isNaN(J);
      }, _r = function(oe, J) {
        for (var ge = oe.length, be = 0; be < ge; ) {
          if (Jt(oe[be], J))
            return !0;
          be++;
        }
        return !1;
      }, Jr = Array.isArray || function(W) {
        return Object.prototype.toString.call(W) === "[object Array]";
      }, Sr = {}, ur = {}, Kr = {
        INDEXEDDB: ee,
        WEBSQL: ae,
        LOCALSTORAGE: Kt
      }, li = [Kr.INDEXEDDB._driver, Kr.WEBSQL._driver, Kr.LOCALSTORAGE._driver], Cn = ["dropInstance"], fi = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Cn), ms = {
        description: "",
        driver: li.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function gs(W, oe) {
        W[oe] = function() {
          var J = arguments;
          return W.ready().then(function() {
            return W[oe].apply(W, J);
          });
        };
      }
      function di() {
        for (var W = 1; W < arguments.length; W++) {
          var oe = arguments[W];
          if (oe)
            for (var J in oe)
              oe.hasOwnProperty(J) && (Jr(oe[J]) ? arguments[0][J] = oe[J].slice() : arguments[0][J] = oe[J]);
        }
        return arguments[0];
      }
      var ys = function() {
        function W(oe) {
          o(this, W);
          for (var J in Kr)
            if (Kr.hasOwnProperty(J)) {
              var ge = Kr[J], be = ge._driver;
              this[J] = be, Sr[be] || this.defineDriver(ge);
            }
          this._defaultConfig = di({}, ms), this._config = di({}, this._defaultConfig, oe), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
          });
        }
        return W.prototype.config = function(J) {
          if ((typeof J > "u" ? "undefined" : s(J)) === "object") {
            if (this._ready)
              return new Error("Can't call config() after localforage has been used.");
            for (var ge in J) {
              if (ge === "storeName" && (J[ge] = J[ge].replace(/\W/g, "_")), ge === "version" && typeof J[ge] != "number")
                return new Error("Database version must be a number.");
              this._config[ge] = J[ge];
            }
            return "driver" in J && J.driver ? this.setDriver(this._config.driver) : !0;
          } else
            return typeof J == "string" ? this._config[J] : this._config;
        }, W.prototype.defineDriver = function(J, ge, be) {
          var pe = new f(function(ke, $e) {
            try {
              var De = J._driver, Le = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!J._driver) {
                $e(Le);
                return;
              }
              for (var ze = fi.concat("_initStorage"), at = 0, Ut = ze.length; at < Ut; at++) {
                var Zt = ze[at], Qt = !_r(Cn, Zt);
                if ((Qt || J[Zt]) && typeof J[Zt] != "function") {
                  $e(Le);
                  return;
                }
              }
              var Or = function() {
                for (var Vc = function(FT) {
                  return function() {
                    var VT = new Error("Method " + FT + " is not implemented by the current driver"), cy = f.reject(VT);
                    return h(cy, arguments[arguments.length - 1]), cy;
                  };
                }, jh = 0, UT = Cn.length; jh < UT; jh++) {
                  var Rh = Cn[jh];
                  J[Rh] || (J[Rh] = Vc(Rh));
                }
              };
              Or();
              var Er = function(Vc) {
                Sr[De] && console.info("Redefining LocalForage driver: " + De), Sr[De] = J, ur[De] = Vc, ke();
              };
              "_support" in J ? J._support && typeof J._support == "function" ? J._support().then(Er, $e) : Er(!!J._support) : Er(!0);
            } catch (Hn) {
              $e(Hn);
            }
          });
          return v(pe, ge, be), pe;
        }, W.prototype.driver = function() {
          return this._driver || null;
        }, W.prototype.getDriver = function(J, ge, be) {
          var pe = Sr[J] ? f.resolve(Sr[J]) : f.reject(new Error("Driver not found."));
          return v(pe, ge, be), pe;
        }, W.prototype.getSerializer = function(J) {
          var ge = f.resolve(st);
          return v(ge, J), ge;
        }, W.prototype.ready = function(J) {
          var ge = this, be = ge._driverSet.then(function() {
            return ge._ready === null && (ge._ready = ge._initDriver()), ge._ready;
          });
          return v(be, J, J), be;
        }, W.prototype.setDriver = function(J, ge, be) {
          var pe = this;
          Jr(J) || (J = [J]);
          var ke = this._getSupportedDrivers(J);
          function $e() {
            pe._config.driver = pe.driver();
          }
          function De(at) {
            return pe._extend(at), $e(), pe._ready = pe._initStorage(pe._config), pe._ready;
          }
          function Le(at) {
            return function() {
              var Ut = 0;
              function Zt() {
                for (; Ut < at.length; ) {
                  var Qt = at[Ut];
                  return Ut++, pe._dbInfo = null, pe._ready = null, pe.getDriver(Qt).then(De).catch(Zt);
                }
                $e();
                var Or = new Error("No available storage method found.");
                return pe._driverSet = f.reject(Or), pe._driverSet;
              }
              return Zt();
            };
          }
          var ze = this._driverSet !== null ? this._driverSet.catch(function() {
            return f.resolve();
          }) : f.resolve();
          return this._driverSet = ze.then(function() {
            var at = ke[0];
            return pe._dbInfo = null, pe._ready = null, pe.getDriver(at).then(function(Ut) {
              pe._driver = Ut._driver, $e(), pe._wrapLibraryMethodsWithReady(), pe._initDriver = Le(ke);
            });
          }).catch(function() {
            $e();
            var at = new Error("No available storage method found.");
            return pe._driverSet = f.reject(at), pe._driverSet;
          }), v(this._driverSet, ge, be), this._driverSet;
        }, W.prototype.supports = function(J) {
          return !!ur[J];
        }, W.prototype._extend = function(J) {
          di(this, J);
        }, W.prototype._getSupportedDrivers = function(J) {
          for (var ge = [], be = 0, pe = J.length; be < pe; be++) {
            var ke = J[be];
            this.supports(ke) && ge.push(ke);
          }
          return ge;
        }, W.prototype._wrapLibraryMethodsWithReady = function() {
          for (var J = 0, ge = fi.length; J < ge; J++)
            gs(this, fi[J]);
        }, W.prototype.createInstance = function(J) {
          return new W(J);
        }, W;
      }(), vs = new ys();
      n.exports = vs;
    }, { 3: 3 }] }, {}, [4])(4);
  });
})(K5);
var bW = K5.exports;
const uu = /* @__PURE__ */ Yu(bW);
uu.config({
  name: "CetusSite",
  storeName: "tokens"
});
class Bs {
  // 
  static async setItem(t, r) {
    try {
      await uu.setItem(t, r);
    } catch (n) {
      console.error(`Failed to set item with key "${t}"`, n);
    }
  }
  // 
  static async getItem(t) {
    try {
      return await uu.getItem(t);
    } catch (r) {
      return console.error(`Failed to get item with key "${t}"`, r), null;
    }
  }
  // 
  static async removeItem(t) {
    try {
      await uu.removeItem(t);
    } catch (r) {
      console.error(`Failed to remove item with key "${t}"`, r);
    }
  }
  // 
  static async clear() {
    try {
      await uu.clear();
    } catch (t) {
      console.error("Failed to clear storage", t);
    }
  }
}
const eh = [
  {
    name: "SuiVision",
    link: "https://suivision.xyz",
    img: Lt("/images/logo_suivision@2x.png"),
    isCustom: !1
  },
  {
    name: "Suiscan",
    link: "https://suiscan.xyz/mainnet",
    img: Lt("/images/logo_suiscan@2x.png"),
    isCustom: !1
  }
], wu = [
  {
    name: "Sui Fullnode",
    link: "https://fullnode.mainnet.sui.io",
    isCustom: !1
  },
  // {
  //   name: "Suiet",
  //   link: "https://mainnet.suiet.app:443",
  //   isCustom: false,
  // },
  {
    name: "Custom RPC URL",
    link: "",
    isCustom: !0
  }
], wW = [
  {
    display: "0.1",
    value: "0.001"
  },
  {
    display: "0.5",
    value: "0.005"
  },
  {
    display: "1",
    value: "0.01"
  }
], _W = "mainnet", xW = {
  mainnet: {
    env: "mainnet",
    fullRpcUrl: "https://fullnode.mainnet.sui.io",
    simulationAccount: "0x326ce9894f08dcaa337fa232641cc34db957aec9ff6614c1186bc9a7508df0bb",
    api: "https://api-sui.cetus.zone",
    aggregatorUrl: "https://api-sui.cetus.zone/router_v3"
  }
}, lc = xW[_W], SW = "0x45f3c0814d7be4aa5fbd32d7e3c40f3c062a2b63eaf5ec4f8c1539b5987b11af", EW = Lt("/images/birdeye-logo.png"), TW = Lt("/images/img-logo@2x.png"), CW = Lt("/images/logo_CoinGecko@2x.png"), AW = Lt("/images/logo_pyth.png");
var Y5 = /* @__PURE__ */ ((e) => (e.CETUS = "CETUS", e.KRIYA = "KRIYA", e.KRIYAV3 = "KRIYAV3", e.FLOWX = "FLOWX", e.FLOWXV3 = "FLOWXV3", e.AFTERMATH = "AFTERMATH", e.HAEDAL = "HAEDAL", e.VOLO = "VOLO", e.AFSUI = "AFSUI", e.DEEPBOOKV3 = "DEEPBOOKV3", e.SCALLOP = "SCALLOP", e.BLUEMOVE = "BLUEMOVE", e.TURBOS = "TURBOS", e.SPRINGSUI = "SPRINGSUI", e.BLUEFIN = "BLUEFIN", e.HAEDALPMM = "HAEDALPMM", e.ALPHAFI = "ALPHAFI", e.STEAMM = "STEAMM", e.STEAMM_OMM = "STEAMM_OMM", e.OBRIC = "OBRIC", e.METASTABLE = "METASTABLE", e.MOMENTUM = "MOMENTUM", e.STEAMM_OMM_V2 = "STEAMM_OMM_V2", e.MAGMA = "MAGMA", e.SEVENK = "SEVENK", e.HAWAL = "HAWAL", e.HAEDALHMMV2 = "HAEDALHMMV2", e.FULLSAIL = "FULLSAIL", e))(Y5 || {});
const X5 = {
  pyth: "Pyth Network",
  coingecko: "CoinGecko",
  birdeye: "Birdeye",
  Cetus: "Cetus"
}, MW = {
  pyth: AW,
  coingecko: CW,
  birdeye: EW,
  Cetus: TW
}, Wt = {
  CETUS: Lt("/images/aggregator-source/cetus.png"),
  // DEEPBOOK: '/images/aggregator-source/deepbook.png',
  KRIYA: Lt("/images/aggregator-source/kriya.png"),
  FLOWX: Lt("/images/aggregator-source/flowx.png"),
  AFTERMATH: Lt("/images/aggregator-source/aftermath.png"),
  TURBOS: Lt("/images/aggregator-source/turbos.png"),
  HAEDAL: Lt("/images/aggregator-source/haedal.png"),
  VOLO: Lt("/images/aggregator-source/volo.png"),
  AFSUI: Lt("/images/aggregator-source/aftermath.png"),
  BLUEMOVE: Lt("/images/aggregator-source/bluemove.png"),
  KRIYAV3: Lt("/images/aggregator-source/kriya.png"),
  FLOWXV3: Lt("/images/aggregator-source/flowx.png"),
  DEEPBOOKV3: Lt("/images/aggregator-source/deepbook.png"),
  SCALLOP: Lt("/images/aggregator-source/scallop.png"),
  SPRINGSUI: Lt("/images/aggregator-source/suilend.png"),
  BLUEFIN: Lt("/images/aggregator-source/bluefin.png"),
  HAEDALPMM: Lt("/images/aggregator-source/haedal.png"),
  ALPHAFI: Lt("/images/aggregator-source/stSui.png"),
  STEAMM: Lt("/images/aggregator-source/steamm.png"),
  OBRIC: Lt("/images/aggregator-source/obric.png"),
  METASTABLE: Lt("/images/aggregator-source/metastable.png"),
  MOMENTUM: Lt("/images/aggregator-source/momentum.png"),
  STEAMM_OMM: Lt("/images/aggregator-source/steamm.png"),
  STEAMM_OMM_V2: Lt("/images/aggregator-source/steamm.png"),
  MAGMA: Lt("/images/aggregator-source/magma.png"),
  SEVENK: Lt("/images/aggregator-source/7k.png"),
  HAWAL: Lt("/images/aggregator-source/haedal.png"),
  HAEDALHMMV2: Lt("/images/aggregator-source/haedal.png"),
  FULLSAIL: Lt("/images/aggregator-source/fullsail.png")
}, om = {
  CETUS: {
    name: "Cetus",
    id: "CETUS",
    logo: Wt.CETUS,
    type: "dex",
    sort: 100
  },
  // DeepBook: {
  //   name: 'DeepBook',
  //   id: AggregatorProvider.DEEPBOOK,
  //   logo: AggregatorSourceImg['DEEPBOOK'],
  //   type: 'dex',
  //   sort: 99
  // },
  DEEPBOOKV3: {
    name: "DeepBook V3",
    id: "DEEPBOOKV3",
    logo: Wt.DEEPBOOKV3,
    type: "dex",
    sort: 99
  },
  KRIYA: {
    name: "Kriya V2",
    id: "KRIYA",
    logo: Wt.KRIYA,
    type: "dex",
    sort: 98
  },
  KRIYAV3: {
    name: "Kriya V3",
    id: "KRIYAV3",
    logo: Wt.KRIYA,
    type: "dex",
    sort: 97
  },
  FLOWX: {
    name: "FlowX V2",
    id: "FLOWX",
    logo: Wt.FLOWX,
    type: "dex",
    sort: 96
  },
  FLOWXV3: {
    name: "FlowX V3",
    id: "FLOWXV3",
    logo: Wt.FLOWX,
    type: "dex",
    sort: 95
  },
  AFTERMATH: {
    name: "Aftermath",
    id: "AFTERMATH",
    logo: Wt.AFTERMATH,
    type: "dex",
    sort: 94
  },
  TURBOS: {
    name: "Turbos",
    id: "TURBOS",
    logo: Wt.TURBOS,
    type: "dex",
    sort: 93
  },
  HAEDAL: {
    name: "Haedal LSD",
    id: "HAEDAL",
    logo: Wt.HAEDAL,
    type: "other",
    sort: 92
  },
  HAWAL: {
    name: "Haedal LSD",
    id: "HAWAL",
    logo: Wt.HAEDAL,
    type: "other",
    sort: 90
  },
  HAEDALPMM: {
    name: "Haedal HMM",
    id: "HAEDALPMM",
    logo: Wt.HAEDALPMM,
    type: "other",
    sort: 92
  },
  HAEDALHMMV2: {
    name: "Haedal HMM",
    id: "HAEDALHMMV2",
    logo: Wt.HAEDALHMMV2,
    type: "other",
    sort: 88
  },
  VOLO: {
    name: "Volo",
    id: "VOLO",
    logo: Wt.VOLO,
    type: "other",
    sort: 91
  },
  AFSUI: {
    name: "Aftermath LSD",
    id: "AFSUI",
    logo: Wt.AFTERMATH,
    type: "other",
    sort: 90
  },
  BLUEMOVE: {
    name: "BlueMove",
    id: "BLUEMOVE",
    logo: Wt.BLUEMOVE,
    type: "dex",
    sort: 80
  },
  BLUEFIN: {
    name: "Bluefin",
    id: "BLUEFIN",
    logo: Wt.BLUEFIN,
    sort: 79,
    type: "dex"
  },
  MOMENTUM: {
    name: "Momentum",
    id: "MOMENTUM",
    logo: Wt.MOMENTUM,
    sort: 68,
    type: "dex"
  },
  SCALLOP: {
    name: "Scallop",
    id: "SCALLOP",
    logo: Wt.SCALLOP,
    type: "other",
    sort: 70
  },
  SPRINGSUI: {
    name: "SpringSui",
    id: "SPRINGSUI",
    logo: Wt.SPRINGSUI,
    type: "other",
    sort: 60
  },
  ALPHAFI: {
    name: "stSUI",
    id: "ALPHAFI",
    logo: Wt.ALPHAFI,
    type: "other",
    sort: 50
  },
  STEAMM: {
    name: "STEAMM CPMM",
    id: "STEAMM",
    logo: Wt.STEAMM,
    sort: 76,
    type: "dex"
  },
  STEAMM_OMM: {
    name: "STEAMM OMM",
    id: "STEAMM_OMM",
    logo: Wt.STEAMM_OMM,
    sort: 75,
    type: "dex"
  },
  STEAMM_OMM_V2: {
    name: "STEAMM OMM",
    id: "STEAMM_OMM_V2",
    logo: Wt.STEAMM_OMM_V2,
    sort: 74,
    type: "dex"
  },
  METASTABLE: {
    name: "Metastable",
    id: "METASTABLE",
    logo: Wt.METASTABLE,
    sort: 77,
    type: "dex"
  },
  OBRIC: {
    name: "Obric",
    id: "OBRIC",
    logo: Wt.OBRIC,
    sort: 76,
    type: "dex"
  },
  MAGMA: {
    name: "Magma",
    id: "MAGMA",
    logo: Wt.MAGMA,
    sort: 67,
    type: "dex"
  },
  SEVENK: {
    name: "7K Spot",
    id: "SEVENK",
    logo: Wt.SEVENK,
    sort: 66,
    type: "dex"
  },
  FULLSAIL: {
    name: "Full Sail",
    id: "FULLSAIL",
    logo: Wt.FULLSAIL,
    sort: 65,
    type: "dex"
  }
}, mb = (e) => {
  let t;
  const r = /* @__PURE__ */ new Set(), n = (u, l) => {
    const f = typeof u == "function" ? u(t) : u;
    if (!Object.is(f, t)) {
      const h = t;
      t = l ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), r.forEach((v) => v(t, h));
    }
  }, i = () => t, a = { setState: n, getState: i, getInitialState: () => c, subscribe: (u) => (r.add(u), () => r.delete(u)) }, c = t = e(n, i, a);
  return a;
}, OW = (e) => e ? mb(e) : mb, IW = (e) => e;
function kW(e, t = IW) {
  const r = Fr.useSyncExternalStore(
    e.subscribe,
    Fr.useCallback(() => t(e.getState()), [e, t]),
    Fr.useCallback(() => t(e.getInitialState()), [e, t])
  );
  return Fr.useDebugValue(r), r;
}
const gb = (e) => {
  const t = OW(e), r = (n) => kW(t, n);
  return Object.assign(r, t), r;
}, Qs = (e) => e ? gb(e) : gb;
function jW(e, t) {
  let r;
  try {
    r = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var s;
      const o = (c) => c === null ? null : JSON.parse(c, t == null ? void 0 : t.reviver), a = (s = r.getItem(i)) != null ? s : null;
      return a instanceof Promise ? a.then(o) : o(a);
    },
    setItem: (i, s) => r.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
    removeItem: (i) => r.removeItem(i)
  };
}
const am = (e) => (t) => {
  try {
    const r = e(t);
    return r instanceof Promise ? r : {
      then(n) {
        return am(n)(r);
      },
      catch(n) {
        return this;
      }
    };
  } catch (r) {
    return {
      then(n) {
        return this;
      },
      catch(n) {
        return am(n)(r);
      }
    };
  }
}, RW = (e, t) => (r, n, i) => {
  let s = {
    storage: jW(() => localStorage),
    partialize: (y) => y,
    version: 0,
    merge: (y, S) => ({
      ...S,
      ...y
    }),
    ...t
  }, o = !1;
  const a = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let u = s.storage;
  if (!u)
    return e(
      (...y) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
        ), r(...y);
      },
      n,
      i
    );
  const l = () => {
    const y = s.partialize({ ...n() });
    return u.setItem(s.name, {
      state: y,
      version: s.version
    });
  }, f = i.setState;
  i.setState = (y, S) => (f(y, S), l());
  const h = e(
    (...y) => (r(...y), l()),
    n,
    i
  );
  i.getInitialState = () => h;
  let v;
  const b = () => {
    var y, S;
    if (!u)
      return;
    o = !1, a.forEach((O) => {
      var I;
      return O((I = n()) != null ? I : h);
    });
    const C = ((S = s.onRehydrateStorage) == null ? void 0 : S.call(s, (y = n()) != null ? y : h)) || void 0;
    return am(u.getItem.bind(u))(s.name).then((O) => {
      if (O)
        if (typeof O.version == "number" && O.version !== s.version) {
          if (s.migrate) {
            const I = s.migrate(
              O.state,
              O.version
            );
            return I instanceof Promise ? I.then((U) => [!0, U]) : [!0, I];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, O.state];
      return [!1, void 0];
    }).then((O) => {
      var I;
      const [U, D] = O;
      if (v = s.merge(
        D,
        (I = n()) != null ? I : h
      ), r(v, !0), U)
        return l();
    }).then(() => {
      C == null || C(v, void 0), v = n(), o = !0, c.forEach((O) => O(v));
    }).catch((O) => {
      C == null || C(void 0, O);
    });
  };
  return i.persist = {
    setOptions: (y) => {
      s = {
        ...s,
        ...y
      }, y.storage && (u = y.storage);
    },
    clearStorage: () => {
      u == null || u.removeItem(s.name);
    },
    getOptions: () => s,
    rehydrate: () => b(),
    hasHydrated: () => o,
    onHydrate: (y) => (a.add(y), () => {
      a.delete(y);
    }),
    onFinishHydration: (y) => (c.add(y), () => {
      c.delete(y);
    })
  }, s.skipHydration || b(), v || h;
}, PW = RW, NW = (e, t) => ({
  ignoreWarnTokenMap: {},
  currentExplorer: eh[0].link,
  setCurrentExplorer: (r) => {
    e(() => ({
      currentExplorer: r
    }));
  },
  rpcList: wu,
  setRpcList: (r) => {
    e(() => ({
      rpcList: [...r]
    }));
  },
  currentRpc: wu[0],
  customRpc: "",
  setCurrentRpc: (r) => {
    e(() => ({
      currentRpc: r
    }));
  },
  setCustomRpc: (r) => {
    e(() => ({
      customRpc: r
    }));
  },
  slippage: "0.5",
  setSlippage: (r) => {
    e(() => ({
      slippage: r
    }));
  },
  isOpenSlippageDialog: !1,
  setIsOpenSlippageDialog: (r) => {
    e(() => ({
      isOpenSlippageDialog: r
    }));
  },
  providers: Object.values(Y5),
  setProviders: (r) => {
    e(() => ({
      providers: r
    }));
  },
  poolApiMap: {},
  setPoolApiMap: (r, n) => {
    const i = t().poolApiMap;
    i[r] = n, e(() => ({
      poolApiMap: { ...i }
    }));
  },
  mevProtect: !0,
  setMevProtect: (r) => {
    e(() => ({
      mevProtect: r
    }));
  },
  transactionMode: "Default",
  setTransctionMode: (r) => {
    e(() => ({
      transactionMode: r
    }));
  },
  maxCapForGas: "0.5",
  setMaxCapForGas: (r) => {
    e(() => ({
      maxCapForGas: r
    }));
  },
  customGasPrice: "1500",
  setCustomGasPrice: (r) => {
    e(() => ({
      customGasPrice: r
    }));
  },
  setIgnoreWarnToken: (r) => {
    const n = t().ignoreWarnTokenMap;
    n[Hs(r)] = !0, e(() => ({
      ignoreWarnTokenMap: { ...n }
    }));
  }
}), Sn = Qs(
  PW(NW, {
    name: "useGlobalStore",
    partialize: (e) => {
      const {
        currentExplorer: t,
        currentRpc: r,
        slippage: n,
        customRpc: i,
        providers: s,
        mevProtect: o,
        ignoreWarnTokenMap: a,
        transactionMode: c,
        maxCapForGas: u,
        customGasPrice: l
      } = e;
      return {
        currentExplorer: t,
        currentRpc: r,
        slippage: n,
        customRpc: i,
        providers: s,
        mevProtect: o,
        ignoreWarnTokenMap: a,
        transactionMode: c,
        maxCapForGas: u,
        customGasPrice: l
      };
    }
  })
);
function Rc() {
  const { currentExplorer: e } = Sn();
  return { getExplorerUrl: (r, n = "account", i = e) => {
    let s;
    return i.includes("suivision") ? s = `${i}/${DW(n)}/${r}` : s = `${i}/${$W(n)}/${r}`, s;
  } };
}
const $W = (e) => {
  switch (e) {
    case "account":
      return "address";
    case "token":
      return "object";
    case "tx":
      return "tx";
    case "poolAddress":
      return "object";
    case "nftAddress":
      return "object";
    case "coin":
      return "coin";
  }
}, DW = (e) => {
  switch (e) {
    case "account":
      return "account";
    case "token":
      return "object";
    case "tx":
      return "txblock";
    case "poolAddress":
      return "object";
    case "nftAddress":
      return "object";
    case "coin":
      return "coin";
  }
};
function J5(e) {
  const {
    text: t,
    keywords: r,
    onKeywordClick: n,
    text_highlight_color: i = "var(--cs-primary)",
    text_size: s = "12px",
    text_color: o = "var(--cs-text-secondary)"
  } = e, a = new RegExp(`(${r.join("|")})`, "gi"), c = t.split(a);
  return /* @__PURE__ */ _.jsx(
    "span",
    {
      style: { display: "inline", whiteSpace: "normal", textAlign: "start" },
      children: c.map((u, l) => {
        const f = r.includes(u);
        return /* @__PURE__ */ _.jsx(
          "span",
          {
            style: {
              lineHeight: "20px",
              fontSize: s,
              color: f ? i : o,
              cursor: "pointer",
              whiteSpace: "inherit"
            },
            onClick: () => n(u),
            children: u
          },
          l
        );
      })
    }
  );
}
function g1({
  size: e = "24px",
  strokeWidth: t = "10",
  color: r = "var(--cs-primary)",
  emptyColor: n = "transparent",
  gapPercentage: i = 0.5
  // 
}) {
  const s = 50 - parseFloat(t), o = 2 * Math.PI * s, a = o * i, c = o - a;
  return /* @__PURE__ */ _.jsxs("svg", { width: e, height: e, viewBox: "0 0 100 100", children: [
    /* @__PURE__ */ _.jsx(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: s,
        fill: "none",
        stroke: n,
        strokeWidth: t
      }
    ),
    /* @__PURE__ */ _.jsx(
      "circle",
      {
        cx: "50",
        cy: "50",
        r: s,
        fill: "none",
        stroke: r,
        strokeWidth: t,
        strokeDasharray: `${c} ${a}`,
        strokeDashoffset: "0",
        strokeLinecap: "round",
        style: {
          animation: "dash 0.5s linear infinite"
          // 
        }
      }
    ),
    /* @__PURE__ */ _.jsx("style", { children: `
          @keyframes dash {
            0% {
              stroke-dashoffset: 0;
            }
            100% {
              stroke-dashoffset: -${o};
            }
          }
        ` })
  ] });
}
const LW = (e, t) => ({
  isOpenTokensDialog: !1,
  defaultFromCoinType: void 0,
  defaultToCoinCoinType: void 0,
  isOpenSecondary: !1,
  byAmountIn: !0,
  findRouterLoading: !1,
  fromAmount: "",
  toAmount: "",
  fromCoin: void 0,
  toCoin: void 0,
  routerData: void 0,
  setDefaultCoin: (r, n) => {
    e(() => ({
      defaultFromCoinType: r,
      defaultToCoinCoinType: n
    }));
  },
  setFromCoin: (r) => {
    e(() => ({
      fromCoin: r
    }));
  },
  setToCoin: (r) => {
    e(() => ({
      toCoin: r
    }));
  },
  setFromAmount: (r) => {
    e(() => ({
      fromAmount: r
    }));
  },
  setToAmount: (r) => {
    e(() => ({
      toAmount: r
    }));
  },
  setRouterData: (r) => {
    e(() => ({
      routerData: r
    }));
  },
  setFindRouterLoading: (r) => {
    e(() => ({
      findRouterLoading: r
    }));
  },
  setByAmountIn: (r) => {
    e(() => ({
      byAmountIn: r
    }));
  },
  setIsOpenSecondary: (r) => {
    e(() => ({
      isOpenSecondary: r
    }));
  },
  setIsOpenTokensDialog: (r) => {
    e(() => ({
      isOpenTokensDialog: r
    }));
  }
}), En = Qs(LW), BW = (e, t) => ({
  tokenMapIsInit: !1,
  requestTokenList: [],
  addRequestTokenList: (r) => {
    e(() => ({
      requestTokenList: [...t().requestTokenList, r]
    }));
  },
  setToken: (r) => {
    const { tokenMap: n, requestTokenList: i } = t(), s = jr(r.coin_type).full_address;
    if (!n.has(s)) {
      const o = new Map(n);
      o.set(s, r);
      const a = i.filter(
        (c) => c !== r.coin_type
      );
      e(() => ({
        tokenMap: o,
        requestTokenList: [...a]
      })), Bs.setItem(sm, o);
    }
  },
  tokenMap: /* @__PURE__ */ new Map(),
  setTokenMap: (r, n = !1) => {
    r.size > 0 ? e(() => ({
      tokenMap: r,
      tokenMapIsInit: !0
    })) : e(() => ({
      tokenMap: r
    })), n || Bs.setItem(sm, r);
  },
  trustedTokenList: [],
  setTrustedTokenList: (r, n = !1) => {
    e(() => ({
      trustedTokenList: r
    })), n || Bs.setItem(q5, r);
  }
}), Pc = Qs(BW);
Bs.getItem(sm).then((e) => {
  e !== null && Pc.getState().setTokenMap(e, !0);
});
Bs.getItem(q5).then(
  (e) => {
    e !== null && Pc.getState().setTrustedTokenList(e, !0);
  }
);
const ka = Qs((e, t) => ({
  currentTypeTab: "Default",
  setCurrentTypeTab: (r) => {
    e(() => ({
      currentTypeTab: r
    }));
  },
  currentPlatformTab: "All",
  setCurrentPlatformTab: (r) => {
    e(() => ({
      currentPlatformTab: r
    }));
  },
  //platformList: ["All", "Native", "Wormhole", "Celer"],
  platformList: ["All", "Wormhole"],
  setPlatformList: (r) => {
    e(() => ({
      platformList: r
    }));
  },
  isOpenImportDialog: !1,
  setIsOpenImportDialog: (r) => {
    e(() => ({
      isOpenImportDialog: r
    }));
  },
  collectTokenMap: /* @__PURE__ */ new Map(),
  setCollectTokenMap: (r, n = !1) => {
    e(() => ({
      collectTokenMap: r
    })), n || Bs.setItem(H5, r);
  },
  showTokenList: [],
  setShowTokenList: (r) => {
    e(() => ({
      showTokenList: [...r]
    }));
  },
  combineTokenList: [],
  setComBineTokenList: (r) => {
    e(() => ({
      combineTokenList: r
    }));
  },
  currentImportTokenData: void 0,
  setCurrentImportTokenData: (r) => {
    e(() => ({
      currentImportTokenData: r
    }));
  },
  importTokenList: [],
  importTokenIsLoading: !1,
  setImportToken: (r, n) => {
    const { importTokenList: i, setImportTokenList: s } = t();
    let o = i;
    if (n)
      o = [r, ...o];
    else {
      const a = sb(r.coin_type);
      o = i.filter(
        (c) => sb(c.coin_type) !== a
      );
    }
    return s(o), Bs.setItem(G5, o), o;
  },
  setImportTokenList: (r) => {
    const n = Pc.getState().trustedTokenList, i = r.filter(
      (s) => !n.some(
        (o) => jr(s.coin_type).full_address === jr(o.coin_type).full_address
      )
    );
    e(() => ({
      importTokenList: i
    }));
  },
  setImportTokenIsLoading: (r) => {
    e(() => ({
      importTokenIsLoading: r
    }));
  },
  searchInput: "",
  setSearchInput: (r) => {
    e(() => ({
      searchInput: r
    }));
  },
  showTokenListIsLoading: !1,
  setShowTokenListIsLoading: (r) => {
    e(() => ({
      showTokenListIsLoading: r
    }));
  }
}));
Bs.getItem(H5).then(
  (e) => {
    e !== null && ka.getState().setCollectTokenMap(e, !0);
  }
);
Bs.getItem(G5).then((e) => {
  e && ka.getState().setImportTokenList(e);
});
const UW = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAPKADAAQAAAABAAAAPAAAAACL3+lcAAAJW0lEQVRoBd1be1BU1xk/LstLdtlVUYKoKKA8fJBKJDVxovYxTadC0zY1/2jaKWM0GRsnTTOpEQNGqc34mGicNpqxGkirMYk4QFONqTG01WioFXzwFhRfUJTl/dple37XnmUf93Hu3Uuknpmdc/ec7/vO97vn9Z3vfHcUGaa0a+2PxlnN9hVWU+Aia5gxLsIaHGk1GUNCAgMCRocaRqHZ7p5BZ++Aw2HrtPe22PqabF32Olun46Stw/Du6s0Fd4ZDNaFhvQS/k/P95ChryKb4iaO/NX1yWHhgwD1gauUPOAadNY1d7bU3u0/csvVmrcr562W1MqTodQGcvzlj9cwppqw5ceYJFKMuMpnCFLuzvK6j+dK1zk3L1xbuYuVac7+Uy8tNf2legiU7cYrJolUBNXyV1zrbSqvas5evK9yhhs+dVhPgd9YvSUmJCzvyzeQxU92FfV3PX15ubSir63pq1cbiMrVtBqhlyM/9wfqli6MOxkaFjVHLqxf9pPGh1sSY0SuT46MGC07UlKiRq6qHC3c8Vbhk/kNLKJMqPjUKqaF1EuIsPn27OGPNkQxePi7F976ZYU6ICDn3+Oyx8byCv066f164W1vV0js389XCDqV2FYf07pz0xAWJlsq5MyxRSsLuV/2UyNCxoQGjVs9JjikoPlndIqeHbA+jZx+LC79BV2GznBDeuu4+B9l+qI4Un2oSWNIfe4j86plYEhqk+N65mqCreMepuvZouZ42yknCMNYLbL/dSX7xu/Pk3zVtribzjjWSC1faSd66b5Ago8FVrvUBut5p6z9H+adLyZB8tVigvpM6fr4Uo9ry7YeukE++vNez7ry37/aRvv5BsmD2WPdizc8Y3qmzJqUeOFp5QEyIKGBsPU8vjF6p12pMhxpZu6eCOOmyKpbKaS9/O3U8ibAEiVWrLpsx2TQjfmqk6JblAxhGBfbZYKM2O9hbO2D85VsXyM2WXu8q13+8iCr6Un6yaKIu+x06KjY6bFHMpIlHikuqPYaVz8SBBWUKMcouZi5NOR4+/Pymx7yVYsHc/ujkTalq1eXAACzejB6A83Mz1uhpLrZ2DJBtdFXmTVs/qCPg0SsBCzC5y/MA/EhC+Ab3Sn+ftxysJTYVAEAL0Homb0wuwHmb0l/U89Rzjg7Rj7+4pVp3DGvw6pWACdiYPBfgWdPMr7FCf3O7w0ly9lVxizGFGsn8WUPbEnjpOZibX4nQHZsAGJ4KHN6VGHnrYVBg1eVJgXR9/MPLc0hb59DcBe97Rxt52LlogA0YQSwAhltGL09FU2sfeftwPZci8I1sfWEmocOOVFz1tPt3FTQQyNIjARswQpYAGD4oPQRDRm5+DenudXCJy3p2BnkybQIprbL5GCVdPXZBFpcgDiKG0QDvIhxuHDyKJH8vv0uOnW1WpAPBqh9OJcu+O0mgPVthE+WBLMjUIwEjsBrgStXqXXRXpG9gkGzYz7dQ/fiJKPLST2Nd7GcrWl3P3g9vvFdFcPDwNwEjsBrgN/ZXGPh3F14ljc09iqIWPjyObMxMdNF10KF7ucFz/roq6cO1ph4qu8G9SPMzsBrgJNcs4X+MDbe7yZ6iBkUxKfHhZMeLs4gxYMhyLa1s85m/3oIA+CoF7m8CVgNuBPwVtGF/NRlQGHbTokaT3S+n+Bz2z1Qoz1HI5p0ucliAlQ5pY4gckVIdzrinLsorPWFMMNn76sNkjDnQR9xXtId5EvVbiZ6neXgZDbAacdfDCtTmnXT+bf5TrSwbrKh3X0kh0RG+7xXG1NzpFpISFy7IYOflkvI75LrIeoC2nkgZRyBTSwJWI7vY0iJg58f1pFnGOGBWFAwLsYQT97rlnt6Yo3QrOvC362LkQlto87VlnjyixCKFwCoYHiJ1ikXwYuR/Kq4YmJkVlZZoVZTFCM7Q7enXv78ku4ihTbStNRlxZWkxqfNuYFd8/Y+VZFDGwI8eH0rOXLYJP3a9RrdCspb2jlhrAPHC9guKix/azKaHi4PZqaq9I8BqxP2shahzGcKLUVbbLvuSMQf//JnnCJg5zSwK9gZ1/6zYUkawJvCk8/T4CB2WLp7IQ+6iAVYDLqNdJRwPdzv6NR/S05J8hzc8HJlvnpddC8TUgicFuqhJwGrAzbsapi0H6jyOcmp405I87996+h1k5bYyUn+rW40YgVbwjhxU5x0BVgPCDHhb+1e1jRwuUe/FgHzM43luCxicBGt2XlScGnK6waMCnXgTsNIh7TjJw3DPi1HNQypKkxRjJma3/XP93kryxXn/wzhy9lUT6MaTgNWAABLEVCgx5B27TqobtW8HjyYPDWfcL2kdKd56QifoppSAEVgNiJZBAIkcwz0vxhU5EsU6tmC9f/y6cLJSZFBB8PbhK6TZJu8dAUZgFQwPRMvIyccb5PViiMnB/H0kwUpgRW3K0z4txGSjDLrt+0TeB8YwCoCb2u3rES0jJfDTr/i8GFL8MC1hWChZUVL8POXHS/8jSQZsCH8CgQD4udeLLiE0SIrDX2ea1RxEnt9WrmhFSbXPUy43pIGNxXq5bGnqdciVEhxLz7L+pNP0+MhrRWltJz46TJIVMV6scsj1QEsqPlpmg6eeVbIcjrTntpbJ2s6M9n7kAdSDgiPo427OfKYHnUptSU+/7zLxPM7Cj6bE9NGz6fcYMctjIkPJQnoObe+2E1vXAOmlF9jSM55xDX8eYQ0SQG5emUTm0UVRLB092/KbghNVZ1idRw+j8PT+Z+r1vEFkDd2PHAFs83/+wTT3tl1zmBUiwq2zV8FBxYhHcA4MwOKtoseQRiVuzBHhNjvOsoh2v88I8BYwEv/T/dX54ec3sjOz/3LIWz8fwCBAOB8CQxImmxK8Gf4f/iM6b+krRc+L6Srbg//Yu7RmpEbfiYFBGaLyFmQeknR6+cxhd0EI56PLuvS1gDvxCHiGrtBZThXRIc0YCj+r6kc4X1iw4Wc0pCiYlY/EHGBLLralrcgqko2MkR3SDNiDFFzKBZgBfxDCh2WHNAPKcoTzIcINQV80NlLVy2Iy9Mqxz2LrkVqNpdpRBRhCsGUhws3ucDyJyHQpwcNZDgvqeGnrYrF9Vqldv3oJQV+IgxI7cCg1rKUeB4H78pGHt7KIg0Jo0HB+xnOxvuO3z2YV7fRuW+1/v3rYu7E9b6TPjAw3bnzgP9TyBo7/2j/FG6Cf4hmH7VO8/wJSjxTWAm8L8gAAAABJRU5ErkJggg==", tu = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAQcklEQVR4Ac07C3BUVZb33vfp7nQSgiEhYYYgESEj40oZjERH/MxAnFEGQQYUZILRGix1y3V3q3bZqd2trZpZqram1rJ2tMZZiUGFAURQ4romiALjmlkFB2eGEVyMEAQSEiSQ9O+9fvfuOfe923Q66aQ7dDS3q/vcd9+553fPOffzXlMyxqX4hc1Vls9p4Iao5nm8Mp5HSoSfmsIUGjcJRfbMIoJa1CFRbhlh2k3CrJ3F6EG/rTWee3DlkbEUUQqQawYTX3ppVTxInoxN4rPjVxAfAf0kDwG/WEM4RKGUEiEEQYgF0ITxJY2ZPfSwHiJPnV+9etMQ3S6rKWcGmPTcq+XWxOhzVhlfGJ8oQGkoSlnFJcUAAlSk8EHoort1bPMaXGN5lzoao5O1muf9a3vW3nvGRbq8XyXaqKlMebG5IpTXtzF6JZ/PfYINSyjFADDUoCA0eiN+SVvXINIuKKF3qQzKLMr9x9n+YLig/vSPF3UMy3OEm6M2ALgqLd6y5fnwVXyNCJChFZcKU2GcoyGtlx6FuD7MYuQDjemHhNC7mLggR5HTCeWUxic7JD6HG6QGDDmbTxSzrCtEELRPKyOLEB74jDWdu+++hyFslJlGUHng7bTEB6INvPrGC6/O65tmt1iTeKGKWxfDGy7OhL+Tduq9ZLMZ9j19uuGekwMpZHY1pfG1qVZe7Il4EV8ZLSNlYGZgIK3qEXDrZje5GOgw67oevPd3mVG+hJW1AUpf3vpI+GrxjAOj7qmrIpZQhwr/CdbG+sz67tWLj11ic/m1kpden8ELrI2RabyWaIO9QkNv+D/9sbMPLPtVNtyyMsDkra809s8iawjjXj9lAhjxk+TTYLdY1bFm+cFsBMgWt6JpW3WomG6KVpCZhCg5XCqUMBE8Qpq6VvyoIVO6GRmg+oAwvji9sy00zalWKrsMBPF1sW69kzzU9eNlzZkyzQXelM2vLbImORtik3mJoqeCw39CO1gxZUntwbnUVvfSwRENgMp39OzoiJWJsgFZG5JO8BjdfWbpkrp0xL+K9sk7drZEruILYDZxZ0/PCj7IQRXFSytGMsLQ2TtJ8tOnX2+zy2kZo5CBgAdCZjNR8Alb/3Urj2J2wQAUHNHWs7gGczBmSfxlxC6jZadA9iRVhqwOa4CpW3c1RqeRalRcKg+E9X5m5x81lp1acc9Ph6T4NTSiLPlH2TI9BEMDJlDyxipI9dStzY3DiZQ2BK78TfMjfVXiWYHUvKKHme1v1+Z0PPCDP6u28QQrXn7zmmilcyieB6sJKFJwUAA85NHj99815OwwpAfM2PLmvHCleAbmeHR86VK6o4n8z/X7xqvyqDDKhjKirDIc0HOhhKc7z6BOiJNaBhkAV3jhUtEiTMZcV5ImEAXt+vr2Vd/fkUpgvF2jjCgrGEAagaED+xiTOmGiTCmDGiq3v7khdBVpkHjeOj3vBG39/J7v5yTbz9y2pyZO4/cIH68RGisV1PEJjerUZr3MEqepTd+JGUUvnlp647kUWbO6nL7rv1vC3+QLZRzgzAAl2E4b25f94CH3yv0dYICq37Rd2VfZ+5ljgNdjQeP10O4TC+4sddFH94tTae/J1v+0J4il9kRRgHbFkroXSuyLOBG+bnbcd8H4+6Mr7tjmYmf/O233W2djk0SJUpLGCJ/YUTD98PLvdChqA0IgHux/QRiUuRMJ/moi0E0HWEx1zBRevW33yp7w7guRaaTeLiIFFBwTJ2z5wRjFD0L4qqkWJKDWZDK972p7y1Vv7P4thmWm/JLxUHYIBJnHZS6HsI75IxuTcRKEv/Xq/vL+qdEvhA7B42H4z7Kjn935varkDtnUZ2/f+9cXKuxfEH1oBbw1S2K3m0obhUOcwBn6x2N3LfiL1PuZXF/91ttHwiV8lsJlccLzv/B/85N755/BtoQHCM1+juhgepnzYfS5JvIuslWqY7Zw1ta9t/dNc35BNfR0dy7BnS3W5Q4XR9yrJzzOa8PEJZOXB2EneO23tu/5WbYyIL4fdGACZgVcwCE/g8El6OqVhAGsK8hC5YoI8zq1tj8uv2NUGxt0WV4qXgd+lKEFgB5+UQAFk+uJ+x4u9pFf7IF1+MRK2d8oobOBqAPqInl44WaDroqGNMC1r7y3igeZLyEc7OeDjlmvkLKF1726/x/sQoz3S/GtaCPUYESCZ/S2CZ/7/nLSZ+bcwuPaT/292peEo0uC4wNMrmMbDwr/ddvfW56tLIjvt7QHkSfSQWM6Qeq79pV90rt1RIDT2ielc4KzYsz5e1nnR4tvGvV+PjaBPCGVl2kes72XaoA4A+MWHGf1Hy+/5SXk7RX0tH+dtWffWasIsrbKTIAv6ygUFJg6lwDIelb4eOktn1a17uu0ilm5O9OAQfPok0Brk/SAeFDMxpjDDI3QF9ZfRoajKTVv/2+xU0QnSWvLpQjGM9JF21OS36ntTFE+wSZw3vgXxFOeI3uAPAjx42gkkcwSnTKs+EJsM+YepIPQBp2xK6vefqDKKdB8ig06qBHW/yNDuoPQ7Ivxh3HIL9FT4sOkaml81qKb07qxYeu70BM176PqCGVd6P2DGGbYYEZ9T+O0rsKAg86oOxOG1QCjLnMk+r+vn4U+vL/mZIZ0B6E5wfxfFp7QH8w/pW0PnGPHjQizlQK+C/TYKxQegKQpIo/f7I4QIKD7w0gpKHMHZ6fSdB2xGXUy+2kIB0Z6GAdgOA260Fk1k5GPvAQxI9rREakNg/CHuutCcLvJ+0rM2uYDVZbD7xe287FsSPNj+cXPpHAw3ljQj2BGkRCMKLSY9m9pumbUjLo5QQ6nWi59WPNU67DyqyTczTJyrozTP2VELQuktkVz8fHWPw/XZe6uD/89VMwrKYehUVkQvQCFBeg/T08eWHbD74ejMdI9nWuHIQNUKzyui0omfLRERSlaH7aSHyqErwreuPPAP0ZK+V8BfxmK0k1lunIj1rA1J9hv/PBy5dFs9gHqqkKSmFqJDkskHzapAiIcUvWvAtb810cbw6V8NSjtPtrA0XcdUoYkCCzyusnj7y29ftjwyURWqZsAD1PIBjV1ouHy1ysQb36f2aUuxxLiarHmrY/ejxTzeaiwikulPPLW4owHv6SPv7/4+iFPc7KVD3ULEczBrsaCMU2nGuiPqwNsBuubNC43CbJhDH/mtfz+gFVMr8cHWirmVcJDqEdppKBPq9t393W/zZUYqFtykoVzCKpj4kOGsiiYK45p6Nz8xh/+KTTRcZXH0fDYq4QX6NU+KY36bty1uKovDYlRN8NaAAzudsddtq7B4yzHSwIogBXVy+H2qJfBmUhm5Yu/w5GQkqDRPYnAE/D8YdP/3HXt6kzoZIuDulEShwnV7QkPuCAK4hT0dz/SPQxtcraEs8G/tfmTRTzA8uQuD4yQgFDP+5K1jJXyKCMF3dwlPww18NMc5jDmUAsb5VeGA5+TjUJZ4zJxp4x7GAU5JXnQtDWrvG723VnTy6KDcPgceeokp0IIhjixdCPOuh2Bz+HBQvDljN6QBc2sUSHpTlErT+yssr8ZoYeGWyZnzWiIDtSgNW4SdG/qFu1msPBp12Dk8St3gxr99hB9c9hE8y+FnAo95K3hEnpMC+yEZrte5+qqC61d17h2kApxB3LG0eAmHfWWMxPpNc4+CPSTShcXfQ4zEmRjTrN+uSETfsk43NRmUbkQcqcBqfvC5s+r+kvif5ZPVyU2FfkX6bTWuhmj3hEmMx0v9YUtx6b2F/ATcpTdmUfk9xjXsNZF04+YMRZTbgnOAZMRe2K8CJ4rOVAn1E3paVoshrrLIzHDZocdgyd2SY5JVgLjv80Vc0Xn7uaeb0Ty+xJr+ksB4GIELO3h5rqK1xR+LiHqJDdZEHH4cp5hk8NIH3aHcAji6E956UhOTXaAlv3w3ZMz8F4uC2fRYNwniuM+Ir+2V0eIXzgLxUVYzgvqYvnhHQdQ3D0Wg2M/x3wKGUkDvFE3dZNhURkGOE3gCVGc8425lqQACMqZBgRBYSQvD8qFiStOrtkSC3RJuD8EAaw5YqgzMpIGwIrfYq3JAsX8tPaultOJsECcyy4+d/GT7sEIYdpls0glgDrYAVarpj+EvhhtVXgJA5j+wFo4O4fXrnBssBmSoc6llRRyLiCuAlUiSoW5oJ9KQ+qAp2rg2cgbpmFu8sBahZcwwI75JWf8UbbftZTrnpaPzry35dQihXz50Jd40qP4KIgCqofSl8/HpYCyW342UxkaBxZ13HFnSWLLnzAAdvH7J9aDD3DVAb0garINuRII0q2Me3c0UBzwNsw53ifXISBlT4w+GJhrHHVM1sddEiW1LNl9dkPY7zRgEwSBPCvIg/yw87uT65LQRl39kRBpAz2Xe4Ele7paIj6ReAaIAgcirHHngtKHkoUfZAA8qlq8r7vX1gS8BwyzBsQNPOEUeRG2fvv3Jo2bN8OSlUitL3u75+chP193aXULD4UdevH1W0uKcJmXjD8gBPAGIgRsrQ4e6cN7GuieYAU4R4yYfN2Kd3qWJncej3WUMWqKdTiVQyaTwQWvFnPUKVV5lH+QAbBx64Li3wUd/TGNum9byVgFN4jpbMuqt/uuQZzxWFA2lBFHEZWXD9YpE/mO+RjqNJTMQxoAEbfcfsWvIPabXC9w05QD/2CJmM6h8egJK945vzRsxA/BatJQSRZlRx223F6U9lR5UA5ItdLydy8ciGnePgGxMSdAbsxztPWbbyscFzlh5d6LPw8zZx2Kliw//IHl4LZbJ8xNbkutp/UAhVh0W2Gtj7NOdClpWeQB8RXWxLqVe/taFN7XBVEGlAWHRYYqyIfQz7XOovmFtSPJNcBi6ZB/IoTRv7+/LUrEwKUxuILBRXfAMR9q+q6/OV3/sWhfs+fioohGNsCj5xJFHyMfj/gDVDsYvCWv9tc0B6/LK+IIH9jb3xhjdA3HA3VZcEYBzwC+JiefGpyu2nhHcFTvFbn0Rv6tfydU7TC6KcbETJyyB/TA0OS06cXbgg0D2oe5GEhgGER1a827oUcijDwjX+fBcPCOtLz7wk9oW4Hhr3/2JprTZwuPvi9m9NmRjVFCwK09xV37SxEglnlAkMeabg+mTXhKh2SYtQGw88PvWfMijtNiC1KYbADwBLlwwreMDSE6dUI3BwK+p5+toaM6Xnv0AzE1EoE/TRGyEly9LHXE0d3R7eFU52JA0+qe/4455FSXrHBqfVQGQCIoTMN+6/kYERASQ68nJDNYWIEhQhoRR+H57580h3zo9xuHoE9XXpDITUk4RMpjlEymUXsOvAd0A4TYtx1CZ8UJHNenunmSBvBUk8PuoqlxvvnV/m0uSQbyxGFR0X8uvjFGyHzO4eB5mKJGDKEsKRGEM436N+lQZJTHg4fhHwL2Fxbr9U/Pph1D4WbaNmoPSGXwk/2inAvnOYuLhfAA2of3lcCeuoMzhooZhLIDYKo2t2XArw7vSxqEtsLjtLW/nk+l9wxAGMVFzgyQzPvRNrHKtvmTNiezwZV96dx4JAPBcgPCR8R0Sg6bJnvq2Vqa+wOaZMHHov74+6LKiZMGSGTVEPeV4P0lkMNNgBrMJHIAIG7gRRV4c0EQS6OkG1rbIbEd1HTS+Mub6JGxkEvR/H/1GixGG+ou8QAAAABJRU5ErkJggg==";
function Gr({
  token: e,
  src: t,
  alt: r,
  className: n,
  style: i,
  showWarn: s,
  haveBorder: o = !0,
  showWarnSize: a = "14px",
  ...c
}) {
  const [u, l] = Mt(tu), { defaultFromCoinType: f, defaultToCoinCoinType: h } = En(), v = (C) => {
    l(tu);
  };
  Bt(() => {
    l(t || tu);
  }, [t]);
  const { importTokenList: b } = ka(), y = Ft(() => {
    const C = b.some(
      (O) => O.coin_type === (e == null ? void 0 : e.coin_type)
    );
    return e && !(C || e != null && e.is_trusted);
  }, [e, b]), S = Ft(() => !!(f && h && (e != null && e.coin_type) && (jr(f).full_address === jr(e == null ? void 0 : e.coin_type).full_address || jr(h).full_address === jr(e == null ? void 0 : e.coin_type).full_address)), [f, h, e == null ? void 0 : e.coin_type]);
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        position: "relative",
        border: o ? "1px solid var(--cs-border)" : "1px solid transparent",
        borderRadius: o ? "50%" : "none",
        borderColor: o && u !== tu ? "var(--cs-border)" : "transparent"
      },
      children: [
        u == tu ? /* @__PURE__ */ _.jsx(
          "svg",
          {
            className: "cs-icon",
            "aria-hidden": "true",
            style: {
              borderRadius: "50%",
              width: "32px",
              height: "32px",
              fill: "var(--cs-primary)",
              ...i
            },
            children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-token_nor" })
          }
        ) : /* @__PURE__ */ _.jsx(
          "img",
          {
            src: u,
            alt: r || "",
            className: [n, "tokenImg"].filter(Boolean).join(" "),
            loading: "lazy",
            decoding: "async",
            style: {
              borderRadius: "100%",
              objectFit: "contain",
              flexShrink: 0,
              ...i
            },
            onError: v,
            ...c
          }
        ),
        (s || y) && !S && /* @__PURE__ */ _.jsx(
          "img",
          {
            style: {
              position: "absolute",
              right: -3,
              bottom: -2,
              width: a,
              height: a,
              objectFit: "contain",
              flexShrink: 0
            },
            src: UW
          }
        )
      ]
    }
  );
}
function FW({ toastData: e, onClose: t }) {
  const { status: r, buildShowInfo: n, tx: i, id: s } = e, { getExplorerUrl: o } = Rc(), a = Ft(() => {
    if (n && r)
      return n(r);
  }, [r]), c = Ft(() => {
    if (r) {
      if (r === "rejected")
        return "var(--cs-error)";
      if (r === "success")
        return "var(--cs-success)";
    }
    return "var(--cs-text-secondary)";
  }, [r]);
  return /* @__PURE__ */ _.jsxs("div", { className: "cs-toast", children: [
    /* @__PURE__ */ _.jsxs("div", { style: { gap: "0px", display: "flex", flexDirection: "column" }, children: [
      /* @__PURE__ */ _.jsxs("div", { style: { display: "flex", gap: "10px", alignItems: "center" }, children: [
        r === "submitted" && /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsx(g1, { size: "20px" }) }),
        /* @__PURE__ */ _.jsxs(
          "svg",
          {
            className: "cs-icon",
            style: { width: "16px", height: "16px", fill: c },
            children: [
              r === "rejected" && /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" }),
              r === "success" && /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-sel" })
            ]
          }
        ),
        r === "submitted" && /* @__PURE__ */ _.jsxs(
          "span",
          {
            style: { marginLeft: "-28px", color: "var(--cs-text-primary)" },
            children: [
              " ",
              "Transaction in progress",
              " "
            ]
          }
        ),
        r === "rejected" && /* @__PURE__ */ _.jsx("span", { className: "red", children: (a == null ? void 0 : a.toastTitleText) || "Transaction failed" }),
        r === "success" && /* @__PURE__ */ _.jsx("span", { className: "green", children: (a == null ? void 0 : a.toastTitleText) || "Transaction Successful" })
      ] }),
      r === "submitted" && /* @__PURE__ */ _.jsxs("div", { children: [
        a != null && a.toastDescriptionContent && typeof a.toastDescriptionContent == "function" ? a.toastDescriptionContent() : /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)" }, children: a == null ? void 0 : a.toastDescriptionContent }),
        !(a != null && a.toastDescriptionContent) && i && /* @__PURE__ */ _.jsx(
          J5,
          {
            text: "Confirmation is in progress. Check your transaction on here",
            keywords: ["here"],
            text_highlight_color: "var(--cs-primary)",
            onKeywordClick: () => {
              window.open(o(i, "tx"), "_blank");
            }
          }
        )
      ] }),
      r === "rejected" && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
        a != null && a.toastDescriptionContent && typeof a.toastDescriptionContent == "function" ? a.toastDescriptionContent() : /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)" }, children: a == null ? void 0 : a.toastDescriptionContent }),
        !(a != null && a.toastDescriptionContent) && /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)" }, children: "Something went wrong" })
      ] }),
      r === "success" && /* @__PURE__ */ _.jsx(_.Fragment, { children: a != null && a.toastDescriptionContent && typeof a.toastDescriptionContent == "function" ? a.toastDescriptionContent() : /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)" }, children: a == null ? void 0 : a.toastDescriptionContent }) }),
      r === "success" && i && /* @__PURE__ */ _.jsxs("div", { className: "view-transaction", children: [
        /* @__PURE__ */ _.jsx("span", { children: "View Transaction" }),
        eh.map((u) => /* @__PURE__ */ _.jsx(
          "a",
          {
            href: o(i, "tx", u.link),
            target: "_blank",
            children: /* @__PURE__ */ _.jsx(Gr, { src: u.img, haveBorder: !1 })
          },
          u.link
        ))
      ] })
    ] }),
    /* @__PURE__ */ _.jsx(
      "svg",
      {
        className: "cs-icon close",
        "aria-hidden": "true",
        onClick: () => t(s),
        children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" })
      }
    )
  ] });
}
const VW = Qs((e, t) => ({
  toasts: [],
  setToasts: (r) => {
    e((n) => ({
      toasts: [...n.toasts, r]
    })), setTimeout(() => {
      e((n) => ({
        toasts: n.toasts.filter(
          (i) => i.id !== r.id
        )
      }));
    }, 3e3);
  },
  removeToast: (r) => {
    e((n) => ({
      toasts: n.toasts.filter((i) => i.id !== r)
    }));
  }
})), Nc = (e = "cs-swap-widget") => {
  const { toasts: t, setToasts: r, removeToast: n } = VW(), i = (a, c = "success") => {
    const l = {
      id: Date.now(),
      status: c,
      buildShowInfo: () => ({ toastTitleText: a })
    };
    r(l);
  }, s = (a) => {
    const c = Date.now();
    return a.id = c, r(a), c;
  }, o = Ii(() => {
    let a = document.getElementById(e);
    a || (a = document.createElement("div"), a.id = e, document.body.appendChild(a));
    const c = a == null ? void 0 : a.getBoundingClientRect();
    let u, l;
    return u = `${window.scrollX + c.left + c.width - 308}px`, l = `${window.scrollY + c.top + 20}px`, Ww.createPortal(
      /* @__PURE__ */ _.jsx("div", { className: "cs-toast-wrapper", style: { left: u, top: l }, children: t && t.map((f) => /* @__PURE__ */ _.jsx(
        FW,
        {
          toastData: f,
          onClose: () => {
            n(f.id);
          }
        },
        f.id
      )) }),
      document.body
    );
  }, [t]);
  return { addCommonToast: i, addTxToast: s, ToastContainer: o, removeToast: n };
};
function zW({ onClick: e }) {
  const [t, r] = Mt(!1), n = () => {
    r(!0), setTimeout(() => {
      r(!1);
    }, 1e3), e();
  };
  return /* @__PURE__ */ _.jsx("div", { className: "refresh-button", children: /* @__PURE__ */ _.jsx(
    "svg",
    {
      className: t ? "rotate cs-icon-hover" : "cs-icon-hover",
      "aria-hidden": "true",
      onClick: n,
      children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-refresh" })
    }
  ) });
}
const Fo = Qs((e, t) => ({
  suiClient: new wa({ url: lc.fullRpcUrl }),
  setSuiClient: (r) => {
    e(() => ({
      suiClient: r
    }));
  },
  aggregatorSDK: new C5({
    signer: lc.simulationAccount,
    client: new wa({ url: lc.fullRpcUrl }),
    env: A5.Mainnet
  }),
  setAggregatorSDK: (r) => {
    e(() => ({
      aggregatorSDK: r
    }));
  }
})), WW = [
  {
    name: "Sudo LP Token",
    symbol: "SLP",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/slp.png",
    coinType: "0xc44d97a4bc4e5a33ca847b72b123172c88a6328196b71414f32c3070233604b2::slp::SLP",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xc44d97a4bc4e5a33ca847b72b123172c88a6328196b71414f32c3070233604b2::slp::SLP",
      coin_priority: 720,
      coingecko_id: "slp"
    }
  },
  {
    name: " WAL",
    symbol: "wWAL",
    decimals: 9,
    logoURL: "https://interestprotocol.infura-ipfs.io/ipfs/QmPLCVWv7citJSc813NbcbZnRSXAEJ4BWVKq4zK8pPVEWq",
    coinType: "0xb1b0650a8862e30e3f604fd6c5838bc25464b8d3d827fbd58af7cb9685b832bf::wwal::WWAL",
    isVerified: !0
  },
  {
    name: "Wrapped GLMR (Portal from Moonbeam)",
    symbol: "WGLMR",
    decimals: 8,
    logoURL: "https://zuwfvhekgt5rgxaa5e5yraqnxeivprtu2siky5qtffa2ysvcvh6q.arweave.net/zSxanIo0-xNcAOk7iIINuRFXxnTUkKx2EylBrEqiqf0",
    coinType: "0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75::coin::COIN",
      labels: ["Wormhole"]
    }
  },
  {
    name: "Spring SUI",
    symbol: "sSUI",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/5iJkTTWnZnTF5vpZA31F5vZZSqGPHuTMNCQSBTqkYGMV",
    coinType: "0x83556891f4a0f233ce7b05cfe7f957d4020492a34f5405b2cb9377d060bef4bf::spring_sui::SPRING_SUI",
    isVerified: !0,
    extensionFields: {
      coin_priority: 908,
      rank: 840,
      suggested_priority: 909
    }
  },
  {
    name: "Volo Staked SUI",
    symbol: "vSUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/vsui.png",
    coinType: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT",
      coin_priority: 910,
      coingecko_id: "volo-staked-sui",
      pyth_id: "57ff7100a282e4af0c91154679c5dae2e5dcacb93fd467ea9cb7e58afdcfde27",
      rank: 860,
      suggested_priority: 910
    }
  },
  {
    name: "AXOLcoin",
    symbol: "AXOL",
    decimals: 9,
    logoURL: "https://api.interestlabs.io/files/99e91dc540e4d32971972eed8ecae0958f0cb3e84018dd1b.png",
    coinType: "0xf00eb7ab086967a33c04a853ad960e5c6b0955ef5a47d50b376d83856dc1215e::axol::AXOL",
    isVerified: !0
  },
  {
    name: "SEND",
    symbol: "SEND",
    decimals: 6,
    logoURL: "https://suilend-assets.s3.us-east-2.amazonaws.com/SEND/SEND.svg",
    coinType: "0xb45fcfcc2cc07ce0702cc2d229621e046c906ef14d9b25e8e4d25f6e8763fef7::send::SEND",
    isVerified: !0
  },
  {
    name: "TIMES",
    symbol: "TIMES",
    decimals: 5,
    logoURL: "https://assets.playdarktimes.com/images/icons/darktimes_logo.png",
    coinType: "0x46fbe54691b27d7abd2c9e5a01088913531f241b98f3c2351f8215e45cc17a4c::times::TIMES",
    isVerified: !0,
    extensionFields: {
      coingecko_id: "times"
    }
  },
  {
    name: "Aptos Coin (Portal from Aptos)",
    symbol: "APT",
    decimals: 8,
    logoURL: "https://hvyfngb6s6wsyytjzbvqjunzqvwlzjjhfmk4z44yacx7sq7fidxa.arweave.net/PXBWmD6XrSxiachrBNG5hWy8pScrFczzmACv-UPlQO4",
    coinType: "0x3a5143bb1196e3bcdfab6203d1683ae29edd26294fc8bfeafe4aaa9d2704df37::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x3a5143bb1196e3bcdfab6203d1683ae29edd26294fc8bfeafe4aaa9d2704df37::coin::COIN",
      coin_priority: 590,
      labels: ["Wormhole"],
      pyth_id: "03ae4db29ed4ae33d323568895aa00337e658e348b37509f5372ae51f0af00d5"
    }
  },
  {
    name: "Haedal staked SUI",
    symbol: "haSUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/hasui.png",
    coinType: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI",
      coin_priority: 960,
      coingecko_id: "haedal-staked-sui",
      pyth_id: "6120ffcf96395c70aa77e72dcb900bf9d40dccab228efca59a17b90ce423d5e8",
      rank: 870,
      suggested_priority: 960
    }
  },
  {
    name: "sNS",
    symbol: "sNS",
    decimals: 6,
    logoURL: "https://3vhaecwgpni3lhtpvmwylermast5evx5e7x46x3hw534olzdqq7q.arweave.net/3U4CCsZ7UbWeb6sthZIsBKfSVv0n789fZ7d3xy8jhD8",
    coinType: "0x6511052d2f1404934e0d877709949bcda7c1d451d1218a4b2643ca2f3fa93991::scallop_ns::SCALLOP_NS",
    isVerified: !0
  },
  {
    name: "sSCA",
    symbol: "sSCA",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/6HrUJbgHzoHMq952F1PG36L94BQkuyjnqAjfPLo3hJ3D",
    coinType: "0x5ca17430c1d046fae9edeaa8fd76c7b4193a00d764a0ecfa9418d733ad27bc1e::scallop_sca::SCALLOP_SCA",
    isVerified: !0,
    extensionFields: {
      rank: 820
    }
  },
  {
    name: "CAP",
    symbol: "CAP",
    decimals: 9,
    logoURL: "https://owhanwxsgozv6rpjuntz4a32lqhb2tl4kurcmyltpd6ipysudv2a.arweave.net/dY4G2vIzs19F6aNnngN6XA4dTXxVIiZhc3j8h-JUHXQ",
    coinType: "0x893aa3f358b70e7dbcf957c64a1f016633630af42fb6097f25c33ef9fa738dd2::cap::CAP",
    isVerified: !0
  },
  {
    name: "mUSD",
    symbol: "mUSD",
    decimals: 9,
    logoURL: "https://mstable.io/coins/musd.svg",
    coinType: "0xe44df51c0b21a27ab915fa1fe2ca610cd3eaa6d9666fe5e62b988bf7f0bd8722::musd::MUSD",
    isVerified: !0
  },
  {
    name: "sSBUSDT",
    symbol: "sSBUSDT",
    decimals: 6,
    logoURL: "https://zu6izvoktna456r6pbxg3knacc4bysfalutz25xo6zfkx6x3wvda.arweave.net/zTyM1cqbQc76PnhubamgELgcSKBdJ5127vZKq_r7tUY",
    coinType: "0xb1d7df34829d1513b73ba17cb7ad90c88d1e104bb65ab8f62f13e0cc103783d3::scallop_sb_usdt::SCALLOP_SB_USDT",
    isVerified: !0
  },
  {
    name: "Wrapped AVAX (Portal from Avalanche)",
    symbol: "WAVAX",
    decimals: 8,
    logoURL: "https://dvv5kcjybfklcqlql7dj7mfrfzj4bgunkcdgz6uh3re4usboi5ba.arweave.net/HWvVCTgJVLFBcF_Gn7CxLlPAmo1Qhmz6h9xJykguR0I",
    coinType: "0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766::coin::COIN",
      coingecko_id: "avalanche-wormhole",
      labels: ["Wormhole"],
      pyth_id: "93da3352f9f1d105fdfe4971cfa80e9dd777bfc5d0f683ebb6e1294b92137bb7"
    }
  },
  {
    name: "suibeaver",
    symbol: "DAM",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8yU5QsDMFoLAoXFfSDrE5m3ZMMAzCzewtwfAy6qHvpju",
    coinType: "0xaf3aae4940a248739ce4964857381fc3f3149a6d05375bfbb2118592907e3bbb::dam::DAM",
    isVerified: !0
  },
  {
    name: "svSUI",
    symbol: "svSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8ot3tVqpC3hhGQhf2sNyGC27Z877ZtcEb79RY1W4fzrB",
    coinType: "0xe1a1cc6bcf0001a015eab84bcc6713393ce20535f55b8b6f35c142e057a25fbe::scallop_v_sui::SCALLOP_V_SUI",
    isVerified: !0
  },
  {
    name: "USD Coin (Portal from Eth)",
    symbol: "wUSDC",
    decimals: 6,
    logoURL: "https://klrhtty4kphjcsrez2eaeh6r27tbaayw3odjadigbrek544f3i2a.arweave.net/UuJ5zxxTzpFKJM6IAh_R1-YQAxbbhpANBgxIrvOF2jQ",
    coinType: "0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN",
      coin_priority: 990,
      coingecko_id: "usd-coin-wormhole-from-ethereum",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 990
    }
  },
  {
    name: "Wrapped Ether (Portal from Eth)",
    symbol: "WETH",
    decimals: 8,
    logoURL: "https://t4gq524jdiihjr6ihouhzsemfczi3eq2cnjyhbfms5utl3hueu6q.arweave.net/nw0O64kaEHTHyDuofMiMKLKNkhoTU4OErJdpNez0JT0",
    coinType: "0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5::coin::COIN",
      coin_priority: 940,
      coingecko_id: "ethereum-wormhole",
      labels: ["Wormhole"],
      pyth_id: "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
      rank: 800
    }
  },
  {
    name: "Mirai Staked SUI",
    symbol: "mSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/3pwmCNEzHcDWVdobJJa2275EVQupXGzffjahSCPiw9G4",
    coinType: "0x922d15d7f55c13fd790f6e54397470ec592caa2b508df292a2e8553f3d3b274f::msui::MSUI",
    isVerified: !0
  },
  {
    name: "ZO Perpetuals LP Token",
    symbol: "ZLP",
    decimals: 6,
    logoURL: "https://img.zofinance.io/zlp.png",
    coinType: "0xf7fade57462e56e2eff1d7adef32e4fd285b21fd81f983f407bb7110ca766cda::zlp::ZLP",
    isVerified: !0
  },
  {
    name: "Wrapped Fantom (Portal from Fantom)",
    symbol: "WFTM",
    decimals: 8,
    logoURL: "https://tqhb43iz7vqrys2frjp73jn2o3uzehbmybq2sv2me2fpo4rocbja.arweave.net/nA4ebRn9YRxLRYpf_aW6dumSHCzAYalXTCaK93IuEFI",
    coinType: "0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396::coin::COIN",
      labels: ["Wormhole"],
      pyth_id: "5c6c0d2386e3352356c3ab84434fafb5ea067ac2678a38a338c4a69ddc4bdb0c"
    }
  },
  {
    name: "swUSDT",
    symbol: "swUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/GNNHRxZcwE3QnxL39LZQksEHB1JARX2bhBHGbcZCvfWg",
    coinType: "0xe6e5a012ec20a49a3d1d57bd2b67140b96cd4d3400b9d79e541f7bdbab661f95::scallop_wormhole_usdt::SCALLOP_WORMHOLE_USDT",
    isVerified: !0
  },
  {
    name: "sUSDY",
    symbol: "sUSDY",
    decimals: 6,
    logoURL: "https://v4kpvw5rr2kprz4echmm33xktmu4lu7kh3qncwrw7xvzdipatkya.arweave.net/rxT627GOlPjnhBHYze7qmynF0-o-4NFaNv3rkaHgmrA",
    coinType: "0xd285cbbf54c87fd93cd15227547467bb3e405da8bbf2ab99f83f323f88ac9a65::scallop_usdy::SCALLOP_USDY",
    isVerified: !0
  },
  {
    name: "$DRF",
    symbol: "DRF",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/4tJCmQbwABnc8z1e8Wyy89j8kCinLdN915LucsZusH2r",
    coinType: "0x294de7579d55c110a00a7c4946e09a1b5cbeca2592fbb83fd7bfacba3cfeaf0e::drf::DRF",
    isVerified: !0
  },
  {
    name: "swSOL",
    symbol: "swSOL",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/38CYobsZ6resAMb939doWgMwcKrVJm7mDXzXNjKHxTfX",
    coinType: "0x1392650f2eca9e3f6ffae3ff89e42a3590d7102b80e2b430f674730bc30d3259::scallop_wormhole_sol::SCALLOP_WORMHOLE_SOL",
    isVerified: !0
  },
  {
    name: "Scallop",
    symbol: "SCA",
    decimals: 9,
    logoURL: "https://vrr7y7aent4hea3r444jrrsvgvgwsz6zi2r2vv2odhgfrgvvs6iq.arweave.net/rGP8fARs-HIDcec4mMZVNU1pZ9lGo6rXThnMWJq1l5E",
    coinType: "0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x7016aae72cfc67f2fadf55769c0a7dd54291a583b63051a5ed71081cce836ac6::sca::SCA",
      coin_priority: 900,
      coingecko_id: "scallop-2",
      pyth_id: "7e17f0ac105abe9214deb9944c30264f5986bf292869c6bd8e8da3ccd92d79bc",
      rank: 830
    }
  },
  {
    name: "Daossui Token",
    symbol: "DAOS",
    decimals: 6,
    logoURL: "https://public.daossui.io/dao-sui/assets/daossui-token.png",
    projectURL: "https://daossui.io/",
    coinType: "0xd40cec91f6dca0673b25451fb0d654e62ad13bf6546a32a21ef0c59eba42e71c::daos::DAOS",
    isVerified: !0
  },
  {
    name: "SPT",
    symbol: "SPT",
    decimals: 9,
    logoURL: "https://seapad.s3.ap-southeast-1.amazonaws.com/uploads/PROD/public/media/images/logo_1685439392353.png",
    coinType: "0xb779486cfd6c19e9218cc7dc17c453014d2d9ba12d2ee4dbb0ec4e1e02ae1cca::spt::SPT",
    isVerified: !0
  },
  {
    name: "Suiba Inu",
    symbol: "SUIB",
    decimals: 9,
    logoURL: "https://fvies4qayyhittfc6gxdfldafsmynmk5o5yitbrtnujlpbktv77a.arweave.net/LVBJcgDGDonMovGuMqxgLJmGsV13cImGM20St4VTr_4",
    coinType: "0xed4504e791e1dad7bf93b41e089b4733c27f35fde505693e18186c2ba8e2e14b::suib::SUIB",
    isVerified: !0
  },
  {
    name: "USD Coin (Celer)",
    symbol: "cUSDC",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/usdc_celer.png",
    coinType: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdc_coin::CELER_USDC_COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdc_coin::CELER_USDC_COIN",
      coin_priority: 830,
      labels: ["Celer"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 930
    }
  },
  {
    name: "FOMO",
    symbol: "FOMO",
    decimals: 2,
    logoURL: "https://7ms6dw2zbrlaaeadpyyz7cy5pwdlz64atqh6gdkpuws3uxpesxeq.arweave.net/-yXh21kMVgAQA34xn4sdfYa8-4CcD-MNT6Wlul3klck",
    coinType: "0xa340e3db1332c21f20f5c08bef0fa459e733575f9a7e2f5faca64f72cd5a54f2::fomo::FOMO",
    isVerified: !0
  },
  {
    name: "MOVE",
    symbol: "MOVE",
    decimals: 9,
    logoURL: "https://gk4id6fee24ru5cdipjxyz6cl42yjtzl3xfuizlpqjub42hx5rvq.arweave.net/MriB-KQmuRp0Q0PTfGfCXzWEzyvdy0Rlb4JoHmj37Gs",
    coinType: "0x648f9eab1434c056d509ad857fb657ac170528798d771f7eb1edc35639e3e75c::movecoin::MOVECOIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x648f9eab1434c056d509ad857fb657ac170528798d771f7eb1edc35639e3e75c::movecoin::MOVECOIN",
      coin_priority: 690
    }
  },
  {
    name: "KOI",
    symbol: "KOI",
    decimals: 6,
    logoURL: "https://ubxwf7ujw5ktuqvndqeqogfoiu343qxl2a3h3i5l5zkzj66fp6xa.arweave.net/oG9i_om3VTpCrRwJBxiuRTfNwuvQNn2jq-5VlPvFf64",
    coinType: "0x01d430425a8a681ef26315e78a082fe744f8d0bbdbd1ab76b9fd78ada09bedca::Koi::KOI",
    isVerified: !0
  },
  {
    name: "Bucket Token",
    symbol: "BUT",
    decimals: 9,
    logoURL: "https://aqua-natural-grasshopper-705.mypinata.cloud/ipfs/QmUKAX4PME9Wb9VU6CMJPisNysaVKZNKpiB3gtMVVZTfjt",
    coinType: "0xbc858cb910b9914bee64fff0f9b38855355a040c49155a17b265d9086d256545::but::BUT",
    isVerified: !0
  },
  {
    name: "USD Coin (Portal from BSC)",
    symbol: "USDCbnb",
    decimals: 8,
    logoURL: "https://co3xbx3vz2ww7tcs2tp4p36hdnkz677tuvqt6wgyfyoeefj6or6a.arweave.net/E7dw33XOrW_MUtTfx-_HG1Wff_OlYT9Y2C4cQhU-dHw",
    coinType: "0x909cba62ce96d54de25bec9502de5ca7b4f28901747bbf96b76c2e63ec5f1cba::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x909cba62ce96d54de25bec9502de5ca7b4f28901747bbf96b76c2e63ec5f1cba::coin::COIN",
      coin_priority: 860,
      coingecko_id: "usd-coin-wormhole-bnb",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 970
    }
  },
  {
    name: "haWAL",
    symbol: "haWAL",
    decimals: 9,
    logoURL: "https://assets.haedal.xyz/logos/hawal.svg",
    coinType: "0x8b4d553839b219c3fd47608a0cc3d5fcc572cb25d41b7df3833208586a8d2470::hawal::HAWAL",
    isVerified: !0
  },
  {
    name: "USD Coin (Portal from Solana)",
    symbol: "USDCsol",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/2q5BcNXs91mPPSaYLCbLRS8Pyha8N76dafj51HdMmrh6",
    coinType: "0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037::coin::COIN",
      coin_priority: 870,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 980
    }
  },
  {
    name: "SPAM",
    symbol: "SPAM",
    decimals: 4,
    logoURL: "https://3fc4a4tjkjryoqps44rgwhydihn5htqyfjmrrmlouf6rt5qyxjbq.arweave.net/2UXAcmlSY4dB8uciax8DQdvTzhgqWRixbqF9GfYYukM",
    coinType: "0x30a644c3485ee9b604f52165668895092191fcaf5489a846afa7fc11cdb9b24a::spam::SPAM",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x30a644c3485ee9b604f52165668895092191fcaf5489a846afa7fc11cdb9b24a::spam::SPAM"
    }
  },
  {
    name: "sKART",
    symbol: "sKARTCOIN",
    decimals: 9,
    logoURL: "https://osp3bhhpqkgtrtuww3cn6cqpcy36lxhu2j4djhbr5fu4fzusrt2a.arweave.net/dJ-wnO-CjTjOlrbE3woPFjfl3PTSeDScMelpwuaSjPQ",
    coinType: "0xfd48ffd0e62ed5cb839400b7e0bee870cd752f9d01c657a665be2afff16995eb::skart::SKART",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xfd48ffd0e62ed5cb839400b7e0bee870cd752f9d01c657a665be2afff16995eb::skart::SKART",
      coin_priority: 770
    }
  },
  {
    name: "FUD Staked SUI",
    symbol: "fudSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8qhJwoDEavz5KdkJEK9FaiHp9rYEqbWhF7HrqsJpUG4F",
    coinType: "0x02358129a7d66f943786a10b518fdc79145f1fc8d23420d9948c4aeea190f603::fud_sui::FUD_SUI",
    isVerified: !0
  },
  {
    name: "suitard",
    symbol: "STD",
    decimals: 9,
    logoURL: "https://hawbf2zd3vl47ileyqlznfwluvtyis7bnbfkadg7vpsvxbpe5h4a.arweave.net/OCwS6yPdV8-hZMQXlpbLpWeES-FoSqAM36vlW4Xk6fg",
    coinType: "0x2cddfc6d4fc855917e990e71cd122b1ee8098aa890186ee15a84524ed17cd8c9::suitard::SUITARD",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x2cddfc6d4fc855917e990e71cd122b1ee8098aa890186ee15a84524ed17cd8c9::suitard::SUITARD",
      coingecko_id: "suitard"
    }
  },
  {
    name: "NAVX Token",
    symbol: "NAVX",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/navx.png",
    coinType: "0xa99b8952d4f7d947ea77fe0ecdcc9e5fc0bcab2841d6e2a5aa00c3044e5544b5::navx::NAVX",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xa99b8952d4f7d947ea77fe0ecdcc9e5fc0bcab2841d6e2a5aa00c3044e5544b5::navx::NAVX",
      coin_priority: 950,
      coingecko_id: "navi",
      pyth_id: "88250f854c019ef4f88a5c073d52a18bb1c6ac437033f5932cd017d24917ab46",
      rank: 770
    }
  },
  {
    name: "Wrapped SOL (Portal from Solana)",
    symbol: "WSOL",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/Ek2PhfPT6AgsJ7TYXx4NQJ1WPtNSxPkCo5bVmGRr1aUo",
    coinType: "0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8::coin::COIN",
      coin_priority: 790,
      labels: ["Wormhole"],
      pyth_id: "ef0d8b6fda2ceba41da15d4095d1da392a0d2f8ed0c6c7bc0f4cfac8c280b56d"
    }
  },
  {
    name: "Suilama",
    symbol: "SUILAMA",
    decimals: 6,
    logoURL: "https://api.movepump.com/uploads/1000030596_8a14750351.jpg",
    coinType: "0x5a4f64079daed04d923c93f3ac4ee04b637e5b3ea2db87d591981c1049508a27::suilama::SUILAMA",
    isVerified: !0
  },
  {
    name: "MEMEFI",
    symbol: "MEMEFI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/AymYAvpqK3rnQE9AqtXwzHzPMQeiqdmm9yamxryDsZCT",
    coinType: "0x506a6fc25f1c7d52ceb06ea44a3114c9380f8e2029b4356019822f248b49e411::memefi::MEMEFI",
    isVerified: !0
  },
  {
    name: "SCUBA DOG",
    symbol: "SCUBA",
    decimals: 6,
    logoURL: "https://j3i5gtlp36ptsx6lyygrujd2cx7vgzaxbqyeiyqded67ihlbehva.arweave.net/TtHTTW_fnzlfy8YNGiR6Ff9TZBcMMERiAyD99B1hIeo",
    coinType: "0x9e6d6124287360cc110044d1f1d7d04a0954eb317c76cf7927244bef0706b113::SCUBA::SCUBA",
    isVerified: !0
  },
  {
    name: "Suiman",
    symbol: "Suiman",
    decimals: 6,
    logoURL: "https://cwwuyv2vk4qwk4vdtkub2hlhwy7vy7wqm5ar6hmxdikusgzcxi4a.arweave.net/Fa1MV1VXIWVyo5qoHR1ntj9cftBnQR8dlxoVSRsiujg",
    coinType: "0xa8b69040684d576828475115b30cc4ce7c7743eab9c7d669535ee31caccef4f5::suiman::SUIMAN",
    isVerified: !0
  },
  {
    name: "ALPHA Token",
    symbol: "ALPHA",
    decimals: 9,
    logoURL: "https://7taj6jfau6n3dri7agspzfnva7qbj5sizz5xc3lb56nmxpsyoiba.arweave.net/_MCfJKCnm7HFHwGk_JW1B-AU9kjOe3FtYe-ay75YcgI",
    coinType: "0xfe3afec26c59e874f3c1d60b8203cb3852d2bb2aa415df9548b8d688e6683f93::alpha::ALPHA",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xfe3afec26c59e874f3c1d60b8203cb3852d2bb2aa415df9548b8d688e6683f93::alpha::ALPHA",
      coingecko_id: "alpha-fi"
    }
  },
  {
    name: "sSBWBTC",
    symbol: "sSBWBTC",
    decimals: 8,
    logoURL: "https://ferq2danvxy5xrhvml37sv3nlwaraso6iwfjtdops7rscscy7zba.arweave.net/KSMNDA2t8dvE9WL3-VdtXYEQSd5FipmNz5fjIUhY_kI",
    coinType: "0x08c0fe357d3a138f4552bee393ce3a28a45bebcca43373d6a90bc44ab76f82e2::scallop_sb_wbtc::SCALLOP_SB_WBTC",
    isVerified: !0
  },
  {
    name: "DeepBook Token",
    symbol: "DEEP",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/5LqWyWG5EU9wPknvW5rY6qSQPtnNAfP27X1PnAiesyFG",
    coinType: "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
    isVerified: !0,
    extensionFields: {
      coingecko_id: "deep",
      suggested_priority: 908
    }
  },
  {
    name: "sDEEP",
    symbol: "sDEEP",
    decimals: 6,
    logoURL: "https://lkjkjfqta7322ikfbcklyovddpnjqrba3hlhhq4u4ilhcfbbjecq.arweave.net/WpKklhMH960hRQiUvDqjG9qYRCDZ1nPDlOIWcRQhSQU",
    coinType: "0xeb7a05a3224837c5e5503575aed0be73c091d1ce5e43aa3c3e716e0ae614608f::scallop_deep::SCALLOP_DEEP",
    isVerified: !0
  },
  {
    name: "SUIME",
    symbol: "SUIME",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suime.png",
    coinType: "0x934692a74595c4f5a0c026130eb2143eea6fc313742f5d7dd9e45fd6ddbb00f1::suime::SUIME",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x934692a74595c4f5a0c026130eb2143eea6fc313742f5d7dd9e45fd6ddbb00f1::suime::SUIME",
      coin_priority: 610
    }
  },
  {
    name: "dak",
    symbol: "dak",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/JAgm2ztSdQGU5CncYUtNSp4Ce6qtv29nttZKAeQn441S",
    coinType: "0x41636c138167952207c88f5a75e433c9e880bc7bd5e4e46047d82be266d36712::dak::DAK",
    isVerified: !0
  },
  {
    name: "Tocen Token",
    symbol: "TOCE",
    decimals: 9,
    logoURL: "https://ipfs.tocen.co/tocen/toce.png",
    coinType: "0xd2013e206f7983f06132d5b61f7c577638ff63171221f4f600a98863febdfb47::toce::TOCE",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xd2013e206f7983f06132d5b61f7c577638ff63171221f4f600a98863febdfb47::toce::TOCE",
      coin_priority: 650
    }
  },
  {
    name: "sWAL",
    symbol: "sWAL",
    decimals: 9,
    logoURL: "https://demac7qmvo7cyr42swwzpki63in27j35g4b6rropmrwsmiszjbsq.arweave.net/GRgBfgyrvixHmpWtl6ke2huvp303A-jFz2RtJiJZSGU",
    coinType: "0x622345b3f80ea5947567760eec7b9639d0582adcfd6ab9fccb85437aeda7c0d0::scallop_wal::SCALLOP_WAL",
    isVerified: !0
  },
  {
    name: "safSUI",
    symbol: "safSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/3XoP2XumjxAAYDBWRJHhBLSHsLzH4jNnxWF6DB4rfWhN",
    coinType: "0x00671b1fa2a124f5be8bdae8b91ee711462c5d9e31bda232e70fd9607b523c88::scallop_af_sui::SCALLOP_AF_SUI",
    isVerified: !0
  },
  {
    name: "Agent S",
    symbol: "S",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/B1xigsnVycuq7LkED5LybeZ6HhLyU14ZMDffDL4q577D",
    coinType: "0xea65bb5a79ff34ca83e2995f9ff6edd0887b08da9b45bf2e31f930d3efb82866::s::S",
    isVerified: !0
  },
  {
    name: "OceansGallerie",
    symbol: "OCEANS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8a67JLSE8m56kK8bMFFt9HUhpSa1XeGFzSxqdrRcKtjB",
    coinType: "0xe90c71d308d8e6fed933d20f8b94d811e1dac649dac7815762520e90f84392f7::oceans::OCEANS",
    isVerified: !0
  },
  {
    name: "SuiBoxer",
    symbol: "SBOX",
    decimals: 1,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sbox.png",
    coinType: "0xbff8dc60d3f714f678cd4490ff08cabbea95d308c6de47a150c79cc875e0c7c6::sbox::SBOX",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xbff8dc60d3f714f678cd4490ff08cabbea95d308c6de47a150c79cc875e0c7c6::sbox::SBOX",
      coin_priority: 630,
      coingecko_id: "suiboxer"
    }
  },
  {
    name: "Fud The Pug",
    symbol: "FUD",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/fud.png",
    coinType: "0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x76cb819b01abed502bee8a702b4c2d547532c12f25001c9dea795a5e631c26f1::fud::FUD",
      coin_priority: 820,
      pyth_id: "6a4090703da959247727f2b490eb21aea95c8684ecfac675f432008830890c75"
    }
  },
  {
    name: "sBLUB",
    symbol: "sBLUB",
    decimals: 2,
    logoURL: "https://gutxmo5scqefen42iu6ysi5unhdsdenwtcqe2z5hxszz3ssdhzsa.arweave.net/NSd2O7IUCFI3mkU9iSO0acchkbaYoE1np7yzncpDPmQ",
    coinType: "0xe72f65446eabfad2103037af2d49d24599106fb44bf4c046c1e7e9acf6844dd0::scallop_blub::SCALLOP_BLUB",
    isVerified: !0
  },
  {
    name: "Typus",
    symbol: "TYPUS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/CQCvjKXMzASaCMXWx1SyUMa6syFJqtwAaAsAhbzsHGXi",
    coinType: "0xf82dc05634970553615eef6112a1ac4fb7bf10272bf6cbe0f80ef44a6c489385::typus::TYPUS",
    isVerified: !0
  },
  {
    name: "sFUD",
    symbol: "sFUD",
    decimals: 5,
    logoURL: "https://enx3zetzw42z2gpckvye66ljal2vfu63rb2qc5arvq7wof3xdbhq.arweave.net/I2-8knm3NZ0Z4lVwT3lpAvVS09uIdQF0Eaw_Zxd3GE8",
    coinType: "0xe56d5167f427cbe597da9e8150ef5c337839aaf46891d62468dcf80bdd8e10d1::scallop_fud::SCALLOP_FUD",
    isVerified: !0
  },
  {
    name: "shaSUI",
    symbol: "shaSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/8raXDMcjv2y9sV6pXSJkiyw6PXa7B44GRXNzuBBstfQL",
    coinType: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9a2376943f7d22f88087c259c5889925f332ca4347e669dc37d54c2bf651af3c::scallop_ha_sui::SCALLOP_HA_SUI"
    }
  },
  {
    name: "Lorenzo stBTC",
    symbol: "stBTC",
    decimals: 8,
    logoURL: "https://node1.irys.xyz/qg69O3RwWkFt8QG2_GeTh-xGOQEkLbaiPjuU-yDsHqM",
    coinType: "0x5f496ed5d9d045c5b788dc1bb85f54100f2ede11e46f6a232c29daada4c5bdb6::coin::COIN",
    isVerified: !0,
    extensionFields: {
      coingecko_id: "lorenzo-stbtc"
    }
  },
  {
    name: "Suia Token",
    symbol: "SUIA",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suia.png",
    coinType: "0x1d58e26e85fbf9ee8596872686da75544342487f95b1773be3c9a49ab1061b19::suia_token::SUIA_TOKEN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x1d58e26e85fbf9ee8596872686da75544342487f95b1773be3c9a49ab1061b19::suia_token::SUIA_TOKEN",
      coin_priority: 800,
      coingecko_id: "suia"
    }
  },
  {
    name: "Wrapped Matic (Portal from Polygon)",
    symbol: "WMATIC",
    decimals: 8,
    logoURL: "https://fe3wnx45vysrtzfr7kwg4aowt7aqb2tku4szytg2ayfwdyp3jk6q.arweave.net/KTdm352uJRnksfqsbgHWn8EA6mqnJZxM2gYLYeH7Sr0",
    coinType: "0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676::coin::COIN",
      coin_priority: 710,
      coingecko_id: "matic-wormhole",
      labels: ["Wormhole"],
      pyth_id: "5de33a9112c2b700b8d30b8a3402c103578ccfa2765696471cc672bd5cf6ac52"
    }
  },
  {
    name: "Bucket USD",
    symbol: "BUCK",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/buck.png",
    coinType: "0xce7ff77a83ea0cb6fd39bd8748e2ec89a3f41e8efdc3f4eb123e0ca37b184db2::buck::BUCK",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xce7ff77a83ea0cb6fd39bd8748e2ec89a3f41e8efdc3f4eb123e0ca37b184db2::buck::BUCK",
      coin_priority: 920,
      coingecko_id: "bucket-protocol-buck-stablecoin",
      pyth_id: "fdf28a46570252b25fd31cb257973f865afc5ca2f320439e45d95e0394bc7382",
      rank: 900,
      suggested_priority: 900
    }
  },
  {
    name: "CETUS Token",
    symbol: "CETUS",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/cetus.png",
    coinType: "0x06864a6f921804860930db6ddbe2e16acdf8504495ea7481637a1c8b9a8fe54b::cetus::CETUS",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x06864a6f921804860930db6ddbe2e16acdf8504495ea7481637a1c8b9a8fe54b::cetus::CETUS",
      coin_priority: 970,
      coingecko_id: "cetus-protocol",
      pyth_id: "e5b274b2611143df055d6e7cd8d93fe1961716bcd4dca1cad87a83bc1e78c1ef",
      rank: 810,
      suggested_priority: 980
    }
  },
  {
    name: "Ondo US Dollar Yield",
    symbol: "USDY",
    decimals: 6,
    logoURL: "https://66wosxwjgpz7qbv4psulb555d35nxqn6h6jtgu2cxzw4awrbtw3q.arweave.net/96zpXskz8_gGvHyosPe9Hvrbwb4_kzNTQr5twFohnbc",
    coinType: "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
      coin_priority: 880,
      coingecko_id: "ondo-us-dollar-yield",
      pyth_id: "e393449f6aff8a4b6d3e1165a7c9ebec103685f3b41e60db4277b5b6d10e7326",
      rank: 890
    }
  },
  {
    name: "Bluefin",
    symbol: "BLUE",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/CppTxB1NXfoDaJL4cjB6RyzFFwzySRF8zD8t2pBaMy8s",
    coinType: "0xe1b45a0e641b9955a20aa0ad1c1f4ad86aad8afb07296d4085e349a50e90bdca::blue::BLUE",
    isVerified: !0
  },
  {
    name: "swBTC",
    symbol: "swBTC",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/82YqjZLgZo2wjsbktvPnKgAaSrUbkfJuL3zq4GBASjnP",
    coinType: "0x2cf76a9cf5d3337961d1154283234f94da2dcff18544dfe5cbdef65f319591b5::scallop_wormhole_btc::SCALLOP_WORMHOLE_BTC",
    isVerified: !0
  },
  {
    name: "Tether (Celer)",
    symbol: "cUSDT",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/usdt_celer.png",
    coinType: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdt_coin::CELER_USDT_COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x94e7a8e71830d2b34b3edaa195dc24c45d142584f06fa257b73af753d766e690::celer_usdt_coin::CELER_USDT_COIN",
      labels: ["Celer"],
      pyth_id: "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b"
    }
  },
  {
    name: "WEWE",
    symbol: "WEWE",
    decimals: 9,
    logoURL: "https://file-walletapp.waveonsui.com/logos/wewe.png",
    coinType: "0xb5b603827d1bfb2859200fd332d5e139ccac2598f0625de153a87cf78954e0c4::wewe::WEWE",
    isVerified: !0
  },
  {
    name: "sSUI",
    symbol: "sSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/GYmShkpMcYFgSsEcpCEZUPiChhBaFeXMQnFrxxjqZdhE",
    coinType: "0xaafc4f740de0dd0dde642a31148fb94517087052f19afb0f7bed1dc41a50c77b::scallop_sui::SCALLOP_SUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xaafc4f740de0dd0dde642a31148fb94517087052f19afb0f7bed1dc41a50c77b::scallop_sui::SCALLOP_SUI"
    }
  },
  {
    name: "USD Coin (Portal from Arbitrum, New)",
    symbol: "USDCarb",
    decimals: 6,
    logoURL: "https://boqgq74qfqr7gfo4x7tpesefwkzawnbe4e3anop54gwsh3ctfdoa.arweave.net/C6Bof5AsI_MV3L_m8kiFsrILNCThNga5_eGtI-xTKNw",
    coinType: "0xc3f8927de33d3deb52c282a836082a413bc73c6ee0bd4d7ec7e3b6b4c28e9abf::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xc3f8927de33d3deb52c282a836082a413bc73c6ee0bd4d7ec7e3b6b4c28e9abf::coin::COIN",
      coin_priority: 841,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 950
    }
  },
  {
    name: "Meadow",
    symbol: "MED",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/meadow.png",
    coinType: "0x9a7ca7b6de5b6e9a4dadec42fada7cd84068aebd7adbd1faeb713622c4628ca9::meadow::MEADOW",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9a7ca7b6de5b6e9a4dadec42fada7cd84068aebd7adbd1faeb713622c4628ca9::meadow::MEADOW",
      coin_priority: 670,
      coingecko_id: "meadow"
    }
  },
  {
    name: "Tether by Sui Bridge",
    symbol: "suiUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/H6RiSi7PDvKaKCzgsLybW1Pdaq4pvakBHnTvghWD5Kad",
    coinType: "0x375f70cf2ae4c00bf37117d0c85a2c71545e6ee05c4a5c7d282cd66a4504b068::usdt::USDT",
    isVerified: !0,
    extensionFields: {
      coin_priority: 831,
      rank: 931,
      suggested_priority: 990
    }
  },
  {
    name: "BLUB",
    symbol: "BLUB",
    decimals: 2,
    logoURL: "https://453ilwcfza3uzupxtaell2f2acwezft7jynjduuc3skuehtu76pq.arweave.net/53aF2EXIN0zR95gItei6AKxMln9OGpHSgtyVQh50_58",
    coinType: "0xfa7ac3951fdca92c5200d468d31a365eb03b2be9936fde615e69f0c1274ad3a0::BLUB::BLUB",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xfa7ac3951fdca92c5200d468d31a365eb03b2be9936fde615e69f0c1274ad3a0::BLUB::BLUB",
      coin_priority: 821,
      coingecko_id: "blub"
    }
  },
  {
    name: "Pum Pup",
    symbol: "PUP",
    decimals: 9,
    logoURL: "https://res.cetus.zone/coin-metadata/mainnet/icon/pup.png",
    coinType: "0x980ec1e7d5a3d11c95039cab901f02a044df2d82bc79d99b60455c02524fad83::pup::PUP",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x980ec1e7d5a3d11c95039cab901f02a044df2d82bc79d99b60455c02524fad83::pup::PUP"
    }
  },
  {
    name: "sSBETH",
    symbol: "sSBETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/4Zaceo2mJ9SQFKFdoqib1WMjdW1oYkNmTqV8MEsHjCCP",
    coinType: "0xb14f82d8506d139eacef109688d1b71e7236bcce9b2c0ad526abcd6aa5be7de0::scallop_sb_eth::SCALLOP_SB_ETH",
    isVerified: !0
  },
  {
    name: "USD Coin (Portal from Arbitrum, Old)",
    symbol: "USDCarb",
    decimals: 6,
    logoURL: "https://zesrehijzslvuwaf7vplw5qsnhjdz4cpsighhn65watc4fwl22gq.arweave.net/ySUSHQnMl1pYBf1eu3YSadI88E-SDHO33bAmLhbL1o0",
    coinType: "0xe32d3ebafa42e6011b87ef1087bbc6053b499bf6f095807b9013aff5a6ecd7bb::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xe32d3ebafa42e6011b87ef1087bbc6053b499bf6f095807b9013aff5a6ecd7bb::coin::COIN",
      coin_priority: 840,
      coingecko_id: "usd-coin-wormhole-arb",
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 940
    }
  },
  {
    name: "aaa cat",
    symbol: "AAA",
    decimals: 6,
    logoURL: "https://45hgkrkliypqc7rpknvnhhqvsdpk23m2sfphh3vcmqrukddd74la.arweave.net/505lRUtGHwF-L1Nq054VkN6tbZqRXnPuomQjRQxj_xY",
    coinType: "0xd976fda9a9786cda1a36dee360013d775a5e5f206f8e20f84fad3385e99eeb2d::aaa::AAA",
    isVerified: !0
  },
  {
    name: "mETH",
    symbol: "mETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/83AAjCZKyL3VKpxDZG71f4qNWuuqg4uHp4BHVLA3G14e",
    coinType: "0xccd628c2334c5ed33e6c47d6c21bb664f8b6307b2ac32c2462a61f69a31ebcee::meth::METH",
    isVerified: !0
  },
  {
    name: "WAVE",
    symbol: "WAV",
    decimals: 9,
    logoURL: "https://files.waveonsui.com/logos/wav.png",
    coinType: "0x82616322719cb327186d5b83a6d7783ce5cef4c5dbd4c6d1b5f3d6e5d288e2be::wav::WAV",
    isVerified: !0
  },
  {
    name: "PIGU",
    symbol: "PIGU",
    decimals: 5,
    logoURL: "https://idcawqx5x4ziq6wq7xck7wlleckqbzv5jbhqpgbbeynww2kd4pda.arweave.net/QMQLQv2_Moh60P3Er9lrIJUA5r1ITweYISYba2lD48Y",
    coinType: "0xfc71274a94f5d9cd1ae6928ecfc9fa910d03eb28258fddeb9842ac3c7b4f3ae6::pigu::PIGU",
    isVerified: !0
  },
  {
    name: "Tether (Portal from Eth)",
    symbol: "wUSDT",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/DJs8CsKRW4sP5dgi8zfZRWiFXpzNsN3EnUYkQknu4dyd",
    coinType: "0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c::coin::COIN",
      coin_priority: 980,
      coingecko_id: "tether-usd-wormhole-from-ethereum",
      labels: ["Wormhole"],
      pyth_id: "2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b",
      rank: 920
    }
  },
  {
    name: "sMOVE",
    symbol: "sMOVECOIN",
    logoURL: "https://4g7mzcwybmcqsnwiygg4eotqtqkays7y6qyyuycm7tetewing4da.arweave.net/4b7MitgLBQk2yMGNwjpwnBQMS_j0MYpgTPzJMlkNNwY",
    coinType: "0xf925a9e67cbe498c7e5cd87a17fc09692c455b940f065f4b462f885ea196a89d::smove::SMOVE",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xf925a9e67cbe498c7e5cd87a17fc09692c455b940f065f4b462f885ea196a89d::smove::SMOVE",
      coin_priority: 760
    }
  },
  {
    name: "SuiAI",
    symbol: "SUAI",
    decimals: 6,
    logoURL: "https://api.suiai.fun/uploads/suai_logo.png",
    coinType: "0xbc732bc5f1e9a9f4bdf4c0672ee538dbf56c161afe04ff1de2176efabdf41f92::suai::SUAI",
    isVerified: !0
  },
  {
    name: "SuiPad",
    symbol: "SUIP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/suip.png",
    coinType: "0xe4239cd951f6c53d9c41e25270d80d31f925ad1655e5ba5b543843d4a66975ee::SUIP::SUIP",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xe4239cd951f6c53d9c41e25270d80d31f925ad1655e5ba5b543843d4a66975ee::SUIP::SUIP",
      coin_priority: 780,
      coingecko_id: "suipad"
    }
  },
  {
    name: "BULLA",
    symbol: "BULLA",
    decimals: 8,
    logoURL: "https://i.imgur.com/YPFKKZw.jpeg",
    coinType: "0xeec46a9527885ade0b62b984315f2f45d4cd40d9a8c19a553e553e722ab33239::bulla::BULLA",
    isVerified: !0
  },
  {
    name: "Dungeon Gold",
    symbol: "DGG",
    decimals: 6,
    logoURL: "https://h6bzmql5j4nlpj3hiiizzqdmygd7xfbkzcn2gtfy4chmjsmmpdsq.arweave.net/P4OWQX1PGrenZ0IRnMBswYf7lCrIm6NMuOCOxMmMeOU",
    coinType: "0x625d518a3cc78899742d76cf785609cd707e15228d4284aa4fee5ca53caa9849::dgg_token::DGG_TOKEN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x625d518a3cc78899742d76cf785609cd707e15228d4284aa4fee5ca53caa9849::dgg_token::DGG_TOKEN"
    }
  },
  {
    name: "sFDUSD",
    symbol: "sFDUSD",
    decimals: 6,
    logoURL: "https://am6vo2vn4mg2lm7vmajonsipgkat56z75mxe55babpztrbssmb4a.arweave.net/Az1Xaq3jDaWz9WAS5skPMoE--z_rLk70IAvzOIZSYHg",
    coinType: "0x6711551c1e7652a270d9fbf0eee25d99594c157cde3cb5fbb49035eb59b1b001::scallop_fdusd::SCALLOP_FDUSD",
    isVerified: !0
  },
  {
    name: "KDX",
    symbol: "KDX",
    decimals: 6,
    logoURL: "https://i.ibb.co/Wsbch2z/kriya.png",
    coinType: "0x3b68324b392cee9cd28eba82df39860b6b220dc89bdd9b21f675d23d6b7416f1::kdx::KDX",
    isVerified: !0
  },
  {
    name: "LuckyStar",
    symbol: "LUCK",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/luck.png",
    coinType: "0x202591744d54ee4f4af736ef3b8508f3d46d982c36747d9587032bd549122179::luck::LUCK",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x202591744d54ee4f4af736ef3b8508f3d46d982c36747d9587032bd549122179::luck::LUCK",
      coin_priority: 640
    }
  },
  {
    name: "OTTER",
    symbol: "OTTER",
    decimals: 9,
    logoURL: "https://i52dwsbjw2rvuagb4yknsxruq2vwqprdhga6p53ik3co6kzdiwea.arweave.net/R3Q7SCm2o1oAweYU2V40hqtoPiM5gef3aFbE7ysjRYg",
    coinType: "0x297b7f887a47fdcdf82364b5b175c2f00c2ece012c06ec7dc58ee7bc0c63aa07::otter::OTTER",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x297b7f887a47fdcdf82364b5b175c2f00c2ece012c06ec7dc58ee7bc0c63aa07::otter::OTTER",
      coin_priority: 660
    }
  },
  {
    name: "Suiswap",
    symbol: "SSWP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sswp.png",
    coinType: "0x361dd589b98e8fcda9a7ee53b85efabef3569d00416640d2faa516e3801d7ffc::TOKEN::TOKEN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x361dd589b98e8fcda9a7ee53b85efabef3569d00416640d2faa516e3801d7ffc::TOKEN::TOKEN",
      coin_priority: 740
    }
  },
  {
    name: "First Digital USD",
    symbol: "FDUSD",
    decimals: 6,
    logoURL: "https://cdn.1stdigital.com/icon/fdusd.svg",
    coinType: "0xf16e6b723f242ec745dfd7634ad072c42d5c1d9ac9d62a39c381303eaa57693a::fdusd::FDUSD",
    isVerified: !0,
    extensionFields: {
      coin_priority: 971,
      pyth_id: "ccdc1a08923e2e4f4b1e6ea89de6acbc5fe1948e9706f5604b8cb50bc1ed3979"
    }
  },
  {
    name: "Dripward",
    symbol: "DRIP",
    decimals: 9,
    logoURL: "https://gh63r3fltrhlf22hh6722j667hyk546aycyevlmody46swnzh5da.arweave.net/Mf247KucTrLrRz-_rSfe-fCu88DAsEqtjh456Vm5P0Y",
    coinType: "0x9eed28fc98688a799fe51aa6ed39b851bd09d950fc785b2d7c9f543796254631::drip::DRIP",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9eed28fc98688a799fe51aa6ed39b851bd09d950fc785b2d7c9f543796254631::drip::DRIP"
    }
  },
  {
    name: "superSUI",
    symbol: "superSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/TAKkVW5fTxDGTTgM22eFNEQX2V6JbLuN2ckBtFybrix",
    coinType: "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x790f258062909e3a0ffc78b3c53ac2f62d7084c3bab95644bdeb05add7250001::super_sui::SUPER_SUI"
    }
  },
  {
    name: "SuiNS Token",
    symbol: "NS",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/FRs7eLL3B5eABDW3hG5xwtaATaU4x8fEZm9V5z8GdFYr",
    coinType: "0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178::ns::NS",
    isVerified: !0
  },
  {
    name: "ARTFI",
    symbol: "ARTFI",
    decimals: 9,
    logoURL: "https://rao3tdm6qnrnk3z6tga4jsnn5ufuapmlqoffpatiqligyjb2vnga.arweave.net/iB25jZ6DYtVvPpmBxMmt7QtAPYuDileCaILQbCQ6q0w",
    coinType: "0x706fa7723231e13e8d37dad56da55c027f3163094aa31c867ca254ba0e0dc79f::artfi::ARTFI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x706fa7723231e13e8d37dad56da55c027f3163094aa31c867ca254ba0e0dc79f::artfi::ARTFI",
      coingecko_id: "artfi"
    }
  },
  {
    name: "sCETUS",
    symbol: "sCETUS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/FfmvsmthhRiAaBwY8nZjx8uavV2ySs7USgn5xamsxFf5",
    coinType: "0xea346ce428f91ab007210443efcea5f5cdbbb3aae7e9affc0ca93f9203c31f0c::scallop_cetus::SCALLOP_CETUS",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xea346ce428f91ab007210443efcea5f5cdbbb3aae7e9affc0ca93f9203c31f0c::scallop_cetus::SCALLOP_CETUS"
    }
  },
  {
    name: "Sacabam",
    symbol: "SCB",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/scb.png",
    coinType: "0x9a5502414b5d51d01c8b5641db7436d789fa15a245694b24aa37c25c2a6ce001::scb::SCB",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9a5502414b5d51d01c8b5641db7436d789fa15a245694b24aa37c25c2a6ce001::scb::SCB",
      coin_priority: 730,
      coingecko_id: "sacabam"
    }
  },
  {
    name: "Pearl",
    symbol: "PRL",
    decimals: 12,
    logoURL: "https://archive.cetus.zone/assets/image/sui/pearl.png",
    coinType: "0x4e56b39acd75721999cf833062dfb77b1d51e749b02d90f049a5688e21919a64::prl::PRL",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x4e56b39acd75721999cf833062dfb77b1d51e749b02d90f049a5688e21919a64::prl::PRL"
    }
  },
  {
    name: "Pyth Network",
    symbol: "PYTH",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/pyth.png",
    coinType: "0x9c6d76eb273e6b5ba2ec8d708b7fa336a5531f6be59f326b5be8d4d8b12348a4::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9c6d76eb273e6b5ba2ec8d708b7fa336a5531f6be59f326b5be8d4d8b12348a4::coin::COIN",
      coin_priority: 810,
      pyth_id: "0bbf28e9a841a1cc788f6a361b17ca072d0ea3098a1e5df1c3922d06719579ff"
    }
  },
  {
    name: "LOOPY",
    symbol: "LOOPY",
    decimals: 6,
    logoURL: "https://lk47si3fdmkhszxbmzuksrg5gcbum5rbnudnjd7cnzxor7g2cd7a.arweave.net/Wrn5I2UbFHlm4WZoqUTdMINGdiFtBtSP4m5u6PzaEP4",
    coinType: "0x9b9c0e26a8ace7edb8fce14acd81507c507c677a400cfb9cc9a0ca4a8432a97a::loopy_sui::LOOPY_SUI",
    isVerified: !0
  },
  {
    name: "JWLSCA",
    symbol: "JWLSCA",
    decimals: 9,
    logoURL: "https://ocknifrosvx5vmpte2zavnpv7fpkauqsqu5tij43iy5shxdle6ha.arweave.net/cJTUFi6Vb9qx8yayCrX1-V6gUhKFOzQnm0Y7I9xrJ44",
    coinType: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlsca::JWLSCA",
    isVerified: !0
  },
  {
    name: "JWLSUI",
    symbol: "JWLSUI",
    decimals: 9,
    logoURL: "https://bwxyokyoypcv4zjesyqn6gnjfopzohnrcv2lqwdvcccgahccintq.arweave.net/Da-HKw7DxV5lJJYg3xmpK5-XHbEVdLhYdRCEYBxCQ2c",
    coinType: "0x2921ca2fe6ee99698b095f046bc9759ce7a764d2e91ab0ad182c143649c3df79::jwlsui::JWLSUI",
    isVerified: !0
  },
  {
    name: "SLOVE",
    symbol: "SLOVE",
    decimals: 6,
    logoURL: "https://ipfs.io/ipfs/bafkreigt2pvpzokflugamigupuwo3xfw3agg3xcfuiduqpv3j6hfooh65a",
    coinType: "0x6dd439dee053557b3dd340287a4b81099b3e729cb48fbdae726dd2dff82736c3::slove::SLOVE",
    isVerified: !0
  },
  {
    name: "FroggnRatt",
    symbol: "FRATT",
    decimals: 2,
    logoURL: "https://xatontgesaqf7cfeboedtsik7xnnz2wespeifbf3igqzifiqi6fa.arweave.net/uCbmzMSQIF-IpAuIOckK_drc6sSTyIKEu0GhlBUQR4o",
    coinType: "0x31348f17429e6b37ed269cc667cc83947ff8c54593dcbd1a56cae06a895a38be::fratt::FRATT",
    isVerified: !0
  },
  {
    name: "Aftermath Staked SUI",
    symbol: "afSUI",
    decimals: 9,
    logoURL: "https://aftermath.finance/coins/afsui.svg",
    coinType: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xf325ce1300e8dac124071d3152c5c5ee6174914f8bc2161e88329cf579246efc::afsui::AFSUI",
      coin_priority: 909,
      pyth_id: "17cd845b16e874485b2684f8b8d1517d744105dbb904eec30222717f4bc9ee0d",
      rank: 850
    }
  },
  {
    name: "JWLCETUS",
    symbol: "JWLCETUS",
    decimals: 9,
    logoURL: "https://t3d7i5s4u6ntxge7nqkwjnfnyswrk22ymd4utk4qmaxlh7zofgyq.arweave.net/nsf0dlynmzuYn2wVZLStxK0Va1hg-UmrkGAus_8uKbE",
    coinType: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlcetus::JWLCETUS",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x0e25582daef54ee41052390c4db5e70a82ec1baed97942db0eb6094267624b5d::jwlcetus::JWLCETUS"
    }
  },
  {
    name: "SUI Token",
    symbol: "SUI",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/sui.png",
    coinType: "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x2::sui::SUI",
      coin_priority: 1e3,
      coingecko_id: "sui",
      pyth_id: "23d7315113f5b1d3ba7a83604c44b94d79f4fd69af77f804fc7f920a6dc65744",
      rank: 880,
      suggested_priority: 1e3
    }
  },
  {
    name: "LOFI",
    symbol: "LOFI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/GqFLYxhLNuKYbSYCVJrjqnARisqogKhggngtYg9sZ9uw",
    coinType: "0xf22da9a24ad027cccb5f2d496cbe91de953d363513db08a3a734d361c7c17503::LOFI::LOFI",
    isVerified: !0
  },
  {
    name: "Sonic Snipe Bot",
    symbol: "Sonic",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/E82DQkogizAv1CYi8nbgWydVx49DHy42qSRzksMx4iwx",
    coinType: "0x555f3aa7c9c60ca67f906557777fab78fd70a302da7d66a23fcb4f8808d15010::sonic::SONIC",
    isVerified: !0
  },
  {
    name: "Sui Plop",
    symbol: "PLOP",
    decimals: 6,
    logoURL: "https://fj74jg6iknyhnkkajybduxndrgvp3r7lklyjnlj7w2cvflsc574a.arweave.net/Kn_Em8hTcHapQE4COl2jiar9x-tS8JatP7aFUq5C7_g",
    coinType: "0x1c6cd615ed4c42a34977212a3407a28eec21acc572c8dbe7d0382bf0289a2590::plop::PLOP",
    isVerified: !0
  },
  {
    name: "WAL Token",
    symbol: "WAL",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/7dgjqChkGXxmhFvqR5AWP4vWUs8hNiJpe9Cw7K4x7GP2",
    coinType: "0x356a26eb9e012a68958082340d4c4116e7f55615cf27affcff209cf0ae544f59::wal::WAL",
    isVerified: !0,
    extensionFields: {
      suggested_priority: 904
    }
  },
  {
    name: "Native USDC",
    symbol: "USDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/EGpc2cG886CrWwLMneF2RyVpZ7D33a6znz6XE8n8nU7h",
    coinType: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
    isVerified: !0,
    extensionFields: {
      coin_priority: 991,
      coingecko_id: "usd-coin",
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 1e3,
      suggested_priority: 991
    }
  },
  {
    name: "STASH",
    symbol: "STASH",
    decimals: 9,
    logoURL: "https://7kyn2qaielikddp6kpi7dtriubzemb2pthesca33bxsxskusunhq.arweave.net/-rDdQAgi0KGN_lPR8c4ooHJGB0-ZySEDew3leSqSo08",
    coinType: "0x2cff601fe16f622fd6203f8f64bef4e68d687f51f4d06f13c2bbba17cb84c87e::stash::STASH",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x2cff601fe16f622fd6203f8f64bef4e68d687f51f4d06f13c2bbba17cb84c87e::stash::STASH"
    }
  },
  {
    name: "swETH",
    symbol: "swETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/J1Ni98whDmtXgtGYDmk7Hy6qfoHas9MJYwMnixgDSdNo",
    coinType: "0x67540ceb850d418679e69f1fb6b2093d6df78a2a699ffc733f7646096d552e9b::scallop_wormhole_eth::SCALLOP_WORMHOLE_ETH",
    isVerified: !0
  },
  {
    name: "meow",
    symbol: "meow",
    decimals: 6,
    logoURL: "https://g2eop2adggvbnllpabicghum55pai3bt23c5yvo3c5gohtix6fma.arweave.net/Nojn6AMxqhatbwBQIx6M714EbDPWxdxV2xdM480X8Vg",
    coinType: "0x06b145d0322e389d6225f336ab57bba4c67e4e701bd6c6bc959d90675900a17e::meow::MEOW",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x06b145d0322e389d6225f336ab57bba4c67e4e701bd6c6bc959d90675900a17e::meow::MEOW"
    }
  },
  {
    name: "SUI TRUMP",
    symbol: "SUITRUMP",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/9Q89LeyqhQSDGun24w1PYZC6zZ4KTGhCPDC2rJpQieY1",
    coinType: "0xdeb831e796f16f8257681c0d5d4108fa94333060300b2459133a96631bf470b8::suitrump::SUITRUMP",
    isVerified: !0
  },
  {
    name: "Wrapped BTC (Portal from Eth)",
    symbol: "WBTC",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/dNcUM18WoBxiGE55MrQVgt9kZ7yho9WbyJWa8NbSxDH",
    coinType: "0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881::coin::COIN",
      coin_priority: 890,
      coingecko_id: "wrapped-btc-wormhole",
      labels: ["Wormhole"],
      pyth_id: "e62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43",
      rank: 790
    }
  },
  {
    name: "Releap",
    symbol: "REAP",
    decimals: 9,
    logoURL: "https://archive.cetus.zone/assets/image/sui/reap.png",
    coinType: "0xde2d3e02ba60b806f81ee9220be2a34932a513fe8d7f553167649e95de21c066::reap_token::REAP_TOKEN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xde2d3e02ba60b806f81ee9220be2a34932a513fe8d7f553167649e95de21c066::reap_token::REAP_TOKEN",
      coin_priority: 750
    }
  },
  {
    name: "ETH by Sui Bridge",
    symbol: "ETH",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/435auUGaKQ3FAT7CZnegmvNNJnbuRc7aSkwTTDJ5JmNw",
    coinType: "0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH",
    isVerified: !0,
    extensionFields: {
      coin_priority: 941,
      coingecko_id: "ethereum",
      pyth_id: "ff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace",
      rank: 780,
      suggested_priority: 890
    }
  },
  {
    name: "BonkCoin (Portal from Solana)",
    symbol: "BONK",
    decimals: 5,
    logoURL: "https://3dgyzd2llawd2e6monsrlnrj4ijs3n3zkno37khmqcfbfjquvknq.arweave.net/2M2Mj0tYLD0TzHNlFbYp4hMtt3lTXb-o7ICKEqYUqps",
    coinType: "0x6907963ca849faff0957b9a8269a7a07065e3def2eef49cc33b50ab946ea5a9f::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x6907963ca849faff0957b9a8269a7a07065e3def2eef49cc33b50ab946ea5a9f::coin::COIN",
      coin_priority: 680,
      labels: ["Wormhole"],
      pyth_id: "72b021217ca3fe68922a19aaf990109cb9d84e9ad004b4d2025ad6f529314419"
    }
  },
  {
    name: "SroomAI DAO",
    symbol: "SHR0",
    decimals: 9,
    logoURL: "https://suidaos.com/logo/shro.png",
    coinType: "0x16ab6a14d76a90328a6b04f06b0a0ce952847017023624e0c37bf8aa314c39ba::shr::SHR",
    isVerified: !0
  },
  {
    name: "USD Coin (Portal from Polygon)",
    symbol: "USDCpol",
    decimals: 6,
    logoURL: "https://otjatct2scltanet7e7untvl3lx4kccddwx5pusxqr6a2pd3qe5a.arweave.net/dNIJinqQlzA0k_k_Rs6r2u_FCEMdr9fSV4R8DTx7gTo",
    coinType: "0xcf72ec52c0f8ddead746252481fb44ff6e8485a39b803825bde6b00d77cdb0bb::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xcf72ec52c0f8ddead746252481fb44ff6e8485a39b803825bde6b00d77cdb0bb::coin::COIN",
      coin_priority: 850,
      labels: ["Wormhole"],
      pyth_id: "eaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a",
      rank: 960
    }
  },
  {
    name: "AlphaFi Staked SUI",
    symbol: "stSUI",
    decimals: 9,
    logoURL: "https://images.alphafi.xyz/stSUI.png",
    coinType: "0xd1b72982e40348d069bb1ff701e634c117bb5f741f44dff91e472d3b01461e55::stsui::STSUI",
    isVerified: !0
  },
  {
    name: "FLAMINGO GRINGO",
    symbol: "FLAMINGO",
    decimals: 6,
    logoURL: "https://oggdkiqjw4niipp2w7r2ooeujubnhynevxkdwlqlqzqnrb7lufwa.arweave.net/cYw1Igm3GoQ9-rfjpziUTQLT4aSt1DsuC4Zg2IfroWw",
    coinType: "0x17c334979cd0698ccf9450a3ec2ae0ce1e4c6b0935353fe5facbf69fa77a72af::flamingo::FLAMINGO",
    isVerified: !0
  },
  {
    name: "AUSD",
    symbol: "AUSD",
    decimals: 6,
    logoURL: "https://qele7wvrqjkzonp2egfsagymxbgrewy7adtywuxng4tmpdaycfxa.arweave.net/gRZP2rGCVZc1-iGLIBsMuE0SWx8A54tS7Tcmx4wYEW4",
    coinType: "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
      coin_priority: 822,
      coingecko_id: "agora-dollar",
      rank: 910
    }
  },
  {
    name: "Chirp Token",
    symbol: "CHIRP",
    decimals: 10,
    logoURL: "https://download.chirpwireless.io/images/CHIRP_White_OBG.svg",
    coinType: "0x1ef4c0b20340b8c6a59438204467ca71e1e7cbe918526f9c2c6c5444517cd5ca::chirp::CHIRP",
    isVerified: !0
  },
  {
    name: "pSTAKE Finance",
    symbol: "PSTAKE",
    decimals: 8,
    logoURL: "https://gateway.irys.xyz/3iYkJnAE2Kt14r6DoRvbbntbdVRjBt9LAURH4DTKmmrb",
    coinType: "0x61017ce4bd0b75b266af53edd60bbe391ba1a9fbe9a7d8553657c94ef73ee2ab::coin::COIN",
    isVerified: !0
  },
  {
    name: "xAIFRENS",
    symbol: "xAIFRENS",
    logoURL: "https://archive.cetus.zone/assets/image/sui/xAIFRENS.png",
    coinType: "0x9fe1780ac27ec50c9c441fb31822f5c148f841f09ee455c6a0daf7c634a30a27::aifrens::AIFRENS",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9fe1780ac27ec50c9c441fb31822f5c148f841f09ee455c6a0daf7c634a30a27::aifrens::AIFRENS",
      coin_priority: 620
    }
  },
  {
    name: "Tardi",
    symbol: "TARDI",
    decimals: 9,
    logoURL: "https://bafybeieycjagqv7xtenzxss5xkcxgeru7wql6izhzokr4ay4xdbrul4ef4.ipfs.w3s.link",
    coinType: "0x4cf08813756dfa7519cb480a1a1a3472b5b4ec067592a8bee0f826808d218158::tardi::TARDI",
    isVerified: !0
  },
  {
    name: "Turbos",
    symbol: "TURBOS",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/4ov3eH2cE4B4DzTsSLmAQNnnmo8zc5MRSFR6wcN4XyLU",
    coinType: "0x5d1f47ea69bb0de31c313d7acf89b890dbb8991ea8e03c6c355171f84bb1ba4a::turbos::TURBOS",
    isVerified: !0
  },
  {
    name: "sudeng",
    symbol: "HIPPO",
    decimals: 9,
    logoURL: "https://i.imgur.com/j2EuFh5.png",
    coinType: "0x8993129d72e733985f7f1a00396cbd055bad6f817fee36576ce483c8bbb8b87b::sudeng::SUDENG",
    isVerified: !0
  },
  {
    name: "Liquor",
    symbol: "LIQ",
    decimals: 6,
    logoURL: "https://cehaawdywth4eyp6isj3vmv3ie2g5s3x4w36u3yrl6ytjeqcnulq.arweave.net/EQ4AWHi0z8Jh_kSTurK7QTRuy3flt-pvEV-xNJICbRc",
    coinType: "0x9c86d1926a0a39e906f20674d6a35f337be8625ebcb6b799ee8ff011f328bee2::liq::LIQ",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x9c86d1926a0a39e906f20674d6a35f337be8625ebcb6b799ee8ff011f328bee2::liq::LIQ"
    }
  },
  {
    name: "Uni",
    symbol: "Uni",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/HK51s6xHPbFRHjHjTLna5XyypW5Yk94c1zjok822FJ88",
    coinType: "0xaf9e228fd0292e2a27b4859bc57a2f3a9faedb9341b6307c84fef163e44790cc::uni::UNI",
    isVerified: !0
  },
  {
    name: "Kriya Staked SUI",
    symbol: "kSUI",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/HdCzDMJeQ6zE5LPFrknSXBkZityS1KZX2SzC1isZn6Ey",
    coinType: "0x41ff228bfd566f0c707173ee6413962a77e3929588d010250e4e76f0d1cc0ad4::ksui::KSUI",
    isVerified: !0
  },
  {
    name: "Pugwifhat",
    symbol: "PUGWIF",
    decimals: 9,
    logoURL: "https://2fqoiyw7ewk4ecchpakhk5rr4brbfy7abyidgjw6cphzlgg464ba.arweave.net/0WDkYt8llcIIR3gUdXYx4GIS4-AOEDMm3hPPlZjc9wI",
    coinType: "0x2cd6f14a4b64c3a0fa9c644e8ed88d9c91d789a071886d67d24e6b435147063d::pugwif::PUGWIF",
    isVerified: !0
  },
  {
    name: "swUSDC",
    symbol: "swUSDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/29eNJ7Qu9B5CDy8Gr58TxtR8QWUKPN2XWsVYK9cLr4Zu",
    coinType: "0xad4d71551d31092230db1fd482008ea42867dbf27b286e9c70a79d2a6191d58d::scallop_wormhole_usdc::SCALLOP_WORMHOLE_USDC",
    isVerified: !0
  },
  {
    name: "awww~~~awww",
    symbol: "awww",
    decimals: 9,
    logoURL: "https://gateway.irys.xyz/9GnzhvzZsXdpZPGV7YH4nEwaYogYdWTVV8Y2JYGgqmJf",
    coinType: "0x594b539e0020ca22f83e9a8f55c1fede4c5730130d5b100fcf01f98ddb4f94c8::awww::AWWW",
    isVerified: !0
  },
  {
    name: "KIMCHI",
    symbol: "KIMCHI",
    decimals: 5,
    logoURL: "https://archive.cetus.zone/assets/image/sui/kimchi.png",
    coinType: "0xb6baa75577e4bbffba70207651824606e51d38ae23aa94fb9fb700e0ecf50064::kimchi::KIMCHI",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xb6baa75577e4bbffba70207651824606e51d38ae23aa94fb9fb700e0ecf50064::kimchi::KIMCHI",
      coin_priority: 600
    }
  },
  {
    name: "AXOL",
    symbol: "AXOL",
    decimals: 9,
    logoURL: "https://p7op7v4f4nub263xmrqch45p32rkeclriobps4v6nrut5g7q464q.arweave.net/f9z_14XjaB17d2RgI_Ov3qKiCXFDgvlyvmxpPpvw57k",
    coinType: "0xae00e078a46616bf6e1e6fb673d18dcd2aa31319a07c9bc92f6063363f597b4e::AXOL::AXOL",
    isVerified: !0
  },
  {
    name: "sUSDC",
    symbol: "sUSDC",
    decimals: 6,
    logoURL: "https://gateway.irys.xyz/29eNJ7Qu9B5CDy8Gr58TxtR8QWUKPN2XWsVYK9cLr4Zu",
    coinType: "0x854950aa624b1df59fe64e630b2ba7c550642e9342267a33061d59fb31582da5::scallop_usdc::SCALLOP_USDC",
    isVerified: !0
  },
  {
    name: "Wrapped Bitcoin by Sui Bridge",
    symbol: "wBTC",
    decimals: 9,
    logoURL: "https://bridge-assets.sui.io/suiWBTC.png",
    coinType: "0xaafb102dd0902f5055cadecd687fb5b71ca82ef0e0285d90afde828ec58ca96b::btc::BTC",
    isVerified: !0,
    extensionFields: {
      coin_priority: 889,
      suggested_priority: 880
    }
  },
  {
    name: "Lombard Staked BTC",
    symbol: "LBTC",
    decimals: 8,
    logoURL: "https://www.lombard.finance/lbtc/LBTC.png",
    projectURL: "https://www.lombard.finance/",
    coinType: "0x3e8e9423d80e1774a7ca128fccd8bf5f1f7753be658c5e645929037f7c819040::lbtc::LBTC",
    isVerified: !0,
    extensionFields: {
      pyth_id: "8f257aab6e7698bb92b15511915e593d6f8eae914452f781874754b03d0c612b"
    }
  },
  {
    name: "xWSB on SUI",
    symbol: "WSB",
    decimals: 6,
    logoURL: "https://api.movepump.com/uploads/asui_4106b1fb1d.jpg",
    coinType: "0x4db126eac4fa99207e98db61d968477021fdeae153de3b244bcfbdc468ef0722::wsb::WSB",
    isVerified: !0
  },
  {
    name: "MOVER USD",
    symbol: "moverUSD",
    decimals: 6,
    logoURL: "https://archive.cetus.zone/assets/image/sui/moverUSD.png",
    coinType: "0x32d5056aaac1be1f9ae44c1d0728792255a05f1475d458287ee463cc26806ca0::mover_usd::MOVER_USD",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0x32d5056aaac1be1f9ae44c1d0728792255a05f1475d458287ee463cc26806ca0::mover_usd::MOVER_USD",
      coin_priority: 570
    }
  },
  {
    name: "Wrapped BNB (Portal from BSC)",
    symbol: "WBNB",
    decimals: 8,
    logoURL: "https://4hl5riddvifwsfzqzggti3dyrekvhogjvwkaduy5w5bgs2k7zwga.arweave.net/4dfYoGOqC2kXMMmNNGx4iRVTuMmtlAHTHbdCaWlfzYw",
    coinType: "0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f::coin::COIN",
    isVerified: !0,
    extensionFields: {
      birdeyeid: "0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f::coin::COIN",
      coin_priority: 700,
      coingecko_id: "binance-coin-wormhole",
      labels: ["Wormhole"],
      pyth_id: "2f95862b045670cd22bee3114c39763a4a08beeb663b145d283c31d7d1101c4f",
      rank: 760
    }
  }
];
function th() {
  return {
    fetchByApi: async (t, r, n, i) => {
      try {
        return r === "GET" ? await yW(`${i || lc.api}${t}`, n) : await vW(`${i || lc.api}${t}`, n);
      } catch (s) {
        throw s;
      }
    }
  };
}
function yb(e, t) {
  return {
    id: e.id || void 0,
    logo_url: e.iconUrl || void 0,
    coin_type: t,
    decimals: e.decimals,
    description: e.description,
    name: e.name,
    symbol: e.symbol
  };
}
function Pl(e) {
  var t;
  return {
    // ...token,
    is_trusted: !!(e != null && e.isVerified) || (e == null ? void 0 : e.is_trusted),
    coin_type: jr((e == null ? void 0 : e.coinType) || (e == null ? void 0 : e.coin_type)).full_address,
    logo_url: (e == null ? void 0 : e.logoURL) || (e == null ? void 0 : e.logo_url) || "",
    decimals: e == null ? void 0 : e.decimals,
    symbol: e == null ? void 0 : e.symbol,
    name: e == null ? void 0 : e.name,
    labels: ((t = e == null ? void 0 : e.extensionFields) == null ? void 0 : t.labels) || (e == null ? void 0 : e.labels)
  };
}
function $c() {
  const { suiClient: e } = Fo(), { fetchByApi: t } = th();
  ka();
  const {
    setTokenMap: r,
    tokenMap: n,
    setToken: i,
    requestTokenList: s,
    addRequestTokenList: o,
    setTrustedTokenList: a
  } = Pc(), c = async () => {
    var C;
    let b = [];
    try {
      const O = await t("/v3/sui/clmm/verified_coins_info", "GET");
      if (!(O != null && O.list) || ((C = O == null ? void 0 : O.list) == null ? void 0 : C.length) === 0)
        throw Error("api no trust tokens data");
      b = O == null ? void 0 : O.list;
    } catch {
      b = WW;
    }
    const y = [], S = b == null ? void 0 : b.reduce((O, I) => (O.set(I.coinType || I.coin_type, Pl(I)), (I.isVerified || I != null && I.is_trusted) && y.push(Pl(I)), O), /* @__PURE__ */ new Map());
    S && (S.get(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
    ) && !S.get("0x2::sui::SUI") ? S.set("0x2::sui::SUI", {
      ...S.get(
        "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
      ),
      coin_type: "0x2::sui::SUI"
    }) : !S.get(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
    ) && S.get("0x2::sui::SUI") && S.set(
      "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
      {
        ...S.get("0x2::sui::SUI"),
        coin_type: "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI"
      }
    ), r(new Map([...n, ...S])), a(y));
  }, u = async (b) => {
    var O;
    if ((b == null ? void 0 : b.length) === 0)
      return;
    const y = await t("/v3/sui/clmm/coins_info", "POST", {
      coinTypes: b
    }), S = (O = y == null ? void 0 : y.data) == null ? void 0 : O.list, C = S == null ? void 0 : S.reduce((I, U) => (I.set(U.coinType, Pl(U)), I), /* @__PURE__ */ new Map());
    return r(new Map([...n, ...C])), C;
  }, l = async (b) => {
    var y, S, C, O;
    try {
      if (!b)
        return;
      let I = b;
      b === "0x2::sui::SUI" && (I = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI");
      const U = await t("/v3/sui/clmm/coins_info", "POST", {
        coinTypes: [I]
      });
      if ((S = (y = U == null ? void 0 : U.data) == null ? void 0 : y.list) != null && S[0]) {
        const D = Pl((O = (C = U == null ? void 0 : U.data) == null ? void 0 : C.list) == null ? void 0 : O[0]);
        return i(D), D;
      }
      throw Error("api no this coin types");
    } catch (I) {
      console.error(" ~ getTokenInfo ~ 57:", I);
    }
  }, f = async (b) => {
    try {
      const y = h(b);
      if (y)
        return y;
      if (s.includes(b))
        return;
      o(b);
      try {
        const S = await l(b);
        if (S)
          return S;
        throw Error("api return is null");
      } catch {
        const C = await e.getCoinMetadata({ coinType: b });
        if (C) {
          Q0(b) && (C.iconUrl = "https://archive.cetus.zone/assets/image/sui/sui.png");
          const O = yb(C, b);
          return i(O), O;
        }
      }
    } catch {
    }
  }, h = Ii(
    (b) => {
      if (b)
        return n.get(jr(b).full_address) || n.get(b);
    },
    [n]
  );
  return {
    getTrustTokens: c,
    fetchTokenInfo: f,
    getTokenInfo: h,
    getTokens: u,
    getTokenListInfo: async (b) => {
      try {
        if (b && b.length > 0) {
          const y = /* @__PURE__ */ new Map(), S = [];
          for (const C of b) {
            const O = h(C);
            O ? y.set(C, O) : S.push(C);
          }
          if (S.length > 0) {
            const C = await u(S);
            C && C.forEach((O, I) => {
              y.set(I, O);
              const U = S.indexOf(I);
              U > -1 && S.splice(U, 1);
            });
          }
          if (S.length > 0)
            for (const C of S)
              try {
                const O = await e.getCoinMetadata({ coinType: C });
                if (O) {
                  Q0(C) && (O.iconUrl = "https://archive.cetus.zone/assets/image/sui/sui.png");
                  const I = yb(O, C);
                  y.set(C, I), i(I);
                }
              } catch {
              }
          return y;
        }
        return;
      } catch {
        return;
      }
    }
  };
}
const Tn = Qs((e, t) => ({
  accounts: [],
  currentAccount: void 0,
  isOpenWalletModal: !1,
  saveCurrentAccount: (r) => {
    e({
      currentAccount: r
    });
  },
  saveAccounts: (r) => {
    e({
      accounts: r
    });
  },
  onWalletModal: (r) => {
    e({
      isOpenWalletModal: r
    });
  },
  isOpenAccountList: !1,
  setIsOpenAccountList: (r) => {
    e(() => ({
      isOpenAccountList: r
    }));
  },
  tokenBalanceObj: {},
  setTokenBalanceObj: (r) => {
    e(() => ({
      tokenBalanceObj: r
    }));
  },
  accountServiceNameObj: {},
  setAccountServiceNameObj: (r) => {
    const n = t().accountServiceNameObj;
    e({
      accountServiceNameObj: { ...n, ...r }
    });
  }
})), xf = (e, t) => {
  if (!(e != null && e.totalBalance) || t === void 0 || t === null)
    return;
  const r = dW(e.totalBalance, t == null ? void 0 : t.decimals), n = jn(r, 4);
  return {
    ...t,
    displayBalance: n,
    totalBalanceFormat: r
  };
};
function $u(e) {
  const { suiClient: t } = Fo(), { currentAccount: r, setTokenBalanceObj: n, tokenBalanceObj: i } = Tn();
  $c();
  const [s, o] = Mt([]), a = async (l = (r == null ? void 0 : r.address) || "", f) => {
    try {
      if (!l) {
        c();
        return;
      }
      let h = [];
      f ? h = [await t.getBalance({
        owner: l,
        coinType: f
      })] : h = [...await t.getAllBalances({
        owner: l
      })], o(h);
      const v = {};
      h.forEach((b) => {
        v[jr(b.coinType).full_address] = b;
      }), n(v);
    } catch {
      o([]);
    }
  }, c = () => {
    n({});
  }, u = Ft(() => {
    const l = e == null ? void 0 : e.coin_type;
    if (l && r) {
      const f = i[l] || i[jr(l).full_address];
      return f ? xf(f, e) : void 0;
    }
  }, [e == null ? void 0 : e.coin_type, i, r]);
  return {
    getOwnerCoinBalances: a,
    balanceInfo: u
  };
}
var Z5 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, n(a)));
      }
      return s;
    }
    function n(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return r.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var o = "";
      for (var a in s)
        t.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? s ? s + " " + o : s + o : s;
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(Z5);
var qW = Z5.exports;
const br = /* @__PURE__ */ Yu(qW);
function xt(e, t, { checkForDefaultPrevented: r = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), r === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function vb(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function rh(...e) {
  return (t) => {
    let r = !1;
    const n = e.map((i) => {
      const s = vb(i, t);
      return !r && typeof s == "function" && (r = !0), s;
    });
    if (r)
      return () => {
        for (let i = 0; i < n.length; i++) {
          const s = n[i];
          typeof s == "function" ? s() : vb(e[i], null);
        }
      };
  };
}
function ar(...e) {
  return R.useCallback(rh(...e), e);
}
function eo(e, t = []) {
  let r = [];
  function n(s, o) {
    const a = R.createContext(o), c = r.length;
    r = [...r, o];
    const u = (f) => {
      var C;
      const { scope: h, children: v, ...b } = f, y = ((C = h == null ? void 0 : h[e]) == null ? void 0 : C[c]) || a, S = R.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ _.jsx(y.Provider, { value: S, children: v });
    };
    u.displayName = s + "Provider";
    function l(f, h) {
      var y;
      const v = ((y = h == null ? void 0 : h[e]) == null ? void 0 : y[c]) || a, b = R.useContext(v);
      if (b)
        return b;
      if (o !== void 0)
        return o;
      throw new Error(`\`${f}\` must be used within \`${s}\``);
    }
    return [u, l];
  }
  const i = () => {
    const s = r.map((o) => R.createContext(o));
    return function(a) {
      const c = (a == null ? void 0 : a[e]) || s;
      return R.useMemo(
        () => ({ [`__scope${e}`]: { ...a, [e]: c } }),
        [a, c]
      );
    };
  };
  return i.scopeName = e, [n, HW(i, ...t)];
}
function HW(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const r = () => {
    const n = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const o = n.reduce((a, { useScope: c, scopeName: u }) => {
        const f = c(s)[`__scope${u}`];
        return { ...a, ...f };
      }, {});
      return R.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return r.scopeName = t.scopeName, r;
}
// @__NO_SIDE_EFFECTS__
function Du(e) {
  const t = /* @__PURE__ */ GW(e), r = R.forwardRef((n, i) => {
    const { children: s, ...o } = n, a = R.Children.toArray(s), c = a.find(KW);
    if (c) {
      const u = c.props.children, l = a.map((f) => f === c ? R.Children.count(u) > 1 ? R.Children.only(null) : R.isValidElement(u) ? u.props.children : null : f);
      return /* @__PURE__ */ _.jsx(t, { ...o, ref: i, children: R.isValidElement(u) ? R.cloneElement(u, void 0, l) : null });
    }
    return /* @__PURE__ */ _.jsx(t, { ...o, ref: i, children: s });
  });
  return r.displayName = `${e}.Slot`, r;
}
var y1 = /* @__PURE__ */ Du("Slot");
// @__NO_SIDE_EFFECTS__
function GW(e) {
  const t = R.forwardRef((r, n) => {
    const { children: i, ...s } = r;
    if (R.isValidElement(i)) {
      const o = XW(i), a = YW(s, i.props);
      return i.type !== R.Fragment && (a.ref = n ? rh(n, o) : o), R.cloneElement(i, a);
    }
    return R.Children.count(i) > 1 ? R.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Q5 = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function e7(e) {
  const t = ({ children: r }) => /* @__PURE__ */ _.jsx(_.Fragment, { children: r });
  return t.displayName = `${e}.Slottable`, t.__radixId = Q5, t;
}
var nh = /* @__PURE__ */ e7("Slottable");
function KW(e) {
  return R.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Q5;
}
function YW(e, t) {
  const r = { ...t };
  for (const n in t) {
    const i = e[n], s = t[n];
    /^on[A-Z]/.test(n) ? i && s ? r[n] = (...a) => {
      const c = s(...a);
      return i(...a), c;
    } : i && (r[n] = i) : n === "style" ? r[n] = { ...i, ...s } : n === "className" && (r[n] = [i, s].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function XW(e) {
  var n, i;
  let t = (n = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : n.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
var JW = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], nr = JW.reduce((e, t) => {
  const r = /* @__PURE__ */ Du(`Primitive.${t}`), n = R.forwardRef((i, s) => {
    const { asChild: o, ...a } = i, c = o ? r : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ _.jsx(c, { ...a, ref: s });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function t7(e, t) {
  e && zw.flushSync(() => e.dispatchEvent(t));
}
function en(e) {
  const t = R.useRef(e);
  return R.useEffect(() => {
    t.current = e;
  }), R.useMemo(() => (...r) => {
    var n;
    return (n = t.current) == null ? void 0 : n.call(t, ...r);
  }, []);
}
function ZW(e, t = globalThis == null ? void 0 : globalThis.document) {
  const r = en(e);
  R.useEffect(() => {
    const n = (i) => {
      i.key === "Escape" && r(i);
    };
    return t.addEventListener("keydown", n, { capture: !0 }), () => t.removeEventListener("keydown", n, { capture: !0 });
  }, [r, t]);
}
var QW = "DismissableLayer", cm = "dismissableLayer.update", eq = "dismissableLayer.pointerDownOutside", tq = "dismissableLayer.focusOutside", bb, r7 = R.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), v1 = R.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: n,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: o,
      onDismiss: a,
      ...c
    } = e, u = R.useContext(r7), [l, f] = R.useState(null), h = (l == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, v] = R.useState({}), b = ar(t, (z) => f(z)), y = Array.from(u.layers), [S] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), C = y.indexOf(S), O = l ? y.indexOf(l) : -1, I = u.layersWithOutsidePointerEventsDisabled.size > 0, U = O >= C, D = iq((z) => {
      const ne = z.target, le = [...u.branches].some((te) => te.contains(ne));
      !U || le || (i == null || i(z), o == null || o(z), z.defaultPrevented || a == null || a());
    }, h), H = sq((z) => {
      const ne = z.target;
      [...u.branches].some((te) => te.contains(ne)) || (s == null || s(z), o == null || o(z), z.defaultPrevented || a == null || a());
    }, h);
    return ZW((z) => {
      O === u.layers.size - 1 && (n == null || n(z), !z.defaultPrevented && a && (z.preventDefault(), a()));
    }, h), R.useEffect(() => {
      if (l)
        return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (bb = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(l)), u.layers.add(l), wb(), () => {
          r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = bb);
        };
    }, [l, h, r, u]), R.useEffect(() => () => {
      l && (u.layers.delete(l), u.layersWithOutsidePointerEventsDisabled.delete(l), wb());
    }, [l, u]), R.useEffect(() => {
      const z = () => v({});
      return document.addEventListener(cm, z), () => document.removeEventListener(cm, z);
    }, []), /* @__PURE__ */ _.jsx(
      nr.div,
      {
        ...c,
        ref: b,
        style: {
          pointerEvents: I ? U ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: xt(e.onFocusCapture, H.onFocusCapture),
        onBlurCapture: xt(e.onBlurCapture, H.onBlurCapture),
        onPointerDownCapture: xt(
          e.onPointerDownCapture,
          D.onPointerDownCapture
        )
      }
    );
  }
);
v1.displayName = QW;
var rq = "DismissableLayerBranch", nq = R.forwardRef((e, t) => {
  const r = R.useContext(r7), n = R.useRef(null), i = ar(t, n);
  return R.useEffect(() => {
    const s = n.current;
    if (s)
      return r.branches.add(s), () => {
        r.branches.delete(s);
      };
  }, [r.branches]), /* @__PURE__ */ _.jsx(nr.div, { ...e, ref: i });
});
nq.displayName = rq;
function iq(e, t = globalThis == null ? void 0 : globalThis.document) {
  const r = en(e), n = R.useRef(!1), i = R.useRef(() => {
  });
  return R.useEffect(() => {
    const s = (a) => {
      if (a.target && !n.current) {
        let c = function() {
          n7(
            eq,
            r,
            u,
            { discrete: !0 }
          );
        };
        const u = { originalEvent: a };
        a.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      n.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", s), t.removeEventListener("click", i.current);
    };
  }, [t, r]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n.current = !0
  };
}
function sq(e, t = globalThis == null ? void 0 : globalThis.document) {
  const r = en(e), n = R.useRef(!1);
  return R.useEffect(() => {
    const i = (s) => {
      s.target && !n.current && n7(tq, r, { originalEvent: s }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, r]), {
    onFocusCapture: () => n.current = !0,
    onBlurCapture: () => n.current = !1
  };
}
function wb() {
  const e = new CustomEvent(cm);
  document.dispatchEvent(e);
}
function n7(e, t, r, { discrete: n }) {
  const i = r.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: r });
  t && i.addEventListener(e, t, { once: !0 }), n ? t7(i, s) : i.dispatchEvent(s);
}
var Gs = globalThis != null && globalThis.document ? R.useLayoutEffect : () => {
}, oq = R[" useId ".trim().toString()] || (() => {
}), aq = 0;
function Lu(e) {
  const [t, r] = R.useState(oq());
  return Gs(() => {
    e || r((n) => n ?? String(aq++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const cq = ["top", "right", "bottom", "left"], $o = Math.min, Fn = Math.max, cd = Math.round, Nl = Math.floor, ss = (e) => ({
  x: e,
  y: e
}), uq = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, lq = {
  start: "end",
  end: "start"
};
function um(e, t, r) {
  return Fn(e, $o(t, r));
}
function Ks(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Ys(e) {
  return e.split("-")[0];
}
function Dc(e) {
  return e.split("-")[1];
}
function b1(e) {
  return e === "x" ? "y" : "x";
}
function w1(e) {
  return e === "y" ? "height" : "width";
}
const fq = /* @__PURE__ */ new Set(["top", "bottom"]);
function ts(e) {
  return fq.has(Ys(e)) ? "y" : "x";
}
function _1(e) {
  return b1(ts(e));
}
function dq(e, t, r) {
  r === void 0 && (r = !1);
  const n = Dc(e), i = _1(e), s = w1(i);
  let o = i === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = ud(o)), [o, ud(o)];
}
function hq(e) {
  const t = ud(e);
  return [lm(e), t, lm(t)];
}
function lm(e) {
  return e.replace(/start|end/g, (t) => lq[t]);
}
const _b = ["left", "right"], xb = ["right", "left"], pq = ["top", "bottom"], mq = ["bottom", "top"];
function gq(e, t, r) {
  switch (e) {
    case "top":
    case "bottom":
      return r ? t ? xb : _b : t ? _b : xb;
    case "left":
    case "right":
      return t ? pq : mq;
    default:
      return [];
  }
}
function yq(e, t, r, n) {
  const i = Dc(e);
  let s = gq(Ys(e), r === "start", n);
  return i && (s = s.map((o) => o + "-" + i), t && (s = s.concat(s.map(lm)))), s;
}
function ud(e) {
  return e.replace(/left|right|bottom|top/g, (t) => uq[t]);
}
function vq(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function i7(e) {
  return typeof e != "number" ? vq(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function ld(e) {
  const {
    x: t,
    y: r,
    width: n,
    height: i
  } = e;
  return {
    width: n,
    height: i,
    top: r,
    left: t,
    right: t + n,
    bottom: r + i,
    x: t,
    y: r
  };
}
function Sb(e, t, r) {
  let {
    reference: n,
    floating: i
  } = e;
  const s = ts(t), o = _1(t), a = w1(o), c = Ys(t), u = s === "y", l = n.x + n.width / 2 - i.width / 2, f = n.y + n.height / 2 - i.height / 2, h = n[a] / 2 - i[a] / 2;
  let v;
  switch (c) {
    case "top":
      v = {
        x: l,
        y: n.y - i.height
      };
      break;
    case "bottom":
      v = {
        x: l,
        y: n.y + n.height
      };
      break;
    case "right":
      v = {
        x: n.x + n.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: n.x - i.width,
        y: f
      };
      break;
    default:
      v = {
        x: n.x,
        y: n.y
      };
  }
  switch (Dc(t)) {
    case "start":
      v[o] -= h * (r && u ? -1 : 1);
      break;
    case "end":
      v[o] += h * (r && u ? -1 : 1);
      break;
  }
  return v;
}
const bq = async (e, t, r) => {
  const {
    placement: n = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = r, a = s.filter(Boolean), c = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let u = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: l,
    y: f
  } = Sb(u, n, c), h = n, v = {}, b = 0;
  for (let y = 0; y < a.length; y++) {
    const {
      name: S,
      fn: C
    } = a[y], {
      x: O,
      y: I,
      data: U,
      reset: D
    } = await C({
      x: l,
      y: f,
      initialPlacement: n,
      placement: h,
      strategy: i,
      middlewareData: v,
      rects: u,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    l = O ?? l, f = I ?? f, v = {
      ...v,
      [S]: {
        ...v[S],
        ...U
      }
    }, D && b <= 50 && (b++, typeof D == "object" && (D.placement && (h = D.placement), D.rects && (u = D.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : D.rects), {
      x: l,
      y: f
    } = Sb(u, h, c)), y = -1);
  }
  return {
    x: l,
    y: f,
    placement: h,
    strategy: i,
    middlewareData: v
  };
};
async function Bu(e, t) {
  var r;
  t === void 0 && (t = {});
  const {
    x: n,
    y: i,
    platform: s,
    rects: o,
    elements: a,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: l = "viewport",
    elementContext: f = "floating",
    altBoundary: h = !1,
    padding: v = 0
  } = Ks(t, e), b = i7(v), S = a[h ? f === "floating" ? "reference" : "floating" : f], C = ld(await s.getClippingRect({
    element: (r = await (s.isElement == null ? void 0 : s.isElement(S))) == null || r ? S : S.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: l,
    strategy: c
  })), O = f === "floating" ? {
    x: n,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, I = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), U = await (s.isElement == null ? void 0 : s.isElement(I)) ? await (s.getScale == null ? void 0 : s.getScale(I)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, D = ld(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: O,
    offsetParent: I,
    strategy: c
  }) : O);
  return {
    top: (C.top - D.top + b.top) / U.y,
    bottom: (D.bottom - C.bottom + b.bottom) / U.y,
    left: (C.left - D.left + b.left) / U.x,
    right: (D.right - C.right + b.right) / U.x
  };
}
const wq = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: r,
      y: n,
      placement: i,
      rects: s,
      platform: o,
      elements: a,
      middlewareData: c
    } = t, {
      element: u,
      padding: l = 0
    } = Ks(e, t) || {};
    if (u == null)
      return {};
    const f = i7(l), h = {
      x: r,
      y: n
    }, v = _1(i), b = w1(v), y = await o.getDimensions(u), S = v === "y", C = S ? "top" : "left", O = S ? "bottom" : "right", I = S ? "clientHeight" : "clientWidth", U = s.reference[b] + s.reference[v] - h[v] - s.floating[b], D = h[v] - s.reference[v], H = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(u));
    let z = H ? H[I] : 0;
    (!z || !await (o.isElement == null ? void 0 : o.isElement(H))) && (z = a.floating[I] || s.floating[b]);
    const ne = U / 2 - D / 2, le = z / 2 - y[b] / 2 - 1, te = $o(f[C], le), ce = $o(f[O], le), V = te, L = z - y[b] - ce, p = z / 2 - y[b] / 2 + ne, d = um(V, p, L), m = !c.arrow && Dc(i) != null && p !== d && s.reference[b] / 2 - (p < V ? te : ce) - y[b] / 2 < 0, x = m ? p < V ? p - V : p - L : 0;
    return {
      [v]: h[v] + x,
      data: {
        [v]: d,
        centerOffset: p - d - x,
        ...m && {
          alignmentOffset: x
        }
      },
      reset: m
    };
  }
}), _q = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var r, n;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: c,
        elements: u
      } = t, {
        mainAxis: l = !0,
        crossAxis: f = !0,
        fallbackPlacements: h,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: y = !0,
        ...S
      } = Ks(e, t);
      if ((r = s.arrow) != null && r.alignmentOffset)
        return {};
      const C = Ys(i), O = ts(a), I = Ys(a) === a, U = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), D = h || (I || !y ? [ud(a)] : hq(a)), H = b !== "none";
      !h && H && D.push(...yq(a, y, b, U));
      const z = [a, ...D], ne = await Bu(t, S), le = [];
      let te = ((n = s.flip) == null ? void 0 : n.overflows) || [];
      if (l && le.push(ne[C]), f) {
        const p = dq(i, o, U);
        le.push(ne[p[0]], ne[p[1]]);
      }
      if (te = [...te, {
        placement: i,
        overflows: le
      }], !le.every((p) => p <= 0)) {
        var ce, V;
        const p = (((ce = s.flip) == null ? void 0 : ce.index) || 0) + 1, d = z[p];
        if (d && (!(f === "alignment" ? O !== ts(d) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        te.every((E) => ts(E.placement) === O ? E.overflows[0] > 0 : !0)))
          return {
            data: {
              index: p,
              overflows: te
            },
            reset: {
              placement: d
            }
          };
        let m = (V = te.filter((x) => x.overflows[0] <= 0).sort((x, E) => x.overflows[1] - E.overflows[1])[0]) == null ? void 0 : V.placement;
        if (!m)
          switch (v) {
            case "bestFit": {
              var L;
              const x = (L = te.filter((E) => {
                if (H) {
                  const A = ts(E.placement);
                  return A === O || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  A === "y";
                }
                return !0;
              }).map((E) => [E.placement, E.overflows.filter((A) => A > 0).reduce((A, j) => A + j, 0)]).sort((E, A) => E[1] - A[1])[0]) == null ? void 0 : L[0];
              x && (m = x);
              break;
            }
            case "initialPlacement":
              m = a;
              break;
          }
        if (i !== m)
          return {
            reset: {
              placement: m
            }
          };
      }
      return {};
    }
  };
};
function Eb(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Tb(e) {
  return cq.some((t) => e[t] >= 0);
}
const xq = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: r
      } = t, {
        strategy: n = "referenceHidden",
        ...i
      } = Ks(e, t);
      switch (n) {
        case "referenceHidden": {
          const s = await Bu(t, {
            ...i,
            elementContext: "reference"
          }), o = Eb(s, r.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: Tb(o)
            }
          };
        }
        case "escaped": {
          const s = await Bu(t, {
            ...i,
            altBoundary: !0
          }), o = Eb(s, r.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: Tb(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, s7 = /* @__PURE__ */ new Set(["left", "top"]);
async function Sq(e, t) {
  const {
    placement: r,
    platform: n,
    elements: i
  } = e, s = await (n.isRTL == null ? void 0 : n.isRTL(i.floating)), o = Ys(r), a = Dc(r), c = ts(r) === "y", u = s7.has(o) ? -1 : 1, l = s && c ? -1 : 1, f = Ks(t, e);
  let {
    mainAxis: h,
    crossAxis: v,
    alignmentAxis: b
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return a && typeof b == "number" && (v = a === "end" ? b * -1 : b), c ? {
    x: v * l,
    y: h * u
  } : {
    x: h * u,
    y: v * l
  };
}
const Eq = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var r, n;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: a
      } = t, c = await Sq(t, e);
      return o === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: i + c.x,
        y: s + c.y,
        data: {
          ...c,
          placement: o
        }
      };
    }
  };
}, Tq = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: r,
        y: n,
        placement: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (S) => {
            let {
              x: C,
              y: O
            } = S;
            return {
              x: C,
              y: O
            };
          }
        },
        ...c
      } = Ks(e, t), u = {
        x: r,
        y: n
      }, l = await Bu(t, c), f = ts(Ys(i)), h = b1(f);
      let v = u[h], b = u[f];
      if (s) {
        const S = h === "y" ? "top" : "left", C = h === "y" ? "bottom" : "right", O = v + l[S], I = v - l[C];
        v = um(O, v, I);
      }
      if (o) {
        const S = f === "y" ? "top" : "left", C = f === "y" ? "bottom" : "right", O = b + l[S], I = b - l[C];
        b = um(O, b, I);
      }
      const y = a.fn({
        ...t,
        [h]: v,
        [f]: b
      });
      return {
        ...y,
        data: {
          x: y.x - r,
          y: y.y - n,
          enabled: {
            [h]: s,
            [f]: o
          }
        }
      };
    }
  };
}, Cq = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: r,
        y: n,
        placement: i,
        rects: s,
        middlewareData: o
      } = t, {
        offset: a = 0,
        mainAxis: c = !0,
        crossAxis: u = !0
      } = Ks(e, t), l = {
        x: r,
        y: n
      }, f = ts(i), h = b1(f);
      let v = l[h], b = l[f];
      const y = Ks(a, t), S = typeof y == "number" ? {
        mainAxis: y,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...y
      };
      if (c) {
        const I = h === "y" ? "height" : "width", U = s.reference[h] - s.floating[I] + S.mainAxis, D = s.reference[h] + s.reference[I] - S.mainAxis;
        v < U ? v = U : v > D && (v = D);
      }
      if (u) {
        var C, O;
        const I = h === "y" ? "width" : "height", U = s7.has(Ys(i)), D = s.reference[f] - s.floating[I] + (U && ((C = o.offset) == null ? void 0 : C[f]) || 0) + (U ? 0 : S.crossAxis), H = s.reference[f] + s.reference[I] + (U ? 0 : ((O = o.offset) == null ? void 0 : O[f]) || 0) - (U ? S.crossAxis : 0);
        b < D ? b = D : b > H && (b = H);
      }
      return {
        [h]: v,
        [f]: b
      };
    }
  };
}, Aq = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var r, n;
      const {
        placement: i,
        rects: s,
        platform: o,
        elements: a
      } = t, {
        apply: c = () => {
        },
        ...u
      } = Ks(e, t), l = await Bu(t, u), f = Ys(i), h = Dc(i), v = ts(i) === "y", {
        width: b,
        height: y
      } = s.floating;
      let S, C;
      f === "top" || f === "bottom" ? (S = f, C = h === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (C = f, S = h === "end" ? "top" : "bottom");
      const O = y - l.top - l.bottom, I = b - l.left - l.right, U = $o(y - l[S], O), D = $o(b - l[C], I), H = !t.middlewareData.shift;
      let z = U, ne = D;
      if ((r = t.middlewareData.shift) != null && r.enabled.x && (ne = I), (n = t.middlewareData.shift) != null && n.enabled.y && (z = O), H && !h) {
        const te = Fn(l.left, 0), ce = Fn(l.right, 0), V = Fn(l.top, 0), L = Fn(l.bottom, 0);
        v ? ne = b - 2 * (te !== 0 || ce !== 0 ? te + ce : Fn(l.left, l.right)) : z = y - 2 * (V !== 0 || L !== 0 ? V + L : Fn(l.top, l.bottom));
      }
      await c({
        ...t,
        availableWidth: ne,
        availableHeight: z
      });
      const le = await o.getDimensions(a.floating);
      return b !== le.width || y !== le.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ih() {
  return typeof window < "u";
}
function Lc(e) {
  return o7(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Wn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function ds(e) {
  var t;
  return (t = (o7(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function o7(e) {
  return ih() ? e instanceof Node || e instanceof Wn(e).Node : !1;
}
function ki(e) {
  return ih() ? e instanceof Element || e instanceof Wn(e).Element : !1;
}
function ls(e) {
  return ih() ? e instanceof HTMLElement || e instanceof Wn(e).HTMLElement : !1;
}
function Cb(e) {
  return !ih() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Wn(e).ShadowRoot;
}
const Mq = /* @__PURE__ */ new Set(["inline", "contents"]);
function pl(e) {
  const {
    overflow: t,
    overflowX: r,
    overflowY: n,
    display: i
  } = ji(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + r) && !Mq.has(i);
}
const Oq = /* @__PURE__ */ new Set(["table", "td", "th"]);
function Iq(e) {
  return Oq.has(Lc(e));
}
const kq = [":popover-open", ":modal"];
function sh(e) {
  return kq.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const jq = ["transform", "translate", "scale", "rotate", "perspective"], Rq = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Pq = ["paint", "layout", "strict", "content"];
function x1(e) {
  const t = S1(), r = ki(e) ? ji(e) : e;
  return jq.some((n) => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !t && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !t && (r.filter ? r.filter !== "none" : !1) || Rq.some((n) => (r.willChange || "").includes(n)) || Pq.some((n) => (r.contain || "").includes(n));
}
function Nq(e) {
  let t = Do(e);
  for (; ls(t) && !wc(t); ) {
    if (x1(t))
      return t;
    if (sh(t))
      return null;
    t = Do(t);
  }
  return null;
}
function S1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const $q = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function wc(e) {
  return $q.has(Lc(e));
}
function ji(e) {
  return Wn(e).getComputedStyle(e);
}
function oh(e) {
  return ki(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Do(e) {
  if (Lc(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Cb(e) && e.host || // Fallback.
    ds(e)
  );
  return Cb(t) ? t.host : t;
}
function a7(e) {
  const t = Do(e);
  return wc(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ls(t) && pl(t) ? t : a7(t);
}
function Uu(e, t, r) {
  var n;
  t === void 0 && (t = []), r === void 0 && (r = !0);
  const i = a7(e), s = i === ((n = e.ownerDocument) == null ? void 0 : n.body), o = Wn(i);
  if (s) {
    const a = fm(o);
    return t.concat(o, o.visualViewport || [], pl(i) ? i : [], a && r ? Uu(a) : []);
  }
  return t.concat(i, Uu(i, [], r));
}
function fm(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function c7(e) {
  const t = ji(e);
  let r = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const i = ls(e), s = i ? e.offsetWidth : r, o = i ? e.offsetHeight : n, a = cd(r) !== s || cd(n) !== o;
  return a && (r = s, n = o), {
    width: r,
    height: n,
    $: a
  };
}
function E1(e) {
  return ki(e) ? e : e.contextElement;
}
function fc(e) {
  const t = E1(e);
  if (!ls(t))
    return ss(1);
  const r = t.getBoundingClientRect(), {
    width: n,
    height: i,
    $: s
  } = c7(t);
  let o = (s ? cd(r.width) : r.width) / n, a = (s ? cd(r.height) : r.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const Dq = /* @__PURE__ */ ss(0);
function u7(e) {
  const t = Wn(e);
  return !S1() || !t.visualViewport ? Dq : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Lq(e, t, r) {
  return t === void 0 && (t = !1), !r || t && r !== Wn(e) ? !1 : t;
}
function Sa(e, t, r, n) {
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  const i = e.getBoundingClientRect(), s = E1(e);
  let o = ss(1);
  t && (n ? ki(n) && (o = fc(n)) : o = fc(e));
  const a = Lq(s, r, n) ? u7(s) : ss(0);
  let c = (i.left + a.x) / o.x, u = (i.top + a.y) / o.y, l = i.width / o.x, f = i.height / o.y;
  if (s) {
    const h = Wn(s), v = n && ki(n) ? Wn(n) : n;
    let b = h, y = fm(b);
    for (; y && n && v !== b; ) {
      const S = fc(y), C = y.getBoundingClientRect(), O = ji(y), I = C.left + (y.clientLeft + parseFloat(O.paddingLeft)) * S.x, U = C.top + (y.clientTop + parseFloat(O.paddingTop)) * S.y;
      c *= S.x, u *= S.y, l *= S.x, f *= S.y, c += I, u += U, b = Wn(y), y = fm(b);
    }
  }
  return ld({
    width: l,
    height: f,
    x: c,
    y: u
  });
}
function ah(e, t) {
  const r = oh(e).scrollLeft;
  return t ? t.left + r : Sa(ds(e)).left + r;
}
function l7(e, t) {
  const r = e.getBoundingClientRect(), n = r.left + t.scrollLeft - ah(e, r), i = r.top + t.scrollTop;
  return {
    x: n,
    y: i
  };
}
function Bq(e) {
  let {
    elements: t,
    rect: r,
    offsetParent: n,
    strategy: i
  } = e;
  const s = i === "fixed", o = ds(n), a = t ? sh(t.floating) : !1;
  if (n === o || a && s)
    return r;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, u = ss(1);
  const l = ss(0), f = ls(n);
  if ((f || !f && !s) && ((Lc(n) !== "body" || pl(o)) && (c = oh(n)), ls(n))) {
    const v = Sa(n);
    u = fc(n), l.x = v.x + n.clientLeft, l.y = v.y + n.clientTop;
  }
  const h = o && !f && !s ? l7(o, c) : ss(0);
  return {
    width: r.width * u.x,
    height: r.height * u.y,
    x: r.x * u.x - c.scrollLeft * u.x + l.x + h.x,
    y: r.y * u.y - c.scrollTop * u.y + l.y + h.y
  };
}
function Uq(e) {
  return Array.from(e.getClientRects());
}
function Fq(e) {
  const t = ds(e), r = oh(e), n = e.ownerDocument.body, i = Fn(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), s = Fn(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let o = -r.scrollLeft + ah(e);
  const a = -r.scrollTop;
  return ji(n).direction === "rtl" && (o += Fn(t.clientWidth, n.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: a
  };
}
const Ab = 25;
function Vq(e, t) {
  const r = Wn(e), n = ds(e), i = r.visualViewport;
  let s = n.clientWidth, o = n.clientHeight, a = 0, c = 0;
  if (i) {
    s = i.width, o = i.height;
    const l = S1();
    (!l || l && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop);
  }
  const u = ah(n);
  if (u <= 0) {
    const l = n.ownerDocument, f = l.body, h = getComputedStyle(f), v = l.compatMode === "CSS1Compat" && parseFloat(h.marginLeft) + parseFloat(h.marginRight) || 0, b = Math.abs(n.clientWidth - f.clientWidth - v);
    b <= Ab && (s -= b);
  } else
    u <= Ab && (s += u);
  return {
    width: s,
    height: o,
    x: a,
    y: c
  };
}
const zq = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Wq(e, t) {
  const r = Sa(e, !0, t === "fixed"), n = r.top + e.clientTop, i = r.left + e.clientLeft, s = ls(e) ? fc(e) : ss(1), o = e.clientWidth * s.x, a = e.clientHeight * s.y, c = i * s.x, u = n * s.y;
  return {
    width: o,
    height: a,
    x: c,
    y: u
  };
}
function Mb(e, t, r) {
  let n;
  if (t === "viewport")
    n = Vq(e, r);
  else if (t === "document")
    n = Fq(ds(e));
  else if (ki(t))
    n = Wq(t, r);
  else {
    const i = u7(e);
    n = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return ld(n);
}
function f7(e, t) {
  const r = Do(e);
  return r === t || !ki(r) || wc(r) ? !1 : ji(r).position === "fixed" || f7(r, t);
}
function qq(e, t) {
  const r = t.get(e);
  if (r)
    return r;
  let n = Uu(e, [], !1).filter((a) => ki(a) && Lc(a) !== "body"), i = null;
  const s = ji(e).position === "fixed";
  let o = s ? Do(e) : e;
  for (; ki(o) && !wc(o); ) {
    const a = ji(o), c = x1(o);
    !c && a.position === "fixed" && (i = null), (s ? !c && !i : !c && a.position === "static" && !!i && zq.has(i.position) || pl(o) && !c && f7(e, o)) ? n = n.filter((l) => l !== o) : i = a, o = Do(o);
  }
  return t.set(e, n), n;
}
function Hq(e) {
  let {
    element: t,
    boundary: r,
    rootBoundary: n,
    strategy: i
  } = e;
  const o = [...r === "clippingAncestors" ? sh(t) ? [] : qq(t, this._c) : [].concat(r), n], a = o[0], c = o.reduce((u, l) => {
    const f = Mb(t, l, i);
    return u.top = Fn(f.top, u.top), u.right = $o(f.right, u.right), u.bottom = $o(f.bottom, u.bottom), u.left = Fn(f.left, u.left), u;
  }, Mb(t, a, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function Gq(e) {
  const {
    width: t,
    height: r
  } = c7(e);
  return {
    width: t,
    height: r
  };
}
function Kq(e, t, r) {
  const n = ls(t), i = ds(t), s = r === "fixed", o = Sa(e, !0, s, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = ss(0);
  function u() {
    c.x = ah(i);
  }
  if (n || !n && !s)
    if ((Lc(t) !== "body" || pl(i)) && (a = oh(t)), n) {
      const v = Sa(t, !0, s, t);
      c.x = v.x + t.clientLeft, c.y = v.y + t.clientTop;
    } else
      i && u();
  s && !n && i && u();
  const l = i && !n && !s ? l7(i, a) : ss(0), f = o.left + a.scrollLeft - c.x - l.x, h = o.top + a.scrollTop - c.y - l.y;
  return {
    x: f,
    y: h,
    width: o.width,
    height: o.height
  };
}
function Rp(e) {
  return ji(e).position === "static";
}
function Ob(e, t) {
  if (!ls(e) || ji(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let r = e.offsetParent;
  return ds(e) === r && (r = r.ownerDocument.body), r;
}
function d7(e, t) {
  const r = Wn(e);
  if (sh(e))
    return r;
  if (!ls(e)) {
    let i = Do(e);
    for (; i && !wc(i); ) {
      if (ki(i) && !Rp(i))
        return i;
      i = Do(i);
    }
    return r;
  }
  let n = Ob(e, t);
  for (; n && Iq(n) && Rp(n); )
    n = Ob(n, t);
  return n && wc(n) && Rp(n) && !x1(n) ? r : n || Nq(e) || r;
}
const Yq = async function(e) {
  const t = this.getOffsetParent || d7, r = this.getDimensions, n = await r(e.floating);
  return {
    reference: Kq(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function Xq(e) {
  return ji(e).direction === "rtl";
}
const Jq = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Bq,
  getDocumentElement: ds,
  getClippingRect: Hq,
  getOffsetParent: d7,
  getElementRects: Yq,
  getClientRects: Uq,
  getDimensions: Gq,
  getScale: fc,
  isElement: ki,
  isRTL: Xq
};
function h7(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function Zq(e, t) {
  let r = null, n;
  const i = ds(e);
  function s() {
    var a;
    clearTimeout(n), (a = r) == null || a.disconnect(), r = null;
  }
  function o(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), s();
    const u = e.getBoundingClientRect(), {
      left: l,
      top: f,
      width: h,
      height: v
    } = u;
    if (a || t(), !h || !v)
      return;
    const b = Nl(f), y = Nl(i.clientWidth - (l + h)), S = Nl(i.clientHeight - (f + v)), C = Nl(l), I = {
      rootMargin: -b + "px " + -y + "px " + -S + "px " + -C + "px",
      threshold: Fn(0, $o(1, c)) || 1
    };
    let U = !0;
    function D(H) {
      const z = H[0].intersectionRatio;
      if (z !== c) {
        if (!U)
          return o();
        z ? o(!1, z) : n = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      z === 1 && !h7(u, e.getBoundingClientRect()) && o(), U = !1;
    }
    try {
      r = new IntersectionObserver(D, {
        ...I,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      r = new IntersectionObserver(D, I);
    }
    r.observe(e);
  }
  return o(!0), s;
}
function Qq(e, t, r, n) {
  n === void 0 && (n = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = n, u = E1(e), l = i || s ? [...u ? Uu(u) : [], ...Uu(t)] : [];
  l.forEach((C) => {
    i && C.addEventListener("scroll", r, {
      passive: !0
    }), s && C.addEventListener("resize", r);
  });
  const f = u && a ? Zq(u, r) : null;
  let h = -1, v = null;
  o && (v = new ResizeObserver((C) => {
    let [O] = C;
    O && O.target === u && v && (v.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      var I;
      (I = v) == null || I.observe(t);
    })), r();
  }), u && !c && v.observe(u), v.observe(t));
  let b, y = c ? Sa(e) : null;
  c && S();
  function S() {
    const C = Sa(e);
    y && !h7(y, C) && r(), y = C, b = requestAnimationFrame(S);
  }
  return r(), () => {
    var C;
    l.forEach((O) => {
      i && O.removeEventListener("scroll", r), s && O.removeEventListener("resize", r);
    }), f == null || f(), (C = v) == null || C.disconnect(), v = null, c && cancelAnimationFrame(b);
  };
}
const eH = Eq, tH = Tq, rH = _q, nH = Aq, iH = xq, Ib = wq, sH = Cq, oH = (e, t, r) => {
  const n = /* @__PURE__ */ new Map(), i = {
    platform: Jq,
    ...r
  }, s = {
    ...i.platform,
    _c: n
  };
  return bq(e, t, {
    ...i,
    platform: s
  });
};
var aH = typeof document < "u", cH = function() {
}, Sf = aH ? Vw : cH;
function fd(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let r, n, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (r = e.length, r !== t.length)
        return !1;
      for (n = r; n-- !== 0; )
        if (!fd(e[n], t[n]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), r = i.length, r !== Object.keys(t).length)
      return !1;
    for (n = r; n-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[n]))
        return !1;
    for (n = r; n-- !== 0; ) {
      const s = i[n];
      if (!(s === "_owner" && e.$$typeof) && !fd(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function p7(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function kb(e, t) {
  const r = p7(e);
  return Math.round(t * r) / r;
}
function Pp(e) {
  const t = R.useRef(e);
  return Sf(() => {
    t.current = e;
  }), t;
}
function uH(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: r = "absolute",
    middleware: n = [],
    platform: i,
    elements: {
      reference: s,
      floating: o
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: u
  } = e, [l, f] = R.useState({
    x: 0,
    y: 0,
    strategy: r,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [h, v] = R.useState(n);
  fd(h, n) || v(n);
  const [b, y] = R.useState(null), [S, C] = R.useState(null), O = R.useCallback((E) => {
    E !== H.current && (H.current = E, y(E));
  }, []), I = R.useCallback((E) => {
    E !== z.current && (z.current = E, C(E));
  }, []), U = s || b, D = o || S, H = R.useRef(null), z = R.useRef(null), ne = R.useRef(l), le = c != null, te = Pp(c), ce = Pp(i), V = Pp(u), L = R.useCallback(() => {
    if (!H.current || !z.current)
      return;
    const E = {
      placement: t,
      strategy: r,
      middleware: h
    };
    ce.current && (E.platform = ce.current), oH(H.current, z.current, E).then((A) => {
      const j = {
        ...A,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: V.current !== !1
      };
      p.current && !fd(ne.current, j) && (ne.current = j, zw.flushSync(() => {
        f(j);
      }));
    });
  }, [h, t, r, ce, V]);
  Sf(() => {
    u === !1 && ne.current.isPositioned && (ne.current.isPositioned = !1, f((E) => ({
      ...E,
      isPositioned: !1
    })));
  }, [u]);
  const p = R.useRef(!1);
  Sf(() => (p.current = !0, () => {
    p.current = !1;
  }), []), Sf(() => {
    if (U && (H.current = U), D && (z.current = D), U && D) {
      if (te.current)
        return te.current(U, D, L);
      L();
    }
  }, [U, D, L, te, le]);
  const d = R.useMemo(() => ({
    reference: H,
    floating: z,
    setReference: O,
    setFloating: I
  }), [O, I]), m = R.useMemo(() => ({
    reference: U,
    floating: D
  }), [U, D]), x = R.useMemo(() => {
    const E = {
      position: r,
      left: 0,
      top: 0
    };
    if (!m.floating)
      return E;
    const A = kb(m.floating, l.x), j = kb(m.floating, l.y);
    return a ? {
      ...E,
      transform: "translate(" + A + "px, " + j + "px)",
      ...p7(m.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: r,
      left: A,
      top: j
    };
  }, [r, a, m.floating, l.x, l.y]);
  return R.useMemo(() => ({
    ...l,
    update: L,
    refs: d,
    elements: m,
    floatingStyles: x
  }), [l, L, d, m, x]);
}
const lH = (e) => {
  function t(r) {
    return {}.hasOwnProperty.call(r, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(r) {
      const {
        element: n,
        padding: i
      } = typeof e == "function" ? e(r) : e;
      return n && t(n) ? n.current != null ? Ib({
        element: n.current,
        padding: i
      }).fn(r) : {} : n ? Ib({
        element: n,
        padding: i
      }).fn(r) : {};
    }
  };
}, fH = (e, t) => ({
  ...eH(e),
  options: [e, t]
}), dH = (e, t) => ({
  ...tH(e),
  options: [e, t]
}), hH = (e, t) => ({
  ...sH(e),
  options: [e, t]
}), pH = (e, t) => ({
  ...rH(e),
  options: [e, t]
}), mH = (e, t) => ({
  ...nH(e),
  options: [e, t]
}), gH = (e, t) => ({
  ...iH(e),
  options: [e, t]
}), yH = (e, t) => ({
  ...lH(e),
  options: [e, t]
});
var vH = "Arrow", m7 = R.forwardRef((e, t) => {
  const { children: r, width: n = 10, height: i = 5, ...s } = e;
  return /* @__PURE__ */ _.jsx(
    nr.svg,
    {
      ...s,
      ref: t,
      width: n,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? r : /* @__PURE__ */ _.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
m7.displayName = vH;
var bH = m7;
function T1(e) {
  const [t, r] = R.useState(void 0);
  return Gs(() => {
    if (e) {
      r({ width: e.offsetWidth, height: e.offsetHeight });
      const n = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let o, a;
        if ("borderBoxSize" in s) {
          const c = s.borderBoxSize, u = Array.isArray(c) ? c[0] : c;
          o = u.inlineSize, a = u.blockSize;
        } else
          o = e.offsetWidth, a = e.offsetHeight;
        r({ width: o, height: a });
      });
      return n.observe(e, { box: "border-box" }), () => n.unobserve(e);
    } else
      r(void 0);
  }, [e]), t;
}
var C1 = "Popper", [g7, ch] = eo(C1), [wH, y7] = g7(C1), v7 = (e) => {
  const { __scopePopper: t, children: r } = e, [n, i] = R.useState(null);
  return /* @__PURE__ */ _.jsx(wH, { scope: t, anchor: n, onAnchorChange: i, children: r });
};
v7.displayName = C1;
var b7 = "PopperAnchor", w7 = R.forwardRef(
  (e, t) => {
    const { __scopePopper: r, virtualRef: n, ...i } = e, s = y7(b7, r), o = R.useRef(null), a = ar(t, o), c = R.useRef(null);
    return R.useEffect(() => {
      const u = c.current;
      c.current = (n == null ? void 0 : n.current) || o.current, u !== c.current && s.onAnchorChange(c.current);
    }), n ? null : /* @__PURE__ */ _.jsx(nr.div, { ...i, ref: a });
  }
);
w7.displayName = b7;
var A1 = "PopperContent", [_H, xH] = g7(A1), _7 = R.forwardRef(
  (e, t) => {
    var fe, ye, Te, N, F, G;
    const {
      __scopePopper: r,
      side: n = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: o = 0,
      arrowPadding: a = 0,
      avoidCollisions: c = !0,
      collisionBoundary: u = [],
      collisionPadding: l = 0,
      sticky: f = "partial",
      hideWhenDetached: h = !1,
      updatePositionStrategy: v = "optimized",
      onPlaced: b,
      ...y
    } = e, S = y7(A1, r), [C, O] = R.useState(null), I = ar(t, (ee) => O(ee)), [U, D] = R.useState(null), H = T1(U), z = (H == null ? void 0 : H.width) ?? 0, ne = (H == null ? void 0 : H.height) ?? 0, le = n + (s !== "center" ? "-" + s : ""), te = typeof l == "number" ? l : { top: 0, right: 0, bottom: 0, left: 0, ...l }, ce = Array.isArray(u) ? u : [u], V = ce.length > 0, L = {
      padding: te,
      boundary: ce.filter(EH),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: V
    }, { refs: p, floatingStyles: d, placement: m, isPositioned: x, middlewareData: E } = uH({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: le,
      whileElementsMounted: (...ee) => Qq(...ee, {
        animationFrame: v === "always"
      }),
      elements: {
        reference: S.anchor
      },
      middleware: [
        fH({ mainAxis: i + ne, alignmentAxis: o }),
        c && dH({
          mainAxis: !0,
          crossAxis: !1,
          limiter: f === "partial" ? hH() : void 0,
          ...L
        }),
        c && pH({ ...L }),
        mH({
          ...L,
          apply: ({ elements: ee, rects: Z, availableWidth: q, availableHeight: he }) => {
            const { width: Y, height: X } = Z.reference, B = ee.floating.style;
            B.setProperty("--radix-popper-available-width", `${q}px`), B.setProperty("--radix-popper-available-height", `${he}px`), B.setProperty("--radix-popper-anchor-width", `${Y}px`), B.setProperty("--radix-popper-anchor-height", `${X}px`);
          }
        }),
        U && yH({ element: U, padding: a }),
        TH({ arrowWidth: z, arrowHeight: ne }),
        h && gH({ strategy: "referenceHidden", ...L })
      ]
    }), [A, j] = E7(m), k = en(b);
    Gs(() => {
      x && (k == null || k());
    }, [x, k]);
    const g = (fe = E.arrow) == null ? void 0 : fe.x, w = (ye = E.arrow) == null ? void 0 : ye.y, P = ((Te = E.arrow) == null ? void 0 : Te.centerOffset) !== 0, [ue, ie] = R.useState();
    return Gs(() => {
      C && ie(window.getComputedStyle(C).zIndex);
    }, [C]), /* @__PURE__ */ _.jsx(
      "div",
      {
        ref: p.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...d,
          transform: x ? d.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: ue,
          "--radix-popper-transform-origin": [
            (N = E.transformOrigin) == null ? void 0 : N.x,
            (F = E.transformOrigin) == null ? void 0 : F.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((G = E.hide) == null ? void 0 : G.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ _.jsx(
          _H,
          {
            scope: r,
            placedSide: A,
            onArrowChange: D,
            arrowX: g,
            arrowY: w,
            shouldHideArrow: P,
            children: /* @__PURE__ */ _.jsx(
              nr.div,
              {
                "data-side": A,
                "data-align": j,
                ...y,
                ref: I,
                style: {
                  ...y.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: x ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
_7.displayName = A1;
var x7 = "PopperArrow", SH = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, S7 = R.forwardRef(function(t, r) {
  const { __scopePopper: n, ...i } = t, s = xH(x7, n), o = SH[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ _.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ _.jsx(
          bH,
          {
            ...i,
            ref: r,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
S7.displayName = x7;
function EH(e) {
  return e !== null;
}
var TH = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var S, C, O;
    const { placement: r, rects: n, middlewareData: i } = t, o = ((S = i.arrow) == null ? void 0 : S.centerOffset) !== 0, a = o ? 0 : e.arrowWidth, c = o ? 0 : e.arrowHeight, [u, l] = E7(r), f = { start: "0%", center: "50%", end: "100%" }[l], h = (((C = i.arrow) == null ? void 0 : C.x) ?? 0) + a / 2, v = (((O = i.arrow) == null ? void 0 : O.y) ?? 0) + c / 2;
    let b = "", y = "";
    return u === "bottom" ? (b = o ? f : `${h}px`, y = `${-c}px`) : u === "top" ? (b = o ? f : `${h}px`, y = `${n.floating.height + c}px`) : u === "right" ? (b = `${-c}px`, y = o ? f : `${v}px`) : u === "left" && (b = `${n.floating.width + c}px`, y = o ? f : `${v}px`), { data: { x: b, y } };
  }
});
function E7(e) {
  const [t, r = "center"] = e.split("-");
  return [t, r];
}
var T7 = v7, C7 = w7, A7 = _7, M7 = S7, CH = "Portal", O7 = R.forwardRef((e, t) => {
  var a;
  const { container: r, ...n } = e, [i, s] = R.useState(!1);
  Gs(() => s(!0), []);
  const o = r || i && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
  return o ? Ww.createPortal(/* @__PURE__ */ _.jsx(nr.div, { ...n, ref: t }), o) : null;
});
O7.displayName = CH;
function AH(e, t) {
  return R.useReducer((r, n) => t[r][n] ?? r, e);
}
var Ni = (e) => {
  const { present: t, children: r } = e, n = MH(t), i = typeof r == "function" ? r({ present: n.isPresent }) : R.Children.only(r), s = ar(n.ref, OH(i));
  return typeof r == "function" || n.isPresent ? R.cloneElement(i, { ref: s }) : null;
};
Ni.displayName = "Presence";
function MH(e) {
  const [t, r] = R.useState(), n = R.useRef(null), i = R.useRef(e), s = R.useRef("none"), o = e ? "mounted" : "unmounted", [a, c] = AH(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return R.useEffect(() => {
    const u = $l(n.current);
    s.current = a === "mounted" ? u : "none";
  }, [a]), Gs(() => {
    const u = n.current, l = i.current;
    if (l !== e) {
      const h = s.current, v = $l(u);
      e ? c("MOUNT") : v === "none" || (u == null ? void 0 : u.display) === "none" ? c("UNMOUNT") : c(l && h !== v ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), Gs(() => {
    if (t) {
      let u;
      const l = t.ownerDocument.defaultView ?? window, f = (v) => {
        const y = $l(n.current).includes(CSS.escape(v.animationName));
        if (v.target === t && y && (c("ANIMATION_END"), !i.current)) {
          const S = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", u = l.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = S);
          });
        }
      }, h = (v) => {
        v.target === t && (s.current = $l(n.current));
      };
      return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        l.clearTimeout(u), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: R.useCallback((u) => {
      n.current = u ? getComputedStyle(u) : null, r(u);
    }, [])
  };
}
function $l(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function OH(e) {
  var n, i;
  let t = (n = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : n.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
var IH = R[" useInsertionEffect ".trim().toString()] || Gs;
function ml({
  prop: e,
  defaultProp: t,
  onChange: r = () => {
  },
  caller: n
}) {
  const [i, s, o] = kH({
    defaultProp: t,
    onChange: r
  }), a = e !== void 0, c = a ? e : i;
  {
    const l = R.useRef(e !== void 0);
    R.useEffect(() => {
      const f = l.current;
      f !== a && console.warn(
        `${n} is changing from ${f ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), l.current = a;
    }, [a, n]);
  }
  const u = R.useCallback(
    (l) => {
      var f;
      if (a) {
        const h = jH(l) ? l(e) : l;
        h !== e && ((f = o.current) == null || f.call(o, h));
      } else
        s(l);
    },
    [a, e, s, o]
  );
  return [c, u];
}
function kH({
  defaultProp: e,
  onChange: t
}) {
  const [r, n] = R.useState(e), i = R.useRef(r), s = R.useRef(t);
  return IH(() => {
    s.current = t;
  }, [t]), R.useEffect(() => {
    var o;
    i.current !== r && ((o = s.current) == null || o.call(s, r), i.current = r);
  }, [r, i]), [r, n, s];
}
function jH(e) {
  return typeof e == "function";
}
var RH = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), PH = "VisuallyHidden", I7 = R.forwardRef(
  (e, t) => /* @__PURE__ */ _.jsx(
    nr.span,
    {
      ...e,
      ref: t,
      style: { ...RH, ...e.style }
    }
  )
);
I7.displayName = PH;
var NH = I7, [uh, Yie] = eo("Tooltip", [
  ch
]), M1 = ch(), k7 = "TooltipProvider", $H = 700, jb = "tooltip.open", [DH, j7] = uh(k7), R7 = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: r = $H,
    skipDelayDuration: n = 300,
    disableHoverableContent: i = !1,
    children: s
  } = e, o = R.useRef(!0), a = R.useRef(!1), c = R.useRef(0);
  return R.useEffect(() => {
    const u = c.current;
    return () => window.clearTimeout(u);
  }, []), /* @__PURE__ */ _.jsx(
    DH,
    {
      scope: t,
      isOpenDelayedRef: o,
      delayDuration: r,
      onOpen: R.useCallback(() => {
        window.clearTimeout(c.current), o.current = !1;
      }, []),
      onClose: R.useCallback(() => {
        window.clearTimeout(c.current), c.current = window.setTimeout(
          () => o.current = !0,
          n
        );
      }, [n]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: R.useCallback((u) => {
        a.current = u;
      }, []),
      disableHoverableContent: i,
      children: s
    }
  );
};
R7.displayName = k7;
var P7 = "Tooltip", [Xie, lh] = uh(P7), dm = "TooltipTrigger", LH = R.forwardRef(
  (e, t) => {
    const { __scopeTooltip: r, ...n } = e, i = lh(dm, r), s = j7(dm, r), o = M1(r), a = R.useRef(null), c = ar(t, a, i.onTriggerChange), u = R.useRef(!1), l = R.useRef(!1), f = R.useCallback(() => u.current = !1, []);
    return R.useEffect(() => () => document.removeEventListener("pointerup", f), [f]), /* @__PURE__ */ _.jsx(C7, { asChild: !0, ...o, children: /* @__PURE__ */ _.jsx(
      nr.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...n,
        ref: c,
        onPointerMove: xt(e.onPointerMove, (h) => {
          h.pointerType !== "touch" && !l.current && !s.isPointerInTransitRef.current && (i.onTriggerEnter(), l.current = !0);
        }),
        onPointerLeave: xt(e.onPointerLeave, () => {
          i.onTriggerLeave(), l.current = !1;
        }),
        onPointerDown: xt(e.onPointerDown, () => {
          i.open && i.onClose(), u.current = !0, document.addEventListener("pointerup", f, { once: !0 });
        }),
        onFocus: xt(e.onFocus, () => {
          u.current || i.onOpen();
        }),
        onBlur: xt(e.onBlur, i.onClose),
        onClick: xt(e.onClick, i.onClose)
      }
    ) });
  }
);
LH.displayName = dm;
var BH = "TooltipPortal", [Jie, UH] = uh(BH, {
  forceMount: void 0
}), _c = "TooltipContent", FH = R.forwardRef(
  (e, t) => {
    const r = UH(_c, e.__scopeTooltip), { forceMount: n = r.forceMount, side: i = "top", ...s } = e, o = lh(_c, e.__scopeTooltip);
    return /* @__PURE__ */ _.jsx(Ni, { present: n || o.open, children: o.disableHoverableContent ? /* @__PURE__ */ _.jsx(N7, { side: i, ...s, ref: t }) : /* @__PURE__ */ _.jsx(VH, { side: i, ...s, ref: t }) });
  }
), VH = R.forwardRef((e, t) => {
  const r = lh(_c, e.__scopeTooltip), n = j7(_c, e.__scopeTooltip), i = R.useRef(null), s = ar(t, i), [o, a] = R.useState(null), { trigger: c, onClose: u } = r, l = i.current, { onPointerInTransitChange: f } = n, h = R.useCallback(() => {
    a(null), f(!1);
  }, [f]), v = R.useCallback(
    (b, y) => {
      const S = b.currentTarget, C = { x: b.clientX, y: b.clientY }, O = GH(C, S.getBoundingClientRect()), I = KH(C, O), U = YH(y.getBoundingClientRect()), D = JH([...I, ...U]);
      a(D), f(!0);
    },
    [f]
  );
  return R.useEffect(() => () => h(), [h]), R.useEffect(() => {
    if (c && l) {
      const b = (S) => v(S, l), y = (S) => v(S, c);
      return c.addEventListener("pointerleave", b), l.addEventListener("pointerleave", y), () => {
        c.removeEventListener("pointerleave", b), l.removeEventListener("pointerleave", y);
      };
    }
  }, [c, l, v, h]), R.useEffect(() => {
    if (o) {
      const b = (y) => {
        const S = y.target, C = { x: y.clientX, y: y.clientY }, O = (c == null ? void 0 : c.contains(S)) || (l == null ? void 0 : l.contains(S)), I = !XH(C, o);
        O ? h() : I && (h(), u());
      };
      return document.addEventListener("pointermove", b), () => document.removeEventListener("pointermove", b);
    }
  }, [c, l, o, u, h]), /* @__PURE__ */ _.jsx(N7, { ...e, ref: s });
}), [zH, WH] = uh(P7, { isInside: !1 }), qH = /* @__PURE__ */ e7("TooltipContent"), N7 = R.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: r,
      children: n,
      "aria-label": i,
      onEscapeKeyDown: s,
      onPointerDownOutside: o,
      ...a
    } = e, c = lh(_c, r), u = M1(r), { onClose: l } = c;
    return R.useEffect(() => (document.addEventListener(jb, l), () => document.removeEventListener(jb, l)), [l]), R.useEffect(() => {
      if (c.trigger) {
        const f = (h) => {
          const v = h.target;
          v != null && v.contains(c.trigger) && l();
        };
        return window.addEventListener("scroll", f, { capture: !0 }), () => window.removeEventListener("scroll", f, { capture: !0 });
      }
    }, [c.trigger, l]), /* @__PURE__ */ _.jsx(
      v1,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        onFocusOutside: (f) => f.preventDefault(),
        onDismiss: l,
        children: /* @__PURE__ */ _.jsxs(
          A7,
          {
            "data-state": c.stateAttribute,
            ...u,
            ...a,
            ref: t,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ _.jsx(qH, { children: n }),
              /* @__PURE__ */ _.jsx(zH, { scope: r, isInside: !0, children: /* @__PURE__ */ _.jsx(NH, { id: c.contentId, role: "tooltip", children: i || n }) })
            ]
          }
        )
      }
    );
  }
);
FH.displayName = _c;
var $7 = "TooltipArrow", HH = R.forwardRef(
  (e, t) => {
    const { __scopeTooltip: r, ...n } = e, i = M1(r);
    return WH(
      $7,
      r
    ).isInside ? null : /* @__PURE__ */ _.jsx(M7, { ...i, ...n, ref: t });
  }
);
HH.displayName = $7;
function GH(e, t) {
  const r = Math.abs(t.top - e.y), n = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x);
  switch (Math.min(r, n, i, s)) {
    case s:
      return "left";
    case i:
      return "right";
    case r:
      return "top";
    case n:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function KH(e, t, r = 5) {
  const n = [];
  switch (t) {
    case "top":
      n.push(
        { x: e.x - r, y: e.y + r },
        { x: e.x + r, y: e.y + r }
      );
      break;
    case "bottom":
      n.push(
        { x: e.x - r, y: e.y - r },
        { x: e.x + r, y: e.y - r }
      );
      break;
    case "left":
      n.push(
        { x: e.x + r, y: e.y - r },
        { x: e.x + r, y: e.y + r }
      );
      break;
    case "right":
      n.push(
        { x: e.x - r, y: e.y - r },
        { x: e.x - r, y: e.y + r }
      );
      break;
  }
  return n;
}
function YH(e) {
  const { top: t, right: r, bottom: n, left: i } = e;
  return [
    { x: i, y: t },
    { x: r, y: t },
    { x: r, y: n },
    { x: i, y: n }
  ];
}
function XH(e, t) {
  const { x: r, y: n } = e;
  let i = !1;
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    const a = t[s], c = t[o], u = a.x, l = a.y, f = c.x, h = c.y;
    l > n != h > n && r < (f - u) * (n - l) / (h - l) + u && (i = !i);
  }
  return i;
}
function JH(e) {
  const t = e.slice();
  return t.sort((r, n) => r.x < n.x ? -1 : r.x > n.x ? 1 : r.y < n.y ? -1 : r.y > n.y ? 1 : 0), ZH(t);
}
function ZH(e) {
  if (e.length <= 1)
    return e.slice();
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const i = e[n];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], o = t[t.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        t.pop();
      else
        break;
    }
    t.push(i);
  }
  t.pop();
  const r = [];
  for (let n = e.length - 1; n >= 0; n--) {
    const i = e[n];
    for (; r.length >= 2; ) {
      const s = r[r.length - 1], o = r[r.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x))
        r.pop();
      else
        break;
    }
    r.push(i);
  }
  return r.pop(), t.length === 1 && r.length === 1 && t[0].x === r[0].x && t[0].y === r[0].y ? t : t.concat(r);
}
var QH = R7, D7 = R.createContext(void 0), eG = (e) => {
  const { dir: t, children: r } = e;
  return /* @__PURE__ */ _.jsx(D7.Provider, { value: t, children: r });
};
function O1(e) {
  const t = R.useContext(D7);
  return e || t || "ltr";
}
const tG = ["tomato", "red", "ruby", "crimson", "pink", "plum", "purple", "violet", "iris", "indigo", "blue", "cyan", "teal", "jade", "green", "grass", "brown", "orange"], rG = ["sky", "mint", "lime", "yellow", "amber"], nG = ["gold", "bronze"], iG = [...tG, ...rG, ...nG], sG = "gray", oG = ["mauve", "slate", "sage", "olive", "sand"], aG = [sG, ...oG];
function cG(e) {
  switch (e) {
    case "tomato":
    case "red":
    case "ruby":
    case "crimson":
    case "pink":
    case "plum":
    case "purple":
    case "violet":
      return "mauve";
    case "iris":
    case "indigo":
    case "blue":
    case "sky":
    case "cyan":
      return "slate";
    case "teal":
    case "jade":
    case "mint":
    case "green":
      return "sage";
    case "grass":
    case "lime":
      return "olive";
    case "yellow":
    case "amber":
    case "orange":
    case "brown":
    case "gold":
    case "bronze":
      return "sand";
  }
}
const uG = ["inherit", "light", "dark"], lG = [...iG, "gray"], fG = [...aG, "auto"], dG = ["solid", "translucent"], hG = ["none", "small", "medium", "large", "full"], pG = ["90%", "95%", "100%", "105%", "110%"], wn = {
  hasBackground: { type: "boolean", default: !0 },
  appearance: { type: "enum", values: uG, default: "inherit" },
  accentColor: { type: "enum", values: lG, default: "indigo" },
  grayColor: { type: "enum", values: fG, default: "auto" },
  panelBackground: { type: "enum", values: dG, default: "translucent" },
  radius: { type: "enum", values: hG, default: "medium" },
  scaling: { type: "enum", values: pG, default: "100%" }
};
function L7(e) {
  return e === "gray" ? "gray" : cG(e);
}
const Ua = () => {
}, dd = R.createContext(void 0);
function mG() {
  const e = R.useContext(dd);
  if (e === void 0)
    throw new Error("`useThemeContext` must be used within a `Theme`");
  return e;
}
const fh = R.forwardRef((e, t) => R.useContext(dd) === void 0 ? R.createElement(
  QH,
  null,
  R.createElement(
    eG,
    { dir: "ltr" },
    R.createElement(B7, { ...e, ref: t })
  )
) : R.createElement(I1, { ...e, ref: t }));
fh.displayName = "Theme";
const B7 = R.forwardRef((e, t) => {
  const { appearance: r = wn.appearance.default, accentColor: n = wn.accentColor.default, grayColor: i = wn.grayColor.default, panelBackground: s = wn.panelBackground.default, radius: o = wn.radius.default, scaling: a = wn.scaling.default, hasBackground: c = wn.hasBackground.default, ...u } = e, [l, f] = R.useState(r);
  R.useEffect(() => f(r), [r]);
  const [h, v] = R.useState(n);
  R.useEffect(() => v(n), [n]);
  const [b, y] = R.useState(i);
  R.useEffect(() => y(i), [i]);
  const [S, C] = R.useState(s);
  R.useEffect(() => C(s), [s]);
  const [O, I] = R.useState(o);
  R.useEffect(() => I(o), [o]);
  const [U, D] = R.useState(a);
  R.useEffect(() => D(a), [a]);
  const H = R.memo(
    ({ appearance: ne }) => R.createElement("script", { dangerouslySetInnerHTML: {
      __html: `!(function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');d.style.colorScheme='${ne}';c.add('${ne}');}catch(e){}})();`
    } }),
    () => !0
    // Never re-render
  );
  H.displayName = "ExplicitRootAppearanceScript", R.useEffect(() => gG(r), [r]);
  const z = b === "auto" ? L7(h) : b;
  return R.createElement(
    R.Fragment,
    null,
    l !== "inherit" && R.createElement(H, { appearance: l }),
    c && R.createElement("style", { dangerouslySetInnerHTML: {
      __html: `
:root, .light, .light-theme { --color-page-background: white; }
.dark, .dark-theme { --color-page-background: var(--${z}-1); }
body { background-color: var(--color-page-background); }
`
    } }),
    R.createElement(I1, {
      ...u,
      ref: t,
      isRoot: !0,
      hasBackground: c,
      //
      appearance: l,
      accentColor: h,
      grayColor: b,
      panelBackground: S,
      radius: O,
      scaling: U,
      //
      onAppearanceChange: f,
      onAccentColorChange: v,
      onGrayColorChange: y,
      onPanelBackgroundChange: C,
      onRadiusChange: I,
      onScalingChange: D
    })
  );
});
B7.displayName = "ThemeRoot";
const I1 = R.forwardRef((e, t) => {
  var r, n, i, s, o, a;
  const c = R.useContext(dd), {
    asChild: u,
    isRoot: l,
    hasBackground: f,
    //
    appearance: h = (r = c == null ? void 0 : c.appearance) !== null && r !== void 0 ? r : wn.appearance.default,
    accentColor: v = (n = c == null ? void 0 : c.accentColor) !== null && n !== void 0 ? n : wn.accentColor.default,
    grayColor: b = (i = c == null ? void 0 : c.resolvedGrayColor) !== null && i !== void 0 ? i : wn.grayColor.default,
    panelBackground: y = (s = c == null ? void 0 : c.panelBackground) !== null && s !== void 0 ? s : wn.panelBackground.default,
    radius: S = (o = c == null ? void 0 : c.radius) !== null && o !== void 0 ? o : wn.radius.default,
    scaling: C = (a = c == null ? void 0 : c.scaling) !== null && a !== void 0 ? a : wn.scaling.default,
    //
    onAppearanceChange: O = Ua,
    onAccentColorChange: I = Ua,
    onGrayColorChange: U = Ua,
    onPanelBackgroundChange: D = Ua,
    onRadiusChange: H = Ua,
    onScalingChange: z = Ua,
    //
    ...ne
  } = e, le = u ? y1 : "div", te = b === "auto" ? L7(v) : b, ce = e.appearance !== void 0 && e.appearance !== "inherit", V = e.grayColor !== void 0, L = !l && (f === !0 || f !== !1 && (ce || V));
  return R.createElement(
    dd.Provider,
    { value: R.useMemo(() => ({
      appearance: h,
      accentColor: v,
      grayColor: b,
      resolvedGrayColor: te,
      panelBackground: y,
      radius: S,
      scaling: C,
      //
      onAppearanceChange: O,
      onAccentColorChange: I,
      onGrayColorChange: U,
      onPanelBackgroundChange: D,
      onRadiusChange: H,
      onScalingChange: z
    }), [
      h,
      v,
      b,
      te,
      y,
      S,
      C,
      //
      O,
      I,
      U,
      D,
      H,
      z
    ]) },
    R.createElement(le, { "data-is-root-theme": l ? "true" : "false", "data-accent-color": v, "data-gray-color": te, "data-has-background": L ? "true" : "false", "data-panel-background": y, "data-radius": S, "data-scaling": C, ref: t, ...ne, className: br("radix-themes", {
      // Only apply theme class to nested `Theme` sections.
      //
      // If it's the root `Theme`, we either rely on
      // - something else setting the theme class when root `appearance` is `inherit`
      // - our script setting it when root `appearance` is explicit
      light: !l && h === "light",
      dark: !l && h === "dark"
    }, ne.className) })
  );
});
I1.displayName = "ThemeImpl";
function gG(e) {
  if (e === "inherit")
    return;
  const t = document.documentElement;
  (t.classList.contains("light-theme") || t.classList.contains("dark-theme")) && (t.classList.remove("light-theme", "dark-theme"), t.style.colorScheme = e, t.classList.add(`${e}-theme`)), (t.classList.contains("light") || t.classList.contains("dark")) && (t.classList.remove("light", "dark"), t.style.colorScheme = e, t.classList.add(e));
}
const gl = {
  type: "enum",
  values: wn.accentColor.values,
  default: void 0
}, dh = {
  type: "boolean",
  default: void 0
};
function Mn(e, t = "", r) {
  var n, i, s, o;
  const a = [];
  if (typeof e == "object") {
    for (const c of Object.keys(e))
      if (c in e) {
        const u = (n = e[c]) === null || n === void 0 ? void 0 : n.toString(), l = u == null ? void 0 : u.startsWith("-"), f = t === "" ? "" : "-", h = l ? `-${t}` : t, v = l ? u == null ? void 0 : u.substring(1) : u;
        if (v === void 0)
          continue;
        const b = (i = r == null ? void 0 : r[v]) !== null && i !== void 0 ? i : v, y = c === "initial" ? `${h}${f}${b}` : `${c}:${h}${f}${b}`;
        a.push(y);
      }
  }
  if (typeof e == "string") {
    const c = e.startsWith("-"), u = t === "" ? "" : "-", l = c ? `-${t}` : t, f = c ? e.substring(1) : e, h = (s = r == null ? void 0 : r[f]) !== null && s !== void 0 ? s : f;
    a.push(`${l}${u}${h}`);
  }
  if (typeof e == "boolean") {
    const c = t === "" ? "" : "-", u = e.toString(), l = (o = r == null ? void 0 : r[u]) !== null && o !== void 0 ? o : u;
    a.push(`${t}${c}${l}`);
  }
  return a.join(" ");
}
const Go = ["auto", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9"], Ko = {
  m: { type: "enum", values: Go, default: void 0, responsive: !0 },
  mx: { type: "enum", values: Go, default: void 0, responsive: !0 },
  my: { type: "enum", values: Go, default: void 0, responsive: !0 },
  mt: { type: "enum", values: Go, default: void 0, responsive: !0 },
  mr: { type: "enum", values: Go, default: void 0, responsive: !0 },
  mb: { type: "enum", values: Go, default: void 0, responsive: !0 },
  ml: { type: "enum", values: Go, default: void 0, responsive: !0 }
};
function yl(e) {
  const { m: t = Ko.m.default, mx: r = Ko.mx.default, my: n = Ko.my.default, mt: i = Ko.mt.default, mr: s = Ko.mr.default, mb: o = Ko.mb.default, ml: a = Ko.ml.default, ...c } = e;
  return { m: t, mx: r, my: n, mt: i, mr: s, mb: o, ml: a, rest: c };
}
function vl(e) {
  return [
    Mn(e.m, "rt-r-m"),
    Mn(e.mx, "rt-r-mx"),
    Mn(e.my, "rt-r-my"),
    Mn(e.mt, "rt-r-mt"),
    Mn(e.mr, "rt-r-mr"),
    Mn(e.mb, "rt-r-mb"),
    Mn(e.ml, "rt-r-ml")
  ].filter(Boolean).join(" ");
}
const k1 = {
  type: "enum",
  values: wn.radius.values,
  default: void 0
};
function U7(e) {
  const t = R.useRef({ value: e, previous: e });
  return R.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var hh = "Checkbox", [yG, Zie] = eo(hh), [vG, j1] = yG(hh);
function bG(e) {
  const {
    __scopeCheckbox: t,
    checked: r,
    children: n,
    defaultChecked: i,
    disabled: s,
    form: o,
    name: a,
    onCheckedChange: c,
    required: u,
    value: l = "on",
    // @ts-expect-error
    internal_do_not_use_render: f
  } = e, [h, v] = ml({
    prop: r,
    defaultProp: i ?? !1,
    onChange: c,
    caller: hh
  }), [b, y] = R.useState(null), [S, C] = R.useState(null), O = R.useRef(!1), I = b ? !!o || !!b.closest("form") : (
    // We set this to true by default so that events bubble to forms without JS (SSR)
    !0
  ), U = {
    checked: h,
    disabled: s,
    setChecked: v,
    control: b,
    setControl: y,
    name: a,
    form: o,
    value: l,
    hasConsumerStoppedPropagationRef: O,
    required: u,
    defaultChecked: Ao(i) ? !1 : i,
    isFormControl: I,
    bubbleInput: S,
    setBubbleInput: C
  };
  return /* @__PURE__ */ _.jsx(
    vG,
    {
      scope: t,
      ...U,
      children: wG(f) ? f(U) : n
    }
  );
}
var F7 = "CheckboxTrigger", V7 = R.forwardRef(
  ({ __scopeCheckbox: e, onKeyDown: t, onClick: r, ...n }, i) => {
    const {
      control: s,
      value: o,
      disabled: a,
      checked: c,
      required: u,
      setControl: l,
      setChecked: f,
      hasConsumerStoppedPropagationRef: h,
      isFormControl: v,
      bubbleInput: b
    } = j1(F7, e), y = ar(i, l), S = R.useRef(c);
    return R.useEffect(() => {
      const C = s == null ? void 0 : s.form;
      if (C) {
        const O = () => f(S.current);
        return C.addEventListener("reset", O), () => C.removeEventListener("reset", O);
      }
    }, [s, f]), /* @__PURE__ */ _.jsx(
      nr.button,
      {
        type: "button",
        role: "checkbox",
        "aria-checked": Ao(c) ? "mixed" : c,
        "aria-required": u,
        "data-state": K7(c),
        "data-disabled": a ? "" : void 0,
        disabled: a,
        value: o,
        ...n,
        ref: y,
        onKeyDown: xt(t, (C) => {
          C.key === "Enter" && C.preventDefault();
        }),
        onClick: xt(r, (C) => {
          f((O) => Ao(O) ? !0 : !O), b && v && (h.current = C.isPropagationStopped(), h.current || C.stopPropagation());
        })
      }
    );
  }
);
V7.displayName = F7;
var z7 = R.forwardRef(
  (e, t) => {
    const {
      __scopeCheckbox: r,
      name: n,
      checked: i,
      defaultChecked: s,
      required: o,
      disabled: a,
      value: c,
      onCheckedChange: u,
      form: l,
      ...f
    } = e;
    return /* @__PURE__ */ _.jsx(
      bG,
      {
        __scopeCheckbox: r,
        checked: i,
        defaultChecked: s,
        disabled: a,
        required: o,
        onCheckedChange: u,
        name: n,
        form: l,
        value: c,
        internal_do_not_use_render: ({ isFormControl: h }) => /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
          /* @__PURE__ */ _.jsx(
            V7,
            {
              ...f,
              ref: t,
              __scopeCheckbox: r
            }
          ),
          h && /* @__PURE__ */ _.jsx(
            G7,
            {
              __scopeCheckbox: r
            }
          )
        ] })
      }
    );
  }
);
z7.displayName = hh;
var W7 = "CheckboxIndicator", q7 = R.forwardRef(
  (e, t) => {
    const { __scopeCheckbox: r, forceMount: n, ...i } = e, s = j1(W7, r);
    return /* @__PURE__ */ _.jsx(
      Ni,
      {
        present: n || Ao(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ _.jsx(
          nr.span,
          {
            "data-state": K7(s.checked),
            "data-disabled": s.disabled ? "" : void 0,
            ...i,
            ref: t,
            style: { pointerEvents: "none", ...e.style }
          }
        )
      }
    );
  }
);
q7.displayName = W7;
var H7 = "CheckboxBubbleInput", G7 = R.forwardRef(
  ({ __scopeCheckbox: e, ...t }, r) => {
    const {
      control: n,
      hasConsumerStoppedPropagationRef: i,
      checked: s,
      defaultChecked: o,
      required: a,
      disabled: c,
      name: u,
      value: l,
      form: f,
      bubbleInput: h,
      setBubbleInput: v
    } = j1(H7, e), b = ar(r, v), y = U7(s), S = T1(n);
    R.useEffect(() => {
      const O = h;
      if (!O)
        return;
      const I = window.HTMLInputElement.prototype, D = Object.getOwnPropertyDescriptor(
        I,
        "checked"
      ).set, H = !i.current;
      if (y !== s && D) {
        const z = new Event("click", { bubbles: H });
        O.indeterminate = Ao(s), D.call(O, Ao(s) ? !1 : s), O.dispatchEvent(z);
      }
    }, [h, y, s, i]);
    const C = R.useRef(Ao(s) ? !1 : s);
    return /* @__PURE__ */ _.jsx(
      nr.input,
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: o ?? C.current,
        required: a,
        disabled: c,
        name: u,
        value: l,
        form: f,
        ...t,
        tabIndex: -1,
        ref: b,
        style: {
          ...t.style,
          ...S,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0,
          // We transform because the input is absolutely positioned but we have
          // rendered it **after** the button. This pulls it back to sit on top
          // of the button.
          transform: "translateX(-100%)"
        }
      }
    );
  }
);
G7.displayName = H7;
function wG(e) {
  return typeof e == "function";
}
function Ao(e) {
  return e === "indeterminate";
}
function K7(e) {
  return Ao(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const _G = ["1", "2", "3"], xG = ["classic", "surface", "soft"], Dl = {
  size: { type: "enum", values: _G, default: "2", responsive: !0 },
  variant: { type: "enum", values: xG, default: "surface" },
  color: gl,
  highContrast: dh
}, ph = R.forwardRef(({ color: e = "currentColor", ...t }, r) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e, xmlns: "http://www.w3.org/2000/svg", ...t, ref: r },
  R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.53547 0.62293C8.88226 0.849446 8.97976 1.3142 8.75325 1.66099L4.5083 8.1599C4.38833 8.34356 4.19397 8.4655 3.9764 8.49358C3.75883 8.52167 3.53987 8.45309 3.3772 8.30591L0.616113 5.80777C0.308959 5.52987 0.285246 5.05559 0.563148 4.74844C0.84105 4.44128 1.31533 4.41757 1.62249 4.69547L3.73256 6.60459L7.49741 0.840706C7.72393 0.493916 8.18868 0.396414 8.53547 0.62293Z" })
));
ph.displayName = "ThickCheckIcon";
const SG = R.forwardRef(({ color: e = "currentColor", ...t }, r) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e, xmlns: "http://www.w3.org/2000/svg", ...t, ref: r },
  R.createElement("path", { d: "M0.135232 3.15803C0.324102 2.95657 0.640521 2.94637 0.841971 3.13523L4.5 6.56464L8.158 3.13523C8.3595 2.94637 8.6759 2.95657 8.8648 3.15803C9.0536 3.35949 9.0434 3.67591 8.842 3.86477L4.84197 7.6148C4.64964 7.7951 4.35036 7.7951 4.15803 7.6148L0.158031 3.86477C-0.0434285 3.67591 -0.0536285 3.35949 0.135232 3.15803Z" })
));
SG.displayName = "ChevronDownIcon";
const Y7 = R.forwardRef(({ color: e = "currentColor", ...t }, r) => R.createElement(
  "svg",
  { width: "9", height: "9", viewBox: "0 0 9 9", fill: e, xmlns: "http://www.w3.org/2000/svg", ...t, ref: r },
  R.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.23826 0.201711C3.54108 -0.0809141 4.01567 -0.0645489 4.29829 0.238264L7.79829 3.98826C8.06724 4.27642 8.06724 4.72359 7.79829 5.01174L4.29829 8.76174C4.01567 9.06455 3.54108 9.08092 3.23826 8.79829C2.93545 8.51567 2.91909 8.04108 3.20171 7.73826L6.22409 4.5L3.20171 1.26174C2.91909 0.958928 2.93545 0.484337 3.23826 0.201711Z" })
));
Y7.displayName = "ThickChevronRightIcon";
const EG = R.forwardRef(({ color: e = "currentColor", ...t }, r) => R.createElement(
  "svg",
  { width: "15", height: "15", viewBox: "0 0 15 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...t, ref: r },
  R.createElement("path", { d: "M7.49991 0.876892C3.84222 0.876892 0.877075 3.84204 0.877075 7.49972C0.877075 11.1574 3.84222 14.1226 7.49991 14.1226C11.1576 14.1226 14.1227 11.1574 14.1227 7.49972C14.1227 3.84204 11.1576 0.876892 7.49991 0.876892ZM1.82707 7.49972C1.82707 4.36671 4.36689 1.82689 7.49991 1.82689C10.6329 1.82689 13.1727 4.36671 13.1727 7.49972C13.1727 10.6327 10.6329 13.1726 7.49991 13.1726C4.36689 13.1726 1.82707 10.6327 1.82707 7.49972ZM8.24992 4.49999C8.24992 4.9142 7.91413 5.24999 7.49992 5.24999C7.08571 5.24999 6.74992 4.9142 6.74992 4.49999C6.74992 4.08577 7.08571 3.74999 7.49992 3.74999C7.91413 3.74999 8.24992 4.08577 8.24992 4.49999ZM6.00003 5.99999H6.50003H7.50003C7.77618 5.99999 8.00003 6.22384 8.00003 6.49999V9.99999H8.50003H9.00003V11H8.50003H7.50003H6.50003H6.00003V9.99999H6.50003H7.00003V6.99999H6.50003H6.00003V5.99999Z", fill: e, fillRule: "evenodd", clipRule: "evenodd" })
));
EG.displayName = "InfoCircledIcon";
const mh = R.forwardRef((e, t) => {
  const { rest: r, ...n } = yl(e), { className: i, style: s, size: o = Dl.size.default, variant: a = Dl.variant.default, color: c = Dl.color.default, highContrast: u = Dl.highContrast.default, ...l } = r;
  return R.createElement(
    "span",
    { className: br("rt-CheckboxRoot", i, Mn(o, "rt-r-size"), vl(n)), style: s },
    R.createElement(
      z7,
      { "data-accent-color": c, ...l, ref: t, className: br("rt-reset", "rt-CheckboxButton", `rt-variant-${a}`, {
        "rt-high-contrast": u
      }) },
      R.createElement(
        q7,
        { className: "rt-CheckboxIndicator" },
        R.createElement(ph, { className: "rt-CheckboxIndicatorIcon" })
      )
    )
  );
});
mh.displayName = "Checkbox";
function X7(e) {
  const t = e + "CollectionProvider", [r, n] = eo(t), [i, s] = r(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (y) => {
    const { scope: S, children: C } = y, O = Fr.useRef(null), I = Fr.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ _.jsx(i, { scope: S, itemMap: I, collectionRef: O, children: C });
  };
  o.displayName = t;
  const a = e + "CollectionSlot", c = /* @__PURE__ */ Du(a), u = Fr.forwardRef(
    (y, S) => {
      const { scope: C, children: O } = y, I = s(a, C), U = ar(S, I.collectionRef);
      return /* @__PURE__ */ _.jsx(c, { ref: U, children: O });
    }
  );
  u.displayName = a;
  const l = e + "CollectionItemSlot", f = "data-radix-collection-item", h = /* @__PURE__ */ Du(l), v = Fr.forwardRef(
    (y, S) => {
      const { scope: C, children: O, ...I } = y, U = Fr.useRef(null), D = ar(S, U), H = s(l, C);
      return Fr.useEffect(() => (H.itemMap.set(U, { ref: U, ...I }), () => void H.itemMap.delete(U))), /* @__PURE__ */ _.jsx(h, { [f]: "", ref: D, children: O });
    }
  );
  v.displayName = l;
  function b(y) {
    const S = s(e + "CollectionConsumer", y);
    return Fr.useCallback(() => {
      const O = S.collectionRef.current;
      if (!O)
        return [];
      const I = Array.from(O.querySelectorAll(`[${f}]`));
      return Array.from(S.itemMap.values()).sort(
        (H, z) => I.indexOf(H.ref.current) - I.indexOf(z.ref.current)
      );
    }, [S.collectionRef, S.itemMap]);
  }
  return [
    { Provider: o, Slot: u, ItemSlot: v },
    b,
    n
  ];
}
var Np = "rovingFocusGroup.onEntryFocus", TG = { bubbles: !1, cancelable: !0 }, bl = "RovingFocusGroup", [hm, J7, CG] = X7(bl), [AG, Z7] = eo(
  bl,
  [CG]
), [MG, OG] = AG(bl), Q7 = R.forwardRef(
  (e, t) => /* @__PURE__ */ _.jsx(hm.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ _.jsx(hm.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ _.jsx(IG, { ...e, ref: t }) }) })
);
Q7.displayName = bl;
var IG = R.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: r,
    orientation: n,
    loop: i = !1,
    dir: s,
    currentTabStopId: o,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: c,
    onEntryFocus: u,
    preventScrollOnEntryFocus: l = !1,
    ...f
  } = e, h = R.useRef(null), v = ar(t, h), b = O1(s), [y, S] = ml({
    prop: o,
    defaultProp: a ?? null,
    onChange: c,
    caller: bl
  }), [C, O] = R.useState(!1), I = en(u), U = J7(r), D = R.useRef(!1), [H, z] = R.useState(0);
  return R.useEffect(() => {
    const ne = h.current;
    if (ne)
      return ne.addEventListener(Np, I), () => ne.removeEventListener(Np, I);
  }, [I]), /* @__PURE__ */ _.jsx(
    MG,
    {
      scope: r,
      orientation: n,
      dir: b,
      loop: i,
      currentTabStopId: y,
      onItemFocus: R.useCallback(
        (ne) => S(ne),
        [S]
      ),
      onItemShiftTab: R.useCallback(() => O(!0), []),
      onFocusableItemAdd: R.useCallback(
        () => z((ne) => ne + 1),
        []
      ),
      onFocusableItemRemove: R.useCallback(
        () => z((ne) => ne - 1),
        []
      ),
      children: /* @__PURE__ */ _.jsx(
        nr.div,
        {
          tabIndex: C || H === 0 ? -1 : 0,
          "data-orientation": n,
          ...f,
          ref: v,
          style: { outline: "none", ...e.style },
          onMouseDown: xt(e.onMouseDown, () => {
            D.current = !0;
          }),
          onFocus: xt(e.onFocus, (ne) => {
            const le = !D.current;
            if (ne.target === ne.currentTarget && le && !C) {
              const te = new CustomEvent(Np, TG);
              if (ne.currentTarget.dispatchEvent(te), !te.defaultPrevented) {
                const ce = U().filter((m) => m.focusable), V = ce.find((m) => m.active), L = ce.find((m) => m.id === y), d = [V, L, ...ce].filter(
                  Boolean
                ).map((m) => m.ref.current);
                rE(d, l);
              }
            }
            D.current = !1;
          }),
          onBlur: xt(e.onBlur, () => O(!1))
        }
      )
    }
  );
}), eE = "RovingFocusGroupItem", tE = R.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: r,
      focusable: n = !0,
      active: i = !1,
      tabStopId: s,
      children: o,
      ...a
    } = e, c = Lu(), u = s || c, l = OG(eE, r), f = l.currentTabStopId === u, h = J7(r), { onFocusableItemAdd: v, onFocusableItemRemove: b, currentTabStopId: y } = l;
    return R.useEffect(() => {
      if (n)
        return v(), () => b();
    }, [n, v, b]), /* @__PURE__ */ _.jsx(
      hm.ItemSlot,
      {
        scope: r,
        id: u,
        focusable: n,
        active: i,
        children: /* @__PURE__ */ _.jsx(
          nr.span,
          {
            tabIndex: f ? 0 : -1,
            "data-orientation": l.orientation,
            ...a,
            ref: t,
            onMouseDown: xt(e.onMouseDown, (S) => {
              n ? l.onItemFocus(u) : S.preventDefault();
            }),
            onFocus: xt(e.onFocus, () => l.onItemFocus(u)),
            onKeyDown: xt(e.onKeyDown, (S) => {
              if (S.key === "Tab" && S.shiftKey) {
                l.onItemShiftTab();
                return;
              }
              if (S.target !== S.currentTarget)
                return;
              const C = RG(S, l.orientation, l.dir);
              if (C !== void 0) {
                if (S.metaKey || S.ctrlKey || S.altKey || S.shiftKey)
                  return;
                S.preventDefault();
                let I = h().filter((U) => U.focusable).map((U) => U.ref.current);
                if (C === "last")
                  I.reverse();
                else if (C === "prev" || C === "next") {
                  C === "prev" && I.reverse();
                  const U = I.indexOf(S.currentTarget);
                  I = l.loop ? PG(I, U + 1) : I.slice(U + 1);
                }
                setTimeout(() => rE(I));
              }
            }),
            children: typeof o == "function" ? o({ isCurrentTabStop: f, hasTabStop: y != null }) : o
          }
        )
      }
    );
  }
);
tE.displayName = eE;
var kG = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function jG(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function RG(e, t, r) {
  const n = jG(e.key, r);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return kG[n];
}
function rE(e, t = !1) {
  const r = document.activeElement;
  for (const n of e)
    if (n === r || (n.focus({ preventScroll: t }), document.activeElement !== r))
      return;
}
function PG(e, t) {
  return e.map((r, n) => e[(t + n) % e.length]);
}
var NG = Q7, $G = tE;
function DG(e, [t, r]) {
  return Math.min(r, Math.max(t, e));
}
var $p = 0;
function LG() {
  R.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Rb()), document.body.insertAdjacentElement("beforeend", e[1] ?? Rb()), $p++, () => {
      $p === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), $p--;
    };
  }, []);
}
function Rb() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Dp = "focusScope.autoFocusOnMount", Lp = "focusScope.autoFocusOnUnmount", Pb = { bubbles: !1, cancelable: !0 }, BG = "FocusScope", nE = R.forwardRef((e, t) => {
  const {
    loop: r = !1,
    trapped: n = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...o
  } = e, [a, c] = R.useState(null), u = en(i), l = en(s), f = R.useRef(null), h = ar(t, (y) => c(y)), v = R.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  R.useEffect(() => {
    if (n) {
      let y = function(I) {
        if (v.paused || !a)
          return;
        const U = I.target;
        a.contains(U) ? f.current = U : fo(f.current, { select: !0 });
      }, S = function(I) {
        if (v.paused || !a)
          return;
        const U = I.relatedTarget;
        U !== null && (a.contains(U) || fo(f.current, { select: !0 }));
      }, C = function(I) {
        if (document.activeElement === document.body)
          for (const D of I)
            D.removedNodes.length > 0 && fo(a);
      };
      document.addEventListener("focusin", y), document.addEventListener("focusout", S);
      const O = new MutationObserver(C);
      return a && O.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", y), document.removeEventListener("focusout", S), O.disconnect();
      };
    }
  }, [n, a, v.paused]), R.useEffect(() => {
    if (a) {
      $b.add(v);
      const y = document.activeElement;
      if (!a.contains(y)) {
        const C = new CustomEvent(Dp, Pb);
        a.addEventListener(Dp, u), a.dispatchEvent(C), C.defaultPrevented || (UG(qG(iE(a)), { select: !0 }), document.activeElement === y && fo(a));
      }
      return () => {
        a.removeEventListener(Dp, u), setTimeout(() => {
          const C = new CustomEvent(Lp, Pb);
          a.addEventListener(Lp, l), a.dispatchEvent(C), C.defaultPrevented || fo(y ?? document.body, { select: !0 }), a.removeEventListener(Lp, l), $b.remove(v);
        }, 0);
      };
    }
  }, [a, u, l, v]);
  const b = R.useCallback(
    (y) => {
      if (!r && !n || v.paused)
        return;
      const S = y.key === "Tab" && !y.altKey && !y.ctrlKey && !y.metaKey, C = document.activeElement;
      if (S && C) {
        const O = y.currentTarget, [I, U] = FG(O);
        I && U ? !y.shiftKey && C === U ? (y.preventDefault(), r && fo(I, { select: !0 })) : y.shiftKey && C === I && (y.preventDefault(), r && fo(U, { select: !0 })) : C === O && y.preventDefault();
      }
    },
    [r, n, v.paused]
  );
  return /* @__PURE__ */ _.jsx(nr.div, { tabIndex: -1, ...o, ref: h, onKeyDown: b });
});
nE.displayName = BG;
function UG(e, { select: t = !1 } = {}) {
  const r = document.activeElement;
  for (const n of e)
    if (fo(n, { select: t }), document.activeElement !== r)
      return;
}
function FG(e) {
  const t = iE(e), r = Nb(t, e), n = Nb(t.reverse(), e);
  return [r, n];
}
function iE(e) {
  const t = [], r = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const i = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || i ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r.nextNode(); )
    t.push(r.currentNode);
  return t;
}
function Nb(e, t) {
  for (const r of e)
    if (!VG(r, { upTo: t }))
      return r;
}
function VG(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function zG(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function fo(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const r = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== r && zG(e) && t && e.select();
  }
}
var $b = WG();
function WG() {
  let e = [];
  return {
    add(t) {
      const r = e[0];
      t !== r && (r == null || r.pause()), e = Db(e, t), e.unshift(t);
    },
    remove(t) {
      var r;
      e = Db(e, t), (r = e[0]) == null || r.resume();
    }
  };
}
function Db(e, t) {
  const r = [...e], n = r.indexOf(t);
  return n !== -1 && r.splice(n, 1), r;
}
function qG(e) {
  return e.filter((t) => t.tagName !== "A");
}
var HG = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Fa = /* @__PURE__ */ new WeakMap(), Ll = /* @__PURE__ */ new WeakMap(), Bl = {}, Bp = 0, sE = function(e) {
  return e && (e.host || sE(e.parentNode));
}, GG = function(e, t) {
  return t.map(function(r) {
    if (e.contains(r))
      return r;
    var n = sE(r);
    return n && e.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(r) {
    return !!r;
  });
}, KG = function(e, t, r, n) {
  var i = GG(t, Array.isArray(e) ? e : [e]);
  Bl[r] || (Bl[r] = /* @__PURE__ */ new WeakMap());
  var s = Bl[r], o = [], a = /* @__PURE__ */ new Set(), c = new Set(i), u = function(f) {
    !f || a.has(f) || (a.add(f), u(f.parentNode));
  };
  i.forEach(u);
  var l = function(f) {
    !f || c.has(f) || Array.prototype.forEach.call(f.children, function(h) {
      if (a.has(h))
        l(h);
      else
        try {
          var v = h.getAttribute(n), b = v !== null && v !== "false", y = (Fa.get(h) || 0) + 1, S = (s.get(h) || 0) + 1;
          Fa.set(h, y), s.set(h, S), o.push(h), y === 1 && b && Ll.set(h, !0), S === 1 && h.setAttribute(r, "true"), b || h.setAttribute(n, "true");
        } catch (C) {
          console.error("aria-hidden: cannot operate on ", h, C);
        }
    });
  };
  return l(t), a.clear(), Bp++, function() {
    o.forEach(function(f) {
      var h = Fa.get(f) - 1, v = s.get(f) - 1;
      Fa.set(f, h), s.set(f, v), h || (Ll.has(f) || f.removeAttribute(n), Ll.delete(f)), v || f.removeAttribute(r);
    }), Bp--, Bp || (Fa = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Ll = /* @__PURE__ */ new WeakMap(), Bl = {});
  };
}, YG = function(e, t, r) {
  r === void 0 && (r = "data-aria-hidden");
  var n = Array.from(Array.isArray(e) ? e : [e]), i = t || HG(e);
  return i ? (n.push.apply(n, Array.from(i.querySelectorAll("[aria-live], script"))), KG(n, i, r, "aria-hidden")) : function() {
    return null;
  };
}, Zi = function() {
  return Zi = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, Zi.apply(this, arguments);
};
function oE(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
function XG(e, t, r) {
  if (r || arguments.length === 2)
    for (var n = 0, i = t.length, s; n < i; n++)
      (s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var Ef = "right-scroll-bar-position", Tf = "width-before-scroll-bar", JG = "with-scroll-bars-hidden", ZG = "--removed-body-scroll-bar-size";
function Up(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function QG(e, t) {
  var r = Mt(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return r.value;
        },
        set current(n) {
          var i = r.value;
          i !== n && (r.value = n, r.callback(n, i));
        }
      }
    };
  })[0];
  return r.callback = t, r.facade;
}
var eK = typeof window < "u" ? R.useLayoutEffect : R.useEffect, Lb = /* @__PURE__ */ new WeakMap();
function tK(e, t) {
  var r = QG(t || null, function(n) {
    return e.forEach(function(i) {
      return Up(i, n);
    });
  });
  return eK(function() {
    var n = Lb.get(r);
    if (n) {
      var i = new Set(n), s = new Set(e), o = r.current;
      i.forEach(function(a) {
        s.has(a) || Up(a, null);
      }), s.forEach(function(a) {
        i.has(a) || Up(a, o);
      });
    }
    Lb.set(r, e);
  }, [e]), r;
}
function rK(e) {
  return e;
}
function nK(e, t) {
  t === void 0 && (t = rK);
  var r = [], n = !1, i = {
    read: function() {
      if (n)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r.length ? r[r.length - 1] : e;
    },
    useMedium: function(s) {
      var o = t(s, n);
      return r.push(o), function() {
        r = r.filter(function(a) {
          return a !== o;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (n = !0; r.length; ) {
        var o = r;
        r = [], o.forEach(s);
      }
      r = {
        push: function(a) {
          return s(a);
        },
        filter: function() {
          return r;
        }
      };
    },
    assignMedium: function(s) {
      n = !0;
      var o = [];
      if (r.length) {
        var a = r;
        r = [], a.forEach(s), o = r;
      }
      var c = function() {
        var l = o;
        o = [], l.forEach(s);
      }, u = function() {
        return Promise.resolve().then(c);
      };
      u(), r = {
        push: function(l) {
          o.push(l), u();
        },
        filter: function(l) {
          return o = o.filter(l), r;
        }
      };
    }
  };
  return i;
}
function iK(e) {
  e === void 0 && (e = {});
  var t = nK(null);
  return t.options = Zi({ async: !0, ssr: !1 }, e), t;
}
var aE = function(e) {
  var t = e.sideCar, r = oE(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var n = t.read();
  if (!n)
    throw new Error("Sidecar medium not found");
  return R.createElement(n, Zi({}, r));
};
aE.isSideCarExport = !0;
function sK(e, t) {
  return e.useMedium(t), aE;
}
var cE = iK(), Fp = function() {
}, gh = R.forwardRef(function(e, t) {
  var r = R.useRef(null), n = R.useState({
    onScrollCapture: Fp,
    onWheelCapture: Fp,
    onTouchMoveCapture: Fp
  }), i = n[0], s = n[1], o = e.forwardProps, a = e.children, c = e.className, u = e.removeScrollBar, l = e.enabled, f = e.shards, h = e.sideCar, v = e.noRelative, b = e.noIsolation, y = e.inert, S = e.allowPinchZoom, C = e.as, O = C === void 0 ? "div" : C, I = e.gapMode, U = oE(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), D = h, H = tK([r, t]), z = Zi(Zi({}, U), i);
  return R.createElement(
    R.Fragment,
    null,
    l && R.createElement(D, { sideCar: cE, removeScrollBar: u, shards: f, noRelative: v, noIsolation: b, inert: y, setCallbacks: s, allowPinchZoom: !!S, lockRef: r, gapMode: I }),
    o ? R.cloneElement(R.Children.only(a), Zi(Zi({}, z), { ref: H })) : R.createElement(O, Zi({}, z, { className: c, ref: H }), a)
  );
});
gh.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
gh.classNames = {
  fullWidth: Tf,
  zeroRight: Ef
};
var Bb, oK = function() {
  if (Bb)
    return Bb;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function aK() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = oK();
  return t && e.setAttribute("nonce", t), e;
}
function cK(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function uK(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var lK = function() {
  var e = 0, t = null;
  return {
    add: function(r) {
      e == 0 && (t = aK()) && (cK(t, r), uK(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, fK = function() {
  var e = lK();
  return function(t, r) {
    R.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && r]);
  };
}, uE = function() {
  var e = fK(), t = function(r) {
    var n = r.styles, i = r.dynamic;
    return e(n, i), null;
  };
  return t;
}, dK = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Vp = function(e) {
  return parseInt(e || "", 10) || 0;
}, hK = function(e) {
  var t = window.getComputedStyle(document.body), r = t[e === "padding" ? "paddingLeft" : "marginLeft"], n = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Vp(r), Vp(n), Vp(i)];
}, pK = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return dK;
  var t = hK(e), r = document.documentElement.clientWidth, n = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, n - r + t[2] - t[0])
  };
}, mK = uE(), dc = "data-scroll-locked", gK = function(e, t, r, n) {
  var i = e.left, s = e.top, o = e.right, a = e.gap;
  return r === void 0 && (r = "margin"), `
  .`.concat(JG, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(a, "px ").concat(n, `;
  }
  body[`).concat(dc, `] {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(n, ";"),
    r === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(n, `;
    `),
    r === "padding" && "padding-right: ".concat(a, "px ").concat(n, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Ef, ` {
    right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Tf, ` {
    margin-right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Ef, " .").concat(Ef, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(Tf, " .").concat(Tf, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body[`).concat(dc, `] {
    `).concat(ZG, ": ").concat(a, `px;
  }
`);
}, Ub = function() {
  var e = parseInt(document.body.getAttribute(dc) || "0", 10);
  return isFinite(e) ? e : 0;
}, yK = function() {
  R.useEffect(function() {
    return document.body.setAttribute(dc, (Ub() + 1).toString()), function() {
      var e = Ub() - 1;
      e <= 0 ? document.body.removeAttribute(dc) : document.body.setAttribute(dc, e.toString());
    };
  }, []);
}, vK = function(e) {
  var t = e.noRelative, r = e.noImportant, n = e.gapMode, i = n === void 0 ? "margin" : n;
  yK();
  var s = R.useMemo(function() {
    return pK(i);
  }, [i]);
  return R.createElement(mK, { styles: gK(s, !t, i, r ? "" : "!important") });
}, pm = !1;
if (typeof window < "u")
  try {
    var Ul = Object.defineProperty({}, "passive", {
      get: function() {
        return pm = !0, !0;
      }
    });
    window.addEventListener("test", Ul, Ul), window.removeEventListener("test", Ul, Ul);
  } catch {
    pm = !1;
  }
var Va = pm ? { passive: !1 } : !1, bK = function(e) {
  return e.tagName === "TEXTAREA";
}, lE = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var r = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    r[t] !== "hidden" && // contains scroll inside self
    !(r.overflowY === r.overflowX && !bK(e) && r[t] === "visible")
  );
}, wK = function(e) {
  return lE(e, "overflowY");
}, _K = function(e) {
  return lE(e, "overflowX");
}, Fb = function(e, t) {
  var r = t.ownerDocument, n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var i = fE(e, n);
    if (i) {
      var s = dE(e, n), o = s[1], a = s[2];
      if (o > a)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== r.body);
  return !1;
}, xK = function(e) {
  var t = e.scrollTop, r = e.scrollHeight, n = e.clientHeight;
  return [
    t,
    r,
    n
  ];
}, SK = function(e) {
  var t = e.scrollLeft, r = e.scrollWidth, n = e.clientWidth;
  return [
    t,
    r,
    n
  ];
}, fE = function(e, t) {
  return e === "v" ? wK(t) : _K(t);
}, dE = function(e, t) {
  return e === "v" ? xK(t) : SK(t);
}, EK = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, TK = function(e, t, r, n, i) {
  var s = EK(e, window.getComputedStyle(t).direction), o = s * n, a = r.target, c = t.contains(a), u = !1, l = o > 0, f = 0, h = 0;
  do {
    if (!a)
      break;
    var v = dE(e, a), b = v[0], y = v[1], S = v[2], C = y - S - s * b;
    (b || C) && fE(e, a) && (f += C, h += b);
    var O = a.parentNode;
    a = O && O.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? O.host : O;
  } while (
    // portaled content
    !c && a !== document.body || // self content
    c && (t.contains(a) || t === a)
  );
  return (l && (i && Math.abs(f) < 1 || !i && o > f) || !l && (i && Math.abs(h) < 1 || !i && -o > h)) && (u = !0), u;
}, Fl = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Vb = function(e) {
  return [e.deltaX, e.deltaY];
}, zb = function(e) {
  return e && "current" in e ? e.current : e;
}, CK = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, AK = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, MK = 0, za = [];
function OK(e) {
  var t = R.useRef([]), r = R.useRef([0, 0]), n = R.useRef(), i = R.useState(MK++)[0], s = R.useState(uE)[0], o = R.useRef(e);
  R.useEffect(function() {
    o.current = e;
  }, [e]), R.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var y = XG([e.lockRef.current], (e.shards || []).map(zb), !0).filter(Boolean);
      return y.forEach(function(S) {
        return S.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), y.forEach(function(S) {
          return S.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var a = R.useCallback(function(y, S) {
    if ("touches" in y && y.touches.length === 2 || y.type === "wheel" && y.ctrlKey)
      return !o.current.allowPinchZoom;
    var C = Fl(y), O = r.current, I = "deltaX" in y ? y.deltaX : O[0] - C[0], U = "deltaY" in y ? y.deltaY : O[1] - C[1], D, H = y.target, z = Math.abs(I) > Math.abs(U) ? "h" : "v";
    if ("touches" in y && z === "h" && H.type === "range")
      return !1;
    var ne = Fb(z, H);
    if (!ne)
      return !0;
    if (ne ? D = z : (D = z === "v" ? "h" : "v", ne = Fb(z, H)), !ne)
      return !1;
    if (!n.current && "changedTouches" in y && (I || U) && (n.current = D), !D)
      return !0;
    var le = n.current || D;
    return TK(le, S, y, le === "h" ? I : U, !0);
  }, []), c = R.useCallback(function(y) {
    var S = y;
    if (!(!za.length || za[za.length - 1] !== s)) {
      var C = "deltaY" in S ? Vb(S) : Fl(S), O = t.current.filter(function(D) {
        return D.name === S.type && (D.target === S.target || S.target === D.shadowParent) && CK(D.delta, C);
      })[0];
      if (O && O.should) {
        S.cancelable && S.preventDefault();
        return;
      }
      if (!O) {
        var I = (o.current.shards || []).map(zb).filter(Boolean).filter(function(D) {
          return D.contains(S.target);
        }), U = I.length > 0 ? a(S, I[0]) : !o.current.noIsolation;
        U && S.cancelable && S.preventDefault();
      }
    }
  }, []), u = R.useCallback(function(y, S, C, O) {
    var I = { name: y, delta: S, target: C, should: O, shadowParent: IK(C) };
    t.current.push(I), setTimeout(function() {
      t.current = t.current.filter(function(U) {
        return U !== I;
      });
    }, 1);
  }, []), l = R.useCallback(function(y) {
    r.current = Fl(y), n.current = void 0;
  }, []), f = R.useCallback(function(y) {
    u(y.type, Vb(y), y.target, a(y, e.lockRef.current));
  }, []), h = R.useCallback(function(y) {
    u(y.type, Fl(y), y.target, a(y, e.lockRef.current));
  }, []);
  R.useEffect(function() {
    return za.push(s), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: h
    }), document.addEventListener("wheel", c, Va), document.addEventListener("touchmove", c, Va), document.addEventListener("touchstart", l, Va), function() {
      za = za.filter(function(y) {
        return y !== s;
      }), document.removeEventListener("wheel", c, Va), document.removeEventListener("touchmove", c, Va), document.removeEventListener("touchstart", l, Va);
    };
  }, []);
  var v = e.removeScrollBar, b = e.inert;
  return R.createElement(
    R.Fragment,
    null,
    b ? R.createElement(s, { styles: AK(i) }) : null,
    v ? R.createElement(vK, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function IK(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const kK = sK(cE, OK);
var hE = R.forwardRef(function(e, t) {
  return R.createElement(gh, Zi({}, e, { ref: t, sideCar: kK }));
});
hE.classNames = gh.classNames;
const jK = hE;
function RK(e, t) {
  return R.useReducer((r, n) => t[r][n] ?? r, e);
}
var R1 = "ScrollArea", [pE, Qie] = eo(R1), [PK, ui] = pE(R1), mE = R.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: r,
      type: n = "hover",
      dir: i,
      scrollHideDelay: s = 600,
      ...o
    } = e, [a, c] = R.useState(null), [u, l] = R.useState(null), [f, h] = R.useState(null), [v, b] = R.useState(null), [y, S] = R.useState(null), [C, O] = R.useState(0), [I, U] = R.useState(0), [D, H] = R.useState(!1), [z, ne] = R.useState(!1), le = ar(t, (ce) => c(ce)), te = O1(i);
    return /* @__PURE__ */ _.jsx(
      PK,
      {
        scope: r,
        type: n,
        dir: te,
        scrollHideDelay: s,
        scrollArea: a,
        viewport: u,
        onViewportChange: l,
        content: f,
        onContentChange: h,
        scrollbarX: v,
        onScrollbarXChange: b,
        scrollbarXEnabled: D,
        onScrollbarXEnabledChange: H,
        scrollbarY: y,
        onScrollbarYChange: S,
        scrollbarYEnabled: z,
        onScrollbarYEnabledChange: ne,
        onCornerWidthChange: O,
        onCornerHeightChange: U,
        children: /* @__PURE__ */ _.jsx(
          nr.div,
          {
            dir: te,
            ...o,
            ref: le,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": C + "px",
              "--radix-scroll-area-corner-height": I + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
mE.displayName = R1;
var gE = "ScrollAreaViewport", yE = R.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: r, children: n, nonce: i, ...s } = e, o = ui(gE, r), a = R.useRef(null), c = ar(t, a, o.onViewportChange);
    return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
      /* @__PURE__ */ _.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ _.jsx(
        nr.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...s,
          ref: c,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: o.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: o.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ _.jsx("div", { ref: o.onContentChange, style: { minWidth: "100%", display: "table" }, children: n })
        }
      )
    ] });
  }
);
yE.displayName = gE;
var hs = "ScrollAreaScrollbar", vE = R.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, i = ui(hs, e.__scopeScrollArea), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: o } = i, a = e.orientation === "horizontal";
    return R.useEffect(() => (a ? s(!0) : o(!0), () => {
      a ? s(!1) : o(!1);
    }), [a, s, o]), i.type === "hover" ? /* @__PURE__ */ _.jsx(NK, { ...n, ref: t, forceMount: r }) : i.type === "scroll" ? /* @__PURE__ */ _.jsx($K, { ...n, ref: t, forceMount: r }) : i.type === "auto" ? /* @__PURE__ */ _.jsx(bE, { ...n, ref: t, forceMount: r }) : i.type === "always" ? /* @__PURE__ */ _.jsx(P1, { ...n, ref: t }) : null;
  }
);
vE.displayName = hs;
var NK = R.forwardRef((e, t) => {
  const { forceMount: r, ...n } = e, i = ui(hs, e.__scopeScrollArea), [s, o] = R.useState(!1);
  return R.useEffect(() => {
    const a = i.scrollArea;
    let c = 0;
    if (a) {
      const u = () => {
        window.clearTimeout(c), o(!0);
      }, l = () => {
        c = window.setTimeout(() => o(!1), i.scrollHideDelay);
      };
      return a.addEventListener("pointerenter", u), a.addEventListener("pointerleave", l), () => {
        window.clearTimeout(c), a.removeEventListener("pointerenter", u), a.removeEventListener("pointerleave", l);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ _.jsx(Ni, { present: r || s, children: /* @__PURE__ */ _.jsx(
    bE,
    {
      "data-state": s ? "visible" : "hidden",
      ...n,
      ref: t
    }
  ) });
}), $K = R.forwardRef((e, t) => {
  const { forceMount: r, ...n } = e, i = ui(hs, e.__scopeScrollArea), s = e.orientation === "horizontal", o = vh(() => c("SCROLL_END"), 100), [a, c] = RK("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return R.useEffect(() => {
    if (a === "idle") {
      const u = window.setTimeout(() => c("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(u);
    }
  }, [a, i.scrollHideDelay, c]), R.useEffect(() => {
    const u = i.viewport, l = s ? "scrollLeft" : "scrollTop";
    if (u) {
      let f = u[l];
      const h = () => {
        const v = u[l];
        f !== v && (c("SCROLL"), o()), f = v;
      };
      return u.addEventListener("scroll", h), () => u.removeEventListener("scroll", h);
    }
  }, [i.viewport, s, c, o]), /* @__PURE__ */ _.jsx(Ni, { present: r || a !== "hidden", children: /* @__PURE__ */ _.jsx(
    P1,
    {
      "data-state": a === "hidden" ? "hidden" : "visible",
      ...n,
      ref: t,
      onPointerEnter: xt(e.onPointerEnter, () => c("POINTER_ENTER")),
      onPointerLeave: xt(e.onPointerLeave, () => c("POINTER_LEAVE"))
    }
  ) });
}), bE = R.forwardRef((e, t) => {
  const r = ui(hs, e.__scopeScrollArea), { forceMount: n, ...i } = e, [s, o] = R.useState(!1), a = e.orientation === "horizontal", c = vh(() => {
    if (r.viewport) {
      const u = r.viewport.offsetWidth < r.viewport.scrollWidth, l = r.viewport.offsetHeight < r.viewport.scrollHeight;
      o(a ? u : l);
    }
  }, 10);
  return xc(r.viewport, c), xc(r.content, c), /* @__PURE__ */ _.jsx(Ni, { present: n || s, children: /* @__PURE__ */ _.jsx(
    P1,
    {
      "data-state": s ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), P1 = R.forwardRef((e, t) => {
  const { orientation: r = "vertical", ...n } = e, i = ui(hs, e.__scopeScrollArea), s = R.useRef(null), o = R.useRef(0), [a, c] = R.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = EE(a.viewport, a.content), l = {
    ...n,
    sizes: a,
    onSizesChange: c,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (h) => s.current = h,
    onThumbPointerUp: () => o.current = 0,
    onThumbPointerDown: (h) => o.current = h
  };
  function f(h, v) {
    return VK(h, o.current, a, v);
  }
  return r === "horizontal" ? /* @__PURE__ */ _.jsx(
    DK,
    {
      ...l,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const h = i.viewport.scrollLeft, v = Wb(h, a, i.dir);
          s.current.style.transform = `translate3d(${v}px, 0, 0)`;
        }
      },
      onWheelScroll: (h) => {
        i.viewport && (i.viewport.scrollLeft = h);
      },
      onDragScroll: (h) => {
        i.viewport && (i.viewport.scrollLeft = f(h, i.dir));
      }
    }
  ) : r === "vertical" ? /* @__PURE__ */ _.jsx(
    LK,
    {
      ...l,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && s.current) {
          const h = i.viewport.scrollTop, v = Wb(h, a);
          s.current.style.transform = `translate3d(0, ${v}px, 0)`;
        }
      },
      onWheelScroll: (h) => {
        i.viewport && (i.viewport.scrollTop = h);
      },
      onDragScroll: (h) => {
        i.viewport && (i.viewport.scrollTop = f(h));
      }
    }
  ) : null;
}), DK = R.forwardRef((e, t) => {
  const { sizes: r, onSizesChange: n, ...i } = e, s = ui(hs, e.__scopeScrollArea), [o, a] = R.useState(), c = R.useRef(null), u = ar(t, c, s.onScrollbarXChange);
  return R.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ _.jsx(
    _E,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: u,
      sizes: r,
      style: {
        bottom: 0,
        left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": yh(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (l) => e.onThumbPointerDown(l.x),
      onDragScroll: (l) => e.onDragScroll(l.x),
      onWheelScroll: (l, f) => {
        if (s.viewport) {
          const h = s.viewport.scrollLeft + l.deltaX;
          e.onWheelScroll(h), CE(h, f) && l.preventDefault();
        }
      },
      onResize: () => {
        c.current && s.viewport && o && n({
          content: s.viewport.scrollWidth,
          viewport: s.viewport.offsetWidth,
          scrollbar: {
            size: c.current.clientWidth,
            paddingStart: pd(o.paddingLeft),
            paddingEnd: pd(o.paddingRight)
          }
        });
      }
    }
  );
}), LK = R.forwardRef((e, t) => {
  const { sizes: r, onSizesChange: n, ...i } = e, s = ui(hs, e.__scopeScrollArea), [o, a] = R.useState(), c = R.useRef(null), u = ar(t, c, s.onScrollbarYChange);
  return R.useEffect(() => {
    c.current && a(getComputedStyle(c.current));
  }, [c]), /* @__PURE__ */ _.jsx(
    _E,
    {
      "data-orientation": "vertical",
      ...i,
      ref: u,
      sizes: r,
      style: {
        top: 0,
        right: s.dir === "ltr" ? 0 : void 0,
        left: s.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": yh(r) + "px",
        ...e.style
      },
      onThumbPointerDown: (l) => e.onThumbPointerDown(l.y),
      onDragScroll: (l) => e.onDragScroll(l.y),
      onWheelScroll: (l, f) => {
        if (s.viewport) {
          const h = s.viewport.scrollTop + l.deltaY;
          e.onWheelScroll(h), CE(h, f) && l.preventDefault();
        }
      },
      onResize: () => {
        c.current && s.viewport && o && n({
          content: s.viewport.scrollHeight,
          viewport: s.viewport.offsetHeight,
          scrollbar: {
            size: c.current.clientHeight,
            paddingStart: pd(o.paddingTop),
            paddingEnd: pd(o.paddingBottom)
          }
        });
      }
    }
  );
}), [BK, wE] = pE(hs), _E = R.forwardRef((e, t) => {
  const {
    __scopeScrollArea: r,
    sizes: n,
    hasThumb: i,
    onThumbChange: s,
    onThumbPointerUp: o,
    onThumbPointerDown: a,
    onThumbPositionChange: c,
    onDragScroll: u,
    onWheelScroll: l,
    onResize: f,
    ...h
  } = e, v = ui(hs, r), [b, y] = R.useState(null), S = ar(t, (le) => y(le)), C = R.useRef(null), O = R.useRef(""), I = v.viewport, U = n.content - n.viewport, D = en(l), H = en(c), z = vh(f, 10);
  function ne(le) {
    if (C.current) {
      const te = le.clientX - C.current.left, ce = le.clientY - C.current.top;
      u({ x: te, y: ce });
    }
  }
  return R.useEffect(() => {
    const le = (te) => {
      const ce = te.target;
      (b == null ? void 0 : b.contains(ce)) && D(te, U);
    };
    return document.addEventListener("wheel", le, { passive: !1 }), () => document.removeEventListener("wheel", le, { passive: !1 });
  }, [I, b, U, D]), R.useEffect(H, [n, H]), xc(b, z), xc(v.content, z), /* @__PURE__ */ _.jsx(
    BK,
    {
      scope: r,
      scrollbar: b,
      hasThumb: i,
      onThumbChange: en(s),
      onThumbPointerUp: en(o),
      onThumbPositionChange: H,
      onThumbPointerDown: en(a),
      children: /* @__PURE__ */ _.jsx(
        nr.div,
        {
          ...h,
          ref: S,
          style: { position: "absolute", ...h.style },
          onPointerDown: xt(e.onPointerDown, (le) => {
            le.button === 0 && (le.target.setPointerCapture(le.pointerId), C.current = b.getBoundingClientRect(), O.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", v.viewport && (v.viewport.style.scrollBehavior = "auto"), ne(le));
          }),
          onPointerMove: xt(e.onPointerMove, ne),
          onPointerUp: xt(e.onPointerUp, (le) => {
            const te = le.target;
            te.hasPointerCapture(le.pointerId) && te.releasePointerCapture(le.pointerId), document.body.style.webkitUserSelect = O.current, v.viewport && (v.viewport.style.scrollBehavior = ""), C.current = null;
          })
        }
      )
    }
  );
}), hd = "ScrollAreaThumb", xE = R.forwardRef(
  (e, t) => {
    const { forceMount: r, ...n } = e, i = wE(hd, e.__scopeScrollArea);
    return /* @__PURE__ */ _.jsx(Ni, { present: r || i.hasThumb, children: /* @__PURE__ */ _.jsx(UK, { ref: t, ...n }) });
  }
), UK = R.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: r, style: n, ...i } = e, s = ui(hd, r), o = wE(hd, r), { onThumbPositionChange: a } = o, c = ar(
      t,
      (f) => o.onThumbChange(f)
    ), u = R.useRef(void 0), l = vh(() => {
      u.current && (u.current(), u.current = void 0);
    }, 100);
    return R.useEffect(() => {
      const f = s.viewport;
      if (f) {
        const h = () => {
          if (l(), !u.current) {
            const v = zK(f, a);
            u.current = v, a();
          }
        };
        return a(), f.addEventListener("scroll", h), () => f.removeEventListener("scroll", h);
      }
    }, [s.viewport, l, a]), /* @__PURE__ */ _.jsx(
      nr.div,
      {
        "data-state": o.hasThumb ? "visible" : "hidden",
        ...i,
        ref: c,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...n
        },
        onPointerDownCapture: xt(e.onPointerDownCapture, (f) => {
          const v = f.target.getBoundingClientRect(), b = f.clientX - v.left, y = f.clientY - v.top;
          o.onThumbPointerDown({ x: b, y });
        }),
        onPointerUp: xt(e.onPointerUp, o.onThumbPointerUp)
      }
    );
  }
);
xE.displayName = hd;
var N1 = "ScrollAreaCorner", SE = R.forwardRef(
  (e, t) => {
    const r = ui(N1, e.__scopeScrollArea), n = !!(r.scrollbarX && r.scrollbarY);
    return r.type !== "scroll" && n ? /* @__PURE__ */ _.jsx(FK, { ...e, ref: t }) : null;
  }
);
SE.displayName = N1;
var FK = R.forwardRef((e, t) => {
  const { __scopeScrollArea: r, ...n } = e, i = ui(N1, r), [s, o] = R.useState(0), [a, c] = R.useState(0), u = !!(s && a);
  return xc(i.scrollbarX, () => {
    var f;
    const l = ((f = i.scrollbarX) == null ? void 0 : f.offsetHeight) || 0;
    i.onCornerHeightChange(l), c(l);
  }), xc(i.scrollbarY, () => {
    var f;
    const l = ((f = i.scrollbarY) == null ? void 0 : f.offsetWidth) || 0;
    i.onCornerWidthChange(l), o(l);
  }), u ? /* @__PURE__ */ _.jsx(
    nr.div,
    {
      ...n,
      ref: t,
      style: {
        width: s,
        height: a,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function pd(e) {
  return e ? parseInt(e, 10) : 0;
}
function EE(e, t) {
  const r = e / t;
  return isNaN(r) ? 0 : r;
}
function yh(e) {
  const t = EE(e.viewport, e.content), r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, n = (e.scrollbar.size - r) * t;
  return Math.max(n, 18);
}
function VK(e, t, r, n = "ltr") {
  const i = yh(r), s = i / 2, o = t || s, a = i - o, c = r.scrollbar.paddingStart + o, u = r.scrollbar.size - r.scrollbar.paddingEnd - a, l = r.content - r.viewport, f = n === "ltr" ? [0, l] : [l * -1, 0];
  return TE([c, u], f)(e);
}
function Wb(e, t, r = "ltr") {
  const n = yh(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - i, o = t.content - t.viewport, a = s - n, c = r === "ltr" ? [0, o] : [o * -1, 0], u = DG(e, c);
  return TE([0, o], [0, a])(u);
}
function TE(e, t) {
  return (r) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + n * (r - e[0]);
  };
}
function CE(e, t) {
  return e > 0 && e < t;
}
var zK = (e, t = () => {
}) => {
  let r = { left: e.scrollLeft, top: e.scrollTop }, n = 0;
  return function i() {
    const s = { left: e.scrollLeft, top: e.scrollTop }, o = r.left !== s.left, a = r.top !== s.top;
    (o || a) && t(), r = s, n = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(n);
};
function vh(e, t) {
  const r = en(e), n = R.useRef(0);
  return R.useEffect(() => () => window.clearTimeout(n.current), []), R.useCallback(() => {
    window.clearTimeout(n.current), n.current = window.setTimeout(r, t);
  }, [r, t]);
}
function xc(e, t) {
  const r = en(t);
  Gs(() => {
    let n = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(n), n = window.requestAnimationFrame(r);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(n), i.unobserve(e);
      };
    }
  }, [e, r]);
}
var WK = mE, qK = yE, qb = vE, Hb = xE, HK = SE, bh = "Switch", [GK, ese] = eo(bh), [KK, YK] = GK(bh), AE = R.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: r,
      name: n,
      checked: i,
      defaultChecked: s,
      required: o,
      disabled: a,
      value: c = "on",
      onCheckedChange: u,
      form: l,
      ...f
    } = e, [h, v] = R.useState(null), b = ar(t, (I) => v(I)), y = R.useRef(!1), S = h ? l || !!h.closest("form") : !0, [C, O] = ml({
      prop: i,
      defaultProp: s ?? !1,
      onChange: u,
      caller: bh
    });
    return /* @__PURE__ */ _.jsxs(KK, { scope: r, checked: C, disabled: a, children: [
      /* @__PURE__ */ _.jsx(
        nr.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": C,
          "aria-required": o,
          "data-state": kE(C),
          "data-disabled": a ? "" : void 0,
          disabled: a,
          value: c,
          ...f,
          ref: b,
          onClick: xt(e.onClick, (I) => {
            O((U) => !U), S && (y.current = I.isPropagationStopped(), y.current || I.stopPropagation());
          })
        }
      ),
      S && /* @__PURE__ */ _.jsx(
        IE,
        {
          control: h,
          bubbles: !y.current,
          name: n,
          value: c,
          checked: C,
          required: o,
          disabled: a,
          form: l,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
AE.displayName = bh;
var ME = "SwitchThumb", OE = R.forwardRef(
  (e, t) => {
    const { __scopeSwitch: r, ...n } = e, i = YK(ME, r);
    return /* @__PURE__ */ _.jsx(
      nr.span,
      {
        "data-state": kE(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...n,
        ref: t
      }
    );
  }
);
OE.displayName = ME;
var XK = "SwitchBubbleInput", IE = R.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: r,
    bubbles: n = !0,
    ...i
  }, s) => {
    const o = R.useRef(null), a = ar(o, s), c = U7(r), u = T1(t);
    return R.useEffect(() => {
      const l = o.current;
      if (!l)
        return;
      const f = window.HTMLInputElement.prototype, v = Object.getOwnPropertyDescriptor(
        f,
        "checked"
      ).set;
      if (c !== r && v) {
        const b = new Event("click", { bubbles: n });
        v.call(l, r), l.dispatchEvent(b);
      }
    }, [c, r, n]), /* @__PURE__ */ _.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: r,
        ...i,
        tabIndex: -1,
        ref: a,
        style: {
          ...i.style,
          ...u,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
IE.displayName = XK;
function kE(e) {
  return e ? "checked" : "unchecked";
}
var JK = AE, ZK = OE;
const QK = ["1", "2", "3"], eY = ["classic", "surface", "soft"], ru = {
  size: { type: "enum", values: QK, default: "2", responsive: !0 },
  variant: { type: "enum", values: eY, default: "surface" },
  color: gl,
  highContrast: dh,
  radius: k1
}, jE = R.forwardRef((e, t) => {
  const { rest: r, ...n } = yl(e), { className: i, style: s, size: o = ru.size.default, variant: a = ru.variant.default, color: c = ru.color.default, highContrast: u = ru.highContrast.default, radius: l = ru.radius.default, ...f } = r;
  return R.createElement(
    "span",
    { "data-radius": l, className: br("rt-SwitchRoot", i, Mn(o, "rt-r-size"), `rt-variant-${a}`, { "rt-high-contrast": u }, vl(n)), style: s },
    R.createElement(
      JK,
      { "data-accent-color": c, ...f, ref: t, className: br("rt-reset", "rt-SwitchButton", {
        "rt-high-contrast": u
      }) },
      R.createElement(ZK, { className: br("rt-SwitchThumb", { "rt-high-contrast": u }) })
    )
  );
});
jE.displayName = "Switch";
var mm = ["Enter", " "], tY = ["ArrowDown", "PageUp", "Home"], RE = ["ArrowUp", "PageDown", "End"], rY = [...tY, ...RE], nY = {
  ltr: [...mm, "ArrowRight"],
  rtl: [...mm, "ArrowLeft"]
}, iY = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, wl = "Menu", [Fu, sY, oY] = X7(wl), [ja, PE] = eo(wl, [
  oY,
  ch,
  Z7
]), _l = ch(), NE = Z7(), [$E, Vo] = ja(wl), [aY, xl] = ja(wl), DE = (e) => {
  const { __scopeMenu: t, open: r = !1, children: n, dir: i, onOpenChange: s, modal: o = !0 } = e, a = _l(t), [c, u] = R.useState(null), l = R.useRef(!1), f = en(s), h = O1(i);
  return R.useEffect(() => {
    const v = () => {
      l.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => l.current = !1;
    return document.addEventListener("keydown", v, { capture: !0 }), () => {
      document.removeEventListener("keydown", v, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ _.jsx(T7, { ...a, children: /* @__PURE__ */ _.jsx(
    $E,
    {
      scope: t,
      open: r,
      onOpenChange: f,
      content: c,
      onContentChange: u,
      children: /* @__PURE__ */ _.jsx(
        aY,
        {
          scope: t,
          onClose: R.useCallback(() => f(!1), [f]),
          isUsingKeyboardRef: l,
          dir: h,
          modal: o,
          children: n
        }
      )
    }
  ) });
};
DE.displayName = wl;
var cY = "MenuAnchor", $1 = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e, i = _l(r);
    return /* @__PURE__ */ _.jsx(C7, { ...i, ...n, ref: t });
  }
);
$1.displayName = cY;
var D1 = "MenuPortal", [uY, LE] = ja(D1, {
  forceMount: void 0
}), BE = (e) => {
  const { __scopeMenu: t, forceMount: r, children: n, container: i } = e, s = Vo(D1, t);
  return /* @__PURE__ */ _.jsx(uY, { scope: t, forceMount: r, children: /* @__PURE__ */ _.jsx(Ni, { present: r || s.open, children: /* @__PURE__ */ _.jsx(O7, { asChild: !0, container: i, children: n }) }) });
};
BE.displayName = D1;
var ci = "MenuContent", [lY, L1] = ja(ci), UE = R.forwardRef(
  (e, t) => {
    const r = LE(ci, e.__scopeMenu), { forceMount: n = r.forceMount, ...i } = e, s = Vo(ci, e.__scopeMenu), o = xl(ci, e.__scopeMenu);
    return /* @__PURE__ */ _.jsx(Fu.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(Ni, { present: n || s.open, children: /* @__PURE__ */ _.jsx(Fu.Slot, { scope: e.__scopeMenu, children: o.modal ? /* @__PURE__ */ _.jsx(fY, { ...i, ref: t }) : /* @__PURE__ */ _.jsx(dY, { ...i, ref: t }) }) }) });
  }
), fY = R.forwardRef(
  (e, t) => {
    const r = Vo(ci, e.__scopeMenu), n = R.useRef(null), i = ar(t, n);
    return R.useEffect(() => {
      const s = n.current;
      if (s)
        return YG(s);
    }, []), /* @__PURE__ */ _.jsx(
      B1,
      {
        ...e,
        ref: i,
        trapFocus: r.open,
        disableOutsidePointerEvents: r.open,
        disableOutsideScroll: !0,
        onFocusOutside: xt(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => r.onOpenChange(!1)
      }
    );
  }
), dY = R.forwardRef((e, t) => {
  const r = Vo(ci, e.__scopeMenu);
  return /* @__PURE__ */ _.jsx(
    B1,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => r.onOpenChange(!1)
    }
  );
}), hY = /* @__PURE__ */ Du("MenuContent.ScrollLock"), B1 = R.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: r,
      loop: n = !1,
      trapFocus: i,
      onOpenAutoFocus: s,
      onCloseAutoFocus: o,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: u,
      onPointerDownOutside: l,
      onFocusOutside: f,
      onInteractOutside: h,
      onDismiss: v,
      disableOutsideScroll: b,
      ...y
    } = e, S = Vo(ci, r), C = xl(ci, r), O = _l(r), I = NE(r), U = sY(r), [D, H] = R.useState(null), z = R.useRef(null), ne = ar(t, z, S.onContentChange), le = R.useRef(0), te = R.useRef(""), ce = R.useRef(0), V = R.useRef(null), L = R.useRef("right"), p = R.useRef(0), d = b ? jK : R.Fragment, m = b ? { as: hY, allowPinchZoom: !0 } : void 0, x = (A) => {
      var fe, ye;
      const j = te.current + A, k = U().filter((Te) => !Te.disabled), g = document.activeElement, w = (fe = k.find((Te) => Te.ref.current === g)) == null ? void 0 : fe.textValue, P = k.map((Te) => Te.textValue), ue = TY(P, j, w), ie = (ye = k.find((Te) => Te.textValue === ue)) == null ? void 0 : ye.ref.current;
      (function Te(N) {
        te.current = N, window.clearTimeout(le.current), N !== "" && (le.current = window.setTimeout(() => Te(""), 1e3));
      })(j), ie && setTimeout(() => ie.focus());
    };
    R.useEffect(() => () => window.clearTimeout(le.current), []), LG();
    const E = R.useCallback((A) => {
      var k, g;
      return L.current === ((k = V.current) == null ? void 0 : k.side) && AY(A, (g = V.current) == null ? void 0 : g.area);
    }, []);
    return /* @__PURE__ */ _.jsx(
      lY,
      {
        scope: r,
        searchRef: te,
        onItemEnter: R.useCallback(
          (A) => {
            E(A) && A.preventDefault();
          },
          [E]
        ),
        onItemLeave: R.useCallback(
          (A) => {
            var j;
            E(A) || ((j = z.current) == null || j.focus(), H(null));
          },
          [E]
        ),
        onTriggerLeave: R.useCallback(
          (A) => {
            E(A) && A.preventDefault();
          },
          [E]
        ),
        pointerGraceTimerRef: ce,
        onPointerGraceIntentChange: R.useCallback((A) => {
          V.current = A;
        }, []),
        children: /* @__PURE__ */ _.jsx(d, { ...m, children: /* @__PURE__ */ _.jsx(
          nE,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: xt(s, (A) => {
              var j;
              A.preventDefault(), (j = z.current) == null || j.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: o,
            children: /* @__PURE__ */ _.jsx(
              v1,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: u,
                onPointerDownOutside: l,
                onFocusOutside: f,
                onInteractOutside: h,
                onDismiss: v,
                children: /* @__PURE__ */ _.jsx(
                  NG,
                  {
                    asChild: !0,
                    ...I,
                    dir: C.dir,
                    orientation: "vertical",
                    loop: n,
                    currentTabStopId: D,
                    onCurrentTabStopIdChange: H,
                    onEntryFocus: xt(c, (A) => {
                      C.isUsingKeyboardRef.current || A.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ _.jsx(
                      A7,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": n9(S.open),
                        "data-radix-menu-content": "",
                        dir: C.dir,
                        ...O,
                        ...y,
                        ref: ne,
                        style: { outline: "none", ...y.style },
                        onKeyDown: xt(y.onKeyDown, (A) => {
                          const k = A.target.closest("[data-radix-menu-content]") === A.currentTarget, g = A.ctrlKey || A.altKey || A.metaKey, w = A.key.length === 1;
                          k && (A.key === "Tab" && A.preventDefault(), !g && w && x(A.key));
                          const P = z.current;
                          if (A.target !== P || !rY.includes(A.key))
                            return;
                          A.preventDefault();
                          const ie = U().filter((fe) => !fe.disabled).map((fe) => fe.ref.current);
                          RE.includes(A.key) && ie.reverse(), SY(ie);
                        }),
                        onBlur: xt(e.onBlur, (A) => {
                          A.currentTarget.contains(A.target) || (window.clearTimeout(le.current), te.current = "");
                        }),
                        onPointerMove: xt(
                          e.onPointerMove,
                          Vu((A) => {
                            const j = A.target, k = p.current !== A.clientX;
                            if (A.currentTarget.contains(j) && k) {
                              const g = A.clientX > p.current ? "right" : "left";
                              L.current = g, p.current = A.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
UE.displayName = ci;
var pY = "MenuGroup", U1 = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ _.jsx(nr.div, { role: "group", ...n, ref: t });
  }
);
U1.displayName = pY;
var mY = "MenuLabel", FE = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ _.jsx(nr.div, { ...n, ref: t });
  }
);
FE.displayName = mY;
var md = "MenuItem", Gb = "menu.itemSelect", wh = R.forwardRef(
  (e, t) => {
    const { disabled: r = !1, onSelect: n, ...i } = e, s = R.useRef(null), o = xl(md, e.__scopeMenu), a = L1(md, e.__scopeMenu), c = ar(t, s), u = R.useRef(!1), l = () => {
      const f = s.current;
      if (!r && f) {
        const h = new CustomEvent(Gb, { bubbles: !0, cancelable: !0 });
        f.addEventListener(Gb, (v) => n == null ? void 0 : n(v), { once: !0 }), t7(f, h), h.defaultPrevented ? u.current = !1 : o.onClose();
      }
    };
    return /* @__PURE__ */ _.jsx(
      VE,
      {
        ...i,
        ref: c,
        disabled: r,
        onClick: xt(e.onClick, l),
        onPointerDown: (f) => {
          var h;
          (h = e.onPointerDown) == null || h.call(e, f), u.current = !0;
        },
        onPointerUp: xt(e.onPointerUp, (f) => {
          var h;
          u.current || (h = f.currentTarget) == null || h.click();
        }),
        onKeyDown: xt(e.onKeyDown, (f) => {
          const h = a.searchRef.current !== "";
          r || h && f.key === " " || mm.includes(f.key) && (f.currentTarget.click(), f.preventDefault());
        })
      }
    );
  }
);
wh.displayName = md;
var VE = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, disabled: n = !1, textValue: i, ...s } = e, o = L1(md, r), a = NE(r), c = R.useRef(null), u = ar(t, c), [l, f] = R.useState(!1), [h, v] = R.useState("");
    return R.useEffect(() => {
      const b = c.current;
      b && v((b.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ _.jsx(
      Fu.ItemSlot,
      {
        scope: r,
        disabled: n,
        textValue: i ?? h,
        children: /* @__PURE__ */ _.jsx($G, { asChild: !0, ...a, focusable: !n, children: /* @__PURE__ */ _.jsx(
          nr.div,
          {
            role: "menuitem",
            "data-highlighted": l ? "" : void 0,
            "aria-disabled": n || void 0,
            "data-disabled": n ? "" : void 0,
            ...s,
            ref: u,
            onPointerMove: xt(
              e.onPointerMove,
              Vu((b) => {
                n ? o.onItemLeave(b) : (o.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: xt(
              e.onPointerLeave,
              Vu((b) => o.onItemLeave(b))
            ),
            onFocus: xt(e.onFocus, () => f(!0)),
            onBlur: xt(e.onBlur, () => f(!1))
          }
        ) })
      }
    );
  }
), gY = "MenuCheckboxItem", zE = R.forwardRef(
  (e, t) => {
    const { checked: r = !1, onCheckedChange: n, ...i } = e;
    return /* @__PURE__ */ _.jsx(KE, { scope: e.__scopeMenu, checked: r, children: /* @__PURE__ */ _.jsx(
      wh,
      {
        role: "menuitemcheckbox",
        "aria-checked": gd(r) ? "mixed" : r,
        ...i,
        ref: t,
        "data-state": z1(r),
        onSelect: xt(
          i.onSelect,
          () => n == null ? void 0 : n(gd(r) ? !0 : !r),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
zE.displayName = gY;
var WE = "MenuRadioGroup", [yY, vY] = ja(
  WE,
  { value: void 0, onValueChange: () => {
  } }
), qE = R.forwardRef(
  (e, t) => {
    const { value: r, onValueChange: n, ...i } = e, s = en(n);
    return /* @__PURE__ */ _.jsx(yY, { scope: e.__scopeMenu, value: r, onValueChange: s, children: /* @__PURE__ */ _.jsx(U1, { ...i, ref: t }) });
  }
);
qE.displayName = WE;
var HE = "MenuRadioItem", GE = R.forwardRef(
  (e, t) => {
    const { value: r, ...n } = e, i = vY(HE, e.__scopeMenu), s = r === i.value;
    return /* @__PURE__ */ _.jsx(KE, { scope: e.__scopeMenu, checked: s, children: /* @__PURE__ */ _.jsx(
      wh,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...n,
        ref: t,
        "data-state": z1(s),
        onSelect: xt(
          n.onSelect,
          () => {
            var o;
            return (o = i.onValueChange) == null ? void 0 : o.call(i, r);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
GE.displayName = HE;
var F1 = "MenuItemIndicator", [KE, bY] = ja(
  F1,
  { checked: !1 }
), YE = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, forceMount: n, ...i } = e, s = bY(F1, r);
    return /* @__PURE__ */ _.jsx(
      Ni,
      {
        present: n || gd(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ _.jsx(
          nr.span,
          {
            ...i,
            ref: t,
            "data-state": z1(s.checked)
          }
        )
      }
    );
  }
);
YE.displayName = F1;
var wY = "MenuSeparator", XE = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e;
    return /* @__PURE__ */ _.jsx(
      nr.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...n,
        ref: t
      }
    );
  }
);
XE.displayName = wY;
var _Y = "MenuArrow", JE = R.forwardRef(
  (e, t) => {
    const { __scopeMenu: r, ...n } = e, i = _l(r);
    return /* @__PURE__ */ _.jsx(M7, { ...i, ...n, ref: t });
  }
);
JE.displayName = _Y;
var V1 = "MenuSub", [xY, ZE] = ja(V1), QE = (e) => {
  const { __scopeMenu: t, children: r, open: n = !1, onOpenChange: i } = e, s = Vo(V1, t), o = _l(t), [a, c] = R.useState(null), [u, l] = R.useState(null), f = en(i);
  return R.useEffect(() => (s.open === !1 && f(!1), () => f(!1)), [s.open, f]), /* @__PURE__ */ _.jsx(T7, { ...o, children: /* @__PURE__ */ _.jsx(
    $E,
    {
      scope: t,
      open: n,
      onOpenChange: f,
      content: u,
      onContentChange: l,
      children: /* @__PURE__ */ _.jsx(
        xY,
        {
          scope: t,
          contentId: Lu(),
          triggerId: Lu(),
          trigger: a,
          onTriggerChange: c,
          children: r
        }
      )
    }
  ) });
};
QE.displayName = V1;
var lu = "MenuSubTrigger", e9 = R.forwardRef(
  (e, t) => {
    const r = Vo(lu, e.__scopeMenu), n = xl(lu, e.__scopeMenu), i = ZE(lu, e.__scopeMenu), s = L1(lu, e.__scopeMenu), o = R.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: c } = s, u = { __scopeMenu: e.__scopeMenu }, l = R.useCallback(() => {
      o.current && window.clearTimeout(o.current), o.current = null;
    }, []);
    return R.useEffect(() => l, [l]), R.useEffect(() => {
      const f = a.current;
      return () => {
        window.clearTimeout(f), c(null);
      };
    }, [a, c]), /* @__PURE__ */ _.jsx($1, { asChild: !0, ...u, children: /* @__PURE__ */ _.jsx(
      VE,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": r.open,
        "aria-controls": i.contentId,
        "data-state": n9(r.open),
        ...e,
        ref: rh(t, i.onTriggerChange),
        onClick: (f) => {
          var h;
          (h = e.onClick) == null || h.call(e, f), !(e.disabled || f.defaultPrevented) && (f.currentTarget.focus(), r.open || r.onOpenChange(!0));
        },
        onPointerMove: xt(
          e.onPointerMove,
          Vu((f) => {
            s.onItemEnter(f), !f.defaultPrevented && !e.disabled && !r.open && !o.current && (s.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => {
              r.onOpenChange(!0), l();
            }, 100));
          })
        ),
        onPointerLeave: xt(
          e.onPointerLeave,
          Vu((f) => {
            var v, b;
            l();
            const h = (v = r.content) == null ? void 0 : v.getBoundingClientRect();
            if (h) {
              const y = (b = r.content) == null ? void 0 : b.dataset.side, S = y === "right", C = S ? -5 : 5, O = h[S ? "left" : "right"], I = h[S ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: f.clientX + C, y: f.clientY },
                  { x: O, y: h.top },
                  { x: I, y: h.top },
                  { x: I, y: h.bottom },
                  { x: O, y: h.bottom }
                ],
                side: y
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(f), f.defaultPrevented)
                return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: xt(e.onKeyDown, (f) => {
          var v;
          const h = s.searchRef.current !== "";
          e.disabled || h && f.key === " " || nY[n.dir].includes(f.key) && (r.onOpenChange(!0), (v = r.content) == null || v.focus(), f.preventDefault());
        })
      }
    ) });
  }
);
e9.displayName = lu;
var t9 = "MenuSubContent", r9 = R.forwardRef(
  (e, t) => {
    const r = LE(ci, e.__scopeMenu), { forceMount: n = r.forceMount, ...i } = e, s = Vo(ci, e.__scopeMenu), o = xl(ci, e.__scopeMenu), a = ZE(t9, e.__scopeMenu), c = R.useRef(null), u = ar(t, c);
    return /* @__PURE__ */ _.jsx(Fu.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(Ni, { present: n || s.open, children: /* @__PURE__ */ _.jsx(Fu.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(
      B1,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...i,
        ref: u,
        align: "start",
        side: o.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (l) => {
          var f;
          o.isUsingKeyboardRef.current && ((f = c.current) == null || f.focus()), l.preventDefault();
        },
        onCloseAutoFocus: (l) => l.preventDefault(),
        onFocusOutside: xt(e.onFocusOutside, (l) => {
          l.target !== a.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: xt(e.onEscapeKeyDown, (l) => {
          o.onClose(), l.preventDefault();
        }),
        onKeyDown: xt(e.onKeyDown, (l) => {
          var v;
          const f = l.currentTarget.contains(l.target), h = iY[o.dir].includes(l.key);
          f && h && (s.onOpenChange(!1), (v = a.trigger) == null || v.focus(), l.preventDefault());
        })
      }
    ) }) }) });
  }
);
r9.displayName = t9;
function n9(e) {
  return e ? "open" : "closed";
}
function gd(e) {
  return e === "indeterminate";
}
function z1(e) {
  return gd(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function SY(e) {
  const t = document.activeElement;
  for (const r of e)
    if (r === t || (r.focus(), document.activeElement !== t))
      return;
}
function EY(e, t) {
  return e.map((r, n) => e[(t + n) % e.length]);
}
function TY(e, t, r) {
  const i = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, s = r ? e.indexOf(r) : -1;
  let o = EY(e, Math.max(s, 0));
  i.length === 1 && (o = o.filter((u) => u !== r));
  const c = o.find(
    (u) => u.toLowerCase().startsWith(i.toLowerCase())
  );
  return c !== r ? c : void 0;
}
function CY(e, t) {
  const { x: r, y: n } = e;
  let i = !1;
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    const a = t[s], c = t[o], u = a.x, l = a.y, f = c.x, h = c.y;
    l > n != h > n && r < (f - u) * (n - l) / (h - l) + u && (i = !i);
  }
  return i;
}
function AY(e, t) {
  if (!t)
    return !1;
  const r = { x: e.clientX, y: e.clientY };
  return CY(r, t);
}
function Vu(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var MY = DE, OY = $1, IY = BE, kY = UE, jY = U1, RY = FE, PY = wh, NY = zE, $Y = qE, DY = GE, LY = YE, BY = XE, UY = JE, FY = QE, VY = e9, zY = r9, _h = "DropdownMenu", [WY, tse] = eo(
  _h,
  [PE]
), mn = PE(), [qY, i9] = WY(_h), s9 = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: r,
    dir: n,
    open: i,
    defaultOpen: s,
    onOpenChange: o,
    modal: a = !0
  } = e, c = mn(t), u = R.useRef(null), [l, f] = ml({
    prop: i,
    defaultProp: s ?? !1,
    onChange: o,
    caller: _h
  });
  return /* @__PURE__ */ _.jsx(
    qY,
    {
      scope: t,
      triggerId: Lu(),
      triggerRef: u,
      contentId: Lu(),
      open: l,
      onOpenChange: f,
      onOpenToggle: R.useCallback(() => f((h) => !h), [f]),
      modal: a,
      children: /* @__PURE__ */ _.jsx(MY, { ...c, open: l, onOpenChange: f, dir: n, modal: a, children: r })
    }
  );
};
s9.displayName = _h;
var o9 = "DropdownMenuTrigger", a9 = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, disabled: n = !1, ...i } = e, s = i9(o9, r), o = mn(r);
    return /* @__PURE__ */ _.jsx(OY, { asChild: !0, ...o, children: /* @__PURE__ */ _.jsx(
      nr.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": n ? "" : void 0,
        disabled: n,
        ...i,
        ref: rh(t, s.triggerRef),
        onPointerDown: xt(e.onPointerDown, (a) => {
          !n && a.button === 0 && a.ctrlKey === !1 && (s.onOpenToggle(), s.open || a.preventDefault());
        }),
        onKeyDown: xt(e.onKeyDown, (a) => {
          n || (["Enter", " "].includes(a.key) && s.onOpenToggle(), a.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
a9.displayName = o9;
var HY = "DropdownMenuPortal", c9 = (e) => {
  const { __scopeDropdownMenu: t, ...r } = e, n = mn(t);
  return /* @__PURE__ */ _.jsx(IY, { ...n, ...r });
};
c9.displayName = HY;
var u9 = "DropdownMenuContent", l9 = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, i = i9(u9, r), s = mn(r), o = R.useRef(!1);
    return /* @__PURE__ */ _.jsx(
      kY,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...s,
        ...n,
        ref: t,
        onCloseAutoFocus: xt(e.onCloseAutoFocus, (a) => {
          var c;
          o.current || (c = i.triggerRef.current) == null || c.focus(), o.current = !1, a.preventDefault();
        }),
        onInteractOutside: xt(e.onInteractOutside, (a) => {
          const c = a.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, l = c.button === 2 || u;
          (!i.modal || l) && (o.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
l9.displayName = u9;
var GY = "DropdownMenuGroup", f9 = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
    return /* @__PURE__ */ _.jsx(jY, { ...i, ...n, ref: t });
  }
);
f9.displayName = GY;
var KY = "DropdownMenuLabel", d9 = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
    return /* @__PURE__ */ _.jsx(RY, { ...i, ...n, ref: t });
  }
);
d9.displayName = KY;
var YY = "DropdownMenuItem", h9 = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
    return /* @__PURE__ */ _.jsx(PY, { ...i, ...n, ref: t });
  }
);
h9.displayName = YY;
var XY = "DropdownMenuCheckboxItem", p9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(NY, { ...i, ...n, ref: t });
});
p9.displayName = XY;
var JY = "DropdownMenuRadioGroup", m9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx($Y, { ...i, ...n, ref: t });
});
m9.displayName = JY;
var ZY = "DropdownMenuRadioItem", g9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(DY, { ...i, ...n, ref: t });
});
g9.displayName = ZY;
var QY = "DropdownMenuItemIndicator", y9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(LY, { ...i, ...n, ref: t });
});
y9.displayName = QY;
var eX = "DropdownMenuSeparator", v9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(BY, { ...i, ...n, ref: t });
});
v9.displayName = eX;
var tX = "DropdownMenuArrow", rX = R.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
    return /* @__PURE__ */ _.jsx(UY, { ...i, ...n, ref: t });
  }
);
rX.displayName = tX;
var nX = (e) => {
  const { __scopeDropdownMenu: t, children: r, open: n, onOpenChange: i, defaultOpen: s } = e, o = mn(t), [a, c] = ml({
    prop: n,
    defaultProp: s ?? !1,
    onChange: i,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ _.jsx(FY, { ...o, open: a, onOpenChange: c, children: r });
}, iX = "DropdownMenuSubTrigger", b9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(VY, { ...i, ...n, ref: t });
});
b9.displayName = iX;
var sX = "DropdownMenuSubContent", w9 = R.forwardRef((e, t) => {
  const { __scopeDropdownMenu: r, ...n } = e, i = mn(r);
  return /* @__PURE__ */ _.jsx(
    zY,
    {
      ...i,
      ...n,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
w9.displayName = sX;
var oX = s9, aX = a9, _9 = c9, cX = l9, uX = f9, lX = d9, fX = h9, dX = p9, hX = m9, pX = g9, x9 = y9, mX = v9, gX = nX, yX = b9, vX = w9;
const bX = ["1", "2", "3"], wX = ["vertical", "horizontal", "both"], zp = {
  size: { type: "enum", values: bX, default: "1", responsive: !0 },
  radius: k1,
  scrollbars: { type: "enum", values: wX, default: "both" }
}, W1 = R.forwardRef((e, t) => {
  const { rest: r, ...n } = yl(e), { className: i, style: s, type: o, scrollHideDelay: a = o !== "scroll" ? 0 : void 0, dir: c, size: u = zp.size.default, radius: l = zp.radius.default, scrollbars: f = zp.scrollbars.default, ...h } = r;
  return R.createElement(
    WK,
    { type: o, scrollHideDelay: a, className: br("rt-ScrollAreaRoot", i, vl(n)), style: s },
    R.createElement(qK, { ...h, ref: t, className: "rt-ScrollAreaViewport" }),
    R.createElement("div", { className: "rt-ScrollAreaViewportFocusRing" }),
    f !== "vertical" ? R.createElement(
      qb,
      { "data-radius": l, orientation: "horizontal", className: br("rt-ScrollAreaScrollbar", Mn(u, "rt-r-size")) },
      R.createElement(Hb, { className: "rt-ScrollAreaThumb" })
    ) : null,
    f !== "horizontal" ? R.createElement(
      qb,
      { "data-radius": l, orientation: "vertical", className: br("rt-ScrollAreaScrollbar", Mn(u, "rt-r-size")) },
      R.createElement(Hb, { className: "rt-ScrollAreaThumb" })
    ) : null,
    f === "both" ? R.createElement(HK, { className: "rt-ScrollAreaCorner" }) : null
  );
});
W1.displayName = "ScrollArea";
const _X = ["1", "2"], xX = ["solid", "soft"], Wp = {
  size: { type: "enum", values: _X, default: "2", responsive: !0 },
  variant: { type: "enum", values: xX, default: "solid" },
  color: gl,
  highContrast: dh
}, S9 = {
  color: gl,
  shortcut: { type: "string", default: void 0 }
}, E9 = (e) => R.createElement(oX, { ...e });
E9.displayName = "DropdownMenuRoot";
const T9 = R.forwardRef((e, t) => R.createElement(aX, { ...e, ref: t, asChild: !0 }));
T9.displayName = "DropdownMenuTrigger";
const C9 = R.createContext({}), A9 = R.forwardRef((e, t) => {
  const r = mG(), { className: n, children: i, size: s = Wp.size.default, variant: o = Wp.variant.default, highContrast: a = Wp.highContrast.default, color: c = S9.color.default, container: u, forceMount: l, ...f } = e, h = c ?? r.accentColor;
  return R.createElement(
    _9,
    { container: u, forceMount: l },
    R.createElement(
      fh,
      { asChild: !0 },
      R.createElement(
        cX,
        { "data-accent-color": h, align: "start", sideOffset: 4, collisionPadding: 10, ...f, ref: t, className: br("rt-PopperContent", "rt-BaseMenuContent", "rt-DropdownMenuContent", n, Mn(s, "rt-r-size"), `rt-variant-${o}`, { "rt-high-contrast": a }) },
        R.createElement(
          W1,
          { type: "auto" },
          R.createElement(
            "div",
            { className: br("rt-BaseMenuViewport", "rt-DropdownMenuViewport") },
            R.createElement(C9.Provider, { value: R.useMemo(() => ({ size: s, variant: o, color: h, highContrast: a }), [s, o, h, a]) }, i)
          )
        )
      )
    )
  );
});
A9.displayName = "DropdownMenuContent";
const M9 = R.forwardRef((e, t) => R.createElement(lX, { ...e, ref: t, className: br("rt-BaseMenuLabel", "rt-DropdownMenuLabel", e.className) }));
M9.displayName = "DropdownMenuLabel";
const O9 = R.forwardRef((e, t) => {
  const { className: r, children: n, color: i = S9.color.default, shortcut: s, ...o } = e;
  return R.createElement(
    fX,
    { "data-accent-color": i, ...o, ref: t, className: br("rt-reset", "rt-BaseMenuItem", "rt-DropdownMenuItem", r) },
    R.createElement(nh, null, n),
    s && R.createElement("div", { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" }, s)
  );
});
O9.displayName = "DropdownMenuItem";
const I9 = R.forwardRef((e, t) => R.createElement(uX, { ...e, ref: t, className: br("rt-BaseMenuGroup", "rt-DropdownMenuGroup", e.className) }));
I9.displayName = "DropdownMenuGroup";
const k9 = R.forwardRef((e, t) => R.createElement(hX, { ...e, ref: t, className: br("rt-BaseMenuRadioGroup", "rt-DropdownMenuRadioGroup", e.className) }));
k9.displayName = "DropdownMenuRadioGroup";
const j9 = R.forwardRef((e, t) => {
  const { children: r, className: n, ...i } = e;
  return R.createElement(
    pX,
    { ...i, ref: t, className: br("rt-BaseMenuItem", "rt-BaseMenuRadioItem", "rt-DropdownMenuItem", "rt-DropdownMenuRadioItem", n) },
    R.createElement(nh, null, r),
    R.createElement(
      x9,
      { className: "rt-BaseMenuItemIndicator rt-DropdownMenuItemIndicator" },
      R.createElement(ph, { className: "rt-BaseMenuItemIndicatorIcon rt-DropdownMenuItemIndicatorIcon" })
    )
  );
});
j9.displayName = "DropdownMenuRadioItem";
const R9 = R.forwardRef((e, t) => {
  const { children: r, className: n, shortcut: i, ...s } = e;
  return R.createElement(
    dX,
    { ...s, ref: t, className: br("rt-BaseMenuItem", "rt-BaseMenuCheckboxItem", "rt-DropdownMenuItem", "rt-DropdownMenuCheckboxItem", n) },
    R.createElement(nh, null, r),
    R.createElement(
      x9,
      { className: "rt-BaseMenuItemIndicator rt-DropdownMenuItemIndicator" },
      R.createElement(ph, { className: "rt-BaseMenuItemIndicatorIcon rt-ContextMenuItemIndicatorIcon" })
    ),
    i && R.createElement("div", { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" }, i)
  );
});
R9.displayName = "DropdownMenuCheckboxItem";
const P9 = (e) => R.createElement(gX, { ...e });
P9.displayName = "DropdownMenuSub";
const N9 = R.forwardRef((e, t) => {
  const { className: r, children: n, ...i } = e;
  return R.createElement(
    yX,
    { ...i, ref: t, className: br("rt-BaseMenuItem", "rt-BaseMenuSubTrigger", "rt-DropdownMenuItem", "rt-DropdownMenuSubTrigger", r) },
    R.createElement(nh, null, n),
    R.createElement(
      "div",
      { className: "rt-BaseMenuShortcut rt-DropdownMenuShortcut" },
      R.createElement(Y7, { className: "rt-BaseMenuSubTriggerIcon rt-DropdownMenuSubtriggerIcon" })
    )
  );
});
N9.displayName = "DropdownMenuSubTrigger";
const $9 = R.forwardRef((e, t) => {
  const { className: r, children: n, container: i, forceMount: s, ...o } = e, { size: a, variant: c, color: u, highContrast: l } = R.useContext(C9);
  return R.createElement(
    _9,
    { container: i, forceMount: s },
    R.createElement(
      fh,
      { asChild: !0 },
      R.createElement(
        vX,
        {
          "data-accent-color": u,
          alignOffset: -Number(a) * 4,
          // Side offset accounts for the outer solid box-shadow
          sideOffset: 1,
          collisionPadding: 10,
          ...o,
          ref: t,
          className: br("rt-PopperContent", "rt-BaseMenuContent", "rt-BaseMenuSubContent", "rt-DropdownMenuContent", "rt-DropdownMenuSubContent", r, Mn(a, "rt-r-size"), `rt-variant-${c}`, { "rt-high-contrast": l })
        },
        R.createElement(
          W1,
          { type: "auto" },
          R.createElement("div", { className: br("rt-BaseMenuViewport", "rt-DropdownMenuViewport") }, n)
        )
      )
    )
  );
});
$9.displayName = "DropdownMenuSubContent";
const D9 = R.forwardRef((e, t) => R.createElement(mX, { ...e, ref: t, className: br("rt-BaseMenuSeparator", "rt-DropdownMenuSeparator", e.className) }));
D9.displayName = "DropdownMenuSeparator";
const Us = Object.assign({}, {
  Root: E9,
  Trigger: T9,
  Content: A9,
  Label: M9,
  Item: O9,
  Group: I9,
  RadioGroup: k9,
  RadioItem: j9,
  CheckboxItem: R9,
  Sub: P9,
  SubTrigger: N9,
  SubContent: $9,
  Separator: D9
}), SX = ["1", "2", "3", "4"], EX = ["classic", "solid", "soft", "surface", "outline", "ghost"], nu = {
  size: { type: "enum", values: SX, default: "2", responsive: !0 },
  variant: { type: "enum", values: EX, default: "solid" },
  color: gl,
  highContrast: dh,
  radius: k1
}, L9 = R.forwardRef((e, t) => {
  const { rest: r, ...n } = yl(e), { className: i, asChild: s = !1, size: o = nu.size.default, variant: a = nu.variant.default, color: c = nu.color.default, highContrast: u = nu.highContrast.default, radius: l = nu.radius.default, ...f } = r, h = s ? y1 : "button";
  return R.createElement(
    h,
    { "data-disabled": f.disabled || void 0, "data-accent-color": c, "data-radius": l, ...f, ref: t, className: br("rt-reset", "rt-BaseButton", i, Mn(o, "rt-r-size"), `rt-variant-${a}`, { "rt-high-contrast": u }, vl(n)) }
  );
});
L9.displayName = "BaseButton";
const B9 = R.forwardRef((e, t) => R.createElement(L9, { ...e, ref: t, className: br("rt-Button", e.className) }));
B9.displayName = "Button";
const TX = {
  loading: { type: "boolean", default: !0 }
}, Ra = R.forwardRef((e, t) => {
  const { rest: r, ...n } = yl(e), { className: i, children: s, loading: o = TX.loading.default, ...a } = r;
  if (!o)
    return R.createElement(R.Fragment, null, s);
  const c = R.isValidElement(s) ? y1 : "span";
  return R.createElement(c, { ref: t, "aria-hidden": !0, className: br("rt-Skeleton", i, vl(n)), "data-inline-skeleton": R.isValidElement(s) ? void 0 : !0, tabIndex: -1, inert: "", ...a }, s);
});
Ra.displayName = "Skeleton";
function q1(e) {
  const { text: t, onClick: r, className: n, btnIsDisabled: i = !1 } = e, s = () => {
    r && r();
  };
  return /* @__PURE__ */ _.jsx(
    B9,
    {
      disabled: i,
      className: n ? `cs-button ${n}` : "cs-button",
      onClick: s,
      children: t
    }
  );
}
function Ea({
  content: e,
  children: t,
  position: r = "top",
  marginTop: n = "0px",
  borderRadius: i = "8px",
  delay: s = 0,
  backgroundColor: o = "var(--cs-bg-primary)"
}) {
  const [a, c] = Mt(!1), [u, l] = Mt(!1), f = Ar(null), h = () => {
    f.current && (clearTimeout(f.current), f.current = null), c(!0);
  };
  Bt(() => () => {
    a || f.current && (clearTimeout(f.current), f.current = null);
  }, [a]);
  const v = () => {
    f.current = setTimeout(() => {
      u || (c(!1), f.current && (clearTimeout(f.current), f.current = null));
    }, 0);
  }, b = () => {
    switch (r) {
      case "top":
        return {
          transform: "translateX(-50%)"
        };
      case "bottom":
        return {
          transform: "translateX(-50%)",
          marginTop: "0px"
        };
      case "left":
        return {
          transform: "translateY(-50%)",
          marginRight: "8px"
        };
      case "right":
        return {
          transform: "translateY(-50%)"
        };
      default:
        return {};
    }
  }, y = Ar(null), [S, C] = Mt({
    left: void 0,
    top: void 0
  });
  return Bt(() => {
    var O;
    if (a && y.current) {
      const I = (O = y.current) == null ? void 0 : O.getBoundingClientRect();
      let U, D;
      r === "top" ? (U = `${window.scrollX + I.left + I.width / 2}px`, D = `${window.scrollY + I.top - 2 * I.height - 8}px`) : r === "bottom" ? (U = `${window.scrollX + I.left + I.width / 2}px`, D = `${window.scrollY + I.bottom}px`) : r === "left" ? (U = `${window.scrollX + I.left - 8}px`, D = `${window.scrollY + I.top + I.height / 2}px`) : r === "right" ? (U = `${window.scrollX + I.right + 8}px`, D = `${window.scrollY + I.top + I.height / 2}px`) : (U = `${window.scrollX + I.left + I.width / 2}px`, D = `${window.scrollY + I.top + I.height / 2}px`), C({ left: U, top: D });
    }
  }, [a]), /* @__PURE__ */ _.jsxs(
    "div",
    {
      ref: y,
      style: { position: "relative", display: "inline-block" },
      onMouseEnter: h,
      onMouseLeave: v,
      children: [
        t,
        a && KT(
          /* @__PURE__ */ _.jsx(
            "div",
            {
              style: {
                transition: "opacity 0.3s ease",
                opacity: a ? 1 : 0,
                position: "absolute",
                zIndex: 9e3,
                padding: "8px 12px",
                backgroundColor: o,
                color: "var(--cs-text-secondary)",
                borderRadius: i,
                fontSize: "12px",
                whiteSpace: "nowrap",
                border: "1px solid",
                borderColor: "var(--cs-border)",
                boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)",
                ...b(),
                ...S,
                marginTop: n
              },
              onMouseEnter: () => l(!0),
              onMouseLeave: () => {
                f.current && (clearTimeout(f.current), f.current = null), l(!1), c(!1);
              },
              children: e
            }
          ),
          document.body
        )
      ]
    }
  );
}
const qp = [
  {
    label: "Default"
  },
  {
    label: "Fast Mode",
    beforeIcon: {
      xlinkHref: "#icon-icon_flash",
      fontSize: "16px",
      activeColor: "var(--cs-primary)",
      activeHoverColor: "var(--cs-primary)"
    }
  }
], CX = (e) => {
  const {
    transactionMode: t,
    setTransactionMode: r,
    maxCapForGas: n,
    setMaxCapForGas: i,
    customGasPrice: s,
    setCustomGasPrice: o,
    suiBalance: a,
    themeType: c
  } = e, u = c == "Light" ? Lt("/images/icon_shio_light@2x.png") : Lt("/images/icon_shio@2x.png"), l = Ft(() => {
    var O;
    return (O = qp.filter(
      (I) => (I == null ? void 0 : I.label) === t
    )) == null ? void 0 : O[0];
  }, [t, qp]), f = (O) => {
    const I = new RegExp("[^\\d-]*(\\d*(?:\\.\\d{0,9})?).*$");
    O.target.value = O.target.value.replace(I, "$1"), i(O.target.value);
  }, h = (O) => {
    const I = new RegExp("[^\\d-]*(\\d*(?:\\.\\d{0,9})?).*$");
    O.target.value = O.target.value.replace(I, "$1");
    const U = Ue(O.target.value).gt(0) ? Ue(O.target.value).div(Math.pow(10, 9)).toString() : "0";
    Ue(U).gt(n) && i(U), o(O.target.value);
  }, v = Ft(() => !n || Number(n) == 0 ? "Please enter a value higher than 0" : n && Number(n) > 5 ? "Only allow up to 5 SUI" : Ue(n).gt(a) ? "Insufficient SUI balance " : Ue(n).lt(Ue(s).div(Math.pow(10, 9))) ? "Max cap cannot be less than custom gas." : "", [n]), b = Ft(() => n && Number(n) > 0 && Number(n) < 2e-6 ? "Your current maximum fee is below the market rate. Please raise it to ensure your transactions are processed." : "", [n]), y = Ft(() => !s || Number(s) == 0 ? "Please enter a value higher than 0" : "", [s]), S = Ft(() => s && Number(s) > 0 && Ue(s).lt(750) ? "Your current maximum fee is below the market rate. Please raise it to ensure your transactions are processed." : "", [s]), C = Ft(() => !s || s === "0" ? "0" : Ue(s).div(Math.pow(10, 9)).toString(), [s]);
  return /* @__PURE__ */ _.jsxs("div", { className: "transaction-mode-container", children: [
    /* @__PURE__ */ _.jsxs("div", { className: "transaction-mode-header", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "transaction-mode-label", children: [
        /* @__PURE__ */ _.jsx("svg", { children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_mode" }) }),
        /* @__PURE__ */ _.jsx("span", { className: "caption-text", children: "Transaction Mode" })
      ] }),
      /* @__PURE__ */ _.jsx("div", { className: "slippage-tab-list", children: qp.map((O) => /* @__PURE__ */ _.jsxs(
        "div",
        {
          className: O.label === l.label ? "active slippage-tab" : "slippage-tab",
          children: [
            O.label !== "Default" && /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_flash" }) }),
            /* @__PURE__ */ _.jsx(
              "span",
              {
                onClick: () => {
                  r(O.label);
                },
                children: O.label
              }
            )
          ]
        },
        O.label
      )) })
    ] }),
    /* @__PURE__ */ _.jsx("p", { className: "transaction-description", children: t === "Default" ? "Standard gas based on real-time network conditions" : "Land your transaction earlier and avoid congestion with a higher gas price. MEV protection is on by default in Fast Mode." }),
    t === "Fast Mode" && /* @__PURE__ */ _.jsxs("div", { className: "fast-mode-section", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "input-card", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "input-label", children: [
          /* @__PURE__ */ _.jsx("span", { children: "Custom Gas Price" }),
          /* @__PURE__ */ _.jsx(
            Ea,
            {
              position: "bottom",
              content: /* @__PURE__ */ _.jsx("div", { className: "tooltip-content", children: "The total gas depends on the gas price and actual gas units consumed." }),
              children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" }) })
            }
          )
        ] }),
        /* @__PURE__ */ _.jsxs("div", { className: "input-right", children: [
          /* @__PURE__ */ _.jsxs("div", { className: "input-field", children: [
            /* @__PURE__ */ _.jsx(
              "input",
              {
                value: s,
                onChange: h,
                placeholder: "0.0"
              }
            ),
            /* @__PURE__ */ _.jsx("span", { className: "caption-text", children: "MIST" })
          ] }),
          /* @__PURE__ */ _.jsxs("div", { className: "unit-text", children: [
            /* @__PURE__ */ _.jsx("span", { children: C }),
            "SUI"
          ] })
        ] })
      ] }),
      y && /* @__PURE__ */ _.jsx(Vl, { text: y, type: "error" }),
      S && /* @__PURE__ */ _.jsx(Vl, { text: S, type: "warn" }),
      /* @__PURE__ */ _.jsxs("div", { className: "input-card", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "input-label", children: [
          /* @__PURE__ */ _.jsx("span", { children: "Set Max Cap for Gas" }),
          /* @__PURE__ */ _.jsx(
            Ea,
            {
              position: "bottom",
              content: /* @__PURE__ */ _.jsx("div", { className: "tooltip-content", children: "Set a max cap for your gas to prevent overpaying" }),
              children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" }) })
            }
          )
        ] }),
        /* @__PURE__ */ _.jsx("div", { className: "input-right", children: /* @__PURE__ */ _.jsxs("div", { className: "input-field", children: [
          /* @__PURE__ */ _.jsx(
            "input",
            {
              value: n,
              onChange: f,
              placeholder: "0.0"
            }
          ),
          /* @__PURE__ */ _.jsx("span", { className: "caption-text", children: "SUI" })
        ] }) })
      ] }),
      v && /* @__PURE__ */ _.jsx(Vl, { text: v, type: "error" }),
      b && /* @__PURE__ */ _.jsx(Vl, { text: b, type: "warn" }),
      /* @__PURE__ */ _.jsxs("div", { className: "powered-by", children: [
        /* @__PURE__ */ _.jsx("span", { children: "Powered by" }),
        /* @__PURE__ */ _.jsx("img", { src: u, alt: "shio" })
      ] })
    ] })
  ] });
}, Vl = (e) => {
  const { text: t, type: r } = e;
  return /* @__PURE__ */ _.jsx(
    "div",
    {
      style: {
        width: "100%",
        padding: "4px 16px",
        borderRadius: "8px",
        background: r === "warn" ? "var(--cs-warning-10)" : "var(--cs-error-10)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ _.jsx(
        "span",
        {
          style: {
            color: r === "warn" ? "var(--cs-warning)" : "var(--cs-error)",
            fontSize: "12px",
            lineHeight: "16px"
          },
          children: t
        }
      )
    }
  );
}, AX = {
  id: "0x9258181f5ceac8dbffb7030890243caed69a9599d2886d957a9cb7656af3bdb3",
  coin_type: "0x2::sui::SUI",
  decimals: 9,
  description: "",
  name: "Sui",
  symbol: "SUI",
  logo_url: "https://archive.cetus.zone/assets/image/sui/sui.png",
  is_verified: !0,
  extensions: {
    rank: "880"
  }
};
function MX({ themeType: e }) {
  const { setIsOpenSlippageDialog: t, isOpenSlippageDialog: r, slippage: n } = Sn();
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "slippage-button",
        onClick: () => t(!0),
        children: [
          /* @__PURE__ */ _.jsxs("span", { children: [
            n,
            "%"
          ] }),
          /* @__PURE__ */ _.jsx("div", { className: "svg-box", children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-verticalslider" }) }) })
        ]
      }
    ),
    r && /* @__PURE__ */ _.jsx(
      OX,
      {
        themeType: e,
        onClose: () => t(!1)
      }
    )
  ] });
}
function OX({
  onClose: e,
  themeType: t
}) {
  const {
    transactionMode: r,
    maxCapForGas: n,
    customGasPrice: i,
    setMaxCapForGas: s,
    setCustomGasPrice: o,
    setTransctionMode: a,
    mevProtect: c,
    setMevProtect: u
  } = Sn(), { balanceInfo: l } = $u(AX), [f, h] = Mt(r), [v, b] = Mt(n), [y, S] = Mt(i), [C, O] = Mt(c), { slippage: I, setSlippage: U } = Sn(), [D, H] = Mt(I), z = (ce) => {
    H(ce.display);
  }, ne = (ce) => {
    const V = new RegExp("[^\\d-]*(\\d*(?:\\.\\d{0,2})?).*$");
    ce.target.value = ce.target.value.replace(V, "$1"), H(ce.target.value);
  }, le = () => {
    D && U(D), f === "Fast Mode" && (s(v), o(y)), a(f), u(C), e();
  };
  Bt(() => {
    f === "Fast Mode" && O(!0);
  }, [f]);
  const te = Ft(() => f === "Fast Mode" && (!v || Number(v) === 0 || Number(v) > 5 || !y || Number(y) === 0 || Ue(v).gt((l == null ? void 0 : l.totalBalanceFormat) || "0") || Ue(v).lt(Ue(y).div(Math.pow(10, 9)))) || !+D ? !0 : Number(D) > 50 || Number(D) < 0.01, [D, f, v, y, l]);
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx("div", { className: "dialog-mask", style: { zIndex: "100" } }),
    /* @__PURE__ */ _.jsx("div", { className: "slippage-settings-dialog", style: { zIndex: "100" }, children: /* @__PURE__ */ _.jsxs("div", { className: "slippage-settings", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "slippage-settings-header", children: [
        /* @__PURE__ */ _.jsx("div", { className: "title", children: "Settings" }),
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", onClick: e, children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" }) })
      ] }),
      /* @__PURE__ */ _.jsxs("div", { className: "title", children: [
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-verticalslider" }) }),
        /* @__PURE__ */ _.jsx("span", { children: "Slippage Tolerance" })
      ] }),
      /* @__PURE__ */ _.jsxs("div", { className: "form-box", children: [
        /* @__PURE__ */ _.jsx("div", { className: "slippage-tab-list", children: wW.map((ce) => /* @__PURE__ */ _.jsxs(
          "span",
          {
            className: ce.display === D ? "active" : "",
            onClick: () => z(ce),
            children: [
              ce.display,
              " %"
            ]
          },
          ce.display
        )) }),
        /* @__PURE__ */ _.jsxs("div", { className: "input-box", children: [
          /* @__PURE__ */ _.jsx("span", { children: "Custom" }),
          /* @__PURE__ */ _.jsx(
            "input",
            {
              className: "cs-input",
              placeholder: "0.0",
              value: D,
              onChange: ne
            }
          ),
          /* @__PURE__ */ _.jsx(
            "div",
            {
              style: { fontSize: "14px", color: "var(--cs-text-primary)" },
              children: "%"
            }
          )
        ] })
      ] }),
      Number(D) <= 0.05 && /* @__PURE__ */ _.jsx("div", { className: "tips warning", children: "Slippage is low. Your transaction may fail." }),
      Number(D) <= 50 && Number(D) > 1 && /* @__PURE__ */ _.jsx("div", { className: "tips warning", children: "Your transaction may frontrun" }),
      Number(D) > 50 && /* @__PURE__ */ _.jsx("div", { className: "tips error", children: " Enter a valid slippage percentage" }),
      /* @__PURE__ */ _.jsx(
        CX,
        {
          transactionMode: f,
          setTransactionMode: h,
          maxCapForGas: v,
          setMaxCapForGas: b,
          customGasPrice: y,
          setCustomGasPrice: S,
          suiBalance: (l == null ? void 0 : l.totalBalanceFormat) || "0",
          themeType: t
        }
      ),
      /* @__PURE__ */ _.jsx(
        IX,
        {
          mevProtect: C,
          setMevProtect: O,
          disabled: f === "Fast Mode"
        }
      ),
      /* @__PURE__ */ _.jsx(
        q1,
        {
          text: "Save",
          btnIsDisabled: te,
          className: "slippage-save-btn",
          onClick: le
        }
      )
    ] }) })
  ] });
}
const IX = (e) => {
  const { mevProtect: t, disabled: r, setMevProtect: n } = e;
  return /* @__PURE__ */ _.jsxs("div", { className: "mev-settings-box", children: [
    /* @__PURE__ */ _.jsx("div", { className: "mev-setting-title", children: /* @__PURE__ */ _.jsxs("div", { className: "name", children: [
      /* @__PURE__ */ _.jsx("svg", { "aria-hidden": "true", cursor: "pointer", fill: "var(--cs-icon-fill)", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_mev" }) }),
      /* @__PURE__ */ _.jsx("span", { children: "MEV Protect" })
    ] }) }),
    /* @__PURE__ */ _.jsxs("div", { className: "mev-setting-Switch", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "label", children: [
        /* @__PURE__ */ _.jsx("span", { children: "Enable MEV Protection" }),
        /* @__PURE__ */ _.jsx(
          Ea,
          {
            position: "bottom",
            marginTop: "-118px",
            content: /* @__PURE__ */ _.jsx(
              "div",
              {
                className: "mev-tips",
                style: {
                  width: "310px",
                  whiteSpace: "wrap",
                  color: "var(--cs-text-primary)"
                },
                children: "By enabling this, your txn will be submitted via 3rd party MEV service provider. MEV value retained will be redistributed to all users who successfully execute their trades with Shio through its point campaign."
              }
            ),
            children: /* @__PURE__ */ _.jsx(
              "svg",
              {
                className: "cs-icon",
                "aria-hidden": "true",
                style: {
                  cursor: "pointer"
                },
                children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" })
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ _.jsx(
        jE,
        {
          checked: t,
          disabled: r,
          className: "cs-switch",
          onClick: () => {
            n(!t);
          }
        }
      )
    ] })
  ] });
};
function kX({
  handleRefresh: e,
  themeType: t
}) {
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsxs("div", { className: "swap-header", children: [
    /* @__PURE__ */ _.jsx("h3", { className: "swap-title", children: "Swap" }),
    /* @__PURE__ */ _.jsxs("div", { className: "right", children: [
      /* @__PURE__ */ _.jsx(MX, { themeType: t }),
      /* @__PURE__ */ _.jsx(zW, { onClick: e })
    ] })
  ] }) });
}
function jX() {
  const [e, t] = Mt(!1);
  return /* @__PURE__ */ _.jsxs(Us.Root, { open: e, onOpenChange: t, children: [
    /* @__PURE__ */ _.jsx(Us.Trigger, { children: /* @__PURE__ */ _.jsx("div", { className: "cs-settings-btn", children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-settings" }) }) }) }),
    /* @__PURE__ */ _.jsx(
      Us.Content,
      {
        variant: "soft",
        className: "cs-dropdown-content",
        style: {
          backgroundColor: "var(--cs-primary-10)"
        },
        side: "bottom",
        align: "end",
        children: /* @__PURE__ */ _.jsxs("div", { className: "cs-settings-box", children: [
          /* @__PURE__ */ _.jsx("h3", { children: "Settings" }),
          /* @__PURE__ */ _.jsx(RX, {}),
          /* @__PURE__ */ _.jsx(
            NX,
            {
              onClose: () => {
                t(!1);
              }
            }
          )
        ] })
      }
    )
  ] });
}
function RX() {
  const { currentExplorer: e, setCurrentExplorer: t, currentRpc: r, setCurrentRpc: n } = Sn(), i = (s) => {
    t(s);
  };
  return /* @__PURE__ */ _.jsxs("div", { className: "settings-card", style: { marginTop: "12px" }, children: [
    /* @__PURE__ */ _.jsxs("h3", { className: "card-title", children: [
      /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-plorer" }) }),
      /* @__PURE__ */ _.jsx("span", { children: "Preferred Explorer" })
    ] }),
    /* @__PURE__ */ _.jsx("div", { className: "explorer-checkbox-group", children: eh.map((s) => /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "group-item",
        style: { justifyContent: "center" },
        onClick: () => i(s.link),
        children: [
          /* @__PURE__ */ _.jsx(
            mh,
            {
              color: "indigo",
              checked: s.link === e,
              variant: "soft",
              className: "cs-checkbox cs-allow-change-checkbox"
            }
          ),
          /* @__PURE__ */ _.jsx("img", { src: s.img }),
          /* @__PURE__ */ _.jsx("span", { children: s.name })
        ]
      },
      s.link
    )) })
  ] });
}
const PX = (e) => !/^(http|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?/.test(e);
function NX({ onClose: e }) {
  const { addTxToast: t } = Nc(), { currentRpc: r, setCurrentRpc: n, customRpc: i, setCustomRpc: s, rpcList: o } = Sn(), [a, c] = Mt(i), [u, l] = Mt(r), f = (y) => {
    t({
      id: 0,
      status: "success",
      buildShowInfo: () => ({
        toastTitleText: "RPC update",
        toastDescriptionContent: `RPC is currently set to ${y}`
      })
    });
  }, h = (y) => {
    l(y), y.isCustom || (n(y), f(y.link), e());
  }, v = (y) => {
    c(y.target.value);
  }, b = () => {
    if (a) {
      const y = {
        name: "Custom RPC URL",
        link: a,
        isCustom: !0
      };
      s(a), n(y), f(a), e();
    }
  };
  return /* @__PURE__ */ _.jsxs("div", { className: "settings-card rpc-settings-card", children: [
    /* @__PURE__ */ _.jsxs("h3", { className: "card-title", children: [
      /* @__PURE__ */ _.jsx("svg", { className: "cs-icon rpc-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-rpc" }) }),
      /* @__PURE__ */ _.jsx("span", { children: "RPC Node" })
    ] }),
    /* @__PURE__ */ _.jsxs("div", { className: "rpc-checkbox-group", children: [
      o.map((y) => /* @__PURE__ */ _.jsxs(
        "div",
        {
          className: "rpc-item",
          onClick: () => h(y),
          children: [
            /* @__PURE__ */ _.jsx(
              mh,
              {
                color: "indigo",
                checked: u.name === y.name,
                variant: "soft",
                className: "cs-checkbox cs-allow-change-checkbox"
              }
            ),
            /* @__PURE__ */ _.jsx("span", { children: y.name })
          ]
        },
        y.name
      )),
      u.isCustom && /* @__PURE__ */ _.jsxs("div", { className: "custom-rpc-input-box", children: [
        /* @__PURE__ */ _.jsx(
          "input",
          {
            className: "cs-input",
            placeholder: "Custom RPC URL",
            onChange: v,
            value: a
          }
        ),
        /* @__PURE__ */ _.jsx(
          q1,
          {
            btnIsDisabled: PX(a),
            text: "Save",
            onClick: b
          }
        )
      ] })
    ] })
  ] });
}
function U9() {
  const { suiClient: e } = Fo(), { setAccountServiceNameObj: t, accountServiceNameObj: r } = Tn(), n = async (s) => {
    if (!((s == null ? void 0 : s.length) < 1))
      try {
        const o = s.map(async (u) => {
          var f;
          const l = await e.resolveNameServiceNames({
            address: u
          });
          return {
            address: u,
            name: ((f = l == null ? void 0 : l.data) == null ? void 0 : f[0]) || ""
          };
        }), a = await Promise.all(o), c = Object.fromEntries(
          a == null ? void 0 : a.map((u) => [u.address, u.name])
        );
        t(c);
      } catch {
      }
  };
  return {
    fetchServiceNames: n,
    getServiceNames: async (s) => {
      const o = [];
      s == null || s.forEach((a) => {
        const c = a == null ? void 0 : a.address;
        r != null && r[c] || o.push(c);
      }), (o == null ? void 0 : o.length) > 0 && n(o);
    }
  };
}
var $X = function() {
  var e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  for (var t = document.activeElement, r = [], n = 0; n < e.rangeCount; n++)
    r.push(e.getRangeAt(n));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || r.forEach(function(i) {
      e.addRange(i);
    }), t && t.focus();
  };
}, DX = $X, Kb = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, LX = "Copy to clipboard: #{key}, Enter";
function BX(e) {
  var t = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function UX(e, t) {
  var r, n, i, s, o, a, c = !1;
  t || (t = {}), r = t.debug || !1;
  try {
    i = DX(), s = document.createRange(), o = document.getSelection(), a = document.createElement("span"), a.textContent = e, a.ariaHidden = "true", a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(l) {
      if (l.stopPropagation(), t.format)
        if (l.preventDefault(), typeof l.clipboardData > "u") {
          r && console.warn("unable to use e.clipboardData"), r && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var f = Kb[t.format] || Kb.default;
          window.clipboardData.setData(f, e);
        } else
          l.clipboardData.clearData(), l.clipboardData.setData(t.format, e);
      t.onCopy && (l.preventDefault(), t.onCopy(l.clipboardData));
    }), document.body.appendChild(a), s.selectNodeContents(a), o.addRange(s);
    var u = document.execCommand("copy");
    if (!u)
      throw new Error("copy command was unsuccessful");
    c = !0;
  } catch (l) {
    r && console.error("unable to copy using execCommand: ", l), r && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), c = !0;
    } catch (f) {
      r && console.error("unable to copy using clipboardData: ", f), r && console.error("falling back to prompt"), n = BX("message" in t ? t.message : LX), window.prompt(n, e);
    }
  } finally {
    o && (typeof o.removeRange == "function" ? o.removeRange(s) : o.removeAllRanges()), a && document.body.removeChild(a), i();
  }
  return c;
}
var FX = UX;
const F9 = /* @__PURE__ */ Yu(FX);
function VX({
  currentAccount: e
}) {
  const { mutate: t } = YT(), r = XT(), { isOpenAccountList: n, setIsOpenAccountList: i, accountServiceNameObj: s } = Tn(), { getServiceNames: o } = U9(), a = Ii(() => {
    n || o(r), i(!n);
  }, [n, r]);
  Bt(() => () => {
    i(!1);
  }, []);
  const c = Ft(() => r.filter((l) => l.address !== e), [r, e]);
  Bt(() => {
  }, [c]);
  const u = (l) => {
    t(
      { account: l },
      {
        onSuccess: () => {
        }
      }
    );
  };
  return /* @__PURE__ */ _.jsxs("div", { className: "cs-account-switch", children: [
    /* @__PURE__ */ _.jsxs("div", { className: "account", onClick: a, children: [
      /* @__PURE__ */ _.jsx("span", { children: e && (s == null ? void 0 : s[e]) || xa(e) }),
      (c == null ? void 0 : c.length) > 0 && /* @__PURE__ */ _.jsx(
        "svg",
        {
          className: `cs-icon ${n ? "open" : "close"}`,
          "aria-hidden": "true",
          children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-unfold" })
        }
      )
    ] }),
    /* @__PURE__ */ _.jsx("div", { className: `account-list ${n ? "open" : "close"}`, children: c.map((l) => {
      var f, h, v, b;
      return /* @__PURE__ */ _.jsxs("div", { className: "account-item", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "left", children: [
          /* @__PURE__ */ _.jsxs("div", { className: "label", children: [
            ((f = l == null ? void 0 : l.label) == null ? void 0 : f.length) > 16 ? ((h = l == null ? void 0 : l.label) == null ? void 0 : h.substring(0, 6)) + "..." + ((b = l == null ? void 0 : l.label) == null ? void 0 : b.substring(((v = l == null ? void 0 : l.label) == null ? void 0 : v.length) - 10)) : l == null ? void 0 : l.label,
            " "
          ] }),
          /* @__PURE__ */ _.jsx("div", { className: "address", children: (s == null ? void 0 : s[l == null ? void 0 : l.address]) || xa(l == null ? void 0 : l.address) })
        ] }),
        /* @__PURE__ */ _.jsx(
          "button",
          {
            className: "cs-outline-btn",
            onClick: () => u(l),
            children: "Switch"
          }
        )
      ] }, l == null ? void 0 : l.address);
    }) })
  ] });
}
const zX = qT(
  ({
    connect: e,
    isSimulate: t = !1
  }) => {
    const r = wd();
    return /* @__PURE__ */ _.jsx("div", { children: r ? /* @__PURE__ */ _.jsx(WX, { isSimulate: t }) : /* @__PURE__ */ _.jsx(
      q1,
      {
        text: "Connect",
        className: "cs-connect-button",
        onClick: () => e(!0)
      }
    ) });
  }
);
function WX({ isSimulate: e }) {
  const { mutate: t } = JT(), r = wd(), { currentWallet: n } = qw(), { addCommonToast: i } = Nc(), { getExplorerUrl: s } = Rc(), { accountServiceNameObj: o } = Tn(), a = () => {
    r && (F9(r.address || "", {
      debug: !1,
      message: "message"
    }), i("Copied"));
  }, c = () => {
    r && window.open(s(r.address, "account"), "_blank");
  };
  return Bt(() => {
  }, [n]), /* @__PURE__ */ _.jsxs(Us.Root, { children: [
    /* @__PURE__ */ _.jsx(Us.Trigger, { children: /* @__PURE__ */ _.jsxs("div", { className: "cs-connected-button", children: [
      /* @__PURE__ */ _.jsx(
        "img",
        {
          src: n == null ? void 0 : n.icon,
          style: { width: "20px", height: "20px" }
        }
      ),
      /* @__PURE__ */ _.jsx(
        "span",
        {
          style: { color: e ? "#fff" : "var(--cs-text-primary)" },
          children: (r == null ? void 0 : r.address) && (o == null ? void 0 : o[r == null ? void 0 : r.address]) || xa(r == null ? void 0 : r.address)
        }
      )
    ] }) }),
    /* @__PURE__ */ _.jsx(
      Us.Content,
      {
        variant: "soft",
        className: "cs-dropdown-content",
        style: {
          backgroundColor: "var(--cs-primary-10)"
        },
        side: "bottom",
        align: "end",
        children: /* @__PURE__ */ _.jsxs("div", { className: "account-op-box", children: [
          /* @__PURE__ */ _.jsx(
            "span",
            {
              style: {
                fontSize: "14px",
                color: "var(--cs-text-secondary)",
                marginBottom: "6px"
              },
              children: r == null ? void 0 : r.label
            }
          ),
          /* @__PURE__ */ _.jsx(VX, { currentAccount: r == null ? void 0 : r.address }),
          /* @__PURE__ */ _.jsxs(
            "div",
            {
              className: "account-op-item",
              onClick: a,
              style: { marginTop: "12px" },
              children: [
                /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_copy" }) }),
                /* @__PURE__ */ _.jsx("span", { children: "Copy address" })
              ]
            }
          ),
          /* @__PURE__ */ _.jsxs("div", { className: "account-op-item", onClick: c, children: [
            /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_link" }) }),
            /* @__PURE__ */ _.jsx("span", { children: "Open explorer" })
          ] }),
          /* @__PURE__ */ _.jsxs("div", { className: "account-op-item", onClick: () => t(), children: [
            /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_disconnect" }) }),
            /* @__PURE__ */ _.jsx("span", { children: "Disconnect" })
          ] })
        ] })
      }
    )
  ] });
}
function qX({
  isSimulate: e = !1
}) {
  const { fetchServiceNames: t } = U9(), r = wd();
  qw();
  const { isOpenWalletModal: n, onWalletModal: i, saveCurrentAccount: s } = Tn();
  return ZT(), Bt(() => {
    r != null && r.address && t([r == null ? void 0 : r.address]);
  }, [r == null ? void 0 : r.address]), /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(
    QT,
    {
      trigger: /* @__PURE__ */ _.jsx(zX, { connect: i, isSimulate: e }),
      open: n,
      onOpenChange: (o) => i(o)
    }
  ) });
}
function HX({
  independentWallet: e,
  customWallet: t,
  logo: r
}) {
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsxs("div", { className: "widget-header", children: [
      /* @__PURE__ */ _.jsx("img", { src: r, className: "cetus-logo" }),
      /* @__PURE__ */ _.jsxs("div", { className: "right", children: [
        e && /* @__PURE__ */ _.jsx(qX, {}),
        /* @__PURE__ */ _.jsx(jX, {})
      ] })
    ] }),
    /* @__PURE__ */ _.jsx("div", { style: { marginTop: "12px" } })
  ] });
}
const V9 = () => {
  const e = Ar(null);
  Bt(() => {
    if (e.current) {
      const n = e.current.style;
      n.setProperty("--size-loader", "50px"), n.setProperty("--size-orbe", "10px");
    }
  }, []);
  const t = (n) => ({
    position: "absolute",
    width: "100%",
    height: "100%",
    animation: `webLoading ease-in-out 1.5s calc(${n} * 0.1s) infinite`,
    opacity: `calc(1 - calc(0.2 * ${n}))`
  }), r = {
    position: "absolute",
    content: "''",
    top: 0,
    left: 0,
    width: "var(--size-orbe)",
    height: "var(--size-orbe)",
    backgroundColor: "var(--cs-primary)",
    // Use CSS variable or replace with your theme color
    boxShadow: "0px 0px 20px 2px var(--cs-primary)",
    // Use theme color
    borderRadius: "50%"
  };
  return /* @__PURE__ */ _.jsx(
    "div",
    {
      style: {
        width: "100%",
        height: "100%",
        position: "absolute",
        zIndex: 100
      },
      children: /* @__PURE__ */ _.jsx(
        "div",
        {
          ref: e,
          style: {
            width: "var(--size-loader)",
            height: "var(--size-loader)",
            position: "absolute",
            top: "50%",
            left: "50%",
            marginTop: "-25px",
            marginLeft: "-25px",
            transform: "rotate(45deg)"
          },
          children: [...Array(5)].map((n, i) => /* @__PURE__ */ _.jsx("div", { style: t(i), children: /* @__PURE__ */ _.jsx("div", { style: r }) }, i))
        }
      )
    }
  );
};
function GX({
  onClose: e,
  transactionData: t
}) {
  const { status: r, buildShowInfo: n, tx: i } = t, s = Ft(() => {
    if (n && r)
      return n(r);
  }, [r]);
  return /* @__PURE__ */ _.jsxs("div", { className: "ts-status-dialog", children: [
    (r === "confirmation" || r === "submitted") && /* @__PURE__ */ _.jsx(KX, { info: s, status: r }),
    (r === "success" || r === "rejected") && /* @__PURE__ */ _.jsx(
      YX,
      {
        info: s,
        status: r,
        tx: i,
        onClose: e
      }
    )
  ] });
}
function KX({
  info: e,
  status: t
}) {
  return /* @__PURE__ */ _.jsxs("div", { className: "progress-dialog", children: [
    /* @__PURE__ */ _.jsx("div", { className: "title", children: t === "confirmation" ? "Waiting for Confirmation" : "Transaction in progress" }),
    /* @__PURE__ */ _.jsx("div", { className: "loading-box", children: /* @__PURE__ */ _.jsx(V9, {}) }),
    /* @__PURE__ */ _.jsxs("div", { className: "ts-content", children: [
      e == null ? void 0 : e.modalDescriptionText,
      " "
    ] }),
    /* @__PURE__ */ _.jsxs("p", { className: "ts-desc", children: [
      " ",
      t === "confirmation" ? "Confirm this transaction in your wallet." : "Confirmation is in progress."
    ] })
  ] });
}
function YX({
  info: e,
  status: t,
  tx: r,
  onClose: n
}) {
  const { getExplorerUrl: i } = Rc();
  return /* @__PURE__ */ _.jsxs("div", { className: "finally-status-dialog", children: [
    /* @__PURE__ */ _.jsxs("div", { className: "center-content", children: [
      /* @__PURE__ */ _.jsxs(
        "div",
        {
          className: t === "success" ? "status-box is-success" : "status-box is-error",
          children: [
            /* @__PURE__ */ _.jsx("div", { className: "status-icon-box", children: /* @__PURE__ */ _.jsx("div", { className: "status-icon", children: /* @__PURE__ */ _.jsx("svg", { className: "icon", "aria-hidden": "true", children: t === "success" ? /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-sel" }) : /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-caution" }) }) }) }),
            t === "success" ? /* @__PURE__ */ _.jsx("span", { children: "Swap Success" }) : /* @__PURE__ */ _.jsx("span", { children: "Swap failed" })
          ]
        }
      ),
      /* @__PURE__ */ _.jsx("div", { className: "ts-content", children: e == null ? void 0 : e.modalDescriptionText }),
      r && /* @__PURE__ */ _.jsxs("div", { className: "view-transaction", children: [
        /* @__PURE__ */ _.jsx("span", { children: "View Transaction" }),
        eh.map((s) => /* @__PURE__ */ _.jsx(
          "a",
          {
            href: i(r, "tx", s.link),
            target: "_blank",
            children: /* @__PURE__ */ _.jsx("img", { src: s.img })
          },
          s.link
        ))
      ] })
    ] }),
    /* @__PURE__ */ _.jsx("button", { className: "cs-solid-btn swap-more-btn", onClick: n, children: t === "success" ? "Swap More" : "Retry" })
  ] });
}
function XX() {
  const { fetchByApi: e } = th(), { setProviders: t } = Sn();
  return {
    fetchRouterConfig: async () => {
      try {
        const n = await e("/router_v3/status", "GET"), { providers: i } = n;
        i && t(i);
      } catch {
      }
    }
  };
}
function JX({ interval: e, callback: t }) {
  const r = Ar(), n = Ar(null);
  Bt(() => {
    r.current = t;
  }, [t]);
  const i = Ii(() => {
    n.current && clearInterval(n.current), e > 0 && (n.current = setInterval(() => {
      r.current && r.current(Date.now());
    }, e));
  }, [e]), s = Ii(() => {
    n.current && (clearInterval(n.current), n.current = null);
  }, []);
  return Bt(() => (i(), () => s()), []), { startTimer: i, stopTimer: s };
}
const ZX = (e, t) => ({
  coinPriceObj: {},
  setPriceObj: (r) => {
    const n = t().coinPriceObj;
    e({
      coinPriceObj: {
        ...n,
        ...r
      }
    });
  },
  clearPriceObj: (r) => {
    const n = t().coinPriceObj;
    r.forEach((i) => {
      delete n[jr(i).full_address];
    }), e({
      coinPriceObj: {
        ...n
      }
    });
  }
}), z9 = Qs(ZX);
function QX(e, t) {
  const r = [];
  for (let n = 0; n < e.length; n += t)
    r.push(e.slice(n, n + t));
  return r;
}
function Sl() {
  const { fetchByApi: e } = th(), { coinPriceObj: t, setPriceObj: r, clearPriceObj: n } = z9(), i = async (a) => {
    const u = QX(a, 10);
    try {
      const f = (await Promise.all(
        u.map((h) => e("/v3/sui/market_price", "GET", {
          base_symbol_address: h.map(
            (v) => Hs(v, !1)
          )
        }))
      )).map((h) => h.prices).flat();
      if (f) {
        const h = {};
        f.forEach((v) => {
          h[jr(v.base_symbol).full_address] = v;
        }), r(h);
      }
      return f;
    } catch {
      return n(a), null;
    }
  }, s = Ii(
    (a) => {
      if (!a)
        return;
      const c = t[jr(a).full_address];
      if (c)
        return c;
    },
    [t]
  ), o = Ii(
    (a, c, u) => {
      const l = Number(c) == 0 || !u ? "0" : u;
      if (c && a && +c) {
        const f = s(a);
        if (f)
          return Ue(c).mul(f.price).toString();
      }
      return l;
    },
    [t]
  );
  return {
    fetchTokenPrices: i,
    getTokenPrice: s,
    getTokenAmountValue: o
  };
}
function eJ() {
  const { tokenBalanceObj: e } = Tn(), { fetchTokenPrices: t } = Sl(), { isOpenTokensDialog: r } = En(), n = Ii(() => {
    if (gW(e)) {
      const i = Object.keys(e);
      t(i);
    }
  }, [e]);
  return Bt(() => {
    r && n();
  }, [r]), { getMyAssetsPrice: n };
}
const tJ = {
  id: "0x9258181f5ceac8dbffb7030890243caed69a9599d2886d957a9cb7656af3bdb3",
  coin_type: "0x2::sui::SUI",
  decimals: 9,
  description: "",
  name: "Sui",
  symbol: "SUI",
  logo_url: "https://imagedelivery.net/cBNDGgkrsEA-b_ixIp9SkQ/sui-coin.svg/public",
  is_trusted: !0,
  extensions: {
    rank: "880"
  }
}, rJ = {
  id: "0x69b7a7c3c200439c1b5f3b19d7d495d5966d5f08de66c69276152f8db3992ec6",
  coin_type: "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  decimals: 6,
  description: "",
  name: "USDC",
  symbol: "USDC",
  logo_url: "https://circle.com/usdc-icon",
  is_trusted: !0,
  extensions: {
    rank: "1000"
  }
}, W9 = rJ, q9 = tJ;
function nJ(e, t) {
  const { fetchTokenInfo: r } = $c(), { setFromCoin: n, setToCoin: i, setDefaultCoin: s, fromCoin: o, toCoin: a } = En(), { setSlippage: c, setRpcList: u, setCurrentRpc: l } = Sn(), { tokenMapIsInit: f } = Pc(), h = Ar({}), v = async (y, S) => {
    if (!S && !y && (o || a))
      return;
    const C = y ? await r(y) : W9, O = S ? await r(S) : q9;
    n(C), i(O), s(C == null ? void 0 : C.coin_type, O == null ? void 0 : O.coin_type);
  }, b = (y = [], S) => {
    let C = [], O = wu[0], I = wu[0];
    y.forEach((U) => {
      const D = {
        name: U,
        link: U,
        isCustom: !1
      };
      C.push(D), U === S && (I = D);
    }), S && y.includes(S) ? C = [
      I,
      O,
      ...C.filter((U) => U.link !== S)
    ] : C.unshift(wu[0]), u([
      ...C,
      {
        name: "Custom RPC URL",
        link: "",
        isCustom: !0
      }
    ]), l(I);
  };
  return Bt(() => {
    if (f && !m1(e, h.current)) {
      const {
        defaultFromToken: y,
        defaultToToken: S,
        defaultSlippage: C,
        customRpcList: O,
        defaultRpc: I
      } = e;
      v(y, S), C && c(C), b(O || [], I), h.current = e;
    }
  }, [e, f]), {
    handleSetDefaultPair: v
  };
}
function iJ(e) {
  const { currentRpc: t } = Sn(), { setSuiClient: r, setAggregatorSDK: n } = Fo(), { currentAccount: i } = Tn();
  Bt(() => {
    if (t) {
      const o = new wa({ url: t.link });
      r(o);
    }
  }, [t]);
  const s = () => {
    const o = {
      endpoint: lc.aggregatorUrl,
      signer: (i == null ? void 0 : i.address) || "",
      client: new wa({ url: t.link }),
      env: A5.Mainnet,
      overlayFeeRate: (e == null ? void 0 : e.overlayFeeRate) || void 0,
      // Overlay fee rate (0.01 represents 1%).
      overlayFeeReceiver: (e == null ? void 0 : e.overlayFeeReceiver) || void 0
      // Address to receive the overlay fees
    }, a = new C5(o);
    n(a);
  };
  Bt(() => {
    t && s();
  }, [t.link, i == null ? void 0 : i.address]), Bt(() => {
    e != null && e.overlayFeeRate && (e != null && e.overlayFeeReceiver) && s();
  }, [e == null ? void 0 : e.overlayFeeRate, e == null ? void 0 : e.overlayFeeReceiver]);
}
const H1 = Qs((e, t) => ({
  transactionData: void 0,
  setTransactionData: (r) => {
    e(() => ({
      transactionData: r
    }));
  }
})), Qr = [];
for (let e = 0; e < 256; ++e)
  Qr.push((e + 256).toString(16).slice(1));
function sJ(e, t = 0) {
  return (Qr[e[t + 0]] + Qr[e[t + 1]] + Qr[e[t + 2]] + Qr[e[t + 3]] + "-" + Qr[e[t + 4]] + Qr[e[t + 5]] + "-" + Qr[e[t + 6]] + Qr[e[t + 7]] + "-" + Qr[e[t + 8]] + Qr[e[t + 9]] + "-" + Qr[e[t + 10]] + Qr[e[t + 11]] + Qr[e[t + 12]] + Qr[e[t + 13]] + Qr[e[t + 14]] + Qr[e[t + 15]]).toLowerCase();
}
let Hp;
const oJ = new Uint8Array(16);
function aJ() {
  if (!Hp) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Hp = crypto.getRandomValues.bind(crypto);
  }
  return Hp(oJ);
}
const cJ = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Yb = { randomUUID: cJ };
function Xb(e, t, r) {
  var i;
  if (Yb.randomUUID && !t && !e)
    return Yb.randomUUID();
  e = e || {};
  const n = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? aJ();
  if (n.length < 16)
    throw new Error("Random bytes length must be >= 16");
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, t) {
    if (r = r || 0, r < 0 || r + 16 > t.length)
      throw new RangeError(`UUID byte range ${r}:${r + 15} is out of buffer bounds`);
    for (let s = 0; s < 16; ++s)
      t[r + s] = n[s];
    return t;
  }
  return sJ(n);
}
var ya = /* @__PURE__ */ ((e) => (e[e.CalculateError = 1e4] = "CalculateError", e[e.NumberTooLarge = 10001] = "NumberTooLarge", e[e.NoRouter = 10002] = "NoRouter", e[e.InsufficientLiquidity = 10003] = "InsufficientLiquidity", e[e.HoneyPot = 10004] = "HoneyPot", e))(ya || {});
const uJ = new wa({
  url: Bx("mainnet")
}), lJ = [
  "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
  // Circle Native USDC
  "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2::ausd::AUSD",
  // Agora USD
  "0xf16e6b723f242ec745dfd7634ad072c42d5c1d9ac9d62a39c381303eaa57693a::fdusd::FDUSD",
  // FDUSD
  "0x960b531667636f39e85867775f52f6b1f220a058c4de786905bdf761e06a56bb::usdy::USDY",
  // Ondo USDY
  "0x294de7579d55c110a00a7c4946e09a1b5cbeca2592fbb83fd7bfacba3cfeaf0e::drf::DRF"
  // DRF
], fJ = ["deny_list", "DenyList", "DenyCap", "create_regulated_currency"], dJ = {
  showType: !0,
  showContent: !0,
  showOwner: !1,
  showPreviousTransaction: !1,
  showStorageRebate: !1,
  showDisplay: !1
}, hJ = async (e) => {
  let t = !1;
  if (lJ.includes(e))
    return t;
  const r = e.split("::"), n = r[0] && Gt(r[0]), i = r[1], s = await uJ.getObject({ id: n, options: dJ }), o = "disassembled" in s.data.content ? s.data.content.disassembled[i] : null;
  return o && typeof o == "string" && new RegExp(fJ.join("|"), "i").test(o) && (t = !0), t;
}, pJ = (e) => {
  var n;
  if (!e)
    return "";
  const t = e == null ? void 0 : e.split(",");
  return (n = t == null ? void 0 : t.map((i) => Hs(i, !1))) == null ? void 0 : n.join(",");
};
function mJ() {
  const { fetchByApi: e } = th(), t = async (s) => {
    try {
      const o = { ...s }, a = pJ(s == null ? void 0 : s.coin_type);
      a && (o.coin_type = a);
      const c = await e("/v2/sui/stats_pools", "GET", o);
      if (c != null && c.lp_list)
        return {
          list: (c == null ? void 0 : c.lp_list) || [],
          total: c == null ? void 0 : c.total
        };
    } catch (o) {
      return console.error("getPoolList ~ Error:", o), await r(s);
    }
    return {
      list: [],
      total: 0
    };
  }, r = async (s) => {
    var o, a, c, u;
    try {
      const l = Lt("/data/pools.json"), f = await fetch(l).then((h) => h.json());
      if ((o = f == null ? void 0 : f.data) != null && o.lp_list) {
        const h = (a = f == null ? void 0 : f.data) == null ? void 0 : a.lp_list;
        let v = h;
        if (s != null && s.coin_type) {
          const y = (u = (c = s == null ? void 0 : s.coin_type) == null ? void 0 : c.split(",")) == null ? void 0 : u.map((S) => ga(S).source_address);
          v = h == null ? void 0 : h.filter((S) => {
            var I, U;
            const C = ga(
              (I = S == null ? void 0 : S.coin_a) == null ? void 0 : I.address
            ).source_address, O = ga(
              (U = S == null ? void 0 : S.coin_b) == null ? void 0 : U.address
            ).source_address;
            return (y == null ? void 0 : y.length) > 1 && y.includes(C) && y.includes(O) ? !0 : !!((y == null ? void 0 : y.length) === 1 && (y.includes(C) || y.includes(O)));
          });
        }
        s != null && s.is_vaults && (v = h == null ? void 0 : h.filter((y) => y == null ? void 0 : y.is_vaults)), s != null && s.has_farming && !(s != null && s.is_vaults) && !(s != null && s.has_mining) && !(s != null && s.no_incentives) && (v = h == null ? void 0 : h.filter((y) => y == null ? void 0 : y.has_farming));
        const b = v;
        return {
          list: b,
          total: (b == null ? void 0 : b.length) || 0
        };
      }
    } catch (l) {
      console.error("getLocalJsonPoolList Error:", l);
    }
    return {
      list: [],
      total: 0
    };
  }, n = (s) => hb(s) === "0x2::sui::SUI" ? "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI" : hb(s);
  return {
    getPoolList: t,
    getLocalJsonPoolList: r,
    getLocalJsonPoolAddress: async (s, o) => {
      try {
        const a = n(s), c = n(o), u = await fetch("/data/all-pools.json").then((l) => l.json());
        if (u)
          return u[`${a.toLocaleLowerCase()}-${c.toLocaleLowerCase()}`] || u[`${c.toLocaleLowerCase()}-${a.toLocaleLowerCase()}`];
      } catch (a) {
        console.error("getLocalJsonPoolAddress Error:", a);
      }
      return [];
    }
  };
}
function gJ(e = !0) {
  const { poolApiMap: t, setPoolApiMap: r } = Sn(), { getPoolList: n, getLocalJsonPoolList: i, getLocalJsonPoolAddress: s } = mJ();
  return {
    getPoolListByCoinType: async (c, u) => {
      if (c && u) {
        const l = [c, u].sort(), f = `${l[0]}_${l[1]}`, h = t[f];
        if (h)
          return h;
        const v = {
          coin_type: `${c},${u}`,
          display_all_pools: !0,
          offset: 0,
          limit: 100,
          order_by: "-tvl",
          no_incentives: !0,
          has_farming: !0,
          has_mining: !0
        };
        let b = e ? await i(v) : void 0;
        (b === void 0 || b.list.length === 0) && (b = await n(v));
        const y = b.list;
        if (y.length > 0)
          return t[f] = y, r(f, y), y;
      }
      return [];
    },
    getPoolAddressByCoinType: async (c, u) => {
      if (c && u) {
        const l = [c, u].sort(), f = `${l[0]}_${l[1]}`;
        if (e) {
          const b = await s(c, u);
          if (!b || b.length === 0) {
            const y = t[f];
            if (y)
              return y.map((S) => S.poolAddress);
          } else
            return b;
        }
        const h = {
          coin_type: `${c},${u}`,
          display_all_pools: !0,
          offset: 0,
          limit: 100,
          order_by: "-tvl",
          no_incentives: !0,
          has_farming: !0,
          has_mining: !0
        }, v = await n(h);
        if (v) {
          const b = v.list;
          if (b.length > 0)
            return t[f] = b, r(f, b), b.map((y) => y.poolAddress);
        }
      }
      return [];
    }
  };
}
function yJ(e) {
  const { routerData: t } = En();
  return { priceAcceptRouterData: Ft(() => {
    if (t && e) {
      if (e.byAmountIn) {
        if (!Ue(e.toAmountUi).eq(t.toAmountUi || "0"))
          return t;
      } else if (!Ue(e.fromAmountUi).eq(t.fromAmountUi || "0"))
        return t;
      return;
    }
  }, [t, e]) };
}
function H9(e, t) {
  return { amountLimit: Ft(() => {
    if (t && t.routerData) {
      const { byAmountIn: n, fromAmountUi: i, toAmountUi: s } = t;
      return n ? Ue(s).mul(Ue(1).sub(Ue(e).div(100))).toString() : Ue(i).mul(Ue(1).add(Ue(e).div(100))).toString();
    }
  }, [e, t]) };
}
function vJ() {
  const { fromCoin: e, toCoin: t } = En(), { getPoolAddressByCoinType: r } = gJ(!0);
  return {
    getSwapPoolAddress: async () => e && t ? await r(
      e.coin_type,
      t.coin_type
    ) : []
  };
}
function G9(e, t, r) {
  return Ft(() => t && r && +t && +r ? e ? Ue(r).div(t).toString() : Ue(t).div(r).toString() : "0", [t, r, e]);
}
function Jb(e) {
  const [t, r] = Mt(), n = async (i) => {
    if (i.is_trusted)
      return !1;
    try {
      return await hJ(i.coin_type);
    } catch {
    }
    return !1;
  };
  return Bt(() => {
    r(void 0), e && n(e).then((i) => {
      r(i);
    });
  }, [e == null ? void 0 : e.coin_type]), {
    isScamsCoin: t
  };
}
function bJ(e, t) {
  const { defaultFromCoinType: r, defaultToCoinCoinType: n } = En(), { getTokenInfo: i } = $c(), { ignoreWarnTokenMap: s } = Sn(), o = i(e), a = i(t), c = Ft(() => !Rl(r, W9.coin_type) || !Rl(n, q9.coin_type), [r, n]), u = Ii(
    (f) => f && !s[Hs(f.coin_type)] && (Rl(r, f.coin_type) || Rl(n, f.coin_type)) ? !f.is_trusted : !1,
    [r, n, s]
  ), l = Ft(() => {
    const f = [];
    return c && (o && u(o) && f.push({ ...o }), a && u(a) && f.push({ ...a })), f;
  }, [
    o == null ? void 0 : o.coin_type,
    a == null ? void 0 : a.coin_type,
    c,
    s
  ]);
  return {
    isCustomMode: c,
    customWarnTokenList: l
  };
}
function wJ() {
  const { aggregatorSDK: e } = Fo(), { getSwapPoolAddress: t } = vJ(), r = (s) => s && s.error ? s.error.code === ya.InsufficientLiquidity || ya.HoneyPot || ya.NumberTooLarge : !1, n = async (s) => {
    var h;
    const { fromToken: o, toToken: a, amount: c, providersKeys: u, by_amount_in: l, uuid: f } = s;
    try {
      const v = {
        from: o.coin_type,
        target: a.coin_type,
        amount: new cv(c),
        byAmountIn: l,
        depth: 3,
        splitAlgorithm: void 0,
        splitFactor: void 0,
        splitCount: void 0,
        providers: u
      }, b = await e.findRouters(v);
      if (b && r(b))
        return i(
          !1,
          l,
          f,
          o,
          a,
          b
        );
      if (!b || !((h = b == null ? void 0 : b.paths) != null && h.length))
        throw Error("not find router");
      return i(
        !1,
        l,
        f,
        o,
        a,
        b
      );
    } catch {
      const b = await t(), y = {
        from: o.coin_type,
        target: a.coin_type,
        amount: new cv(c),
        byAmountIn: l,
        pools: b
      };
      try {
        const S = await e.swapInPools(y);
        return !S || !S.routeData ? i(!0, l, f, o, a) : i(
          !0,
          l,
          f,
          o,
          a,
          S.routeData
        );
      } catch {
        return {
          uuid: f,
          byAmountIn: l,
          isDegrade: !0
        };
      }
    }
  }, i = (s, o, a, c, u, l) => {
    var f;
    if (l) {
      const h = l.error !== void 0, v = im(
        l.amountIn.toString(),
        c.decimals
      ).toString(), b = im(
        l.amountOut.toString(),
        u.decimals
      ).toString();
      return {
        routerData: h ? void 0 : l,
        fromAmountUi: h ? o ? v : "" : v,
        toAmountUi: h && o ? "" : b,
        uuid: a,
        byAmountIn: o,
        isDegrade: s,
        errorCode: (f = l.error) == null ? void 0 : f.code
      };
    } else
      return {
        uuid: a,
        byAmountIn: o,
        isDegrade: s
      };
  };
  return {
    findBestRouters: n
  };
}
function Wa(e) {
  const t = Ar(e);
  return Bt(() => {
    t.current = e;
  }, [e]), t;
}
function _J(e) {
  try {
    return e && e.toString().includes("Rejected from user");
  } catch {
    return !1;
  }
}
function xJ(e) {
  const t = String(e);
  return t.indexOf("withdraw_with_proof") > -1 || t.indexOf("check_coin_threshold") > -1 || t.indexOf('Identifier("balance")') > -1;
}
function SJ(e) {
  return !!String(e).includes("Could not find the referenced transaction");
}
function EJ(e) {
  return !!String(e).includes("Max cap reached.");
}
function TJ(e) {
  return !!String(e).includes("Fast Mode service error");
}
function CJ(e) {
  return _J(e) ? "User rejected the request" : xJ(e) ? "Exceeded price slippage" : SJ(e) ? "Oops. Failed to sync data from your txid. Please check your txn status from explorer or from your wallet." : EJ(e) ? "Max cap reached. This is to prevent your txn from overpaying. You can choose to edit your gas max cap in settings if needed." : TJ(e) ? "Fast Mode service error, please switch to the Default Transaction Mode or try again later." : "Transaction failed";
}
var G1 = {}, AJ = Yr && Yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(G1, "__esModule", { value: !0 });
var MJ = G1.executeAuction = K9;
const OJ = AJ(LS), IJ = "https://rpc.getshio.com", kJ = 500, jJ = 300;
function K9(e, t, r = kJ) {
  const n = {
    jsonrpc: "2.0",
    method: "shio_executeAuction",
    params: [e, t],
    id: 1
  };
  return new Promise((i, s) => {
    setTimeout(i, r), OJ.default.post(IJ, n, {
      headers: {
        "Content-Type": "application/json"
      },
      timeout: r
    }).then((o) => {
      setTimeout(i, jJ);
    }).catch(s);
  });
}
G1.default = { executeAuction: K9 };
const RJ = "0x2::sui::SUI", PJ = "https://rpc.getshio.com/fast", NJ = "0x1889977f0fb56ae730e7bda8e8e32859ce78874458c74910d36121a81a615123", Zb = [
  {
    objectId: "0xc32ce42eac951759666cbc993646b72387ec2708a2917c2c6fb7d21f00108c18",
    version: 72869622
  },
  {
    objectId: "0x0289acae0edcdf1fe3aedc2e886bc23064d41c359e0179a18152a64d1c1c2b3e",
    version: 327637282
  },
  {
    objectId: "0x03132160e8c2c45208abf3ccf165e82edcc42fee2e614afe54582f9740a808b8",
    version: 327637282
  },
  {
    objectId: "0x072ae7307459e535379f422995a0d10132f12a3450298f8cf0cc07bd164f9999",
    version: 327637282
  },
  {
    objectId: "0x1c1a96a2f4a34ea09ab15b8ff98f4b6b4338ce89f4158eb7d3eb2cd4dcbd6d86",
    version: 327637282
  },
  {
    objectId: "0x20d76f37ad9f2421a9e6afaf3bb204250b1c2241c50e8a955e86a1a48767d06f",
    version: 327637282
  },
  {
    objectId: "0x213ed368233cc7480fcb6336e70c5ae7ee106b2317ba02ccb5d0478e45bcc046",
    version: 327637282
  },
  {
    objectId: "0x22ce1e80937354eba5549fed2937dc6e2b24026d03505bb51a3e4a64aa4142f6",
    version: 327637282
  },
  {
    objectId: "0x26188cb7ce5ae633279f440f66081cb65cc585e428de18e194f8843e866f799f",
    version: 327637282
  },
  {
    objectId: "0x38642f01422480128388d3e2948d3dc1b2680f9914077edb6bd3451ae1c5bcf0",
    version: 327637282
  },
  {
    objectId: "0x3dd85b6424aea1cae9eff6e55456ca783e056226325f1362106eca8b3ed04ca0",
    version: 327637282
  },
  {
    objectId: "0x42f8adc490542369d9c3b95e9f6eb70b2583102900feb7e103072ed49ba7fc3d",
    version: 327637282
  },
  {
    objectId: "0x46b8158c82fa6bda7230d31a127d934c7295a0042083b4900f3096e9191f6f3f",
    version: 327637282
  },
  {
    objectId: "0x6ebac88a8c3f7a4a9fb05ea49d188a1fe8520ae59ee736e0473004d3033512a4",
    version: 327637282
  },
  {
    objectId: "0x6f55ad6cb40cfc124c11b11c19be0a80237b104acd955e7b52ccb7bf9046fe33",
    version: 327637282
  },
  {
    objectId: "0x71aafb8bac986e82e5f78846bf3b36c2a82505585625207324140227a27ff279",
    version: 327637282
  },
  {
    objectId: "0x7fe9b08680d4179de5672f213b863525b21f10604ca161538075e9338d1d2324",
    version: 327637282
  },
  {
    objectId: "0x81538ef2909a3e0dd3d7f38bcbee191509bae4e8666272938ced295672e2ee8d",
    version: 327637282
  },
  {
    objectId: "0x828eb6b3354ad68a23dd792313a16a0d888b7ea4fdb884bb22bd569f8e61319e",
    version: 327637282
  },
  {
    objectId: "0x9705a332b8c1650dd7fe687ef9f9a9638afb51c30c0b34db150d60b920bc07eb",
    version: 327637282
  },
  {
    objectId: "0x9918f73797a9390e9888b55454f2b31bc01de1a4634acab08f80641c4248e8a5",
    version: 327637282
  },
  {
    objectId: "0x9cd4c08bdf2e132ec2cc77b0f03be60a94951e046d8e82ed5494f44e609edd2f",
    version: 327637282
  },
  {
    objectId: "0xac8ce2033571140509788337c8a1f3aa8941a320ecd7047acda310d39cad9e03",
    version: 327637282
  },
  {
    objectId: "0xbcd4527035265461a9a7b4f1e57c63ea7a6bdf0dc223c66033c218d880f928b1",
    version: 327637282
  },
  {
    objectId: "0xbfdb691b8cc0b3c3a3b7a654f6682f3e53b164d9ee00b9582cdb4d0a353440a9",
    version: 327637282
  },
  {
    objectId: "0xc2559d5c52ae04837ddf943a8c2cd53a5a0b512cee615d30d3abe25aa339465e",
    version: 327637282
  },
  {
    objectId: "0xc56db634d02511e66d7ca1254312b71c60d64dc44bf67ea46b922c52d8aebba6",
    version: 327637282
  },
  {
    objectId: "0xc84545cbff1b36b874ab2b69d11a3d108f23562e87550588c0bda335b27101e0",
    version: 327637282
  },
  {
    objectId: "0xcc141659b5885043f9bfcfe470064819ab9ac667953bcedd1000e0652e90ee76",
    version: 327637282
  },
  {
    objectId: "0xef6bf4952968d25d3e79f7e4db1dc38f2e9d99d61ad38f3829acb4100fe6383a",
    version: 327637282
  },
  {
    objectId: "0xf2ed8d00ef829de5c4a3c5adf2d6b0f41f7fec005fb9c88e5616b98173b2fd66",
    version: 327637282
  },
  {
    objectId: "0xfce73f3c32c3f56ddb924a04cabd44dd870b72954bbe7c3d7767c3b8c25c4326",
    version: 327637282
  }
];
async function $J(e) {
  const t = e.client, r = await e.transaction.build({
    client: t,
    onlyTransactionKind: !0
  });
  let n = e.sender ?? e.transaction.getData().sender;
  if (!n)
    throw new Error("Sender need to be either set in options or in transaction data");
  return await t.call("shio_estimateFastModeFee", [
    n,
    e.transaction.getData().gasData.price,
    Yf.from(r).toString("base64")
  ]);
}
function DJ() {
  return Zb[Math.floor(Math.random() * Zb.length)];
}
async function LJ(e, t, r) {
  return await e.executeTransactionBlock({
    transactionBlock: t.bytes,
    signature: t.signature,
    options: r
  });
}
async function BJ(e, t, r) {
  let n = e.moveCall({
    package: "0x2",
    module: "coin",
    function: "into_balance",
    typeArguments: [RJ],
    arguments: [t]
  });
  return UJ(e, n, r);
}
async function UJ(e, t, r) {
  let n = DJ();
  e.moveCall({
    package: NJ,
    module: "auctioneer",
    function: "submit_bid",
    arguments: [
      e.sharedObjectRef({
        objectId: n.objectId,
        mutable: !0,
        initialSharedVersion: n.version
      }),
      e.pure.u64(r),
      t
    ]
  });
}
const gm = "CoinWithBalance", FJ = We({
  type: Nt(),
  balance: el()
});
async function VJ(e, t, r) {
  var u, l;
  const n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
  if (!e.sender)
    throw new Error("Sender must be set to resolve CoinWithBalance");
  for (const f of e.commands)
    if (f.$kind === "$Intent" && f.$Intent.name === gm) {
      const { type: h, balance: v } = fr(
        FJ,
        f.$Intent.data
      );
      h !== "gas" && v > 0n && n.add(h), i.set(h, (i.get(h) ?? 0n) + v);
    }
  const s = /* @__PURE__ */ new Set();
  for (const f of e.inputs)
    (u = f.Object) != null && u.ImmOrOwnedObject && s.add(f.Object.ImmOrOwnedObject.objectId), (l = f.UnresolvedObject) != null && l.objectId && s.add(f.UnresolvedObject.objectId);
  const o = /* @__PURE__ */ new Map(), a = t.client;
  await Promise.all(
    [...n].map(async (f) => {
      o.set(
        f,
        await zJ({
          coinType: f,
          balance: i.get(f),
          client: a,
          owner: e.sender,
          usedIds: s
        })
      );
    })
  );
  const c = /* @__PURE__ */ new Map();
  c.set("gas", { $kind: "GasCoin", GasCoin: !0 });
  for (const [f, h] of e.commands.entries()) {
    if (h.$kind !== "$Intent" || h.$Intent.name !== gm)
      continue;
    const { type: v, balance: b } = h.$Intent.data;
    if (b === 0n && v !== "gas") {
      e.replaceCommand(
        f,
        ni.Commands.MoveCall({ target: "0x2::coin::zero", typeArguments: [v] })
      );
      continue;
    }
    const y = [];
    if (!c.has(v)) {
      const [S, ...C] = o.get(v).map(
        (O) => e.addInput(
          "object",
          ni.Inputs.ObjectRef({
            objectId: O.coinObjectId,
            digest: O.digest,
            version: O.version
          })
        )
      );
      C.length > 0 && y.push(ni.Commands.MergeCoins(S, C)), c.set(v, S);
    }
    y.push(
      ni.Commands.SplitCoins(c.get(v), [
        e.addInput(
          "pure",
          ni.Inputs.Pure(Ri.bcs.u64().serialize(b))
        )
      ])
    ), e.replaceCommand(f, y), e.mapArguments((S) => S.$kind === "Result" && S.Result === f ? {
      $kind: "NestedResult",
      NestedResult: [f + y.length - 1, 0]
    } : S);
  }
  return r();
}
async function zJ({
  coinType: e,
  balance: t,
  client: r,
  owner: n,
  usedIds: i
}) {
  let s = t;
  const o = [];
  return a();
  async function a(c = null) {
    const { data: u, hasNextPage: l, nextCursor: f } = await r.getCoins({
      owner: n,
      coinType: e,
      cursor: c
    }), h = u.sort(
      (v, b) => Number(BigInt(b.balance) - BigInt(v.balance))
    );
    for (const v of h) {
      if (i.has(v.coinObjectId))
        continue;
      const b = BigInt(v.balance);
      if (o.push(v), s -= b, s <= 0)
        return o;
    }
    if (l)
      return a(f);
    throw new Error(
      `Not enough coins of type ${e} to satisfy requested balance`
    );
  }
}
function Y9() {
  const { suiClient: e } = Fo(), { currentAccount: t } = Tn(), { mutateAsync: r } = eC(), { mutate: n } = tC({
    execute: async ({ bytes: c, signature: u }) => await s(c, u)
  }), i = Ft(() => "sui:mainnet", [t]), s = async (c, u, l = !1) => {
    var h, v;
    if (l) {
      const b = await e.devInspectTransactionBlock({
        transactionBlock: ni.Transaction.from(Hr(c)),
        sender: t.address
      });
      if (!b || ((h = b.effects) == null ? void 0 : h.status.status) === "failure")
        throw Error((v = b.effects) == null ? void 0 : v.status.error);
    }
    return await e.executeTransactionBlock({
      transactionBlock: c,
      signature: u,
      options: {
        showEvents: !0,
        showRawEffects: !0,
        showEffects: !0,
        showBalanceChanges: !0,
        showObjectChanges: !0,
        showInput: !0
      }
    });
  };
  return {
    signAndExecuteTransactionBlock: async (c, u = !1) => {
      var f, h;
      let l;
      if (typeof c == "string" ? l = ni.Transaction.from(c) : l = c, u) {
        const v = await e.devInspectTransactionBlock({
          transactionBlock: c,
          sender: t.address
        });
        if (!v || ((f = v.effects) == null ? void 0 : f.status.status) === "failure")
          throw Error((h = v.effects) == null ? void 0 : h.status.error);
      }
      return l.setGasBudget(1e8), new Promise((v, b) => {
        n(
          {
            transaction: l,
            chain: i
          },
          {
            onSuccess: (y) => {
              v(y);
            },
            onError: (y) => {
              console.error(
                "signAndExecuteTransactionBlock transaction failed",
                y
              ), b(y);
            }
          }
        );
      });
    },
    signTransactionBlock: async (c) => (c instanceof Uint8Array && (c = ni.Transaction.from(c)), typeof c == "string" && (c = ni.Transaction.from(Hr(c))), new Promise((u, l) => {
      r(
        {
          transaction: c,
          chain: i
        },
        {
          onSuccess: (f) => {
            u(f);
          },
          onError: (f) => {
            console.error("signTransactionBlock failed", f), l(f);
          },
          onSettled: (f, h, v, b) => {
            console.error("signTransactionBlock onSettled", {
              data: f,
              error: h,
              variables: v
            });
          }
        }
      );
    })),
    executeTransactionBlock: s
  };
}
function WJ() {
  const {
    signTransactionBlock: e,
    executeTransactionBlock: t,
    signAndExecuteTransactionBlock: r
  } = Y9(), { currentAccount: n } = Tn();
  return {
    getFastModeTx: async (s, o, a) => {
      let c, u, l;
      try {
        const f = new wa({ url: PJ });
        s.setSender(n == null ? void 0 : n.address), s.setGasPrice(Number(a));
        const h = ni.Transaction.from(s);
        h.addIntentResolver(gm, VJ);
        const v = await $J({
          transaction: h,
          client: f
        }), b = Ue(o).mul(Math.pow(10, 9)).toString();
        if (Ue(v.gasBudget).gt(b))
          throw Error(
            "Max cap reached. This is to prevent your txn from overpaying. You can choose to edit your gas max cap in settings if needed."
          );
        s.setGasBudget(v.gasBudget);
        const y = s.splitCoins(s.gas, [v.tipAmount]);
        BJ(s, y[0], v.tipAmount);
        const S = await s.build({
          client: f
        }), C = await e(S), { bytes: O, signature: I } = C;
        l = O, u = (/* @__PURE__ */ new Date()).getTime(), c = await LJ(f, C, {
          showEffects: !0,
          showEvents: !0
        });
      } catch (f) {
        throw String(f).includes("Failed to fetch") ? Error("Fast Mode service error") : f;
      }
      return {
        result: c,
        startExecuteTime: u,
        transactionBlockBytes: l
      };
    }
  };
}
function qJ() {
  const {
    signTransactionBlock: e,
    executeTransactionBlock: t,
    signAndExecuteTransactionBlock: r
  } = Y9(), { currentAccount: n } = Tn(), { suiClient: i } = Fo(), { setTransactionData: s } = H1(), { addTxToast: o, removeToast: a } = Nc(), { getFastModeTx: c } = WJ(), u = 5, l = 2e3;
  async function f(b, y = 1) {
    try {
      let S;
      try {
        S = await i.getTransactionBlock({
          digest: b,
          options: {
            showEvents: !0,
            showEffects: !0,
            showBalanceChanges: !0,
            showInput: !0,
            showRawInput: !0,
            showObjectChanges: !0
          }
        });
      } catch {
        S = await i.getTransactionBlock({
          digest: b,
          options: {
            showEvents: !0,
            showEffects: !0
          }
        });
      }
      if (S)
        return S;
      throw new Error("Empty response");
    } catch (S) {
      if (console.error(`Attempt ${y} failed:`, S), y >= u)
        throw new Error(
          "Failed to fetch transaction status after maximum retries."
        );
      return await fb(l), f(b, y + 1);
    }
  }
  const h = async (b, y, S = {
    useDevInspect: !1,
    useMev: !1,
    txAction: "signTransactionBlock",
    useFastMode: !1,
    maxCapForGas: "",
    customGasPrice: ""
  }) => {
    var le, te, ce;
    const {
      useDevInspect: C = !1,
      useMev: O,
      txAction: I = "signTransactionBlock",
      useFastMode: U = !1,
      maxCapForGas: D = "",
      customGasPrice: H = ""
    } = S;
    let z;
    y.status = "confirmation", s(y);
    let ne = "";
    try {
      let V, L, p;
      typeof b == "function" ? p = await b() : p = b, p.setSender(n.address);
      let d;
      if (U && D && H) {
        const x = await c(
          p,
          D,
          H
        );
        V = x.result, d = x.startExecuteTime, L = x.transactionBlockBytes;
      } else if (I === "signTransactionBlock") {
        const x = await e(p), { bytes: E, signature: A } = x;
        if (O)
          try {
            const j = await MJ(E, A, 500);
          } catch {
          }
        V = await t(
          E,
          A,
          C
        );
      } else
        V = await r(
          p,
          C
        );
      y.status = "submitted", s({ ...y }), y.tx = V.digest, z = o(y), await fb(l), ne = V == null ? void 0 : V.digest;
      let m;
      if (((le = V == null ? void 0 : V.effects) == null ? void 0 : le.status.status) === "success" ? m = V : m = await f(ne, 0), !m || ((te = m.effects) == null ? void 0 : te.status.status) === "failure")
        v(y, (ce = m.effects) == null ? void 0 : ce.status.error);
      else {
        const x = mW(
          m,
          n == null ? void 0 : n.address,
          !1
        );
        if (y.buildShowInfo) {
          const E = y.buildShowInfo("success", x);
          y.buildShowInfo = (A) => E;
        }
        a(z), y.status = "success", s({ ...y });
      }
      return m;
    } catch (V) {
      v(y, V);
    }
  }, v = (b, y) => {
    const S = CJ(y);
    if (b.buildShowInfo) {
      const C = b.buildShowInfo("confirmation");
      b.buildShowInfo = (O) => (C.toastDescriptionContent = S, C.modalDescriptionText = S, C), b.status = "rejected", s({ ...b });
    } else
      b.buildShowInfo = (C) => {
        const O = {};
        return O.toastDescriptionContent = S, O.modalDescriptionText = S, O;
      }, b.status = "rejected", s({ ...b });
  };
  return {
    signAndExecuteTransaction: h
  };
}
function K1(e, t = 1e3) {
  const r = Ar(), n = Ii(
    (...i) => {
      r.current && clearTimeout(r.current), r.current = setTimeout(() => {
        e(...i);
      }, t);
    },
    [e, t]
  );
  return Bt(() => () => {
    r.current && clearTimeout(r.current);
  }, []), n;
}
function HJ() {
  const { aggregatorSDK: e } = Fo(), { findBestRouters: t } = wJ(), { getTokenAmountValue: r, fetchTokenPrices: n } = Sl(), {
    providers: i,
    slippage: s,
    mevProtect: o,
    maxCapForGas: a,
    transactionMode: c,
    customGasPrice: u
  } = Sn(), { signAndExecuteTransaction: l } = qJ(), { setTransactionData: f } = H1(), { addTxToast: h } = Nc(), {
    fromCoin: v,
    toCoin: b,
    setFromCoin: y,
    setToCoin: S,
    setToAmount: C,
    fromAmount: O,
    toAmount: I,
    setFromAmount: U,
    setFindRouterLoading: D,
    setRouterData: H,
    setByAmountIn: z,
    byAmountIn: ne
  } = En(), [le, te] = Mt(""), ce = Wa(le), V = Wa(ne), L = Wa(O), p = Wa(I), d = Wa(v), m = Wa(b), { balanceInfo: x, getOwnerCoinBalances: E } = $u(v), { balanceInfo: A } = $u(b), j = r(v == null ? void 0 : v.coin_type, O), k = r(b == null ? void 0 : b.coin_type, I), w = K1(async (ee, Z, q) => {
    if (d.current && m.current && +ee) {
      (+L.current || +p.current) && D(!0);
      const he = hW(
        ee,
        Z ? d.current.decimals : m.current.decimals
      ), Y = await t({
        fromToken: d.current,
        toToken: m.current,
        amount: he.toString(),
        providersKeys: i,
        by_amount_in: Z,
        uuid: q
      });
      D(!1), ce.current === q && (Z ? +L.current ? (C(Y.toAmountUi || ""), H(Y)) : C("") : +p.current ? (U(Y.fromAmountUi || ""), H(Y)) : U(""));
    } else
      ie(!Z);
  }, 500), P = (ee, Z, q = !1) => {
    if (z(Z), Z ? (U(ee), q && C("")) : (C(ee), q && U("")), +ee) {
      const he = Xb();
      te(he), w(ee, Z, he);
    } else
      D(!1), H(void 0), ie(!Z);
  }, ue = (ee, Z = !0) => {
    ie(), Z ? ((ee == null ? void 0 : ee.coin_type) === (b == null ? void 0 : b.coin_type) && S(v), y(ee)) : ((ee == null ? void 0 : ee.coin_type) === (v == null ? void 0 : v.coin_type) && y(b), S(ee));
  }, ie = (ee) => {
    ee === void 0 ? (U(""), C("")) : ee ? U("") : C(""), D(!1), H(void 0);
  }, fe = () => {
    const ee = V.current ? L.current : p.current;
    if (+ee) {
      const Z = Xb();
      te(Z), w(ee, V.current, Z);
    }
  }, ye = async (ee, Z) => {
    const { routerData: q, byAmountIn: he, fromAmountUi: Y, toAmountUi: X } = ee, B = new ni.Transaction(), se = {
      router: q,
      slippage: Number(s) / 100,
      txb: B,
      partner: Z || SW
    };
    try {
      const me = {
        status: "confirmation",
        buildShowInfo: (Oe, Be) => {
          const Xe = `Swap ${jn(Y, v == null ? void 0 : v.decimals)} ${v == null ? void 0 : v.symbol} for ${jn(X, b == null ? void 0 : b.decimals)} ${b == null ? void 0 : b.symbol}`, Re = {
            modalDescriptionText: Xe,
            toastTitleText: Xe
          };
          if (Oe === "success") {
            let He = Y, rt = X;
            Be && (He = db(Be, v) || Y, rt = db(Be, b) || X);
            const Qe = `Swapped ${jn(He, v == null ? void 0 : v.decimals)} ${v == null ? void 0 : v.symbol} for ${jn(rt, b == null ? void 0 : b.decimals)} ${b == null ? void 0 : b.symbol}`;
            Re.toastTitleText = Qe, Re.modalDescriptionText = Qe;
          }
          return Re;
        },
        id: 0
      };
      f(me), await l(async () => (await e.fastRouterSwap(se), B), me, {
        useMev: o,
        useFastMode: c === "Fast Mode",
        maxCapForGas: a,
        customGasPrice: u
      }) ? (ie(), E()) : fe();
    } catch (me) {
      String(me).includes("TypeError: Failed to fetch") && h({
        id: 0,
        status: "rejected",
        buildShowInfo(de, xe) {
          return {
            toastTitleText: "RPC loading failed",
            toastDescriptionContent: "Try resubmission. Or to check your network and switch an RPC in settings to try again."
          };
        }
      });
    }
  };
  Bt(() => {
    Te(), ie();
  }, [v == null ? void 0 : v.coin_type, b == null ? void 0 : b.coin_type]);
  const Te = () => {
    const ee = [];
    v && ee.push(v.coin_type), b && ee.push(b.coin_type), ee.length > 0 && n(ee);
  }, { isScamsCoin: N } = Jb(v), { isScamsCoin: F } = Jb(b), G = Ft(() => {
    if (!(!N && !F)) {
      if (N && F)
        return `${v == null ? void 0 : v.symbol} and ${b == null ? void 0 : b.symbol} are`;
      if (N)
        return `${v == null ? void 0 : v.symbol} token is `;
      if (F)
        return `${b == null ? void 0 : b.symbol} token is `;
    }
  }, [N, F]);
  return {
    handleAmountChange: P,
    handleSelectToken: ue,
    fromBalanceInfo: x,
    toBalanceInfo: A,
    fromAmountValue: j,
    toAmountValue: k,
    doSwapAction: ye,
    reCalculateRouteData: fe,
    refreshMarketPrice: Te,
    scamsText: G
  };
}
function GJ(e) {
  const { fromCoin: t, toCoin: r, fromAmount: n, toAmount: i, routerData: s } = En(), { currentAccount: o } = Tn(), a = Ft(() => {
    const c = {
      text: "Swap",
      disabled: !1
    };
    if (!(o != null && o.address))
      return c.text = "Connect Wallet", c.disabled = !1, c;
    if (!t || !r)
      return c.text = "Select a token", c.disabled = !0, c;
    if (!+n && !+i)
      return c.text = "Enter an amount", c.disabled = !0, c;
    if (s && s.errorCode) {
      if (s.errorCode === ya.InsufficientLiquidity)
        return c.text = "Insufficient liquidity for this trade", c.disabled = !0, c;
      if (s.errorCode === ya.NoRouter || s.errorCode === ya.HoneyPot)
        return c.text = "No Available Route", c.disabled = !0, c;
    }
    return +n && Ue(n).gt(e || 0) ? (c.disabled = !0, c.text = `Insufficient ${sn(t == null ? void 0 : t.symbol)} Balance`, c) : ((!+n || !+i) && (c.disabled = !0), c);
  }, [
    o == null ? void 0 : o.address,
    n,
    i,
    e,
    s == null ? void 0 : s.errorCode,
    t,
    r
  ]);
  return {
    btnText: a.text,
    btnDisabled: a.disabled
  };
}
const Qb = 878, Wi = 176, zl = 72, Yo = 22, KJ = 8, Ts = 16, YJ = 24, XJ = 12, JJ = 16, ZJ = 8, QJ = 22, Zr = 50, Ir = 55, qa = 13, Gn = 5;
function X9(e, t, r) {
  const [n, i] = Mt({}), [s, o] = Mt([]), [a, c] = Mt([]), [u, l] = Mt(0), { fromCoin: f, toCoin: h } = En(), [v, b] = Mt([]), [y, S] = Mt([]);
  function C(p, d, m, x = 3) {
    const E = /* @__PURE__ */ new Set();
    p.forEach((ie) => {
      E.add(ie.from), E.add(ie.target);
    });
    const A = [], j = [], k = /* @__PURE__ */ new Set();
    p.forEach((ie) => {
      var fe;
      if (ie.from === d && ie.target !== m) {
        const ye = ie.target, Te = p.some(
          (F) => F.target === ye && F.from !== d
        );
        let N = !1;
        if (Te) {
          const F = new Set(
            (fe = p.filter((Z) => Z.from === ye)) == null ? void 0 : fe.map((Z) => Z == null ? void 0 : Z.target)
          );
          Array.from(F).every(
            (Z) => Z === m
          ) && (N = !0);
        }
        N || k.add(ye);
      }
    }), k.forEach((ie) => {
      const fe = {};
      p.forEach((ye) => {
        ye.from === d && ye.target === ie && (fe[d] || (fe[d] = []), fe[d].push(ye));
      }), Object.keys(fe).forEach((ye) => {
        const Te = /* @__PURE__ */ new Map();
        fe[ye].forEach((N) => {
          const F = N.provider, G = N.feeRate, ee = `${F}_${G}`;
          if (Te.has(ee)) {
            const Z = Te.get(ee);
            Z.amountIn = Ue(Z.amountIn).plus(N.amountIn || "0").toString(), Z.amountOut = Ue(Z.amountOut).plus(N.amountOut || "0").toString();
          } else
            Te.set(ee, {
              ...N,
              amountIn: N.amountIn || "0",
              amountOut: N.amountOut || "0"
            });
        }), fe[ye] = Array.from(Te.values());
      }), j.push({
        target: `0-${ie}`,
        originalTarget: ie,
        list: fe
      });
    }), j.length > 0 && A.push(j);
    const g = [], w = /* @__PURE__ */ new Set();
    p.forEach((ie) => {
      ie.from !== d && ie.from !== m && w.add(ie.from), ie.target !== d && ie.target !== m && w.add(ie.target);
    }), w.forEach((ie) => {
      const fe = {};
      p.forEach((ye) => {
        ye.target === ie && (ye.from === d ? k.has(ie) || (fe[ye.from] || (fe[ye.from] = []), fe[ye.from].push(ye)) : (fe[ye.from] || (fe[ye.from] = []), fe[ye.from].push(ye)));
      }), Object.keys(fe).length > 0 && (Object.keys(fe).forEach((ye) => {
        const Te = /* @__PURE__ */ new Map();
        fe[ye].forEach((N) => {
          const F = N.provider, G = N.feeRate, ee = `${F}_${G}`;
          if (Te.has(ee)) {
            const Z = Te.get(ee);
            Z.amountIn = Ue(Z.amountIn).plus(N.amountIn || "0").toString(), Z.amountOut = Ue(Z.amountOut).plus(N.amountOut || "0").toString();
          } else
            Te.set(ee, {
              ...N,
              amountIn: N.amountIn || "0",
              amountOut: N.amountOut || "0"
            });
        }), fe[ye] = Array.from(Te.values());
      }), g.push({
        target: `1-${ie}`,
        originalTarget: ie,
        list: fe
      }));
    }), g.length > 0 && A.push(g);
    const P = [], ue = {};
    return p.forEach((ie) => {
      ie.target === m && (ue[ie.from] || (ue[ie.from] = []), ue[ie.from].push(ie));
    }), Object.keys(ue).length > 0 && (Object.keys(ue).forEach((ie) => {
      const fe = /* @__PURE__ */ new Map();
      ue[ie].forEach((ye) => {
        const Te = ye.provider, N = ye.feeRate, F = `${Te}_${N}`;
        if (fe.has(F)) {
          const G = fe.get(F);
          G.amountIn = Ue(G.amountIn).plus(ye.amountIn || "0").toString(), G.amountOut = Ue(G.amountOut).plus(ye.amountOut || "0").toString();
        } else
          fe.set(F, {
            ...ye,
            amountIn: ye.amountIn || "0",
            amountOut: ye.amountOut || "0"
          });
      }), ue[ie] = Array.from(fe.values());
    }), P.push({
      target: `2-${m}`,
      originalTarget: m,
      list: ue
    })), P.length > 0 && A.push(P), A;
  }
  function O(p, d, m) {
    var w, P, ue;
    const x = p.length, E = x * Wi + (x - 1) * zl, A = (Qb - E) / 2, j = /* @__PURE__ */ new Map(), k = [], g = /* @__PURE__ */ new Map();
    if (p.forEach((ie, fe) => {
      ie.forEach((ye) => {
        const Te = `${fe}-${ye.target}`, N = L(ye.list);
        g.set(Te, N);
      });
    }), x === 1) {
      const ie = p[0];
      let fe = Zr;
      ie.forEach((ye) => {
        const Te = `0-${ye.target}`, N = g.get(Te) || 0;
        j.set(Te, {
          ...ye,
          id: Te,
          top: fe,
          left: A,
          height: N,
          width: Wi,
          columnIndex: 0
        }), fe += N + Ts;
      }), k.push(ie);
    } else if (x === 2) {
      const ie = p[0], fe = p[1], ye = fe.some((G) => G.list && G.list[d]), Te = ie.map((G) => {
        var Z;
        const ee = ((Z = G.list[d]) == null ? void 0 : Z.reduce(
          (q, he) => q + parseFloat(he.amountIn || "0"),
          0
        )) || 0;
        return { block: G, totalAmountIn: ee };
      }).sort((G, ee) => ee.totalAmountIn - G.totalAmountIn).map(({ block: G }) => G);
      let N = ye ? Zr + Yo : Zr;
      Te.forEach((G) => {
        const ee = `0-${G.target}`, Z = g.get(ee) || 0;
        j.set(ee, {
          ...G,
          id: ee,
          top: N,
          left: A,
          height: Z,
          width: Wi,
          columnIndex: 0
        }), N += Z + Ts;
      });
      let F = Zr;
      fe.forEach((G) => {
        const ee = `1-${G.target}`, Z = g.get(ee) || 0;
        j.set(ee, {
          ...G,
          id: ee,
          top: F,
          left: A + Wi + zl,
          height: Z,
          width: Wi,
          columnIndex: 1
        }), F += Z + Ts;
      }), k.push(Te, fe);
    } else {
      const ie = p[0], fe = p[1], ye = p[2], Te = ((w = ye[0]) == null ? void 0 : w.originalTarget) || ((P = ye[0]) == null ? void 0 : P.target), N = ie.map((de) => {
        var Ot, $t;
        const xe = de.originalTarget || de.target, Oe = `0-${de.target}`, Be = g.get(Oe) || 0, Xe = fe.some((Ge) => Ge.originalTarget == de.originalTarget), Re = (($t = (Ot = ye == null ? void 0 : ye[0]) == null ? void 0 : Ot.list) == null ? void 0 : $t[de == null ? void 0 : de.originalTarget]) && !Xe, He = fe.some((Ge) => {
          const ht = Ge.originalTarget || Ge.target;
          return m.some((ct) => ct.from === xe && ct.target === ht);
        }), rt = [];
        fe.forEach((Ge) => {
          const ht = Ge.originalTarget || Ge.target;
          m.some(
            (ct) => ct.from === xe && ct.target === ht
          ) && rt.push(ht);
        });
        let Qe = 6;
        if (Re && !He)
          Qe = 1;
        else if (Re && He)
          Qe = 2;
        else if (!Re && He)
          if (rt.length === 1) {
            const Ge = rt[0], ht = fe.find((et) => (et.originalTarget || et.target) === Ge);
            (ht ? Object.keys(ht.list || {}).length : 0) === 1 ? Qe = 3 : Qe = 5;
          } else
            rt.every(
              (ht) => {
                const ct = fe.find((st) => (st.originalTarget || st.target) === ht);
                return (ct ? Object.keys(ct.list || {}).length : 0) === 1;
              }
            ) ? Qe = 4 : Qe = 6;
        return {
          block: de,
          target: xe,
          height: Be,
          hasDirectToTarget: Re,
          hasConnectionToSecond: He,
          secondColTargets: rt,
          priority: Qe
        };
      });
      N.sort((de, xe) => {
        var Xe, Re;
        if (de.priority !== xe.priority)
          return de.priority - xe.priority;
        const Oe = ((Xe = de.block.list[d]) == null ? void 0 : Xe.reduce(
          (He, rt) => He + parseFloat(rt.amountIn || "0"),
          0
        )) || 0;
        return (((Re = xe.block.list[d]) == null ? void 0 : Re.reduce(
          (He, rt) => He + parseFloat(rt.amountIn || "0"),
          0
        )) || 0) - Oe;
      });
      const F = ye.some((de) => (de.originalTarget || de.target) === Te && de.list && de.list[d]), G = fe.some((de) => de.list && de.list[d]);
      let ee = F ? Zr + Yo : Zr;
      if (G) {
        const de = fe.find((xe) => xe.list && xe.list[d]);
        if (de)
          if (Object.keys(
            de.list || {}
          ).length === 1) {
            const Oe = `1-${de.target}`, Be = g.get(Oe) || 0;
            ee += Be + Ts;
          } else
            ee += Yo;
      }
      G && N.length > 0 && (N[0].hasDirectToTarget && ee <= Zr + Yo ? ee += 50 : ee += Ts);
      let Z = ee;
      N.forEach((de, xe) => {
        const Oe = `0-${de.block.target}`, Be = g.get(Oe) || 0;
        j.set(Oe, {
          ...de.block,
          id: Oe,
          top: Z,
          left: A,
          height: Be,
          width: Wi,
          columnIndex: 0
        }), xe < N.length - 1 && (Z += Be + Ts);
      });
      const q = [], he = fe.find((de) => de.list && de.list[d]);
      he && q.push(he), N.forEach((de) => {
        de.secondColTargets.forEach((xe) => {
          const Oe = fe.find((Be) => (Be.originalTarget || Be.target) === xe);
          Oe && !q.some((Be) => Be.target === Oe.target) && q.push(Oe);
        });
      }), fe.forEach((de) => {
        const xe = de.originalTarget || de.target;
        q.some(
          (Oe) => (Oe.originalTarget || Oe.target) === xe
        ) || q.push(de);
      });
      let Y = F ? Zr + Yo : Zr;
      N.some((de) => de.hasDirectToTarget && de.hasConnectionToSecond) && (Y += Yo);
      const B = (ue = N.filter((de) => de.hasDirectToTarget && !de.hasConnectionToSecond)) == null ? void 0 : ue.length;
      let se = Y;
      q.forEach((de, xe) => {
        const Oe = `1-${de.target}`, Be = g.get(Oe) || 0;
        xe === 0 && B > 0 && (G ? se += Yo : se += B * 120 + B * Ts), j.set(Oe, {
          ...de,
          id: Oe,
          top: se,
          left: A + Wi + zl,
          height: Be,
          width: Wi,
          columnIndex: 1
        }), se += Be + Ts;
      });
      let me = Zr;
      ye.forEach((de) => {
        const xe = `2-${de.target}`, Oe = g.get(xe) || 0;
        j.set(xe, {
          ...de,
          id: xe,
          top: me,
          left: A + 2 * Wi + 2 * zl,
          height: Oe,
          width: Wi,
          columnIndex: 2
        }), me += Oe + Ts;
      }), k.push(
        N.map((de) => de.block),
        q,
        ye
      );
    }
    return { nodesMap: j, orderedNodeColume: k };
  }
  function I(p, d, m) {
    const x = {}, E = [];
    if (p.forEach((A, j) => {
      A.forEach((k) => {
        const g = k.originalTarget || k.target;
        if (k.list && k.list[m]) {
          const w = k.list[m].reduce(
            (P, ue) => P + parseFloat(ue.amountIn || "0"),
            0
          );
          E.push({
            target: g,
            amountIn: w,
            colIndex: j
          });
        }
      });
    }), E.length > 0) {
      const A = E.reduce(
        (g, w) => g + w.amountIn,
        0
      ), j = [];
      E.forEach(({ amountIn: g }) => {
        const w = A > 0 ? wf(Ue(g).div(A).mul(100).toString(), 0) : 0;
        j.push(Number(w) || 1);
      });
      const k = _f(j);
      E.forEach(({ target: g }, w) => {
        var ue;
        const P = ((ue = k[w]) == null ? void 0 : ue.toString()) || "0";
        x[m] || (x[m] = {}), x[m][g] = { fromPercent: P };
      });
    }
    return p.length > 0 && p[0].forEach((j) => {
      const k = j.originalTarget || j.target, g = `0-${k}`, w = [];
      let P = !1;
      if (p.length > 1 && (P = p[1].some((ie) => (ie.originalTarget || ie.target) === k)), P)
        p[1].forEach((ie) => {
          const fe = ie.originalTarget || ie.target;
          if (ie.list && ie.list[k]) {
            const ye = ie.list[k].reduce(
              (Te, N) => Te + parseFloat(N.amountIn || "0"),
              0
            );
            w.push({
              target: fe,
              amountIn: ye
            });
          }
        });
      else
        for (let ue = 1; ue < p.length; ue++)
          p[ue].forEach((fe) => {
            const ye = fe.originalTarget || fe.target;
            if (fe.list && fe.list[k]) {
              const Te = fe.list[k].reduce(
                (N, F) => N + parseFloat(F.amountIn || "0"),
                0
              );
              w.push({
                target: ye,
                amountIn: Te
              });
            }
          });
      if (w.length > 0) {
        const ue = w.reduce(
          (ye, Te) => ye + Te.amountIn,
          0
        ), ie = [];
        w.forEach(({ amountIn: ye }) => {
          const Te = ue > 0 ? wf(Ue(ye).div(ue).mul(100).toString(), 0) : 0;
          ie.push(Number(Te) || 1);
        });
        const fe = _f(ie);
        w.forEach(({ target: ye }, Te) => {
          const N = fe[Te];
          x[g] || (x[g] = {}), x[g][ye] = {
            fromPercent: N.toString()
          };
        });
      }
    }), p.length > 2 && p[1].forEach((j) => {
      const k = j.originalTarget || j.target, g = `1-${k}`, w = [];
      if (p[2].forEach((ue) => {
        const ie = ue.originalTarget || ue.target;
        if (ue.list && ue.list[k]) {
          const fe = ue.list[k].reduce(
            (ye, Te) => ye + parseFloat(Te.amountIn || "0"),
            0
          );
          w.push({
            target: ie,
            amountIn: fe
          });
        }
      }), w.length > 0) {
        const ue = w.reduce(
          (ye, Te) => ye + Te.amountIn,
          0
        ), ie = [];
        w.forEach(({ amountIn: ye }) => {
          const Te = ue > 0 ? wf(Ue(ye).div(ue).mul(100).toString(), 0) : 0;
          ie.push(Number(Te) || 1);
        });
        const fe = _f(ie);
        w.forEach(({ target: ye }, Te) => {
          const N = fe[Te];
          x[g] || (x[g] = {}), x[g][ye] = {
            fromPercent: N.toString()
          };
        });
      }
    }), x;
  }
  function U(p, d, m) {
    for (const [x, E] of m.entries())
      if (x.startsWith(`${p}-`) && (E.originalTarget === d || E.target === d))
        return E;
    return null;
  }
  function D(p, d, m, x, E) {
    var ue, ie, fe, ye, Te, N;
    const A = [], j = ((ie = (ue = x[x.length - 1]) == null ? void 0 : ue[0]) == null ? void 0 : ie.originalTarget) || ((ye = (fe = x[x.length - 1]) == null ? void 0 : fe[0]) == null ? void 0 : ye.target);
    if (j) {
      const F = U(
        x.length - 1,
        j,
        d
      );
      if (F) {
        const G = ((N = (Te = p[m]) == null ? void 0 : Te[j]) == null ? void 0 : N.fromPercent) || "0";
        x.length > 0 && x[x.length - 1].some((Z) => (Z.originalTarget || Z.target) === j && Z.list && Z.list[m]) && (x.length === 1 && x[0].length === 1 ? A.push({
          from: m,
          to: F.id,
          fromX: qa,
          fromY: F.top + F.height / 2,
          toX: F.left - Gn,
          toY: F.top + F.height / 2,
          fromPercent: G,
          isStart: !0
        }) : A.push({
          from: m,
          to: F.id,
          fromX: qa,
          fromY: Zr + 10,
          toX: F.left - Gn,
          toY: Zr + 10,
          fromPercent: G,
          isStart: !0
        }));
      }
    }
    for (let F = 0; F < x.length; F++)
      x[F].forEach((ee) => {
        var X, B;
        const Z = ee.originalTarget || ee.target, q = U(
          F,
          Z,
          d
        );
        if (!q || !(ee.list && ee.list[m]) || Z === j)
          return;
        const Y = ((B = (X = p[m]) == null ? void 0 : X[Z]) == null ? void 0 : B.fromPercent) || "0";
        x.length > 2 && F === 1 ? Object.keys(ee.list || {}).length === 1 ? A.push({
          from: m,
          to: q.id,
          fromX: qa,
          fromY: q.top + q.height / 2,
          toX: q.left - Gn,
          toY: q.top + q.height / 2,
          fromPercent: Y,
          isStart: !0
        }) : A.push({
          from: m,
          to: q.id,
          fromX: qa,
          fromY: q.top + 10,
          toX: q.left - Gn,
          toY: q.top + 10,
          fromPercent: Y,
          isStart: !0
        }) : A.push({
          from: m,
          to: q.id,
          fromX: qa,
          fromY: q.top + q.height / 2,
          toX: q.left - Gn,
          toY: q.top + q.height / 2,
          fromPercent: Y,
          isStart: !0
        });
      });
    const k = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map();
    for (let F = 0; F < x.length; F++)
      x[F].forEach((ee) => {
        const Z = ee.originalTarget || ee.target;
        if (!U(
          F,
          Z,
          d
        ))
          return;
        const he = ee.list || {};
        Object.entries(he).forEach(
          ([Y, X]) => {
            if (Y === m)
              return;
            let B = null;
            for (let de = F - 1; de >= 0 && (B = U(
              de,
              Y,
              d
            ), !B); de--)
              ;
            if (!B)
              return;
            const se = B.id, me = k.get(se) || 0;
            k.set(se, me + 1);
          }
        );
      });
    for (let F = 0; F < x.length; F++)
      x[F].forEach((ee) => {
        const Z = ee.originalTarget || ee.target, q = U(
          F,
          Z,
          d
        );
        if (!q)
          return;
        const he = ee.list || {};
        Object.entries(he).forEach(
          ([Y, X]) => {
            var Oe, Be, Xe, Re, He, rt, Qe, Ot, $t, Ge, ht, ct, et, st;
            if (Y === m)
              return;
            let B = null;
            for (let yt = F - 1; yt >= 0 && (B = U(
              yt,
              Y,
              d
            ), !B); yt--)
              ;
            if (!B)
              return;
            const se = B.id, me = B.top + B.height / 2;
            let de = !1;
            const xe = g.get(se) || 0;
            if (g.set(se, xe + 1), x.length === 3 && B.columnIndex === 0 && q.columnIndex === 2) {
              const yt = (Oe = x[0]) == null ? void 0 : Oe[0];
              if (yt && (B.originalTarget || B.target) === (yt.originalTarget || yt.target))
                if (x.length > 1 && x[1].some((vt) => vt.list && vt.list[m]))
                  de = !0;
                else {
                  de = !1;
                  const vt = ((Xe = (Be = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : Be[Z]) == null ? void 0 : Xe.fromPercent) || "0";
                  A.push({
                    from: B.id,
                    to: q.id,
                    fromX: B.left + B.width,
                    fromY: B.top + 10,
                    toX: q.left,
                    toY: B.top + 10,
                    fromPercent: vt
                  });
                }
              else if (me >= q.top && me <= q.top + q.height) {
                const it = ((He = (Re = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : Re[Z]) == null ? void 0 : He.fromPercent) || "0";
                A.push({
                  from: B.id,
                  to: q.id,
                  fromX: B.left + B.width,
                  fromY: me,
                  toX: q.left - Gn,
                  toY: me,
                  fromPercent: it
                });
              } else {
                let it = !1;
                for (let vt = B.top; vt <= B.top + B.height; vt += 5)
                  if (vt >= q.top && vt <= q.top + q.height) {
                    const Dt = ((Qe = (rt = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : rt[Z]) == null ? void 0 : Qe.fromPercent) || "0";
                    A.push({
                      from: B.id,
                      to: q.id,
                      fromX: B.left + B.width,
                      fromY: vt,
                      toX: q.left - Gn,
                      toY: vt,
                      fromPercent: Dt
                    }), it = !0;
                    break;
                  }
                it || (de = !0);
              }
            } else if (me >= q.top && me <= q.top + q.height) {
              const yt = (($t = (Ot = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : Ot[Z]) == null ? void 0 : $t.fromPercent) || "0";
              A.push({
                from: B.id,
                to: q.id,
                fromX: B.left + B.width,
                fromY: me,
                toX: q.left,
                toY: me,
                fromPercent: yt
              });
            } else {
              let yt = !1;
              for (let it = B.top; it <= B.top + B.height; it += 5)
                if (it > q.top + 10 && it < q.top + q.height - 10) {
                  const vt = ((ht = (Ge = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : Ge[Z]) == null ? void 0 : ht.fromPercent) || "0";
                  A.push({
                    from: B.id,
                    to: q.id,
                    fromX: B.left + B.width,
                    fromY: it,
                    toX: q.left,
                    toY: it,
                    fromPercent: vt
                  }), yt = !0;
                  break;
                }
              yt || (de = !0);
            }
            if (de) {
              const yt = ((et = (ct = p[`${B.columnIndex}-${B.originalTarget || B.target}`]) == null ? void 0 : ct[Z]) == null ? void 0 : et.fromPercent) || "0", it = k.get(se) || 1, vt = g.get(se) || 0, Dt = 50, pt = B.top + 10, It = B.height - 20, Vt = it > 3 ? Math.min(
                Dt,
                It / Math.max(1, it - 1)
              ) : Dt, Ke = pt + vt * Vt;
              if (x.length === 3 && B.columnIndex === 0 && q.columnIndex === 2) {
                const Rt = (st = x[0]) == null ? void 0 : st[0];
                if (Rt && (B.originalTarget || B.target) === (Rt.originalTarget || Rt.target)) {
                  const zt = B.left + B.width / 2, $ = B.top;
                  A.push({
                    from: B.id,
                    to: q.id,
                    fromX: zt,
                    fromY: $,
                    toX: q.left,
                    toY: Zr + 10,
                    fromPercent: yt,
                    segments: [
                      {
                        x1: zt,
                        y1: $,
                        x2: zt,
                        y2: Zr + 10
                      },
                      {
                        x1: zt,
                        y1: Zr + 10,
                        x2: q.left - Gn,
                        y2: Zr + 10
                      }
                    ]
                  });
                } else
                  q.top > B.top + B.height ? A.push({
                    from: B.id,
                    to: q.id,
                    fromX: B.left + B.width,
                    fromY: Ke,
                    toX: B.left + B.width + Ir,
                    toY: Ke,
                    fromPercent: yt,
                    segments: [
                      {
                        x1: B.left + B.width,
                        y1: Ke,
                        x2: B.left + B.width + Ir,
                        y2: Ke
                      },
                      {
                        x1: B.left + B.width + Ir,
                        y1: Ke,
                        x2: B.left + B.width + Ir,
                        y2: q.top + 20
                      },
                      {
                        x1: B.left + B.width + Ir,
                        y1: q.top + 20,
                        x2: q.left,
                        y2: q.top + 20
                      }
                    ]
                  }) : A.push({
                    from: B.id,
                    to: q.id,
                    fromX: B.left + B.width,
                    fromY: Ke,
                    toX: B.left + B.width + Ir,
                    toY: Ke,
                    fromPercent: yt,
                    segments: [
                      {
                        x1: B.left + B.width,
                        y1: Ke,
                        x2: B.left + B.width + Ir,
                        y2: Ke
                      },
                      {
                        x1: B.left + B.width + Ir,
                        y1: Ke,
                        x2: B.left + B.width + Ir,
                        y2: q.top + q.height - 20
                      },
                      {
                        x1: B.left + B.width + Ir,
                        y1: q.top + q.height - 20,
                        x2: q.left - Gn,
                        y2: q.top + q.height - 20
                      }
                    ]
                  });
              } else
                x.length === 3 && B.columnIndex === 1 && q.columnIndex === 2 && q.top < B.top ? A.push({
                  from: B.id,
                  to: q.id,
                  fromX: B.left + B.width,
                  fromY: Ke,
                  toX: q.left + q.width / 2,
                  toY: Ke,
                  fromPercent: yt,
                  segments: [
                    {
                      x1: B.left + B.width,
                      y1: Ke,
                      x2: q.left + q.width / 2,
                      y2: Ke
                    },
                    {
                      x1: q.left + q.width / 2,
                      y1: Ke,
                      x2: q.left + q.width / 2,
                      y2: q.top + q.height + Gn
                    }
                  ]
                }) : q.top > B.top + B.height ? A.push({
                  from: B.id,
                  to: q.id,
                  fromX: B.left + B.width,
                  fromY: Ke,
                  toX: B.left + B.width + Ir,
                  toY: Ke,
                  fromPercent: yt,
                  segments: [
                    {
                      x1: B.left + B.width,
                      y1: Ke,
                      x2: B.left + B.width + Ir,
                      y2: Ke
                    },
                    {
                      x1: B.left + B.width + Ir,
                      y1: Ke,
                      x2: B.left + B.width + Ir,
                      y2: q.top + 20
                    },
                    {
                      x1: B.left + B.width + Ir,
                      y1: q.top + 20,
                      x2: q.left - Gn,
                      y2: q.top + 20
                    }
                  ]
                }) : A.push({
                  from: B.id,
                  to: q.id,
                  fromX: B.left + B.width,
                  fromY: Ke,
                  toX: B.left + B.width + Ir,
                  toY: Ke,
                  fromPercent: yt,
                  segments: [
                    {
                      x1: B.left + B.width,
                      y1: Ke,
                      x2: B.left + B.width + Ir,
                      y2: Ke
                    },
                    {
                      x1: B.left + B.width + Ir,
                      y1: Ke,
                      x2: B.left + B.width + Ir,
                      y2: q.top + q.height - 20
                    },
                    {
                      x1: B.left + B.width + Ir,
                      y1: q.top + q.height - 20,
                      x2: q.left - Gn,
                      y2: q.top + q.height - 20
                    }
                  ]
                });
            }
          }
        );
      });
    const w = Math.max(
      ...Array.from(d.values()).map((F) => F.columnIndex)
    ), P = Array.from(d.values()).filter(
      (F) => F.columnIndex === w
    );
    if (P.length > 0) {
      const F = P[0], G = F.top + F.height / 2;
      A.push({
        from: F.id,
        to: "final",
        fromX: F.left + F.width,
        fromY: G,
        toX: Qb - qa,
        toY: G,
        fromPercent: "100",
        isFinal: !0
      });
    }
    return { edges: A };
  }
  function H(p) {
    if (p.length === 0)
      return 0;
    let d = 1 / 0, m = -1 / 0;
    return p.forEach((x) => {
      d = Math.min(d, x.top), m = Math.max(m, x.top + x.height);
    }), m - d;
  }
  const z = async () => {
    var ue;
    const p = (ue = e == null ? void 0 : e.routerData) == null ? void 0 : ue.paths;
    if (!p || (p == null ? void 0 : p.length) === 0)
      return;
    const d = pb(
      (f == null ? void 0 : f.coin_type) || t || ""
    ), m = pb(
      (h == null ? void 0 : h.coin_type) || r || ""
    ), x = C(
      p,
      d,
      m,
      3
    ), { nodesMap: E, orderedNodeColume: A } = O(
      x,
      d,
      p
    );
    S(A);
    const j = I(
      A,
      p,
      d
    ), { edges: k } = D(
      j,
      E,
      d,
      A
    ), g = [...E.values()], w = H([...E.values()]) + Zr + 32;
    l(w), o(g), c(k);
    const P = Array.from(
      new Set(
        [...E.values()].map(
          (ie) => ie.originalTarget || ie.target
        )
      )
    );
    ce([...P, d]);
  }, { getTokenListInfo: ne } = $c(), [le, te] = Mt(/* @__PURE__ */ new Map()), ce = async (p) => {
    const d = await ne(p);
    d && (d == null ? void 0 : d.size) > 0 && te(d);
  };
  Bt(() => {
    var p;
    z(), V(((p = e == null ? void 0 : e.routerData) == null ? void 0 : p.paths) || []);
  }, [e]);
  function V(p) {
    if (!Array.isArray(p))
      return [];
    const d = /* @__PURE__ */ new Set();
    p.forEach((m) => {
      m.provider && d.add(m.provider);
    }), b(Array.from(d));
  }
  function L(p) {
    let d = KJ * 2 + YJ;
    const m = Object.entries(p);
    return m.forEach(([x, E], A) => {
      d += XJ * 2, d += JJ, d += 10, E.forEach((j) => {
        d += QJ;
      });
    }), d + ((m == null ? void 0 : m.length) - 1) * ZJ + 10;
  }
  return {
    newFormatSwapRouter: n,
    nodes: s,
    edges: a,
    tokenMap: le,
    panelHeight: u,
    getAllProviders: V,
    allProviders: v,
    resultColumes: y
  };
}
function eZ({ themeType: e }) {
  const t = e == "Light" ? Lt("/images/logo_light@2x.png") : Lt("/images/logo@2x.png");
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        width: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        marginTop: "16px"
      },
      children: [
        /* @__PURE__ */ _.jsx(
          "span",
          {
            style: {
              fontSize: "12px",
              color: "var(--cs-text-primary)",
              fontWeight: "500",
              marginRight: "8px"
            },
            children: "Powered by"
          }
        ),
        /* @__PURE__ */ _.jsx("img", { style: { height: "20px" }, src: t })
      ]
    }
  );
}
function Y1({
  baseToken: e,
  quoteToken: t,
  baseAmount: r,
  quoteAmount: n,
  loading: i,
  fontSize: s = "14px"
}) {
  const [o, a] = Mt(!0), c = G9(o, r, n);
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "current-price-block",
      style: {
        cursor: "pointer"
      },
      onClick: () => {
        a(!o);
      },
      children: [
        /* @__PURE__ */ _.jsx(
          Gr,
          {
            src: o ? e == null ? void 0 : e.logo_url : t == null ? void 0 : t.logo_url,
            token: o ? e : t,
            showWarnSize: "10px"
          }
        ),
        /* @__PURE__ */ _.jsxs(
          "span",
          {
            style: {
              display: "flex",
              alignItems: "center",
              color: "var(--cs-text-primary)",
              fontSize: s,
              maxWidth: "80%"
            },
            children: [
              "1",
              " ",
              sn(o ? e == null ? void 0 : e.symbol : t == null ? void 0 : t.symbol),
              " ",
              "=",
              " ",
              i ? /* @__PURE__ */ _.jsx(
                Ra,
                {
                  className: "custom-skeleton",
                  style: {
                    height: "16px",
                    width: "40px",
                    marginLeft: "2px",
                    marginRight: "2px"
                  }
                }
              ) : jn(c, t == null ? void 0 : t.decimals),
              " ",
              sn(o ? t == null ? void 0 : t.symbol : e == null ? void 0 : e.symbol)
            ]
          }
        ),
        /* @__PURE__ */ _.jsx(
          Gr,
          {
            src: o ? t == null ? void 0 : t.logo_url : e == null ? void 0 : e.logo_url,
            token: o ? t : e,
            showWarnSize: "8px"
          }
        ),
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-swap" }) })
      ]
    }
  );
}
function Bc() {
  const [e, t] = Mt(window.innerWidth), r = K1(() => {
    t(window.innerWidth);
  }, 300);
  Bt(() => (window.addEventListener("resize", r), () => {
    window.removeEventListener("resize", r);
  }), []);
  const n = Ft(() => e < 810, [e]);
  return { windowWidth: e, isApp: n };
}
function xh({
  content: e,
  children: t,
  position: r,
  autoSwitchTooltip: n = !1,
  borderRadius: i = "8px"
}) {
  const { isApp: s } = Bc();
  return s && n ? /* @__PURE__ */ _.jsxs(Us.Root, { children: [
    /* @__PURE__ */ _.jsx(Us.Trigger, { children: /* @__PURE__ */ _.jsx(
      "button",
      {
        style: {
          background: "none",
          border: "none",
          padding: "0",
          margin: "0",
          outline: "none",
          boxShadow: "none",
          color: "inherit",
          font: "inherit",
          textAlign: "inherit"
        },
        children: t
      }
    ) }),
    /* @__PURE__ */ _.jsx(
      Us.Content,
      {
        variant: "soft",
        style: {
          transition: "opacity 0.3s ease",
          display: "block",
          zIndex: 9e3,
          padding: "8px 12px",
          backgroundColor: "var(--cs-bg-primary)",
          color: "var(--cs-text-secondary)",
          borderRadius: i,
          fontSize: "12px",
          whiteSpace: "nowrap",
          border: "1px solid",
          borderColor: "var(--cs-border)",
          boxShadow: "0px 2px 10px rgba(0, 0, 0, 0.1)"
        },
        side: r,
        align: "center",
        children: e
      }
    )
  ] }) : /* @__PURE__ */ _.jsx(Ea, { content: e, position: r, borderRadius: i, children: t });
}
function tZ({
  pr: e = "8px",
  pl: t = "8px",
  value: r,
  isLoading: n
}) {
  const { isApp: i } = Bc();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "swap-info-between",
      style: {
        paddingLeft: t,
        paddingRight: e
      },
      children: [
        /* @__PURE__ */ _.jsxs("div", { className: "left", children: [
          /* @__PURE__ */ _.jsx("span", { children: "Overlay Fee" }),
          /* @__PURE__ */ _.jsx(
            xh,
            {
              autoSwitchTooltip: !0,
              position: "top",
              content: /* @__PURE__ */ _.jsx(
                "div",
                {
                  style: {
                    color: "var(--cs-text-secondary)",
                    fontSize: "12px",
                    lineHeight: "18px",
                    width: i ? "200px" : "280px",
                    textAlign: "start",
                    whiteSpace: "normal"
                  },
                  children: "Fees charged by the integrator, which has been deducted from the output."
                }
              ),
              children: /* @__PURE__ */ _.jsx(
                "svg",
                {
                  className: "cs-icon",
                  "aria-hidden": "true",
                  style: {
                    cursor: "pointer",
                    width: "20px",
                    height: "20px"
                  },
                  children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" })
                }
              )
            }
          )
        ] }),
        n ? /* @__PURE__ */ _.jsx(
          Ra,
          {
            className: "custom-skeleton",
            style: { height: "18px", width: "80px" }
          }
        ) : /* @__PURE__ */ _.jsx("div", { className: "right", children: r ? `${Ue(r).mul(100).toString()}%` : "" })
      ]
    }
  );
}
function J9(e, t, r, n) {
  const { getTokenPrice: i } = Sl(), s = i(e == null ? void 0 : e.coin_type), o = i(t == null ? void 0 : t.coin_type), a = G9(!0, r, n), c = Ft(() => {
    if (o && s)
      return Ue(s.price).div(o.price).toString();
  }, [s == null ? void 0 : s.price, o == null ? void 0 : o.price]), u = Ft(() => {
    if (c && +a)
      return Ue(a).sub(c).div(a).mul(100).toFixed(10);
  }, [c, a]), l = Ft(() => {
    const y = [];
    return s && y.push(s.market), o && !y.includes(o.market) && y.push(o.market), y;
  }, [s == null ? void 0 : s.market, o == null ? void 0 : o.market]), f = Ft(() => !s || !o || s.market === "cetus" || o.market === "cetus", [s, o]), h = Ft(() => f ? !1 : u && Ue(u).lt(0) ? Ue(u).abs().gt(5) : !1, [u, f]), v = Ft(() => f ? !1 : u && Ue(u).lt(0) ? Ue(u).abs().gt(10) : !1, [u, f]), b = Ft(() => {
    let y, S = "yellow";
    if (f)
      return {
        priceImpactText: void 0,
        textColor: "yellow"
      };
    if (u)
      if (Ue(u).gt(0))
        S = "green", Ue(u).lt(0.1) ? y = "< 0.1% cheaper than" : y = `${jn(u, 2, !0, nn.ROUND_UP)}% cheaper than`;
      else if (Ue(u).eq(0))
        y = "0%", S = "green";
      else {
        const C = Ue(u).abs();
        C.lte(5) ? (S = "green", y = `Within ${jn(C.toString(), 2, !0, nn.ROUND_UP)}%`) : C.lte(10) ? (S = "yellow", y = `${jn(C.toString(), 2, !0, nn.ROUND_UP)}% more than`) : C.lte(100) ? (S = "red", y = `${jn(C.toString(), 2, !0, nn.ROUND_UP)}% more than`) : (S = "red", y = "> 100% more than");
      }
    return {
      priceImpactText: y,
      textColor: S
    };
  }, [u, f]);
  return {
    swapPrice: a,
    marketPrice: c,
    priceImpact: u,
    sources: l,
    showPriceImpactTips: h,
    showPriceImpactWarn: v,
    priceImpactTextInfo: b,
    showIncalculable: f
  };
}
function Z9({
  isLoading: e,
  routerData: t,
  noTips: r
}) {
  const { fromCoin: n, toCoin: i, fromAmount: s, toAmount: o } = En();
  Bc();
  const {
    priceImpact: a,
    sources: c,
    marketPrice: u,
    priceImpactTextInfo: l,
    showIncalculable: f
  } = J9(
    n,
    i,
    t == null ? void 0 : t.fromAmountUi,
    t == null ? void 0 : t.toAmountUi
  );
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    !r && Ue(a).lte(-30) && !f && /* @__PURE__ */ _.jsx("div", { className: "price-impact-tips red", children: "High price difference. Be cautious before submitting your order." }),
    /* @__PURE__ */ _.jsxs("div", { className: "price-impact-block", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "left", children: [
        /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-secondary)" }, children: "Price Difference" }),
        /* @__PURE__ */ _.jsx(
          xh,
          {
            autoSwitchTooltip: !0,
            position: "top",
            content: /* @__PURE__ */ _.jsx(
              rZ,
              {
                fromToken: n,
                toToken: i,
                sources: c,
                baseAmount: "1",
                quoteAmount: u,
                showIncalculable: f
              }
            ),
            children: /* @__PURE__ */ _.jsx(
              "svg",
              {
                className: "cs-icon",
                "aria-hidden": "true",
                style: {
                  cursor: "pointer",
                  width: "20px",
                  height: "20px"
                },
                children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" })
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ _.jsxs("div", { children: [
        e && /* @__PURE__ */ _.jsx(
          Ra,
          {
            className: "custom-skeleton",
            style: { width: "80px", height: "20px" }
          }
        ),
        !e && /* @__PURE__ */ _.jsxs("div", { className: "right", children: [
          /* @__PURE__ */ _.jsx("span", { className: l == null ? void 0 : l.textColor, children: l.priceImpactText && !f ? l == null ? void 0 : l.priceImpactText : "Incalculable" }),
          l.priceImpactText && !f && /* @__PURE__ */ _.jsx("div", { className: "platforms", children: c.map((h) => /* @__PURE__ */ _.jsx(
            Ea,
            {
              content: /* @__PURE__ */ _.jsx(
                "span",
                {
                  style: {
                    fontSize: "12px",
                    color: "var(--cs-text-primary)"
                  },
                  children: X5[h]
                }
              ),
              position: "top",
              delay: 300,
              children: /* @__PURE__ */ _.jsx(
                Gr,
                {
                  src: MW[h],
                  haveBorder: !1,
                  style: {
                    width: "16px",
                    height: "16px"
                  }
                }
              )
            },
            h
          )) })
        ] })
      ] })
    ] })
  ] });
}
function rZ({
  fromToken: e,
  toToken: t,
  baseAmount: r,
  quoteAmount: n,
  sources: i,
  showIncalculable: s
}) {
  const { isApp: o } = Bc();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: "8px"
      },
      children: [
        /* @__PURE__ */ _.jsx(
          "p",
          {
            style: {
              color: "var(--cs-text-secondary)",
              fontSize: "12px",
              lineHeight: "18px",
              width: o ? "200px" : "300px",
              textAlign: "start",
              whiteSpace: "normal"
            },
            children: "The difference between the market price and estimated price due to trade size."
          }
        ),
        !s && /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              flexDirection: "column",
              alignItems: "flex-start"
            },
            children: [
              /* @__PURE__ */ _.jsx("p", { style: { fontSize: "12px", color: "var(--cs-text-primary)" }, children: "Market price sources:" }),
              r && n ? /* @__PURE__ */ _.jsx(
                Y1,
                {
                  baseToken: e,
                  quoteToken: t,
                  baseAmount: "1",
                  quoteAmount: n,
                  loading: !1,
                  fontSize: "12px"
                }
              ) : /* @__PURE__ */ _.jsx("p", { style: { color: "var(--cs-text-primary)", fontSize: "12px" }, children: "Price is unknown" })
            ]
          }
        ),
        !s && /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center"
            },
            children: [
              /* @__PURE__ */ _.jsx(
                "p",
                {
                  style: {
                    color: "var(--cs-text-secondary)",
                    fontSize: "12px",
                    whiteSpace: "pre"
                  },
                  children: "Market price sources:"
                }
              ),
              /* @__PURE__ */ _.jsx(
                "p",
                {
                  style: {
                    color: "var(--cs-text-secondary)",
                    fontSize: "12px",
                    whiteSpace: "pre"
                  },
                  children: i.map((a) => X5[a] + "  ").join("")
                }
              )
            ]
          }
        )
      ]
    }
  );
}
function Q9({
  pr: e = "8px",
  pl: t = "8px",
  amountLimit: r,
  isLoading: n
}) {
  const { fromCoin: i, toCoin: s, byAmountIn: o } = En();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "swap-info-between",
      style: {
        paddingLeft: t,
        paddingRight: e
      },
      children: [
        /* @__PURE__ */ _.jsx("div", { className: "left", children: o ? "Minimum Received" : "Maximum Sold" }),
        n ? /* @__PURE__ */ _.jsx(
          Ra,
          {
            className: "custom-skeleton",
            style: { height: "18px", width: "80px" }
          }
        ) : /* @__PURE__ */ _.jsxs("div", { className: "right", children: [
          jn(
            r,
            o ? s == null ? void 0 : s.decimals : i == null ? void 0 : i.decimals,
            !1,
            nn.ROUND_DOWN
          ),
          " ",
          sn(o ? (s == null ? void 0 : s.symbol) || "" : (i == null ? void 0 : i.symbol) || "")
        ] })
      ]
    }
  );
}
function nZ({ scamsText: e }) {
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        marginTop: "16px",
        borderRadius: "8px",
        border: "1px solid var(--cs-border)",
        paddingTop: "12px",
        width: "100%",
        backgroundColor: "var(--cs-bg-secondary-common)"
      },
      children: [
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              padding: "0 12px",
              justifyContent: "center",
              textAlign: "center"
            },
            children: [
              /* @__PURE__ */ _.jsx(
                "svg",
                {
                  className: "cs-icon",
                  style: {
                    width: "20px",
                    height: "20px",
                    fill: "var(--cs-warning)"
                  },
                  "aria-hidden": "true",
                  children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-alert" })
                }
              ),
              /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-warning)", marginLeft: "4px" }, children: "Alert" })
            ]
          }
        ),
        /* @__PURE__ */ _.jsx(
          "div",
          {
            style: {
              borderRadius: "8px",
              padding: "11px",
              margin: "-1px",
              marginTop: "14px",
              border: "1px solid var(--cs-border)",
              lineHeight: "1"
            },
            children: /* @__PURE__ */ _.jsx(
              J5,
              {
                text: `${e} detected to have Deny List feature. It's an optional feature on Sui designed for regulated coins (learn more). However, it could be misused by HoneyPot scams, which may restrict users from selling the tokens after buying. Please be cautious.`,
                keywords: ["learn more"],
                onKeywordClick: (t) => {
                  window.open(
                    "https://docs.sui.io/guides/developer/coin/regulated",
                    "_blank"
                  );
                }
              }
            )
          }
        )
      ]
    }
  );
}
function iZ({ onClick: e }) {
  return /* @__PURE__ */ _.jsxs("div", { className: "cs-icon-button cs-back-button", onClick: (t) => {
    t.stopPropagation(), e();
  }, children: [
    /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-back" }) }),
    /* @__PURE__ */ _.jsx("span", { children: "Back" })
  ] });
}
function X1({
  title: e,
  backClick: t
}) {
  return /* @__PURE__ */ _.jsxs("div", { className: "cs-have-back-header", children: [
    /* @__PURE__ */ _.jsx(iZ, { onClick: t }),
    /* @__PURE__ */ _.jsx("span", { className: "title", children: e })
  ] });
}
const Wl = globalThis || void 0 || self;
var sZ = typeof Wl == "object" && Wl && Wl.Object === Object && Wl;
const eT = sZ;
var oZ = typeof self == "object" && self && self.Object === Object && self, aZ = eT || oZ || Function("return this")();
const ps = aZ;
var cZ = ps.Symbol;
const fs = cZ;
var tT = Object.prototype, uZ = tT.hasOwnProperty, lZ = tT.toString, iu = fs ? fs.toStringTag : void 0;
function fZ(e) {
  var t = uZ.call(e, iu), r = e[iu];
  try {
    e[iu] = void 0;
    var n = !0;
  } catch {
  }
  var i = lZ.call(e);
  return n && (t ? e[iu] = r : delete e[iu]), i;
}
var dZ = Object.prototype, hZ = dZ.toString;
function pZ(e) {
  return hZ.call(e);
}
var mZ = "[object Null]", gZ = "[object Undefined]", ew = fs ? fs.toStringTag : void 0;
function Uc(e) {
  return e == null ? e === void 0 ? gZ : mZ : ew && ew in Object(e) ? fZ(e) : pZ(e);
}
function Lo(e) {
  return e != null && typeof e == "object";
}
var yZ = "[object Symbol]";
function zu(e) {
  return typeof e == "symbol" || Lo(e) && Uc(e) == yZ;
}
function Cf(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var vZ = Array.isArray;
const Ln = vZ;
var bZ = 1 / 0, tw = fs ? fs.prototype : void 0, rw = tw ? tw.toString : void 0;
function rT(e) {
  if (typeof e == "string")
    return e;
  if (Ln(e))
    return Cf(e, rT) + "";
  if (zu(e))
    return rw ? rw.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -bZ ? "-0" : t;
}
function Fc(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function nT(e) {
  return e;
}
var wZ = "[object AsyncFunction]", _Z = "[object Function]", xZ = "[object GeneratorFunction]", SZ = "[object Proxy]";
function iT(e) {
  if (!Fc(e))
    return !1;
  var t = Uc(e);
  return t == _Z || t == xZ || t == wZ || t == SZ;
}
var EZ = ps["__core-js_shared__"];
const Gp = EZ;
var nw = function() {
  var e = /[^.]+$/.exec(Gp && Gp.keys && Gp.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function TZ(e) {
  return !!nw && nw in e;
}
var CZ = Function.prototype, AZ = CZ.toString;
function Pa(e) {
  if (e != null) {
    try {
      return AZ.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var MZ = /[\\^$.*+?()[\]{}|]/g, OZ = /^\[object .+?Constructor\]$/, IZ = Function.prototype, kZ = Object.prototype, jZ = IZ.toString, RZ = kZ.hasOwnProperty, PZ = RegExp(
  "^" + jZ.call(RZ).replace(MZ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function NZ(e) {
  if (!Fc(e) || TZ(e))
    return !1;
  var t = iT(e) ? PZ : OZ;
  return t.test(Pa(e));
}
function $Z(e, t) {
  return e == null ? void 0 : e[t];
}
function Na(e, t) {
  var r = $Z(e, t);
  return NZ(r) ? r : void 0;
}
var DZ = Na(ps, "WeakMap");
const ym = DZ;
var iw = Object.create, LZ = function() {
  function e() {
  }
  return function(t) {
    if (!Fc(t))
      return {};
    if (iw)
      return iw(t);
    e.prototype = t;
    var r = new e();
    return e.prototype = void 0, r;
  };
}();
const BZ = LZ;
function UZ(e, t) {
  var r = -1, n = e.length;
  for (t || (t = Array(n)); ++r < n; )
    t[r] = e[r];
  return t;
}
var FZ = function() {
  try {
    var e = Na(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}();
const sw = FZ;
function VZ(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n && t(e[r], r, e) !== !1; )
    ;
  return e;
}
var zZ = 9007199254740991, WZ = /^(?:0|[1-9]\d*)$/;
function sT(e, t) {
  var r = typeof e;
  return t = t ?? zZ, !!t && (r == "number" || r != "symbol" && WZ.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function oT(e, t, r) {
  t == "__proto__" && sw ? sw(e, t, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : e[t] = r;
}
function J1(e, t) {
  return e === t || e !== e && t !== t;
}
var qZ = Object.prototype, HZ = qZ.hasOwnProperty;
function aT(e, t, r) {
  var n = e[t];
  (!(HZ.call(e, t) && J1(n, r)) || r === void 0 && !(t in e)) && oT(e, t, r);
}
function Sh(e, t, r, n) {
  var i = !r;
  r || (r = {});
  for (var s = -1, o = t.length; ++s < o; ) {
    var a = t[s], c = n ? n(r[a], e[a], a, r, e) : void 0;
    c === void 0 && (c = e[a]), i ? oT(r, a, c) : aT(r, a, c);
  }
  return r;
}
var GZ = 9007199254740991;
function Z1(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= GZ;
}
function Eh(e) {
  return e != null && Z1(e.length) && !iT(e);
}
var KZ = Object.prototype;
function Q1(e) {
  var t = e && e.constructor, r = typeof t == "function" && t.prototype || KZ;
  return e === r;
}
function YZ(e, t) {
  for (var r = -1, n = Array(e); ++r < e; )
    n[r] = t(r);
  return n;
}
var XZ = "[object Arguments]";
function ow(e) {
  return Lo(e) && Uc(e) == XZ;
}
var cT = Object.prototype, JZ = cT.hasOwnProperty, ZZ = cT.propertyIsEnumerable, QZ = ow(function() {
  return arguments;
}()) ? ow : function(e) {
  return Lo(e) && JZ.call(e, "callee") && !ZZ.call(e, "callee");
};
const uT = QZ;
function eQ() {
  return !1;
}
var lT = typeof exports == "object" && exports && !exports.nodeType && exports, aw = lT && typeof module == "object" && module && !module.nodeType && module, tQ = aw && aw.exports === lT, cw = tQ ? ps.Buffer : void 0, rQ = cw ? cw.isBuffer : void 0, nQ = rQ || eQ;
const yd = nQ;
var iQ = "[object Arguments]", sQ = "[object Array]", oQ = "[object Boolean]", aQ = "[object Date]", cQ = "[object Error]", uQ = "[object Function]", lQ = "[object Map]", fQ = "[object Number]", dQ = "[object Object]", hQ = "[object RegExp]", pQ = "[object Set]", mQ = "[object String]", gQ = "[object WeakMap]", yQ = "[object ArrayBuffer]", vQ = "[object DataView]", bQ = "[object Float32Array]", wQ = "[object Float64Array]", _Q = "[object Int8Array]", xQ = "[object Int16Array]", SQ = "[object Int32Array]", EQ = "[object Uint8Array]", TQ = "[object Uint8ClampedArray]", CQ = "[object Uint16Array]", AQ = "[object Uint32Array]", lr = {};
lr[bQ] = lr[wQ] = lr[_Q] = lr[xQ] = lr[SQ] = lr[EQ] = lr[TQ] = lr[CQ] = lr[AQ] = !0;
lr[iQ] = lr[sQ] = lr[yQ] = lr[oQ] = lr[vQ] = lr[aQ] = lr[cQ] = lr[uQ] = lr[lQ] = lr[fQ] = lr[dQ] = lr[hQ] = lr[pQ] = lr[mQ] = lr[gQ] = !1;
function MQ(e) {
  return Lo(e) && Z1(e.length) && !!lr[Uc(e)];
}
function Th(e) {
  return function(t) {
    return e(t);
  };
}
var fT = typeof exports == "object" && exports && !exports.nodeType && exports, _u = fT && typeof module == "object" && module && !module.nodeType && module, OQ = _u && _u.exports === fT, Kp = OQ && eT.process, IQ = function() {
  try {
    var e = _u && _u.require && _u.require("util").types;
    return e || Kp && Kp.binding && Kp.binding("util");
  } catch {
  }
}();
const Sc = IQ;
var uw = Sc && Sc.isTypedArray, kQ = uw ? Th(uw) : MQ;
const dT = kQ;
var jQ = Object.prototype, RQ = jQ.hasOwnProperty;
function hT(e, t) {
  var r = Ln(e), n = !r && uT(e), i = !r && !n && yd(e), s = !r && !n && !i && dT(e), o = r || n || i || s, a = o ? YZ(e.length, String) : [], c = a.length;
  for (var u in e)
    (t || RQ.call(e, u)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    sT(u, c))) && a.push(u);
  return a;
}
function pT(e, t) {
  return function(r) {
    return e(t(r));
  };
}
var PQ = pT(Object.keys, Object);
const NQ = PQ;
var $Q = Object.prototype, DQ = $Q.hasOwnProperty;
function LQ(e) {
  if (!Q1(e))
    return NQ(e);
  var t = [];
  for (var r in Object(e))
    DQ.call(e, r) && r != "constructor" && t.push(r);
  return t;
}
function El(e) {
  return Eh(e) ? hT(e) : LQ(e);
}
function BQ(e) {
  var t = [];
  if (e != null)
    for (var r in Object(e))
      t.push(r);
  return t;
}
var UQ = Object.prototype, FQ = UQ.hasOwnProperty;
function VQ(e) {
  if (!Fc(e))
    return BQ(e);
  var t = Q1(e), r = [];
  for (var n in e)
    n == "constructor" && (t || !FQ.call(e, n)) || r.push(n);
  return r;
}
function ey(e) {
  return Eh(e) ? hT(e, !0) : VQ(e);
}
var zQ = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, WQ = /^\w*$/;
function ty(e, t) {
  if (Ln(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || zu(e) ? !0 : WQ.test(e) || !zQ.test(e) || t != null && e in Object(t);
}
var qQ = Na(Object, "create");
const Wu = qQ;
function HQ() {
  this.__data__ = Wu ? Wu(null) : {}, this.size = 0;
}
function GQ(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var KQ = "__lodash_hash_undefined__", YQ = Object.prototype, XQ = YQ.hasOwnProperty;
function JQ(e) {
  var t = this.__data__;
  if (Wu) {
    var r = t[e];
    return r === KQ ? void 0 : r;
  }
  return XQ.call(t, e) ? t[e] : void 0;
}
var ZQ = Object.prototype, QQ = ZQ.hasOwnProperty;
function eee(e) {
  var t = this.__data__;
  return Wu ? t[e] !== void 0 : QQ.call(t, e);
}
var tee = "__lodash_hash_undefined__";
function ree(e, t) {
  var r = this.__data__;
  return this.size += this.has(e) ? 0 : 1, r[e] = Wu && t === void 0 ? tee : t, this;
}
function Ta(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
Ta.prototype.clear = HQ;
Ta.prototype.delete = GQ;
Ta.prototype.get = JQ;
Ta.prototype.has = eee;
Ta.prototype.set = ree;
function nee() {
  this.__data__ = [], this.size = 0;
}
function Ch(e, t) {
  for (var r = e.length; r--; )
    if (J1(e[r][0], t))
      return r;
  return -1;
}
var iee = Array.prototype, see = iee.splice;
function oee(e) {
  var t = this.__data__, r = Ch(t, e);
  if (r < 0)
    return !1;
  var n = t.length - 1;
  return r == n ? t.pop() : see.call(t, r, 1), --this.size, !0;
}
function aee(e) {
  var t = this.__data__, r = Ch(t, e);
  return r < 0 ? void 0 : t[r][1];
}
function cee(e) {
  return Ch(this.__data__, e) > -1;
}
function uee(e, t) {
  var r = this.__data__, n = Ch(r, e);
  return n < 0 ? (++this.size, r.push([e, t])) : r[n][1] = t, this;
}
function to(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
to.prototype.clear = nee;
to.prototype.delete = oee;
to.prototype.get = aee;
to.prototype.has = cee;
to.prototype.set = uee;
var lee = Na(ps, "Map");
const qu = lee;
function fee() {
  this.size = 0, this.__data__ = {
    hash: new Ta(),
    map: new (qu || to)(),
    string: new Ta()
  };
}
function dee(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Ah(e, t) {
  var r = e.__data__;
  return dee(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
}
function hee(e) {
  var t = Ah(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function pee(e) {
  return Ah(this, e).get(e);
}
function mee(e) {
  return Ah(this, e).has(e);
}
function gee(e, t) {
  var r = Ah(this, e), n = r.size;
  return r.set(e, t), this.size += r.size == n ? 0 : 1, this;
}
function ro(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
ro.prototype.clear = fee;
ro.prototype.delete = hee;
ro.prototype.get = pee;
ro.prototype.has = mee;
ro.prototype.set = gee;
var yee = "Expected a function";
function ry(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(yee);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var o = e.apply(this, n);
    return r.cache = s.set(i, o) || s, o;
  };
  return r.cache = new (ry.Cache || ro)(), r;
}
ry.Cache = ro;
var vee = 500;
function bee(e) {
  var t = ry(e, function(n) {
    return r.size === vee && r.clear(), n;
  }), r = t.cache;
  return t;
}
var wee = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, _ee = /\\(\\)?/g, xee = bee(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(wee, function(r, n, i, s) {
    t.push(i ? s.replace(_ee, "$1") : n || r);
  }), t;
});
const See = xee;
function Eee(e) {
  return e == null ? "" : rT(e);
}
function mT(e, t) {
  return Ln(e) ? e : ty(e, t) ? [e] : See(Eee(e));
}
var Tee = 1 / 0;
function Mh(e) {
  if (typeof e == "string" || zu(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -Tee ? "-0" : t;
}
function ny(e, t) {
  t = mT(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Mh(t[r++])];
  return r && r == n ? e : void 0;
}
function Cee(e, t, r) {
  var n = e == null ? void 0 : ny(e, t);
  return n === void 0 ? r : n;
}
function gT(e, t) {
  for (var r = -1, n = t.length, i = e.length; ++r < n; )
    e[i + r] = t[r];
  return e;
}
var Aee = pT(Object.getPrototypeOf, Object);
const yT = Aee;
function Mee() {
  this.__data__ = new to(), this.size = 0;
}
function Oee(e) {
  var t = this.__data__, r = t.delete(e);
  return this.size = t.size, r;
}
function Iee(e) {
  return this.__data__.get(e);
}
function kee(e) {
  return this.__data__.has(e);
}
var jee = 200;
function Ree(e, t) {
  var r = this.__data__;
  if (r instanceof to) {
    var n = r.__data__;
    if (!qu || n.length < jee - 1)
      return n.push([e, t]), this.size = ++r.size, this;
    r = this.__data__ = new ro(n);
  }
  return r.set(e, t), this.size = r.size, this;
}
function os(e) {
  var t = this.__data__ = new to(e);
  this.size = t.size;
}
os.prototype.clear = Mee;
os.prototype.delete = Oee;
os.prototype.get = Iee;
os.prototype.has = kee;
os.prototype.set = Ree;
function Pee(e, t) {
  return e && Sh(t, El(t), e);
}
function Nee(e, t) {
  return e && Sh(t, ey(t), e);
}
var vT = typeof exports == "object" && exports && !exports.nodeType && exports, lw = vT && typeof module == "object" && module && !module.nodeType && module, $ee = lw && lw.exports === vT, fw = $ee ? ps.Buffer : void 0, dw = fw ? fw.allocUnsafe : void 0;
function Dee(e, t) {
  if (t)
    return e.slice();
  var r = e.length, n = dw ? dw(r) : new e.constructor(r);
  return e.copy(n), n;
}
function bT(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
    var o = e[r];
    t(o, r, e) && (s[i++] = o);
  }
  return s;
}
function wT() {
  return [];
}
var Lee = Object.prototype, Bee = Lee.propertyIsEnumerable, hw = Object.getOwnPropertySymbols, Uee = hw ? function(e) {
  return e == null ? [] : (e = Object(e), bT(hw(e), function(t) {
    return Bee.call(e, t);
  }));
} : wT;
const iy = Uee;
function Fee(e, t) {
  return Sh(e, iy(e), t);
}
var Vee = Object.getOwnPropertySymbols, zee = Vee ? function(e) {
  for (var t = []; e; )
    gT(t, iy(e)), e = yT(e);
  return t;
} : wT;
const _T = zee;
function Wee(e, t) {
  return Sh(e, _T(e), t);
}
function xT(e, t, r) {
  var n = t(e);
  return Ln(e) ? n : gT(n, r(e));
}
function vm(e) {
  return xT(e, El, iy);
}
function qee(e) {
  return xT(e, ey, _T);
}
var Hee = Na(ps, "DataView");
const bm = Hee;
var Gee = Na(ps, "Promise");
const wm = Gee;
var Kee = Na(ps, "Set");
const _m = Kee;
var pw = "[object Map]", Yee = "[object Object]", mw = "[object Promise]", gw = "[object Set]", yw = "[object WeakMap]", vw = "[object DataView]", Xee = Pa(bm), Jee = Pa(qu), Zee = Pa(wm), Qee = Pa(_m), ete = Pa(ym), ta = Uc;
(bm && ta(new bm(new ArrayBuffer(1))) != vw || qu && ta(new qu()) != pw || wm && ta(wm.resolve()) != mw || _m && ta(new _m()) != gw || ym && ta(new ym()) != yw) && (ta = function(e) {
  var t = Uc(e), r = t == Yee ? e.constructor : void 0, n = r ? Pa(r) : "";
  if (n)
    switch (n) {
      case Xee:
        return vw;
      case Jee:
        return pw;
      case Zee:
        return mw;
      case Qee:
        return gw;
      case ete:
        return yw;
    }
  return t;
});
const Hu = ta;
var tte = Object.prototype, rte = tte.hasOwnProperty;
function nte(e) {
  var t = e.length, r = new e.constructor(t);
  return t && typeof e[0] == "string" && rte.call(e, "index") && (r.index = e.index, r.input = e.input), r;
}
var ite = ps.Uint8Array;
const vd = ite;
function sy(e) {
  var t = new e.constructor(e.byteLength);
  return new vd(t).set(new vd(e)), t;
}
function ste(e, t) {
  var r = t ? sy(e.buffer) : e.buffer;
  return new e.constructor(r, e.byteOffset, e.byteLength);
}
var ote = /\w*$/;
function ate(e) {
  var t = new e.constructor(e.source, ote.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var bw = fs ? fs.prototype : void 0, ww = bw ? bw.valueOf : void 0;
function cte(e) {
  return ww ? Object(ww.call(e)) : {};
}
function ute(e, t) {
  var r = t ? sy(e.buffer) : e.buffer;
  return new e.constructor(r, e.byteOffset, e.length);
}
var lte = "[object Boolean]", fte = "[object Date]", dte = "[object Map]", hte = "[object Number]", pte = "[object RegExp]", mte = "[object Set]", gte = "[object String]", yte = "[object Symbol]", vte = "[object ArrayBuffer]", bte = "[object DataView]", wte = "[object Float32Array]", _te = "[object Float64Array]", xte = "[object Int8Array]", Ste = "[object Int16Array]", Ete = "[object Int32Array]", Tte = "[object Uint8Array]", Cte = "[object Uint8ClampedArray]", Ate = "[object Uint16Array]", Mte = "[object Uint32Array]";
function Ote(e, t, r) {
  var n = e.constructor;
  switch (t) {
    case vte:
      return sy(e);
    case lte:
    case fte:
      return new n(+e);
    case bte:
      return ste(e, r);
    case wte:
    case _te:
    case xte:
    case Ste:
    case Ete:
    case Tte:
    case Cte:
    case Ate:
    case Mte:
      return ute(e, r);
    case dte:
      return new n();
    case hte:
    case gte:
      return new n(e);
    case pte:
      return ate(e);
    case mte:
      return new n();
    case yte:
      return cte(e);
  }
}
function Ite(e) {
  return typeof e.constructor == "function" && !Q1(e) ? BZ(yT(e)) : {};
}
var kte = "[object Map]";
function jte(e) {
  return Lo(e) && Hu(e) == kte;
}
var _w = Sc && Sc.isMap, Rte = _w ? Th(_w) : jte;
const Pte = Rte;
var Nte = "[object Set]";
function $te(e) {
  return Lo(e) && Hu(e) == Nte;
}
var xw = Sc && Sc.isSet, Dte = xw ? Th(xw) : $te;
const Lte = Dte;
var Bte = 1, Ute = 2, Fte = 4, ST = "[object Arguments]", Vte = "[object Array]", zte = "[object Boolean]", Wte = "[object Date]", qte = "[object Error]", ET = "[object Function]", Hte = "[object GeneratorFunction]", Gte = "[object Map]", Kte = "[object Number]", TT = "[object Object]", Yte = "[object RegExp]", Xte = "[object Set]", Jte = "[object String]", Zte = "[object Symbol]", Qte = "[object WeakMap]", ere = "[object ArrayBuffer]", tre = "[object DataView]", rre = "[object Float32Array]", nre = "[object Float64Array]", ire = "[object Int8Array]", sre = "[object Int16Array]", ore = "[object Int32Array]", are = "[object Uint8Array]", cre = "[object Uint8ClampedArray]", ure = "[object Uint16Array]", lre = "[object Uint32Array]", ir = {};
ir[ST] = ir[Vte] = ir[ere] = ir[tre] = ir[zte] = ir[Wte] = ir[rre] = ir[nre] = ir[ire] = ir[sre] = ir[ore] = ir[Gte] = ir[Kte] = ir[TT] = ir[Yte] = ir[Xte] = ir[Jte] = ir[Zte] = ir[are] = ir[cre] = ir[ure] = ir[lre] = !0;
ir[qte] = ir[ET] = ir[Qte] = !1;
function Af(e, t, r, n, i, s) {
  var o, a = t & Bte, c = t & Ute, u = t & Fte;
  if (r && (o = i ? r(e, n, i, s) : r(e)), o !== void 0)
    return o;
  if (!Fc(e))
    return e;
  var l = Ln(e);
  if (l) {
    if (o = nte(e), !a)
      return UZ(e, o);
  } else {
    var f = Hu(e), h = f == ET || f == Hte;
    if (yd(e))
      return Dee(e, a);
    if (f == TT || f == ST || h && !i) {
      if (o = c || h ? {} : Ite(e), !a)
        return c ? Wee(e, Nee(o, e)) : Fee(e, Pee(o, e));
    } else {
      if (!ir[f])
        return i ? e : {};
      o = Ote(e, f, a);
    }
  }
  s || (s = new os());
  var v = s.get(e);
  if (v)
    return v;
  s.set(e, o), Lte(e) ? e.forEach(function(S) {
    o.add(Af(S, t, r, S, e, s));
  }) : Pte(e) && e.forEach(function(S, C) {
    o.set(C, Af(S, t, r, C, e, s));
  });
  var b = u ? c ? qee : vm : c ? ey : El, y = l ? void 0 : b(e);
  return VZ(y || e, function(S, C) {
    y && (C = S, S = e[C]), aT(o, C, Af(S, t, r, C, e, s));
  }), o;
}
var fre = 1, dre = 4;
function hre(e) {
  return Af(e, fre | dre);
}
var pre = "__lodash_hash_undefined__";
function mre(e) {
  return this.__data__.set(e, pre), this;
}
function gre(e) {
  return this.__data__.has(e);
}
function bd(e) {
  var t = -1, r = e == null ? 0 : e.length;
  for (this.__data__ = new ro(); ++t < r; )
    this.add(e[t]);
}
bd.prototype.add = bd.prototype.push = mre;
bd.prototype.has = gre;
function yre(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
    if (t(e[r], r, e))
      return !0;
  return !1;
}
function vre(e, t) {
  return e.has(t);
}
var bre = 1, wre = 2;
function CT(e, t, r, n, i, s) {
  var o = r & bre, a = e.length, c = t.length;
  if (a != c && !(o && c > a))
    return !1;
  var u = s.get(e), l = s.get(t);
  if (u && l)
    return u == t && l == e;
  var f = -1, h = !0, v = r & wre ? new bd() : void 0;
  for (s.set(e, t), s.set(t, e); ++f < a; ) {
    var b = e[f], y = t[f];
    if (n)
      var S = o ? n(y, b, f, t, e, s) : n(b, y, f, e, t, s);
    if (S !== void 0) {
      if (S)
        continue;
      h = !1;
      break;
    }
    if (v) {
      if (!yre(t, function(C, O) {
        if (!vre(v, O) && (b === C || i(b, C, r, n, s)))
          return v.push(O);
      })) {
        h = !1;
        break;
      }
    } else if (!(b === y || i(b, y, r, n, s))) {
      h = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), h;
}
function _re(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n, i) {
    r[++t] = [i, n];
  }), r;
}
function xre(e) {
  var t = -1, r = Array(e.size);
  return e.forEach(function(n) {
    r[++t] = n;
  }), r;
}
var Sre = 1, Ere = 2, Tre = "[object Boolean]", Cre = "[object Date]", Are = "[object Error]", Mre = "[object Map]", Ore = "[object Number]", Ire = "[object RegExp]", kre = "[object Set]", jre = "[object String]", Rre = "[object Symbol]", Pre = "[object ArrayBuffer]", Nre = "[object DataView]", Sw = fs ? fs.prototype : void 0, Yp = Sw ? Sw.valueOf : void 0;
function $re(e, t, r, n, i, s, o) {
  switch (r) {
    case Nre:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case Pre:
      return !(e.byteLength != t.byteLength || !s(new vd(e), new vd(t)));
    case Tre:
    case Cre:
    case Ore:
      return J1(+e, +t);
    case Are:
      return e.name == t.name && e.message == t.message;
    case Ire:
    case jre:
      return e == t + "";
    case Mre:
      var a = _re;
    case kre:
      var c = n & Sre;
      if (a || (a = xre), e.size != t.size && !c)
        return !1;
      var u = o.get(e);
      if (u)
        return u == t;
      n |= Ere, o.set(e, t);
      var l = CT(a(e), a(t), n, i, s, o);
      return o.delete(e), l;
    case Rre:
      if (Yp)
        return Yp.call(e) == Yp.call(t);
  }
  return !1;
}
var Dre = 1, Lre = Object.prototype, Bre = Lre.hasOwnProperty;
function Ure(e, t, r, n, i, s) {
  var o = r & Dre, a = vm(e), c = a.length, u = vm(t), l = u.length;
  if (c != l && !o)
    return !1;
  for (var f = c; f--; ) {
    var h = a[f];
    if (!(o ? h in t : Bre.call(t, h)))
      return !1;
  }
  var v = s.get(e), b = s.get(t);
  if (v && b)
    return v == t && b == e;
  var y = !0;
  s.set(e, t), s.set(t, e);
  for (var S = o; ++f < c; ) {
    h = a[f];
    var C = e[h], O = t[h];
    if (n)
      var I = o ? n(O, C, h, t, e, s) : n(C, O, h, e, t, s);
    if (!(I === void 0 ? C === O || i(C, O, r, n, s) : I)) {
      y = !1;
      break;
    }
    S || (S = h == "constructor");
  }
  if (y && !S) {
    var U = e.constructor, D = t.constructor;
    U != D && "constructor" in e && "constructor" in t && !(typeof U == "function" && U instanceof U && typeof D == "function" && D instanceof D) && (y = !1);
  }
  return s.delete(e), s.delete(t), y;
}
var Fre = 1, Ew = "[object Arguments]", Tw = "[object Array]", ql = "[object Object]", Vre = Object.prototype, Cw = Vre.hasOwnProperty;
function zre(e, t, r, n, i, s) {
  var o = Ln(e), a = Ln(t), c = o ? Tw : Hu(e), u = a ? Tw : Hu(t);
  c = c == Ew ? ql : c, u = u == Ew ? ql : u;
  var l = c == ql, f = u == ql, h = c == u;
  if (h && yd(e)) {
    if (!yd(t))
      return !1;
    o = !0, l = !1;
  }
  if (h && !l)
    return s || (s = new os()), o || dT(e) ? CT(e, t, r, n, i, s) : $re(e, t, c, r, n, i, s);
  if (!(r & Fre)) {
    var v = l && Cw.call(e, "__wrapped__"), b = f && Cw.call(t, "__wrapped__");
    if (v || b) {
      var y = v ? e.value() : e, S = b ? t.value() : t;
      return s || (s = new os()), i(y, S, r, n, s);
    }
  }
  return h ? (s || (s = new os()), Ure(e, t, r, n, i, s)) : !1;
}
function Oh(e, t, r, n, i) {
  return e === t ? !0 : e == null || t == null || !Lo(e) && !Lo(t) ? e !== e && t !== t : zre(e, t, r, n, Oh, i);
}
var Wre = 1, qre = 2;
function Hre(e, t, r, n) {
  var i = r.length, s = i, o = !n;
  if (e == null)
    return !s;
  for (e = Object(e); i--; ) {
    var a = r[i];
    if (o && a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++i < s; ) {
    a = r[i];
    var c = a[0], u = e[c], l = a[1];
    if (o && a[2]) {
      if (u === void 0 && !(c in e))
        return !1;
    } else {
      var f = new os();
      if (n)
        var h = n(u, l, c, e, t, f);
      if (!(h === void 0 ? Oh(l, u, Wre | qre, n, f) : h))
        return !1;
    }
  }
  return !0;
}
function AT(e) {
  return e === e && !Fc(e);
}
function Gre(e) {
  for (var t = El(e), r = t.length; r--; ) {
    var n = t[r], i = e[n];
    t[r] = [n, i, AT(i)];
  }
  return t;
}
function MT(e, t) {
  return function(r) {
    return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
function Kre(e) {
  var t = Gre(e);
  return t.length == 1 && t[0][2] ? MT(t[0][0], t[0][1]) : function(r) {
    return r === e || Hre(r, e, t);
  };
}
function Yre(e, t) {
  return e != null && t in Object(e);
}
function Xre(e, t, r) {
  t = mT(t, e);
  for (var n = -1, i = t.length, s = !1; ++n < i; ) {
    var o = Mh(t[n]);
    if (!(s = e != null && r(e, o)))
      break;
    e = e[o];
  }
  return s || ++n != i ? s : (i = e == null ? 0 : e.length, !!i && Z1(i) && sT(o, i) && (Ln(e) || uT(e)));
}
function Jre(e, t) {
  return e != null && Xre(e, t, Yre);
}
var Zre = 1, Qre = 2;
function ene(e, t) {
  return ty(e) && AT(t) ? MT(Mh(e), t) : function(r) {
    var n = Cee(r, e);
    return n === void 0 && n === t ? Jre(r, e) : Oh(t, n, Zre | Qre);
  };
}
function tne(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function rne(e) {
  return function(t) {
    return ny(t, e);
  };
}
function nne(e) {
  return ty(e) ? tne(Mh(e)) : rne(e);
}
function OT(e) {
  return typeof e == "function" ? e : e == null ? nT : typeof e == "object" ? Ln(e) ? ene(e[0], e[1]) : Kre(e) : nne(e);
}
function ine(e) {
  return function(t, r, n) {
    for (var i = -1, s = Object(t), o = n(t), a = o.length; a--; ) {
      var c = o[e ? a : ++i];
      if (r(s[c], c, s) === !1)
        break;
    }
    return t;
  };
}
var sne = ine();
const one = sne;
function ane(e, t) {
  return e && one(e, t, El);
}
function cne(e, t) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!Eh(r))
      return e(r, n);
    for (var i = r.length, s = t ? i : -1, o = Object(r); (t ? s-- : ++s < i) && n(o[s], s, o) !== !1; )
      ;
    return r;
  };
}
var une = cne(ane);
const IT = une;
function lne(e, t) {
  var r = [];
  return IT(e, function(n, i, s) {
    t(n, i, s) && r.push(n);
  }), r;
}
function fne(e, t) {
  var r = Ln(e) ? bT : lne;
  return r(e, OT(t));
}
function dne(e, t) {
  var r = -1, n = Eh(e) ? Array(e.length) : [];
  return IT(e, function(i, s, o) {
    n[++r] = t(i, s, o);
  }), n;
}
function hne(e, t) {
  return Oh(e, t);
}
function pne(e, t) {
  var r = e.length;
  for (e.sort(t); r--; )
    e[r] = e[r].value;
  return e;
}
function mne(e, t) {
  if (e !== t) {
    var r = e !== void 0, n = e === null, i = e === e, s = zu(e), o = t !== void 0, a = t === null, c = t === t, u = zu(t);
    if (!a && !u && !s && e > t || s && o && c && !a && !u || n && o && c || !r && c || !i)
      return 1;
    if (!n && !s && !u && e < t || u && r && i && !n && !s || a && r && i || !o && i || !c)
      return -1;
  }
  return 0;
}
function gne(e, t, r) {
  for (var n = -1, i = e.criteria, s = t.criteria, o = i.length, a = r.length; ++n < o; ) {
    var c = mne(i[n], s[n]);
    if (c) {
      if (n >= a)
        return c;
      var u = r[n];
      return c * (u == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
function yne(e, t, r) {
  t.length ? t = Cf(t, function(s) {
    return Ln(s) ? function(o) {
      return ny(o, s.length === 1 ? s[0] : s);
    } : s;
  }) : t = [nT];
  var n = -1;
  t = Cf(t, Th(OT));
  var i = dne(e, function(s, o, a) {
    var c = Cf(t, function(u) {
      return u(s);
    });
    return { criteria: c, index: ++n, value: s };
  });
  return pne(i, function(s, o) {
    return gne(s, o, r);
  });
}
function vne(e, t, r, n) {
  return e == null ? [] : (Ln(t) || (t = t == null ? [] : [t]), r = n ? void 0 : r, Ln(r) || (r = r == null ? [] : [r]), yne(e, t, r));
}
function bne({
  toBack: e,
  onSubmitClick: t,
  data: r
}) {
  const { fromCoin: n, toCoin: i } = En(), s = Ar(!1), { slippage: o } = Sn(), [a, c] = Mt(r), { fromAmountUi: u, toAmountUi: l, byAmountIn: f } = a, { amountLimit: h } = H9(o, a), { showPriceImpactTips: v, showPriceImpactWarn: b } = J9(
    n,
    i,
    u,
    l
  ), { priceAcceptRouterData: y } = yJ(a), [S, C] = Mt(!1), [O, I] = Mt(!1);
  Ft(() => f ? i : n, [f]);
  const U = Ft(() => y !== void 0, [y]), D = () => {
    if (y) {
      if (s.current)
        return;
      s.current = !0;
      const z = hre(y);
      c(z), setTimeout(() => {
        s.current = !1;
      }, 300);
    }
  }, H = Ft(() => S ? !1 : !!b, [S, b]);
  return /* @__PURE__ */ _.jsxs("div", { className: "secondary-dialog", children: [
    /* @__PURE__ */ _.jsx(X1, { title: "Review your order", backClick: e }),
    /* @__PURE__ */ _.jsxs("div", { className: "secondary-content", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "trade-info", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "amount-info", children: [
          /* @__PURE__ */ _.jsx("span", { className: "amount", children: No(u || "") }),
          /* @__PURE__ */ _.jsx(
            Gr,
            {
              src: n == null ? void 0 : n.logo_url,
              token: n,
              style: {
                width: "28px",
                height: "28px"
              }
            }
          ),
          /* @__PURE__ */ _.jsx("span", { className: "symbol", children: sn((n == null ? void 0 : n.symbol) || "") })
        ] }),
        /* @__PURE__ */ _.jsx("div", { className: "dividing-line", children: /* @__PURE__ */ _.jsx("div", { className: "swap-icon", children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-trade" }) }) }) }),
        /* @__PURE__ */ _.jsxs("div", { className: "amount-info", children: [
          /* @__PURE__ */ _.jsx("span", { className: "amount", children: No(l || "") }),
          /* @__PURE__ */ _.jsx(
            Gr,
            {
              src: i == null ? void 0 : i.logo_url,
              token: i,
              style: {
                width: "28px",
                height: "28px"
              }
            }
          ),
          /* @__PURE__ */ _.jsx("span", { className: "symbol", children: sn((i == null ? void 0 : i.symbol) || "") })
        ] })
      ] }),
      /* @__PURE__ */ _.jsxs(
        "div",
        {
          className: "current-price-tips-box yellow",
          style: {
            fontSize: "12px",
            marginTop: "8px",
            flexDirection: "column",
            justifyContent: "start",
            gap: "10px"
          },
          children: [
            /* @__PURE__ */ _.jsx(
              "div",
              {
                className: "current-price-box",
                style: {
                  backgroundColor: "var(--cs-bg-primary)",
                  marginTop: "-1px"
                },
                children: /* @__PURE__ */ _.jsx(
                  Y1,
                  {
                    baseToken: n,
                    quoteToken: i,
                    baseAmount: u || "0",
                    quoteAmount: l || "0",
                    loading: !1
                  }
                )
              }
            ),
            v && /* @__PURE__ */ _.jsx(
              "div",
              {
                style: {
                  paddingLeft: "8px",
                  paddingBottom: "10px",
                  color: "var(--cs-warning)"
                },
                children: "High price difference. Be cautious before submitting your order."
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ _.jsxs("div", { className: "swap-info-between", style: { marginTop: "16px" }, children: [
        /* @__PURE__ */ _.jsx("div", { className: "left", children: "Slippage Tolerance" }),
        /* @__PURE__ */ _.jsxs("div", { className: "right", children: [
          o,
          "%"
        ] })
      ] }),
      /* @__PURE__ */ _.jsx(
        Q9,
        {
          pl: "0px",
          pr: "0px",
          isLoading: !1,
          amountLimit: h
        }
      ),
      /* @__PURE__ */ _.jsx(Z9, { isLoading: !1, routerData: a, noTips: !0 }),
      b && /* @__PURE__ */ _.jsxs("div", { style: { width: "100%", marginTop: "8px", gap: "1px" }, children: [
        /* @__PURE__ */ _.jsx(
          "div",
          {
            style: {
              width: "100%",
              gap: "8px",
              fontSize: "12px",
              backgroundColor: "var(--cs-error-10)",
              paddingLeft: "16px",
              paddingRight: "16px",
              paddingTop: "8px",
              paddingBottom: "8px",
              borderRadius: "12px",
              color: "var(--cs-error)"
            },
            children: "The exchange rate of this order deviates from the market price by a large percentage. Are you sure you want to continue the swap?"
          }
        ),
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              width: "100%",
              gap: "16px",
              display: "flex",
              flexDirection: "row",
              marginTop: "-10px"
            },
            children: [
              /* @__PURE__ */ _.jsx(
                "button",
                {
                  className: S ? "swap-btn cs-outline-btn secondary-btn ignorePriceImpact-btn" : "swap-btn cs-outline-btn secondary-btn",
                  style: {
                    fontSize: "14px",
                    height: "42px",
                    flex: 1,
                    color: S ? "var(--cs-primary)" : "var(--cs-btn-disabled-text)"
                  },
                  onClick: () => {
                    C(!0);
                  },
                  children: "Yes, please continue."
                }
              ),
              /* @__PURE__ */ _.jsx(
                "button",
                {
                  className: "swap-btn cs-outline-btn secondary-btn",
                  style: {
                    fontSize: "14px",
                    height: "42px",
                    color: "var(--cs-btn-disabled-text)",
                    flex: 1
                  },
                  onClick: () => e(),
                  children: "No,cancel it."
                }
              )
            ]
          }
        )
      ] })
    ] }),
    !U && /* @__PURE__ */ _.jsx(
      "button",
      {
        disabled: H || O,
        className: "swap-btn cs-solid-btn",
        style: { marginTop: "16px" },
        onClick: () => {
          O || (I(!0), t(a));
        },
        children: O ? /* @__PURE__ */ _.jsx(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "center"
            },
            children: /* @__PURE__ */ _.jsx(g1, {})
          }
        ) : "Confirm Swap"
      }
    ),
    U && /* @__PURE__ */ _.jsxs("div", { className: "price-update", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "left", children: [
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-alert" }) }),
        /* @__PURE__ */ _.jsx("span", { children: "Price update" })
      ] }),
      /* @__PURE__ */ _.jsx("div", { className: "right", children: /* @__PURE__ */ _.jsx("button", { className: "cs-solid-btn", onClick: D, children: "Accept" }) })
    ] })
  ] });
}
function kT({ allProviders: e }) {
  const { isApp: t } = Bc();
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: e == null ? void 0 : e.map((r) => {
    var n;
    return t ? /* @__PURE__ */ _.jsx(
      Gr,
      {
        src: Wt == null ? void 0 : Wt[r],
        style: { width: "16px", height: "16px" },
        haveBorder: !1
      },
      r
    ) : /* @__PURE__ */ _.jsx(
      Ea,
      {
        content: /* @__PURE__ */ _.jsx("div", { style: { color: "var(--cs-text-primary)" }, children: ((n = om[r]) == null ? void 0 : n.name) || r }),
        position: "top",
        delay: 300,
        children: /* @__PURE__ */ _.jsx(
          Gr,
          {
            src: Wt == null ? void 0 : Wt[r],
            style: { width: "16px", height: "16px" },
            haveBorder: !1
          }
        )
      },
      r
    );
  }) });
}
function Ih(e) {
  const { text: t, type: r, classType: n = "" } = e, [i, s] = Mt(!1), { addCommonToast: o } = Nc(), a = (c) => {
    i || (Qd(c), F9(t, {
      debug: !1,
      message: "message"
    }), o("Copied"), s(!i));
  };
  return Bt(() => {
    i && setTimeout(() => {
      s(!1);
    }, 2e3);
  }, [i]), /* @__PURE__ */ _.jsx(_.Fragment, { children: r === "btn" ? /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: n ? `${n} copy-btn` : "copy-btn",
      onClick: a,
      children: [
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon cs-copy-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: i ? "#icon-sel" : "#icon-icon_copy" }) }),
        /* @__PURE__ */ _.jsx("span", { children: "Copy" })
      ]
    }
  ) : /* @__PURE__ */ _.jsx(
    "svg",
    {
      className: "cs-icon cs-copy-icon",
      "aria-hidden": "true",
      onClick: a,
      children: /* @__PURE__ */ _.jsx("use", { xlinkHref: i ? "#icon-sel" : "#icon-icon_copy" })
    }
  ) });
}
const Ha = 2;
function wne({
  data: e,
  config: t = {},
  originFromCoinType: r,
  originToCoinType: n,
  isWidget: i
}) {
  const { nodes: s, edges: o, tokenMap: a, panelHeight: c, resultColumes: u } = X9(
    e,
    r,
    n
  ), l = Ar(null), f = {
    nodeWidth: 176,
    searchStep: 5,
    nodePadding: 10,
    maxSearchDistance: 50,
    arrowOffset: 5,
    ...t
  }, h = Ft(() => s == null ? void 0 : s.map((v) => {
    var C;
    const b = v.originalTarget || v.target, y = a == null ? void 0 : a.get(b), S = Object.keys(v == null ? void 0 : v.list);
    return {
      ...v,
      targetSymbol: y == null ? void 0 : y.symbol,
      targetImg: y == null ? void 0 : y.logo_url,
      targetIsTrusted: y == null ? void 0 : y.is_trusted,
      fromGroups: (C = Object.values(v == null ? void 0 : v.list)) == null ? void 0 : C.map(
        (O, I) => {
          const U = a == null ? void 0 : a.get(S[I]), D = `${sn((U == null ? void 0 : U.symbol) || "", 8)} > ${sn((y == null ? void 0 : y.symbol) || "", 8)}`, H = O.reduce((te, ce) => te + parseFloat(ce.amountOut || "0"), 0), z = [];
          O.forEach((te) => {
            const ce = parseFloat(te.amountOut || "0"), V = H > 0 ? wf(
              Ue(ce).div(H).mul(100).toString(),
              0
            ) : "0";
            z.push(Number(V) || 1);
          });
          const ne = _f(z);
          return {
            list: O.map((te, ce) => {
              var p;
              const V = ((p = ne[ce]) == null ? void 0 : p.toString()) || "0", L = a == null ? void 0 : a.get(te == null ? void 0 : te.from);
              return {
                ...te,
                percent: V,
                fromLogo: L == null ? void 0 : L.logo_url,
                targetLogo: y == null ? void 0 : y.logo_url,
                fromSymbol: L == null ? void 0 : L.symbol,
                targetSymbol: y == null ? void 0 : y.symbol,
                fromIsTrusted: L == null ? void 0 : L.is_trusted,
                toIsTrusted: y == null ? void 0 : y.is_trusted,
                displayFee: fW(lW(te == null ? void 0 : te.feeRate, 4))
              };
            }).sort((te, ce) => Number(ce == null ? void 0 : ce.percent) - Number(te == null ? void 0 : te.percent)),
            title: D
          };
        }
      )
    };
  }), [s, a, u]);
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        position: "relative",
        width: "878px",
        height: `${c ? `${c}px` : "531px"}`
      },
      ref: l,
      children: [
        /* @__PURE__ */ _.jsx(Sne, { edges: o, nodes: s, config: f }),
        /* @__PURE__ */ _.jsx(Ene, { data: h, isWidget: i })
      ]
    }
  );
}
function _ne(e, t, r, n, i, s, o, a) {
  const c = i + o, u = s + a, l = Math.min(e, r), f = Math.max(e, r), h = Math.min(t, n), v = Math.max(t, n);
  if (f < i || l > c || v < s || h > u)
    return !1;
  if (l >= i && f <= c && h >= s && v <= u)
    return !0;
  if (Math.abs(t - n) < 1e-3)
    return t >= s && t <= u && f >= i && l <= c;
  if (Math.abs(e - r) < 1e-3)
    return e >= i && e <= c && v >= s && h <= u;
  const b = [
    // 
    { x1: i, y1: s, x2: c, y2: s },
    // 
    { x1: i, y1: u, x2: c, y2: u },
    // 
    { x1: i, y1: s, x2: i, y2: u },
    // 
    { x1: c, y1: s, x2: c, y2: u }
  ];
  for (const y of b)
    if (xne(
      e,
      t,
      r,
      n,
      y.x1,
      y.y1,
      y.x2,
      y.y2
    ))
      return !0;
  return !1;
}
function xne(e, t, r, n, i, s, o, a) {
  const c = (e - r) * (s - a) - (t - n) * (i - o);
  if (Math.abs(c) < 1e-3)
    return !1;
  const u = ((e - i) * (s - a) - (t - s) * (i - o)) / c, l = -((e - r) * (t - s) - (t - n) * (e - i)) / c;
  return u >= 0 && u <= 1 && l >= 0 && l <= 1;
}
function Hl(e, t, r, n, i, s = 176, o, a, c = [], u = [], l = {}) {
  const f = l.searchStep || 5, h = l.nodePadding || 10;
  l.maxSearchDistance;
  const v = l.arrowOffset || 5, b = (V, L, p, d) => {
    for (const m of c)
      if (!(a.from === m.id || a.to === m.id) && _ne(
        V,
        L,
        p,
        d,
        m.left,
        m.top,
        m.width,
        m.height
      ))
        return !0;
    return !1;
  }, y = (V) => {
    if (b(e, V, r - v, V))
      return !1;
    const L = S.top, p = S.top + S.height, d = C.top, m = C.top + C.height, x = Math.max(L, d), E = Math.min(p, m);
    return x < E ? V >= x + h && V <= E - h : !1;
  }, S = c.find((V) => V.id === a.from), C = c.find((V) => V.id === a.to);
  if (!S || !C)
    return `M${e},${t} L${r},${t == n ? n : t}`;
  if (o) {
    const V = C.top + C.height / 2;
    return y(V) ? `M${e},${t} L${r - v},${V}` : `M${e},${t} L${r - v},${t}`;
  }
  const O = u.filter((V) => V.from === a.from);
  if (u.filter((V) => V.to === a.to), O.length === 1) {
    const V = S.top + S.height / 2;
    if (y(V))
      return `M${e},${V} L${r - v},${V}`;
  }
  const I = S.top, U = S.top + S.height, D = C.top, H = C.top + C.height, z = Math.max(I, D), ne = Math.min(U, H);
  if (z < ne) {
    for (let V = z + h; V <= ne - h; V += f)
      if (y(V))
        return `M${e},${V} L${r - v},${V}`;
  }
  const le = S.top + S.height / 2, te = C.left + C.width / 2, ce = C.top + C.height;
  if (U - 10 < D) {
    const V = S.left + S.width / 2, L = S.top + S.height, p = C.top + C.height / 2;
    return !b(V, U, V, p) && !b(V, p, r - v, p) ? `M${V},${L} L${V},${U} L${V},${p} L${r - v},${p}` : `M${e},${L} L${te},${L} L${te},${ce}`;
  } else if (I + 10 >= H)
    return `M${e},${le} L${te},${le} L${te},${ce}`;
  return `M${e},${le} L${r},${le}`;
}
function Sne({
  edges: e,
  nodes: t,
  config: r
}) {
  var i, s, o, a;
  const n = Ar(null);
  return /* @__PURE__ */ _.jsxs(
    "svg",
    {
      ref: n,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        pointerEvents: "none",
        zIndex: 1,
        width: "100%",
        height: "100%"
      },
      children: [
        /* @__PURE__ */ _.jsxs("defs", { children: [
          /* @__PURE__ */ _.jsxs("linearGradient", { id: "arrowGradient", x1: "0%", y1: "0%", x2: "100%", y2: "0%", children: [
            /* @__PURE__ */ _.jsx("stop", { offset: "0%", stopColor: "rgba(0, 255, 165, 1)" }),
            /* @__PURE__ */ _.jsx("stop", { offset: "100%", stopColor: "rgba(0, 183, 255, 1)" })
          ] }),
          /* @__PURE__ */ _.jsx(
            "marker",
            {
              id: "arrowhead",
              markerWidth: "5",
              markerHeight: "9",
              refX: "4",
              refY: "3.5",
              orient: "auto",
              children: /* @__PURE__ */ _.jsx(
                "path",
                {
                  d: "M1 1 L4 3.5 L1 6",
                  fill: "none",
                  stroke: "url(#arrowGradient)",
                  strokeWidth: "1",
                  strokeLinecap: "round",
                  strokeLinejoin: "round"
                }
              )
            }
          )
        ] }),
        (() => {
          const c = (e == null ? void 0 : e.filter((h) => h.isStart)) || [], u = c.reduce(
            (h, v) => v.fromY > h.fromY ? v : h,
            c[0]
          ), l = (e == null ? void 0 : e.filter((h) => h.isFinal)) || [], f = l.reduce(
            (h, v) => v.toY > h.toY ? v : h,
            l[0]
          );
          if (u && f) {
            const S = `M 13 8 Q 13 ${u.fromY - 10} ${u.fromX} ${u.fromY}`, C = `M 865 4 L 865 ${f.toY} L ${f.toX} ${f.toY}`;
            return /* @__PURE__ */ _.jsxs("g", { children: [
              /* @__PURE__ */ _.jsx(
                "path",
                {
                  d: S,
                  stroke: "var(--cs-border)",
                  strokeWidth: Ha,
                  fill: "none"
                }
              ),
              /* @__PURE__ */ _.jsx(
                "path",
                {
                  d: C,
                  stroke: "var(--cs-border)",
                  strokeWidth: Ha,
                  fill: "none"
                }
              ),
              /* @__PURE__ */ _.jsx("circle", { cx: 13, cy: 4, r: "4", fill: "#75C8FF" }),
              /* @__PURE__ */ _.jsx(
                "circle",
                {
                  cx: 865,
                  cy: 4,
                  r: "4",
                  fill: "#75C8FF"
                }
              )
            ] });
          }
          return null;
        })(),
        (i = e == null ? void 0 : e.filter((c) => c.isCrossColumnConnection && c.isStart)) == null ? void 0 : i.map((c, u) => {
          let l, f, h;
          if (c.segments && c.segments.length > 0) {
            l = c.segments.map((H, z) => z === 0 ? `M${H.x1},${H.y1} L${H.x2},${H.y2}` : `L${H.x2},${H.y2}`).join(" ");
            const I = c.segments[0], U = I.x2 - I.x1, D = I.y2 - I.y1;
            Math.abs(U) > Math.abs(D) ? (h = (I.y1 + I.y2) / 2, f = I.x1 + 30) : D < 0 ? (h = I.y1 - 16, f = (I.x1 + I.x2) / 2) : (h = I.y1 + 30, f = (I.x1 + I.x2) / 2);
          } else {
            l = Hl(
              c.fromX,
              c.fromY,
              c.toX,
              c.toY,
              c.toBlockHeight,
              r.nodeWidth,
              !!c.isStart,
              c,
              t,
              e,
              r
            );
            const I = l.split(" ");
            let U = c.fromX, D = c.fromY, H = !1;
            if (I.length > 0 && I[0].startsWith("M")) {
              const z = I[0].substring(1).split(",");
              z.length === 2 && (U = parseFloat(z[0]), D = parseFloat(z[1]));
            }
            if (I.length >= 3) {
              const z = I[1], ne = I[2];
              if (z && ne) {
                const le = z.substring(1).split(","), te = ne.substring(1).split(",");
                if (le.length === 2 && te.length === 2) {
                  const ce = parseFloat(le[1]), V = parseFloat(te[1]);
                  ce < V && (H = !0);
                }
              }
            }
            H ? (c.fromPercent && `${c.fromPercent}`, f = U, h = D + 12) : (f = U + 30, h = D);
          }
          const v = c.fromPercent ? `${c.fromPercent}%` : "", b = v.length * 6, y = Math.max(42, b + 10), S = 16, C = f - y / 2, O = h - S / 2;
          return /* @__PURE__ */ _.jsxs("g", { children: [
            /* @__PURE__ */ _.jsx(
              "path",
              {
                d: l,
                stroke: "var(--cs-border)",
                strokeWidth: Ha,
                fill: "none",
                markerEnd: "url(#arrowhead)",
                strokeLinecap: "square",
                strokeLinejoin: "miter"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "rect",
              {
                x: C,
                y: O,
                width: y,
                height: S,
                rx: "4",
                ry: "4",
                fill: "var(--cs-router-percent-bg)"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "text",
              {
                x: f,
                y: O + S / 2 + 0.5,
                fontSize: "10",
                fill: "#00B7FF",
                textAnchor: "middle",
                dominantBaseline: "middle",
                pointerEvents: "auto",
                children: v
              }
            )
          ] }, `cross-${u}`);
        }),
        (s = e == null ? void 0 : e.filter((c) => c.renderOnTop)) == null ? void 0 : s.map((c, u) => {
          let l, f, h;
          if (c.segments && c.segments.length > 0) {
            l = c.segments.map((H, z) => z === 0 ? `M${H.x1},${H.y1} L${H.x2},${H.y2}` : `L${H.x2},${H.y2}`).join(" ");
            const I = c.segments[0], U = I.x2 - I.x1, D = I.y2 - I.y1;
            Math.abs(U) > Math.abs(D) ? (h = (I.y1 + I.y2) / 2, f = I.x1 + 30) : D < 0 ? (h = I.y1 - 16, f = (I.x1 + I.x2) / 2) : (h = I.y1 + 30, f = (I.x1 + I.x2) / 2);
          } else
            l = Hl(
              c.fromX,
              c.fromY,
              c.toX,
              c.toY,
              c.toBlockHeight,
              r.nodeWidth,
              !!c.isStart,
              c,
              t,
              e,
              r
            ), f = (c.fromX + c.toX) / 2, h = (c.fromY + c.toY) / 2;
          const v = c.fromPercent ? `${c.fromPercent}%` : "", b = v.length * 6, y = Math.max(42, b + 10), S = 16, C = f - y / 2, O = h - S / 2;
          return /* @__PURE__ */ _.jsxs("g", { children: [
            /* @__PURE__ */ _.jsx(
              "path",
              {
                d: l,
                stroke: "var(--cs-border)",
                strokeWidth: Ha,
                fill: "none",
                markerEnd: "url(#arrowhead)",
                strokeLinecap: "square",
                strokeLinejoin: "miter"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "rect",
              {
                x: C,
                y: O,
                width: y,
                height: S,
                rx: "4",
                ry: "4",
                fill: "var(--cs-router-percent-bg)"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "text",
              {
                x: f,
                y: O + S / 2 + 0.5,
                fontSize: "10",
                fill: "#00B7FF",
                textAnchor: "middle",
                dominantBaseline: "middle",
                pointerEvents: "auto",
                children: v
              }
            )
          ] }, `cross-other-${u}`);
        }),
        (o = e == null ? void 0 : e.filter(
          (c) => c.isCrossColumnConnection && !c.isStart && !c.renderOnTop
        )) == null ? void 0 : o.map((c, u) => {
          let l, f, h;
          if (c.segments && c.segments.length > 0) {
            l = c.segments.map((H, z) => z === 0 ? `M${H.x1},${H.y1} L${H.x2},${H.y2}` : `L${H.x2},${H.y2}`).join(" ");
            const I = c.segments[0], U = I.x2 - I.x1, D = I.y2 - I.y1;
            Math.abs(U) > Math.abs(D) ? (h = (I.y1 + I.y2) / 2, f = I.x1 + 30) : D < 0 ? (h = I.y1 - 16, f = (I.x1 + I.x2) / 2) : (h = I.y1 + 30, f = (I.x1 + I.x2) / 2);
          } else
            l = Hl(
              c.fromX,
              c.fromY,
              c.toX,
              c.toY,
              c.toBlockHeight,
              r.nodeWidth,
              !!c.isStart,
              c,
              t,
              e,
              r
            ), f = (c.fromX + c.toX) / 2, h = (c.fromY + c.toY) / 2;
          const v = c.fromPercent ? `${c.fromPercent}%` : "", b = v.length * 6, y = Math.max(42, b + 10), S = 16, C = f - y / 2, O = h - S / 2;
          return /* @__PURE__ */ _.jsxs("g", { children: [
            /* @__PURE__ */ _.jsx(
              "path",
              {
                d: l,
                stroke: "var(--cs-border)",
                strokeWidth: Ha,
                fill: "none",
                markerEnd: "url(#arrowhead)",
                strokeLinecap: "square",
                strokeLinejoin: "miter"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "rect",
              {
                x: C,
                y: O,
                width: y,
                height: S,
                rx: "4",
                ry: "4",
                fill: "var(--cs-router-percent-bg)"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "text",
              {
                x: f,
                y: O + S / 2 + 0.5,
                fontSize: "10",
                fill: "#00B7FF",
                textAnchor: "middle",
                dominantBaseline: "middle",
                pointerEvents: "auto",
                children: v
              }
            )
          ] }, `cross-other-${u}`);
        }),
        (a = e == null ? void 0 : e.filter(
          (c) => !c.isCrossColumnConnection && !c.renderOnTop
        )) == null ? void 0 : a.map((c, u) => {
          let l, f, h;
          if (c.segments && c.segments.length > 0) {
            l = c.segments.map((H, z) => z === 0 ? `M${H.x1},${H.y1} L${H.x2},${H.y2}` : `L${H.x2},${H.y2}`).join(" ");
            const I = c.segments[0], U = I.x2 - I.x1, D = I.y2 - I.y1;
            Math.abs(U) > Math.abs(D) ? (h = (I.y1 + I.y2) / 2, f = I.x1 + 30) : D < 0 ? (h = I.y1 - 16, f = (I.x1 + I.x2) / 2) : (h = I.y1 + 30, f = (I.x1 + I.x2) / 2);
          } else {
            l = Hl(
              c.fromX,
              c.fromY,
              c.toX,
              c.toY,
              c.toBlockHeight,
              r.nodeWidth,
              !!c.isStart,
              c,
              t,
              e,
              r
            );
            const I = l.split(" ");
            let U = c.fromX, D = c.fromY, H = !1;
            if (I.length > 0 && I[0].startsWith("M")) {
              const z = I[0].substring(1).split(",");
              z.length === 2 && (U = parseFloat(z[0]), D = parseFloat(z[1]));
            }
            if (I.length >= 3) {
              const z = I[1], ne = I[2];
              if (z && ne) {
                const le = z.substring(1).split(","), te = ne.substring(1).split(",");
                if (le.length === 2 && te.length === 2) {
                  const ce = parseFloat(le[1]), V = parseFloat(te[1]);
                  ce < V && (H = !0);
                }
              }
            }
            H ? (c.fromPercent && `${c.fromPercent}`, f = U, h = D + 12) : (f = U + 30, h = D);
          }
          const v = c.fromPercent ? `${c.fromPercent}%` : "", b = v.length * 6, y = Math.max(42, b + 10), S = 16, C = f - y / 2, O = h - S / 2;
          return /* @__PURE__ */ _.jsxs("g", { children: [
            /* @__PURE__ */ _.jsx(
              "path",
              {
                d: l,
                stroke: "var(--cs-border)",
                strokeWidth: Ha,
                fill: "none",
                markerEnd: "url(#arrowhead)",
                strokeLinecap: "square",
                strokeLinejoin: "miter"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "rect",
              {
                x: C,
                y: O,
                width: y,
                height: S,
                rx: "4",
                ry: "4",
                fill: "var(--cs-router-percent-bg)"
              }
            ),
            /* @__PURE__ */ _.jsx(
              "text",
              {
                x: f,
                y: O + S / 2 + 0.5,
                fontSize: "10",
                fill: "#00B7FF",
                textAnchor: "middle",
                dominantBaseline: "middle",
                pointerEvents: "auto",
                children: v
              }
            )
          ] }, `normal-${u}`);
        })
      ]
    }
  );
}
function Ene({ data: e, isWidget: t }) {
  return /* @__PURE__ */ _.jsx(
    "div",
    {
      style: {
        width: "100%",
        position: "relative",
        height: "100%",
        zIndex: 2
      },
      children: e == null ? void 0 : e.map((r) => /* @__PURE__ */ _.jsx(
        Tne,
        {
          data: r,
          isWidget: t
        },
        r.target
      ))
    }
  );
}
function Tne({ data: e, isWidget: t }) {
  var r;
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        width: "176px",
        padding: "8px",
        background: "--cs-bg-primary",
        borderRadius: "8px",
        border: "1px solid",
        borderColor: "var(--cs-border)",
        position: "absolute",
        left: `${e == null ? void 0 : e.left}px`,
        top: `${(e == null ? void 0 : e.top) + "px"}`
      },
      "data-node-id": e == null ? void 0 : e.target,
      children: [
        /* @__PURE__ */ _.jsx(
          xh,
          {
            autoSwitchTooltip: !0,
            position: "bottom",
            borderRadius: "12px",
            content: /* @__PURE__ */ _.jsx(Mne, { data: e }),
            children: /* @__PURE__ */ _.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  height: "24px"
                },
                children: [
                  /* @__PURE__ */ _.jsx(
                    Gr,
                    {
                      src: e == null ? void 0 : e.targetImg,
                      haveBorder: !1,
                      token: {
                        coin_type: e == null ? void 0 : e.originalTarget,
                        logo_url: e == null ? void 0 : e.targetImg,
                        symbol: e == null ? void 0 : e.targetSymbol,
                        is_trusted: e == null ? void 0 : e.targetIsTrusted
                      },
                      style: { width: "24px", height: "24px", borderRadius: "100%" }
                    }
                  ),
                  /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)" }, children: sn((e == null ? void 0 : e.targetSymbol) || "", 16) })
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ _.jsx("div", { style: { width: "100%", marginTop: "-7.5px", padding: "0px" }, children: (r = e == null ? void 0 : e.fromGroups) == null ? void 0 : r.map((n) => /* @__PURE__ */ _.jsx(Cne, { data: n, isWidget: t }, n.from)) })
      ]
    }
  );
}
function Cne({ data: e, isWidget: t }) {
  var r;
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        padding: "12px 8px",
        background: "var(--cs-primary-10)",
        borderRadius: "8px",
        width: "100%",
        marginTop: "8px"
      },
      children: [
        /* @__PURE__ */ _.jsx(
          "span",
          {
            style: {
              height: "16px",
              fontSize: "14px",
              color: "var(--cs-primary)",
              width: "100%"
            },
            children: e == null ? void 0 : e.title
          }
        ),
        /* @__PURE__ */ _.jsx(
          "div",
          {
            style: {
              width: "100%",
              marginTop: "7px"
            },
            children: (r = e == null ? void 0 : e.list) == null ? void 0 : r.map((n) => {
              var i, s;
              return /* @__PURE__ */ _.jsx(
                xh,
                {
                  position: "bottom",
                  content: /* @__PURE__ */ _.jsx(Ane, { data: n }, n == null ? void 0 : n.id),
                  children: /* @__PURE__ */ _.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        height: "22px",
                        width: "142px",
                        cursor: "pointer",
                        alignItems: "center"
                      },
                      children: [
                        /* @__PURE__ */ _.jsx(
                          Gr,
                          {
                            src: (i = om[n == null ? void 0 : n.provider]) == null ? void 0 : i.logo,
                            haveBorder: !1,
                            style: {
                              width: "16px",
                              height: "16px",
                              borderRadius: "100%"
                            }
                          }
                        ),
                        /* @__PURE__ */ _.jsx(
                          "span",
                          {
                            style: {
                              fontSize: "12px",
                              color: "#7F98A7",
                              marginLeft: "4px",
                              flex: 1
                            },
                            children: (s = om[n == null ? void 0 : n.provider]) == null ? void 0 : s.name
                          }
                        ),
                        /* @__PURE__ */ _.jsxs(
                          "span",
                          {
                            style: {
                              fontSize: "12px",
                              color: "#7F98A7",
                              flex: "1",
                              textAlign: "right"
                            },
                            children: [
                              n == null ? void 0 : n.percent,
                              "%"
                            ]
                          }
                        )
                      ]
                    },
                    n.provider
                  )
                }
              );
            })
          }
        )
      ]
    }
  );
}
function Ane({ data: e }) {
  const { getExplorerUrl: t } = Rc();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        width: "190px",
        display: "flex",
        flexDirection: "column",
        gap: "12px"
      },
      className: "no-close-widget-flag",
      children: [
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              padding: "0",
              gap: "0px"
            },
            children: [
              /* @__PURE__ */ _.jsx(
                Gr,
                {
                  src: e == null ? void 0 : e.fromLogo,
                  showWarnSize: "12px",
                  haveBorder: !1,
                  token: {
                    coin_type: e == null ? void 0 : e.from,
                    logo_url: e == null ? void 0 : e.fromLogo,
                    symbol: e == null ? void 0 : e.fromSymbol,
                    is_trusted: e == null ? void 0 : e.fromIsTrusted
                  },
                  style: {
                    width: "16px",
                    height: "16px",
                    borderRadius: "100%"
                  }
                }
              ),
              /* @__PURE__ */ _.jsx(
                Gr,
                {
                  src: e == null ? void 0 : e.targetLogo,
                  showWarnSize: "12px",
                  haveBorder: !1,
                  token: {
                    coin_type: e == null ? void 0 : e.target,
                    logo_url: e == null ? void 0 : e.targetLogo,
                    symbol: e == null ? void 0 : e.targetSymbol,
                    is_trusted: e == null ? void 0 : e.toIsTrusted
                  },
                  style: {
                    width: "16px",
                    height: "16px",
                    borderRadius: "100%"
                  }
                }
              ),
              /* @__PURE__ */ _.jsxs(
                "span",
                {
                  style: {
                    fontSize: "12px",
                    color: "var(--cs-text-primary)",
                    flex: 1,
                    textAlign: "left",
                    marginLeft: "4px"
                  },
                  children: [
                    sn((e == null ? void 0 : e.fromSymbol) || "", 8),
                    " -",
                    " ",
                    sn((e == null ? void 0 : e.targetSymbol) || "", 8)
                  ]
                }
              ),
              (e == null ? void 0 : e.feeRate) && Number(e == null ? void 0 : e.feeRate) > 0 && /* @__PURE__ */ _.jsx(
                "div",
                {
                  style: {
                    minWidth: "50px",
                    height: "16px",
                    border: "1px solid var(--cs-border)",
                    borderRadius: "12px",
                    padding: "0px 6px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                  },
                  children: /* @__PURE__ */ _.jsx(
                    "span",
                    {
                      style: {
                        fontSize: "12px",
                        lineHeight: "12px",
                        fontWeight: "400",
                        color: "var(--cs-primary)"
                      },
                      children: e.displayFee
                    }
                  )
                }
              )
            ]
          }
        ),
        (e == null ? void 0 : e.id) && /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              width: "100%",
              display: "flex",
              justifyContent: "space-between",
              height: "20px",
              padding: "0"
            },
            children: [
              /* @__PURE__ */ _.jsx("div", { style: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ _.jsx(
                "span",
                {
                  style: { fontSize: "12px", color: "var(--cs-text-secondary)" },
                  children: "Pool"
                }
              ) }),
              /* @__PURE__ */ _.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
                /* @__PURE__ */ _.jsx(
                  "a",
                  {
                    onClick: Qd,
                    href: t(e == null ? void 0 : e.id, "poolAddress"),
                    target: "_blank",
                    style: {
                      textDecoration: "none",
                      color: "var(--cs-text-primary)",
                      marginRight: "4px"
                    },
                    children: xa(e == null ? void 0 : e.id)
                  }
                ),
                /* @__PURE__ */ _.jsx(Ih, { text: (e == null ? void 0 : e.id) || "" })
              ] })
            ]
          }
        )
      ]
    }
  );
}
function Mne({ data: e }) {
  const { getExplorerUrl: t } = Rc();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        width: "100%",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        fontSize: "12px",
        padding: "0px",
        gap: "12px"
      },
      children: [
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              alignItems: "center",
              gap: "8px",
              flexShrink: 0
            },
            children: [
              /* @__PURE__ */ _.jsx(
                Gr,
                {
                  src: e == null ? void 0 : e.targetImg,
                  showWarnSize: "12px",
                  haveBorder: !1,
                  token: {
                    coin_type: e == null ? void 0 : e.originalTarget,
                    logo_url: e == null ? void 0 : e.targetImg,
                    symbol: e == null ? void 0 : e.targetSymbol,
                    is_trusted: e == null ? void 0 : e.targetIsTrusted
                  },
                  style: {
                    width: "20px",
                    height: "20px",
                    borderRadius: "100%"
                  }
                }
              ),
              /* @__PURE__ */ _.jsx("span", { style: { color: "var(--cs-text-primary)", fontSize: "12px" }, children: sn((e == null ? void 0 : e.targetSymbol) || "") })
            ]
          }
        ),
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "row",
              alignItems: "center"
            },
            children: [
              /* @__PURE__ */ _.jsx(
                "a",
                {
                  onClick: Qd,
                  href: t(e == null ? void 0 : e.originalTarget, "coin"),
                  target: "_blank",
                  style: {
                    textDecoration: "none",
                    color: "var(--cs-text-secondary)",
                    marginRight: "4px"
                  },
                  children: xa(e == null ? void 0 : e.originalTarget)
                }
              ),
              /* @__PURE__ */ _.jsx(Ih, { text: (e == null ? void 0 : e.originalTarget) || "" })
            ]
          }
        )
      ]
    }
  );
}
function One({
  toBack: e,
  data: t,
  allProviders: r
}) {
  const { fromCoin: n, toCoin: i, fromAmount: s, toAmount: o } = En();
  return /* @__PURE__ */ _.jsxs("div", { className: "route-dialog", children: [
    /* @__PURE__ */ _.jsx(X1, { title: "Route", backClick: e }),
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        style: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          padding: "0px 16px",
          marginTop: "20px"
        },
        children: [
          /* @__PURE__ */ _.jsx(
            "span",
            {
              style: {
                fontSize: "14px",
                color: "var(--cs-text-secondary)"
              },
              children: "Router"
            }
          ),
          /* @__PURE__ */ _.jsx(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                gap: "2px",
                flexWrap: "wrap",
                justifyContent: "flex-end",
                paddingLeft: "8px"
              },
              children: /* @__PURE__ */ _.jsx(kT, { allProviders: r })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ _.jsx(
      "div",
      {
        style: {
          width: "100%",
          overflow: "auto",
          padding: "16px",
          minHeight: "550px",
          background: "var(--cs-bg-primary)"
        },
        children: /* @__PURE__ */ _.jsxs("div", { style: { width: "876px", marginTop: "16px" }, children: [
          /* @__PURE__ */ _.jsxs(
            "div",
            {
              style: {
                width: "100%",
                height: "100%",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: "16px"
              },
              children: [
                /* @__PURE__ */ _.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ _.jsx(
                    Gr,
                    {
                      src: n == null ? void 0 : n.logo_url,
                      style: {
                        width: "24px",
                        height: "24px"
                      }
                    }
                  ),
                  /* @__PURE__ */ _.jsx(
                    "span",
                    {
                      style: {
                        fontSize: "14px",
                        fontWeight: "500",
                        color: "var(--cs-text-primary)"
                      },
                      children: No(s || "0")
                    }
                  ),
                  /* @__PURE__ */ _.jsx(
                    "span",
                    {
                      style: {
                        fontSize: "14px",
                        fontWeight: "500",
                        color: "var(--cs-text-primary)"
                      },
                      children: n == null ? void 0 : n.symbol
                    }
                  )
                ] }),
                /* @__PURE__ */ _.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
                  /* @__PURE__ */ _.jsx(
                    "span",
                    {
                      style: {
                        fontSize: "14px",
                        fontWeight: "500",
                        color: "var(--cs-text-primary)"
                      },
                      children: No(o || "0")
                    }
                  ),
                  /* @__PURE__ */ _.jsx(
                    "span",
                    {
                      style: {
                        fontSize: "14px",
                        fontWeight: "500",
                        color: "var(--cs-text-primary)"
                      },
                      children: i == null ? void 0 : i.symbol
                    }
                  ),
                  /* @__PURE__ */ _.jsx(
                    Gr,
                    {
                      src: i == null ? void 0 : i.logo_url,
                      style: {
                        width: "24px",
                        height: "24px"
                      }
                    }
                  )
                ] })
              ]
            }
          ),
          /* @__PURE__ */ _.jsx(wne, { data: t })
        ] })
      }
    )
  ] });
}
function Ine({
  hasSubMenu: e,
  data: t,
  isLoading: r,
  allProviders: n
}) {
  const [i, s] = Mt(!1);
  return Bc(), /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "simple-router-block",
      style: {
        paddingLeft: e ? "8px" : "0px",
        paddingRight: e ? "8px" : "0px"
      },
      children: [
        /* @__PURE__ */ _.jsx(
          "div",
          {
            className: "left",
            style: {
              whiteSpace: "nowrap",
              color: e ? "var(--cs-text-secondary)" : "var(--cs-text-primary)",
              paddingRight: "8px"
            },
            children: e ? "Auto Router" : "Route"
          }
        ),
        r ? /* @__PURE__ */ _.jsx(
          Ra,
          {
            className: "custom-skeleton",
            style: { width: "80px", height: "18px" }
          }
        ) : /* @__PURE__ */ _.jsxs(
          "div",
          {
            className: "right",
            onClick: () => {
              s(!0);
            },
            children: [
              /* @__PURE__ */ _.jsx(kT, { allProviders: n }),
              e && /* @__PURE__ */ _.jsx(
                "svg",
                {
                  className: "cs-icon spread-icon",
                  "aria-hidden": "true",
                  style: { width: "16px", height: "16px", flexShrink: 0 },
                  children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-spread" })
                }
              )
            ]
          }
        ),
        i && e && /* @__PURE__ */ _.jsx(
          One,
          {
            data: t,
            toBack: () => s(!1),
            allProviders: n
          }
        )
      ]
    }
  );
}
function jT() {
  const { setCollectTokenMap: e, collectTokenMap: t } = ka(), r = (i) => {
    const s = new Map(t);
    s.get(i.coin_type) ? s.delete(i.coin_type) : s.set(i.coin_type, i), e(s);
  }, n = Ii((i) => t.get(i.coin_type) !== void 0, [t]);
  return {
    handleCollectToken: r,
    isCollectToken: n,
    collectTokenMap: t
  };
}
function kne(e) {
  const { trustedTokenList: t } = Pc(), { tokenBalanceObj: r, currentAccount: n } = Tn(), { coinPriceObj: i } = z9(), { getTokenAmountValue: s } = Sl(), { fetchTokenInfo: o } = $c(), {
    currentTypeTab: a,
    showTokenList: c,
    setShowTokenList: u,
    combineTokenList: l,
    importTokenList: f,
    setComBineTokenList: h,
    setImportToken: v,
    setCurrentImportTokenData: b,
    setImportTokenIsLoading: y,
    currentImportTokenData: S,
    searchInput: C,
    setSearchInput: O,
    importTokenIsLoading: I,
    showTokenListIsLoading: U,
    setCurrentTypeTab: D,
    setCurrentPlatformTab: H
  } = ka(), [z, ne] = Mt(!1);
  Bt(() => {
    t && (t == null ? void 0 : t.length) > 0 && ne(!0);
  }, [t]);
  const [le, te] = Mt(!1);
  Bt(() => {
    lb(i) || te(!0);
  }, [i]);
  const ce = Ar({}), [V, L] = Mt(!1);
  Bt(() => {
    (!lb(r) || !m1(ce.current, r)) && (ce.current = r, L(!0));
  }, [r]);
  const p = Ft(() => (f == null ? void 0 : f.length) > 1 ? f == null ? void 0 : f.map((ue) => {
    const ie = xf(
      r == null ? void 0 : r[ue == null ? void 0 : ue.coin_type],
      ue
    ), fe = ie == null ? void 0 : ie.totalBalanceFormat, ye = Ue(fe).gt("0") ? s(ue == null ? void 0 : ue.coin_type, fe) : "0";
    return {
      ...ue,
      balance: fe,
      rate: ye
    };
  }) : f, [f, r, i]), d = (ue, ie) => {
    const fe = ie && ie.toLocaleLowerCase().trim(), ye = ue.map((N) => {
      let F = 0, G = 0;
      N.symbol.toLowerCase() === fe || N.name.toLowerCase() === fe || N.coin_type.toLowerCase() === fe ? (F = 1e3, G = 2) : N.symbol.toLowerCase().indexOf(fe) > -1 ? (F = 100, G = 0) : N.name.toLowerCase().indexOf(fe) > -1 ? (F = 10, G = 0) : N.coin_type.toLowerCase().indexOf(fe) > -1 ? (F = 1, G = 0) : N.coin_type.toLowerCase() == "0x2::sui::sui" && (G = 1);
      let ee = Array.isArray(N == null ? void 0 : N.coin_priority) ? Number(N.coin_priority[0]) || 0 : Number(N == null ? void 0 : N.coin_priority) || 0;
      return e === N.coin_type && !ie && (G = 12, F = 1e3, ee = 1e4), {
        ...N,
        mark: F,
        sort: G,
        coin_priority_sort: ee,
        rateNumber: Number((N == null ? void 0 : N.rate) || "0"),
        balanceNumber: Number((N == null ? void 0 : N.balance) || "0")
      };
    });
    return vne(
      ye,
      [
        (N) => !ie && e === N.coin_type ? 1 : 0,
        //  token 
        "rateNumber",
        "balanceNumber",
        "sort",
        "mark",
        "coin_priority_sort"
      ],
      ["desc", "desc", "desc", "desc", "desc", "desc"]
    );
  }, m = (ue, ie = !1) => {
    const fe = ie ? ue.trim() : ue.toLowerCase().trim(), ye = ["symbol", "name", "coin_type"];
    return fne(
      fe.length === 0 ? l : [...l, ...p],
      (N) => ye.some((F) => {
        const G = N[F];
        if (typeof G == "string") {
          const ee = ie ? G : G.toLowerCase();
          return F === "coin_type" ? ee.includes(fe) || Hs(ee, !0).includes(
            Hs(fe, !0)
          ) : ee.includes(fe);
        }
        return !1;
      })
    );
  }, x = (ue) => {
    ue || b(void 0);
    const ie = m(ue);
    if ((ie == null ? void 0 : ie.length) === 0) {
      E(ue);
      return;
    } else {
      const fe = d(ie, ue);
      u(fe);
    }
  }, E = async (ue) => {
    y(!0);
    try {
      if (W5(ue)) {
        const ie = ue.trim(), fe = jr(ie).full_address, ye = await o(fe);
        if (!ye) {
          u([]);
          return;
        }
        const Te = xf(
          r == null ? void 0 : r[fe],
          ye
        ), N = (Te == null ? void 0 : Te.totalBalanceFormat) || "0", F = Ue(N).gt("0") ? s(ie, N) : "0", G = {
          ...ye,
          balance: N,
          rate: F
        };
        u([G]), b(G);
      } else {
        u([]);
        return;
      }
    } catch {
      b(void 0), u([]);
      return;
    } finally {
      y(!1);
    }
  }, A = (ue) => {
    if (ue === "Default")
      g("All"), H("All");
    else {
      const ie = d(
        p,
        C
      );
      u(ie);
    }
  }, j = () => {
    if (S) {
      const ue = v(S, !0), ie = d(ue, C);
      u(ie), b(void 0), O("");
    }
  }, k = (ue) => {
    const ie = v(ue, !1), fe = d(ie, C);
    u(fe);
  }, g = (ue) => {
    const ie = ue === "All" ? [...l] : l.filter((ye) => ue == "Native" ? !ye.labels || ye.labels.length == 0 || ye.labels == "Native" : ye.labels && ye.labels.length > 0 && ye.labels[0].toLowerCase() == ue.toLowerCase()), fe = d(ie, C);
    u(fe);
  };
  Bt(() => {
    if (!z || !(t != null && t.length)) {
      h([]);
      return;
    }
    if (!(n != null && n.address))
      h(t);
    else if (n != null && n.address) {
      const ue = [];
      for (const ie of t) {
        const fe = r == null ? void 0 : r[ie == null ? void 0 : ie.coin_type], ye = xf(fe, ie), Te = (ye == null ? void 0 : ye.totalBalanceFormat) || "0", N = (ye == null ? void 0 : ye.displayBalance) || "0", F = Ue(Te).gt("0") ? s(ie == null ? void 0 : ie.coin_type, Te) : "0";
        ue.push({
          ...ie,
          balance: N,
          rate: jn(F, 4, !0)
        });
      }
      h(ue);
    }
  }, [
    z,
    le,
    V,
    n == null ? void 0 : n.address,
    i
  ]);
  const w = Ar([]);
  Bt(() => {
    if ((l == null ? void 0 : l.length) > 0 && !hne(w.current, l)) {
      w.current = l;
      const ue = d(l);
      e ? p.find(
        (fe) => fe.coin_type === e
      ) !== void 0 || a !== "Default" ? (D("Imported"), A("Imported")) : u(S ? [S] : ue) : u(ue);
    }
  }, [l, e]);
  const P = Ft(() => {
    if (a === "Default") {
      if (!U && (c == null ? void 0 : c.length) === 0)
        return !0;
    } else if ((c == null ? void 0 : c.length) === 0 && !I)
      return !0;
    return !1;
  }, [
    C,
    c,
    S,
    I,
    U
  ]);
  return {
    showTokenList: c,
    handleSearch: x,
    handleChangePlatform: g,
    currentImportTokenData: S,
    handleChangeType: A,
    handleImportClick: j,
    handleDeleteImportClick: k,
    isNoData: P
  };
}
function jne({
  tokenList: e,
  onHandleTokenAction: t
}) {
  return /* @__PURE__ */ _.jsx("div", { className: "token-collect-list", children: e.map((r) => /* @__PURE__ */ _.jsx(
    Rne,
    {
      token: r,
      onHandleTokenAction: t
    },
    r.coin_type
  )) });
}
function Rne({
  token: e,
  onHandleTokenAction: t
}) {
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "token-collect-item",
      onClick: () => {
        t(e, "select_token");
      },
      children: [
        /* @__PURE__ */ _.jsx(
          Gr,
          {
            src: e == null ? void 0 : e.logo_url,
            token: e,
            style: { width: "20px", height: "20px" }
          }
        ),
        /* @__PURE__ */ _.jsx("span", { style: { marginLeft: "4px" }, children: e.symbol }),
        /* @__PURE__ */ _.jsx("i", { children: /* @__PURE__ */ _.jsx(
          "svg",
          {
            className: "cs-icon",
            "aria-hidden": "true",
            onClick: (r) => {
              r.stopPropagation(), t(e, "un_collect");
            },
            children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" })
          }
        ) })
      ]
    }
  );
}
function Pne(e) {
  const {
    img: t = "",
    text: r,
    width: n = "100%",
    // height = "auto",
    height: i = "100%",
    padding: s = "20px",
    subItem: o
  } = e;
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: n,
        height: i,
        padding: s,
        boxSizing: "border-box",
        textAlign: "center"
      },
      children: [
        t && /* @__PURE__ */ _.jsx(
          "img",
          {
            src: t,
            alt: "No Data",
            style: {
              width: "160px",
              height: "160px"
            }
          }
        ),
        r && /* @__PURE__ */ _.jsx("div", { style: { color: "var(--cs-text-primary)", fontSize: "14px" }, children: r }),
        o && o
      ]
    }
  );
}
function Nne({
  tabList: e,
  currentTab: t,
  changeTab: r
}) {
  return /* @__PURE__ */ _.jsx("div", { className: "platform-tabs", children: e.map((n) => /* @__PURE__ */ _.jsx(
    "div",
    {
      className: t === n ? "platform-tab-item active" : "platform-tab-item",
      onClick: () => {
        r(n);
      },
      children: n
    },
    n
  )) });
}
var Aw = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function $ne(e, t) {
  return !!(e === t || Aw(e) && Aw(t));
}
function Dne(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var r = 0; r < e.length; r++)
    if (!$ne(e[r], t[r]))
      return !1;
  return !0;
}
function Lne(e, t) {
  t === void 0 && (t = Dne);
  var r = null;
  function n() {
    for (var i = [], s = 0; s < arguments.length; s++)
      i[s] = arguments[s];
    if (r && r.lastThis === this && t(i, r.lastArgs))
      return r.lastResult;
    var o = e.apply(this, i);
    return r = {
      lastResult: o,
      lastArgs: i,
      lastThis: this
    }, o;
  }
  return n.clear = function() {
    r = null;
  }, n;
}
function xm() {
  return xm = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, xm.apply(null, arguments);
}
function Mw(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function Sm(e, t) {
  return Sm = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, Sm(e, t);
}
function Bne(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Sm(e, t);
}
var Ow = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function Une(e, t) {
  return !!(e === t || Ow(e) && Ow(t));
}
function Fne(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var r = 0; r < e.length; r++)
    if (!Une(e[r], t[r]))
      return !1;
  return !0;
}
function Xp(e, t) {
  t === void 0 && (t = Fne);
  var r, n = [], i, s = !1;
  function o() {
    for (var a = [], c = 0; c < arguments.length; c++)
      a[c] = arguments[c];
    return s && r === this && t(a, n) || (i = e.apply(this, a), s = !0, r = this, n = a), i;
  }
  return o;
}
function Iw(e, t) {
  if (e == null)
    return {};
  var r = {};
  for (var n in e)
    if ({}.hasOwnProperty.call(e, n)) {
      if (t.indexOf(n) !== -1)
        continue;
      r[n] = e[n];
    }
  return r;
}
var Vne = typeof performance == "object" && typeof performance.now == "function", kw = Vne ? function() {
  return performance.now();
} : function() {
  return Date.now();
};
function jw(e) {
  cancelAnimationFrame(e.id);
}
function zne(e, t) {
  var r = kw();
  function n() {
    kw() - r >= t ? e.call(null) : i.id = requestAnimationFrame(n);
  }
  var i = {
    id: requestAnimationFrame(n)
  };
  return i;
}
var Jp = -1;
function Rw(e) {
  if (e === void 0 && (e = !1), Jp === -1 || e) {
    var t = document.createElement("div"), r = t.style;
    r.width = "50px", r.height = "50px", r.overflow = "scroll", document.body.appendChild(t), Jp = t.offsetWidth - t.clientWidth, document.body.removeChild(t);
  }
  return Jp;
}
var Ga = null;
function Pw(e) {
  if (e === void 0 && (e = !1), Ga === null || e) {
    var t = document.createElement("div"), r = t.style;
    r.width = "50px", r.height = "50px", r.overflow = "scroll", r.direction = "rtl";
    var n = document.createElement("div"), i = n.style;
    return i.width = "100px", i.height = "100px", t.appendChild(n), document.body.appendChild(t), t.scrollLeft > 0 ? Ga = "positive-descending" : (t.scrollLeft = 1, t.scrollLeft === 0 ? Ga = "negative" : Ga = "positive-ascending"), document.body.removeChild(t), Ga;
  }
  return Ga;
}
Rn.env.NODE_ENV;
var Wne = 150, qne = function(t, r) {
  return t;
}, Mf = null, Of = null;
Rn.env.NODE_ENV !== "production" && typeof window < "u" && typeof window.WeakSet < "u" && (Mf = /* @__PURE__ */ new WeakSet(), Of = /* @__PURE__ */ new WeakSet());
function Hne(e) {
  var t, r = e.getItemOffset, n = e.getEstimatedTotalSize, i = e.getItemSize, s = e.getOffsetForIndexAndAlignment, o = e.getStartIndexForOffset, a = e.getStopIndexForStartIndex, c = e.initInstanceProps, u = e.shouldResetStyleCacheOnItemSizeChange, l = e.validateProps;
  return t = /* @__PURE__ */ function(f) {
    Bne(h, f);
    function h(b) {
      var y;
      return y = f.call(this, b) || this, y._instanceProps = c(y.props, Mw(y)), y._outerRef = void 0, y._resetIsScrollingTimeoutId = null, y.state = {
        instance: Mw(y),
        isScrolling: !1,
        scrollDirection: "forward",
        scrollOffset: typeof y.props.initialScrollOffset == "number" ? y.props.initialScrollOffset : 0,
        scrollUpdateWasRequested: !1
      }, y._callOnItemsRendered = void 0, y._callOnItemsRendered = Xp(function(S, C, O, I) {
        return y.props.onItemsRendered({
          overscanStartIndex: S,
          overscanStopIndex: C,
          visibleStartIndex: O,
          visibleStopIndex: I
        });
      }), y._callOnScroll = void 0, y._callOnScroll = Xp(function(S, C, O) {
        return y.props.onScroll({
          scrollDirection: S,
          scrollOffset: C,
          scrollUpdateWasRequested: O
        });
      }), y._getItemStyle = void 0, y._getItemStyle = function(S) {
        var C = y.props, O = C.direction, I = C.itemSize, U = C.layout, D = y._getItemStyleCache(u && I, u && U, u && O), H;
        if (D.hasOwnProperty(S))
          H = D[S];
        else {
          var z = r(y.props, S, y._instanceProps), ne = i(y.props, S, y._instanceProps), le = O === "horizontal" || U === "horizontal", te = O === "rtl", ce = le ? z : 0;
          D[S] = H = {
            position: "absolute",
            left: te ? void 0 : ce,
            right: te ? ce : void 0,
            top: le ? 0 : z,
            height: le ? "100%" : ne,
            width: le ? ne : "100%"
          };
        }
        return H;
      }, y._getItemStyleCache = void 0, y._getItemStyleCache = Xp(function(S, C, O) {
        return {};
      }), y._onScrollHorizontal = function(S) {
        var C = S.currentTarget, O = C.clientWidth, I = C.scrollLeft, U = C.scrollWidth;
        y.setState(function(D) {
          if (D.scrollOffset === I)
            return null;
          var H = y.props.direction, z = I;
          if (H === "rtl")
            switch (Pw()) {
              case "negative":
                z = -I;
                break;
              case "positive-descending":
                z = U - O - I;
                break;
            }
          return z = Math.max(0, Math.min(z, U - O)), {
            isScrolling: !0,
            scrollDirection: D.scrollOffset < z ? "forward" : "backward",
            scrollOffset: z,
            scrollUpdateWasRequested: !1
          };
        }, y._resetIsScrollingDebounced);
      }, y._onScrollVertical = function(S) {
        var C = S.currentTarget, O = C.clientHeight, I = C.scrollHeight, U = C.scrollTop;
        y.setState(function(D) {
          if (D.scrollOffset === U)
            return null;
          var H = Math.max(0, Math.min(U, I - O));
          return {
            isScrolling: !0,
            scrollDirection: D.scrollOffset < H ? "forward" : "backward",
            scrollOffset: H,
            scrollUpdateWasRequested: !1
          };
        }, y._resetIsScrollingDebounced);
      }, y._outerRefSetter = function(S) {
        var C = y.props.outerRef;
        y._outerRef = S, typeof C == "function" ? C(S) : C != null && typeof C == "object" && C.hasOwnProperty("current") && (C.current = S);
      }, y._resetIsScrollingDebounced = function() {
        y._resetIsScrollingTimeoutId !== null && jw(y._resetIsScrollingTimeoutId), y._resetIsScrollingTimeoutId = zne(y._resetIsScrolling, Wne);
      }, y._resetIsScrolling = function() {
        y._resetIsScrollingTimeoutId = null, y.setState({
          isScrolling: !1
        }, function() {
          y._getItemStyleCache(-1, null);
        });
      }, y;
    }
    h.getDerivedStateFromProps = function(y, S) {
      return Gne(y, S), l(y), null;
    };
    var v = h.prototype;
    return v.scrollTo = function(y) {
      y = Math.max(0, y), this.setState(function(S) {
        return S.scrollOffset === y ? null : {
          scrollDirection: S.scrollOffset < y ? "forward" : "backward",
          scrollOffset: y,
          scrollUpdateWasRequested: !0
        };
      }, this._resetIsScrollingDebounced);
    }, v.scrollToItem = function(y, S) {
      S === void 0 && (S = "auto");
      var C = this.props, O = C.itemCount, I = C.layout, U = this.state.scrollOffset;
      y = Math.max(0, Math.min(y, O - 1));
      var D = 0;
      if (this._outerRef) {
        var H = this._outerRef;
        I === "vertical" ? D = H.scrollWidth > H.clientWidth ? Rw() : 0 : D = H.scrollHeight > H.clientHeight ? Rw() : 0;
      }
      this.scrollTo(s(this.props, y, S, U, this._instanceProps, D));
    }, v.componentDidMount = function() {
      var y = this.props, S = y.direction, C = y.initialScrollOffset, O = y.layout;
      if (typeof C == "number" && this._outerRef != null) {
        var I = this._outerRef;
        S === "horizontal" || O === "horizontal" ? I.scrollLeft = C : I.scrollTop = C;
      }
      this._callPropsCallbacks();
    }, v.componentDidUpdate = function() {
      var y = this.props, S = y.direction, C = y.layout, O = this.state, I = O.scrollOffset, U = O.scrollUpdateWasRequested;
      if (U && this._outerRef != null) {
        var D = this._outerRef;
        if (S === "horizontal" || C === "horizontal")
          if (S === "rtl")
            switch (Pw()) {
              case "negative":
                D.scrollLeft = -I;
                break;
              case "positive-ascending":
                D.scrollLeft = I;
                break;
              default:
                var H = D.clientWidth, z = D.scrollWidth;
                D.scrollLeft = z - H - I;
                break;
            }
          else
            D.scrollLeft = I;
        else
          D.scrollTop = I;
      }
      this._callPropsCallbacks();
    }, v.componentWillUnmount = function() {
      this._resetIsScrollingTimeoutId !== null && jw(this._resetIsScrollingTimeoutId);
    }, v.render = function() {
      var y = this.props, S = y.children, C = y.className, O = y.direction, I = y.height, U = y.innerRef, D = y.innerElementType, H = y.innerTagName, z = y.itemCount, ne = y.itemData, le = y.itemKey, te = le === void 0 ? qne : le, ce = y.layout, V = y.outerElementType, L = y.outerTagName, p = y.style, d = y.useIsScrolling, m = y.width, x = this.state.isScrolling, E = O === "horizontal" || ce === "horizontal", A = E ? this._onScrollHorizontal : this._onScrollVertical, j = this._getRangeToRender(), k = j[0], g = j[1], w = [];
      if (z > 0)
        for (var P = k; P <= g; P++)
          w.push(Ph(S, {
            data: ne,
            key: te(P, ne),
            index: P,
            isScrolling: d ? x : void 0,
            style: this._getItemStyle(P)
          }));
      var ue = n(this.props, this._instanceProps);
      return Ph(V || L || "div", {
        className: C,
        onScroll: A,
        ref: this._outerRefSetter,
        style: xm({
          position: "relative",
          height: I,
          width: m,
          overflow: "auto",
          WebkitOverflowScrolling: "touch",
          willChange: "transform",
          direction: O
        }, p)
      }, Ph(D || H || "div", {
        children: w,
        ref: U,
        style: {
          height: E ? "100%" : ue,
          pointerEvents: x ? "none" : void 0,
          width: E ? ue : "100%"
        }
      }));
    }, v._callPropsCallbacks = function() {
      if (typeof this.props.onItemsRendered == "function") {
        var y = this.props.itemCount;
        if (y > 0) {
          var S = this._getRangeToRender(), C = S[0], O = S[1], I = S[2], U = S[3];
          this._callOnItemsRendered(C, O, I, U);
        }
      }
      if (typeof this.props.onScroll == "function") {
        var D = this.state, H = D.scrollDirection, z = D.scrollOffset, ne = D.scrollUpdateWasRequested;
        this._callOnScroll(H, z, ne);
      }
    }, v._getRangeToRender = function() {
      var y = this.props, S = y.itemCount, C = y.overscanCount, O = this.state, I = O.isScrolling, U = O.scrollDirection, D = O.scrollOffset;
      if (S === 0)
        return [0, 0, 0, 0];
      var H = o(this.props, D, this._instanceProps), z = a(this.props, H, D, this._instanceProps), ne = !I || U === "backward" ? Math.max(1, C) : 1, le = !I || U === "forward" ? Math.max(1, C) : 1;
      return [Math.max(0, H - ne), Math.max(0, Math.min(S - 1, z + le)), H, z];
    }, h;
  }(HT), t.defaultProps = {
    direction: "ltr",
    itemData: void 0,
    layout: "vertical",
    overscanCount: 2,
    useIsScrolling: !1
  }, t;
}
var Gne = function(t, r) {
  var n = t.children, i = t.direction, s = t.height, o = t.layout, a = t.innerTagName, c = t.outerTagName, u = t.width, l = r.instance;
  if (Rn.env.NODE_ENV !== "production") {
    (a != null || c != null) && Of && !Of.has(l) && (Of.add(l), console.warn("The innerTagName and outerTagName props have been deprecated. Please use the innerElementType and outerElementType props instead."));
    var f = i === "horizontal" || o === "horizontal";
    switch (i) {
      case "horizontal":
      case "vertical":
        Mf && !Mf.has(l) && (Mf.add(l), console.warn('The direction prop should be either "ltr" (default) or "rtl". Please use the layout prop to specify "vertical" (default) or "horizontal" orientation.'));
        break;
      case "ltr":
      case "rtl":
        break;
      default:
        throw Error('An invalid "direction" prop has been specified. Value should be either "ltr" or "rtl". ' + ('"' + i + '" was specified.'));
    }
    switch (o) {
      case "horizontal":
      case "vertical":
        break;
      default:
        throw Error('An invalid "layout" prop has been specified. Value should be either "horizontal" or "vertical". ' + ('"' + o + '" was specified.'));
    }
    if (n == null)
      throw Error('An invalid "children" prop has been specified. Value should be a React component. ' + ('"' + (n === null ? "null" : typeof n) + '" was specified.'));
    if (f && typeof u != "number")
      throw Error('An invalid "width" prop has been specified. Horizontal lists must specify a number for width. ' + ('"' + (u === null ? "null" : typeof u) + '" was specified.'));
    if (!f && typeof s != "number")
      throw Error('An invalid "height" prop has been specified. Vertical lists must specify a number for height. ' + ('"' + (s === null ? "null" : typeof s) + '" was specified.'));
  }
}, Kne = /* @__PURE__ */ Hne({
  getItemOffset: function(t, r) {
    var n = t.itemSize;
    return r * n;
  },
  getItemSize: function(t, r) {
    var n = t.itemSize;
    return n;
  },
  getEstimatedTotalSize: function(t) {
    var r = t.itemCount, n = t.itemSize;
    return n * r;
  },
  getOffsetForIndexAndAlignment: function(t, r, n, i, s, o) {
    var a = t.direction, c = t.height, u = t.itemCount, l = t.itemSize, f = t.layout, h = t.width, v = a === "horizontal" || f === "horizontal", b = v ? h : c, y = Math.max(0, u * l - b), S = Math.min(y, r * l), C = Math.max(0, r * l - b + l + o);
    switch (n === "smart" && (i >= C - b && i <= S + b ? n = "auto" : n = "center"), n) {
      case "start":
        return S;
      case "end":
        return C;
      case "center": {
        var O = Math.round(C + (S - C) / 2);
        return O < Math.ceil(b / 2) ? 0 : O > y + Math.floor(b / 2) ? y : O;
      }
      case "auto":
      default:
        return i >= C && i <= S ? i : i < C ? C : S;
    }
  },
  getStartIndexForOffset: function(t, r) {
    var n = t.itemCount, i = t.itemSize;
    return Math.max(0, Math.min(n - 1, Math.floor(r / i)));
  },
  getStopIndexForStartIndex: function(t, r, n) {
    var i = t.direction, s = t.height, o = t.itemCount, a = t.itemSize, c = t.layout, u = t.width, l = i === "horizontal" || c === "horizontal", f = r * a, h = l ? u : s, v = Math.ceil((h + n - f) / a);
    return Math.max(0, Math.min(
      o - 1,
      r + v - 1
      // -1 is because stop index is inclusive
    ));
  },
  initInstanceProps: function(t) {
  },
  shouldResetStyleCacheOnItemSizeChange: !0,
  validateProps: function(t) {
    var r = t.itemSize;
    if (Rn.env.NODE_ENV !== "production" && typeof r != "number")
      throw Error('An invalid "itemSize" prop has been specified. Value should be a number. ' + ('"' + (r === null ? "null" : typeof r) + '" was specified.'));
  }
});
function Nw(e, t) {
  for (var r in e)
    if (!(r in t))
      return !0;
  for (var n in t)
    if (e[n] !== t[n])
      return !0;
  return !1;
}
var Yne = ["style"], Xne = ["style"];
function Jne(e, t) {
  var r = e.style, n = Iw(e, Yne), i = t.style, s = Iw(t, Xne);
  return !Nw(r, i) && !Nw(n, s);
}
const Zne = GT(({ data: e, index: t, style: r }) => {
  const { items: n, onHandleTokenAction: i, showCollect: s, showDelete: o } = e, a = n[t];
  return /* @__PURE__ */ _.jsx("div", { style: r, children: /* @__PURE__ */ _.jsx(
    tie,
    {
      data: a,
      onHandleTokenAction: i,
      showCollect: s,
      showDelete: o
    }
  ) });
}, Jne), Qne = Lne(
  (e, t, r, n) => ({
    items: e,
    onHandleTokenAction: t,
    showCollect: r,
    showDelete: n
  })
);
function eie({
  showTokenList: e,
  onHandleTokenAction: t,
  showCollect: r = !0,
  showDelete: n = !1
}) {
  const i = Ar(null);
  Bt(() => {
    i.current && i.current.scrollTo(0);
  }, [e.length]);
  const s = Qne(
    e,
    t,
    r,
    n
  );
  return /* @__PURE__ */ _.jsx("div", { className: "token-list", children: /* @__PURE__ */ _.jsx(
    Kne,
    {
      ref: i,
      style: {
        overflowY: "scroll",
        scrollbarWidth: "none",
        msOverflowStyle: "none",
        padding: "8px"
      },
      height: 360,
      itemCount: e.length,
      itemData: s,
      itemSize: 72,
      width: "100%",
      children: Zne
    }
  ) });
}
function tie({
  data: e,
  showCollect: t,
  showDelete: r,
  onHandleTokenAction: n
}) {
  const { isCollectToken: i } = jT(), { getExplorerUrl: s } = Rc();
  return Sl(), /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "token-list-item",
      onClick: (o) => {
        t && (o.stopPropagation(), n(e, "select_token"));
      },
      children: [
        /* @__PURE__ */ _.jsx(
          Gr,
          {
            className: "token-img",
            src: e == null ? void 0 : e.logo_url,
            token: e,
            showWarnSize: "16px",
            showWarn: !t
          }
        ),
        /* @__PURE__ */ _.jsxs("div", { className: "token-info", children: [
          /* @__PURE__ */ _.jsx("h4", { className: "token-symbol", children: /* @__PURE__ */ _.jsx("span", { children: sn(e.symbol) }) }),
          /* @__PURE__ */ _.jsx("p", { className: "token-name", children: sn(e == null ? void 0 : e.name, 20) }),
          /* @__PURE__ */ _.jsxs("div", { className: "copy", children: [
            /* @__PURE__ */ _.jsx(
              "a",
              {
                onClick: Qd,
                href: s(e == null ? void 0 : e.coin_type, "coin"),
                target: "_blank",
                style: { fontSize: "12px" },
                children: xa(e == null ? void 0 : e.coin_type)
              }
            ),
            /* @__PURE__ */ _.jsx(Ih, { text: e == null ? void 0 : e.coin_type })
          ] })
        ] }),
        /* @__PURE__ */ _.jsxs("div", { className: "token-balance", children: [
          /* @__PURE__ */ _.jsxs("div", { className: "balance", children: [
            /* @__PURE__ */ _.jsx("h4", { children: e == null ? void 0 : e.balance }),
            /* @__PURE__ */ _.jsx("p", { children: e != null && e.rate ? U5(e == null ? void 0 : e.rate, 2) : "" })
          ] }),
          r && /* @__PURE__ */ _.jsx(
            "div",
            {
              className: "collect-button",
              onClick: (o) => {
                o.stopPropagation(), n(e, "delete_import");
              },
              children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-icon_del1" }) })
            }
          ),
          t && /* @__PURE__ */ _.jsx(
            "div",
            {
              className: "collect-button",
              onClick: (o) => {
                o.stopPropagation(), n(e, "collect_token");
              },
              children: /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx(
                "use",
                {
                  xlinkHref: i(e) ? "#icon-star_sel" : "#icon-star"
                }
              ) })
            }
          )
        ] })
      ]
    },
    e == null ? void 0 : e.coin_type
  );
}
function rie({
  currentType: e,
  changeTab: t
}) {
  const r = ["Default", "Imported"];
  return /* @__PURE__ */ _.jsx("div", { className: "type-tabs", children: r.map((n) => /* @__PURE__ */ _.jsx(
    "div",
    {
      className: e === n ? "type-tab-item active" : "type-tab-item",
      onClick: () => t(n),
      children: n
    },
    n
  )) });
}
function nie({
  backClick: e,
  onSelectToken: t,
  currToken: r
}) {
  const {
    showTokenList: n,
    isNoData: i,
    handleSearch: s,
    handleChangePlatform: o,
    handleChangeType: a,
    handleImportClick: c,
    handleDeleteImportClick: u
  } = kne(r == null ? void 0 : r.coin_type), {
    importTokenList: l,
    currentTypeTab: f,
    setCurrentTypeTab: h,
    currentPlatformTab: v,
    setCurrentPlatformTab: b,
    platformList: y,
    isOpenImportDialog: S,
    setIsOpenImportDialog: C,
    setSearchInput: O,
    searchInput: I,
    importTokenIsLoading: U,
    currentImportTokenData: D,
    setCurrentImportTokenData: H
  } = ka();
  Bt(() => () => {
    O(""), b("All"), h("Default"), H(void 0);
  }, []);
  const { handleCollectToken: z, collectTokenMap: ne } = jT(), le = (m) => {
    h(m), a(m);
  }, te = (m) => {
    b(m), o(m);
  }, ce = () => {
    c(), C(!1);
  }, V = (m) => {
    let x = m.replace(/[^a-zA-Z0-9\s]+$/g, "").trim();
    O(x), x ? L(x) : (L(""), le("Default"));
  }, L = K1((m) => {
    W5(m) ? s(Hs(m, !0)) : s(m);
  }, 300), p = (m, x) => {
    if (x === "delete_import") {
      u(m);
      return;
    }
    if (x === "collect_token" || x === "un_collect") {
      z(m);
      return;
    }
    x === "select_token" && (t(m), e());
  }, d = Ft(() => Array.from(ne.values()), [ne]);
  return /* @__PURE__ */ _.jsxs("div", { className: "token-select-modal", children: [
    /* @__PURE__ */ _.jsx(X1, { backClick: e, title: "Select Token" }),
    /* @__PURE__ */ _.jsxs("div", { className: "token-select-content", style: { position: "relative" }, children: [
      /* @__PURE__ */ _.jsxs("div", { className: "center-content", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "search-input", style: { position: "relative" }, children: [
          /* @__PURE__ */ _.jsx(
            "input",
            {
              className: "token-search-input",
              placeholder: "Search by token or address",
              value: I,
              onChange: (m) => V(m.target.value),
              style: { paddingRight: "40px" }
            }
          ),
          I.length > 0 && /* @__PURE__ */ _.jsx(
            "svg",
            {
              className: "cs-icon",
              "aria-hidden": "true",
              style: {
                width: "20px",
                height: "20px",
                cursor: "pointer",
                position: "absolute",
                top: "50%",
                transform: "translateY(-50%)",
                right: "12px"
              },
              onClick: (m) => {
                V("");
              },
              children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" })
            }
          )
        ] }),
        d.length > 0 && /* @__PURE__ */ _.jsx(
          jne,
          {
            tokenList: d,
            onHandleTokenAction: p
          }
        ),
        I.length === 0 && /* @__PURE__ */ _.jsx(
          rie,
          {
            currentType: f,
            changeTab: le
          }
        ),
        I.length === 0 && f === "Default" && /* @__PURE__ */ _.jsx(
          Nne,
          {
            tabList: y,
            currentTab: v,
            changeTab: te
          }
        )
      ] }),
      i && /* @__PURE__ */ _.jsx(
        iie,
        {
          showTooltip: I.length > 0,
          text: I.length > 0 || D === void 0 ? "No tokens found" : "No Imported Tokens"
        }
      ),
      U && /* @__PURE__ */ _.jsx(V9, {}),
      D && /* @__PURE__ */ _.jsx(
        "div",
        {
          style: {
            width: "93%",
            marginLeft: "16px",
            backgroundColor: "var(--cs-warning-10)",
            borderRadius: "12px",
            padding: "16px",
            fontSize: "12px",
            marginTop: "16px",
            color: " var(--cs-warning)"
          },
          children: "The token is not on the Frequently Traded List. Please note that anyone can create a token on Sui blockchain with any name, including creating fake versions of existing tokens or tokens that claim to represent projects that do not have a token. Always conduct your own research before trading."
        }
      ),
      n.length > 0 && /* @__PURE__ */ _.jsxs("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ _.jsx(
          eie,
          {
            showTokenList: n,
            showCollect: !D,
            showDelete: !D && f === "Imported",
            onHandleTokenAction: p
          }
        ),
        D && /* @__PURE__ */ _.jsx(
          "div",
          {
            className: "center",
            style: {
              position: "absolute",
              top: "100px",
              left: "50%",
              transform: "translateX(-50%)"
            },
            children: /* @__PURE__ */ _.jsx(
              "button",
              {
                className: "cs-solid-btn swap-btn",
                style: {
                  height: "32px",
                  width: "140px",
                  fontSize: "14px",
                  borderRadius: "8px",
                  fontFamily: "Inter, Inter",
                  fontWeight: 500
                },
                onClick: () => {
                  ce(), p(D, "select_token");
                },
                children: "Import"
              }
            )
          }
        )
      ] })
    ] })
  ] });
}
function iie({
  showTooltip: e,
  text: t
}) {
  return /* @__PURE__ */ _.jsx("div", { style: { height: "360px" }, children: /* @__PURE__ */ _.jsx(
    Pne,
    {
      text: t,
      subItem: e ? /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsx(
        Ea,
        {
          position: "bottom",
          content: /* @__PURE__ */ _.jsx("div", { style: { color: "var(--cs-text-primary)" }, children: "The unique id of coin" }),
          children: /* @__PURE__ */ _.jsxs(
            "div",
            {
              style: {
                fontSize: "12px",
                color: "var(--cs-text-secondary)",
                display: "flex",
                flexDirection: "row"
              },
              children: [
                "Or you can enter Coin Type",
                /* @__PURE__ */ _.jsx(
                  "svg",
                  {
                    className: "cs-icon",
                    "aria-hidden": "true",
                    style: {
                      cursor: "pointer",
                      width: "20px",
                      height: "20px"
                    },
                    children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-tips" })
                  }
                )
              ]
            }
          )
        }
      ) }) : void 0
    }
  ) });
}
function sie({
  onClose: e,
  tokenList: t,
  onSureClick: r
}) {
  const [n, i] = Mt(!1), { setIgnoreWarnToken: s } = Sn();
  return /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx("div", { className: "dialog-mask", onClick: e }),
    /* @__PURE__ */ _.jsxs("div", { className: "import-dialog", children: [
      /* @__PURE__ */ _.jsxs("div", { className: "cs-dialog-header", children: [
        /* @__PURE__ */ _.jsx("div", { className: "title", children: "Tips" }),
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", onClick: e, children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-close" }) })
      ] }),
      /* @__PURE__ */ _.jsxs("div", { className: "import-content", children: [
        /* @__PURE__ */ _.jsx("div", { className: "tip-text-box", children: /* @__PURE__ */ _.jsx("p", { className: "tips-text", children: "The default trading pair given in this swap widget contains a community imported token that is imported by the integrator. Please acknowledge the risk and conduct your own research before interacting." }) }),
        t.map((o) => /* @__PURE__ */ _.jsxs("div", { className: "import-token-info", children: [
          /* @__PURE__ */ _.jsx(
            Gr,
            {
              style: {
                width: "30px",
                height: "30px",
                borderRadius: "36px"
              },
              token: o,
              showWarnSize: "16px",
              src: o.logo_url
            }
          ),
          /* @__PURE__ */ _.jsxs("div", { className: "info", children: [
            /* @__PURE__ */ _.jsx("div", { className: "name", children: /* @__PURE__ */ _.jsxs("span", { children: [
              " ",
              o.symbol,
              " "
            ] }) }),
            /* @__PURE__ */ _.jsxs("div", { className: "address", children: [
              /* @__PURE__ */ _.jsx("span", { children: xa(o.coin_type) }),
              /* @__PURE__ */ _.jsx(Ih, { text: o.coin_type })
            ] })
          ] })
        ] }, o.coin_type)),
        /* @__PURE__ */ _.jsxs("div", { className: "risk-checkbox ", children: [
          /* @__PURE__ */ _.jsx(
            mh,
            {
              color: "indigo",
              checked: n,
              variant: "soft",
              className: "cs-checkbox cs-allow-change-checkbox",
              onClick: () => {
                i(!n);
              }
            }
          ),
          /* @__PURE__ */ _.jsx("span", { children: "I acknowledge the risk" })
        ] }),
        /* @__PURE__ */ _.jsxs("div", { className: "button-block", children: [
          /* @__PURE__ */ _.jsx("button", { className: "cs-outline-btn", onClick: e, children: "Cancel" }),
          /* @__PURE__ */ _.jsx(
            "button",
            {
              className: "cs-solid-btn",
              disabled: !n,
              onClick: () => {
                r(), t.forEach((o) => {
                  s(o.coin_type);
                });
              },
              children: "Confirm"
            }
          )
        ] })
      ] })
    ] })
  ] });
}
function RT(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
}
var Gu;
(function(e) {
  e.event = "event", e.props = "prop";
})(Gu || (Gu = {}));
function xo() {
}
function oie(e) {
  var t, r = void 0;
  return function() {
    for (var n = [], i = arguments.length; i--; )
      n[i] = arguments[i];
    return t && n.length === t.length && n.every(function(s, o) {
      return s === t[o];
    }) || (t = n, r = e.apply(void 0, n)), r;
  };
}
function Ku(e) {
  return !!(e || "").match(/\d/);
}
function hc(e) {
  return e == null;
}
function aie(e) {
  return typeof e == "number" && isNaN(e);
}
function PT(e) {
  return hc(e) || aie(e) || typeof e == "number" && !isFinite(e);
}
function NT(e) {
  return e.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
function cie(e) {
  switch (e) {
    case "lakh":
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;
    case "wan":
      return /(\d)(?=(\d{4})+(?!\d))/g;
    case "thousand":
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g;
  }
}
function uie(e, t, r) {
  var n = cie(r), i = e.search(/[1-9]/);
  return i = i === -1 ? e.length : i, e.substring(0, i) + e.substring(i, e.length).replace(n, "$1" + t);
}
function lie(e) {
  var t = Ar(e);
  t.current = e;
  var r = Ar(function() {
    for (var n = [], i = arguments.length; i--; )
      n[i] = arguments[i];
    return t.current.apply(t, n);
  });
  return r.current;
}
function oy(e, t) {
  t === void 0 && (t = !0);
  var r = e[0] === "-", n = r && t;
  e = e.replace("-", "");
  var i = e.split("."), s = i[0], o = i[1] || "";
  return {
    beforeDecimal: s,
    afterDecimal: o,
    hasNegation: r,
    addNegation: n
  };
}
function fie(e) {
  if (!e)
    return e;
  var t = e[0] === "-";
  t && (e = e.substring(1, e.length));
  var r = e.split("."), n = r[0].replace(/^0+/, "") || "0", i = r[1] || "";
  return (t ? "-" : "") + n + (i ? "." + i : "");
}
function $T(e, t, r) {
  for (var n = "", i = r ? "0" : "", s = 0; s <= t - 1; s++)
    n += e[s] || i;
  return n;
}
function $w(e, t) {
  return Array(t + 1).join(e);
}
function DT(e) {
  var t = e + "", r = t[0] === "-" ? "-" : "";
  r && (t = t.substring(1));
  var n = t.split(/[eE]/g), i = n[0], s = n[1];
  if (s = Number(s), !s)
    return r + i;
  i = i.replace(".", "");
  var o = 1 + s, a = i.length;
  return o < 0 ? i = "0." + $w("0", Math.abs(o)) + i : o >= a ? i = i + $w("0", o - a) : i = (i.substring(0, o) || "0") + "." + i.substring(o), r + i;
}
function Dw(e, t, r) {
  if (["", "-"].indexOf(e) !== -1)
    return e;
  var n = (e.indexOf(".") !== -1 || r) && t, i = oy(e), s = i.beforeDecimal, o = i.afterDecimal, a = i.hasNegation, c = parseFloat("0." + (o || "0")), u = o.length <= t ? "0." + o : c.toFixed(t), l = u.split("."), f = s;
  s && Number(l[0]) && (f = s.split("").reverse().reduce(function(y, S, C) {
    return y.length > C ? (Number(y[0]) + Number(S)).toString() + y.substring(1, y.length) : S + y;
  }, l[0]));
  var h = $T(l[1] || "", t, r), v = a ? "-" : "", b = n ? "." : "";
  return "" + v + f + b + h;
}
function na(e, t) {
  if (e.value = e.value, e !== null) {
    if (e.createTextRange) {
      var r = e.createTextRange();
      return r.move("character", t), r.select(), !0;
    }
    return e.selectionStart || e.selectionStart === 0 ? (e.focus(), e.setSelectionRange(t, t), !0) : (e.focus(), !1);
  }
}
var LT = oie(function(e, t) {
  for (var r = 0, n = 0, i = e.length, s = t.length; e[r] === t[r] && r < i; )
    r++;
  for (; e[i - 1 - n] === t[s - 1 - n] && s - n > r && i - n > r; )
    n++;
  return {
    from: { start: r, end: i - n },
    to: { start: r, end: s - n }
  };
}), die = function(e, t) {
  var r = Math.min(e.selectionStart, t);
  return {
    from: { start: r, end: e.selectionEnd },
    to: { start: r, end: t }
  };
};
function hie(e, t, r) {
  return Math.min(Math.max(e, t), r);
}
function Zp(e) {
  return Math.max(e.selectionStart, e.selectionEnd);
}
function pie() {
  return typeof navigator < "u" && !(navigator.platform && /iPhone|iPod/.test(navigator.platform));
}
function mie(e) {
  return {
    from: {
      start: 0,
      end: 0
    },
    to: {
      start: 0,
      end: e.length
    },
    lastValue: ""
  };
}
function gie(e) {
  var t = e.currentValue, r = e.formattedValue, n = e.currentValueIndex, i = e.formattedValueIndex;
  return t[n] === r[i];
}
function yie(e, t, r, n, i, s, o) {
  o === void 0 && (o = gie);
  var a = i.findIndex(function(U) {
    return U;
  }), c = e.slice(0, a);
  !t && !r.startsWith(c) && (t = c, r = c + r, n = n + c.length);
  for (var u = r.length, l = e.length, f = {}, h = new Array(u), v = 0; v < u; v++) {
    h[v] = -1;
    for (var b = 0, y = l; b < y; b++) {
      var S = o({
        currentValue: r,
        lastValue: t,
        formattedValue: e,
        currentValueIndex: v,
        formattedValueIndex: b
      });
      if (S && f[b] !== !0) {
        h[v] = b, f[b] = !0;
        break;
      }
    }
  }
  for (var C = n; C < u && (h[C] === -1 || !s(r[C])); )
    C++;
  var O = C === u || h[C] === -1 ? l : h[C];
  for (C = n - 1; C > 0 && h[C] === -1; )
    C--;
  var I = C === -1 || h[C] === -1 ? 0 : h[C] + 1;
  return I > O ? O : n - I < O - n ? I : O;
}
function Lw(e, t, r, n) {
  var i = e.length;
  if (t = hie(t, 0, i), n === "left") {
    for (; t >= 0 && !r[t]; )
      t--;
    t === -1 && (t = r.indexOf(!0));
  } else {
    for (; t <= i && !r[t]; )
      t++;
    t > i && (t = r.lastIndexOf(!0));
  }
  return t === -1 && (t = i), t;
}
function vie(e) {
  for (var t = Array.from({ length: e.length + 1 }).map(function() {
    return !0;
  }), r = 0, n = t.length; r < n; r++)
    t[r] = !!(Ku(e[r]) || Ku(e[r - 1]));
  return t;
}
function BT(e, t, r, n, i, s) {
  s === void 0 && (s = xo);
  var o = lie(function(b, y) {
    var S, C;
    return PT(b) ? (C = "", S = "") : typeof b == "number" || y ? (C = typeof b == "number" ? DT(b) : b, S = n(C)) : (C = i(b, void 0), S = n(C)), { formattedValue: S, numAsString: C };
  }), a = Mt(function() {
    return o(hc(e) ? t : e, r);
  }), c = a[0], u = a[1], l = function(b, y) {
    b.formattedValue !== c.formattedValue && u({
      formattedValue: b.formattedValue,
      numAsString: b.value
    }), s(b, y);
  }, f = e, h = r;
  hc(e) && (f = c.numAsString, h = !0);
  var v = o(f, h);
  return Ft(function() {
    u(v);
  }, [v.formattedValue]), [c, l];
}
function bie(e) {
  return e.replace(/[^0-9]/g, "");
}
function wie(e) {
  return e;
}
function _ie(e) {
  var t = e.type;
  t === void 0 && (t = "text");
  var r = e.displayType;
  r === void 0 && (r = "input");
  var n = e.customInput, i = e.renderText, s = e.getInputRef, o = e.format;
  o === void 0 && (o = wie);
  var a = e.removeFormatting;
  a === void 0 && (a = bie);
  var c = e.defaultValue, u = e.valueIsNumericString, l = e.onValueChange, f = e.isAllowed, h = e.onChange;
  h === void 0 && (h = xo);
  var v = e.onKeyDown;
  v === void 0 && (v = xo);
  var b = e.onMouseUp;
  b === void 0 && (b = xo);
  var y = e.onFocus;
  y === void 0 && (y = xo);
  var S = e.onBlur;
  S === void 0 && (S = xo);
  var C = e.value, O = e.getCaretBoundary;
  O === void 0 && (O = vie);
  var I = e.isValidInputCharacter;
  I === void 0 && (I = Ku);
  var U = e.isCharacterSame, D = RT(e, ["type", "displayType", "customInput", "renderText", "getInputRef", "format", "removeFormatting", "defaultValue", "valueIsNumericString", "onValueChange", "isAllowed", "onChange", "onKeyDown", "onMouseUp", "onFocus", "onBlur", "value", "getCaretBoundary", "isValidInputCharacter", "isCharacterSame"]), H = BT(C, c, !!u, o, a, l), z = H[0], ne = z.formattedValue, le = z.numAsString, te = H[1], ce = Ar(), V = Ar({ formattedValue: ne, numAsString: le }), L = function(Y, X) {
    V.current = { formattedValue: Y.formattedValue, numAsString: Y.value }, te(Y, X);
  }, p = Mt(!1), d = p[0], m = p[1], x = Ar(null), E = Ar({
    setCaretTimeout: null,
    focusTimeout: null
  });
  Bt(function() {
    return m(!0), function() {
      clearTimeout(E.current.setCaretTimeout), clearTimeout(E.current.focusTimeout);
    };
  }, []);
  var A = o, j = function(Y, X) {
    var B = parseFloat(X);
    return {
      formattedValue: Y,
      value: X,
      floatValue: isNaN(B) ? void 0 : B
    };
  }, k = function(Y, X, B) {
    Y.selectionStart === 0 && Y.selectionEnd === Y.value.length || (na(Y, X), E.current.setCaretTimeout = setTimeout(function() {
      Y.value === B && Y.selectionStart !== X && na(Y, X);
    }, 0));
  }, g = function(Y, X, B) {
    return Lw(Y, X, O(Y), B);
  }, w = function(Y, X, B) {
    var se = O(X), me = yie(X, ne, Y, B, se, I, U);
    return me = Lw(X, me, se), me;
  }, P = function(Y) {
    var X = Y.formattedValue;
    X === void 0 && (X = "");
    var B = Y.input, se = Y.source, me = Y.event, de = Y.numAsString, xe;
    if (B) {
      var Oe = Y.inputValue || B.value, Be = Zp(B);
      B.value = X, xe = w(Oe, X, Be), xe !== void 0 && k(B, xe, X);
    }
    X !== ne && L(j(X, de), { event: me, source: se });
  };
  Bt(function() {
    var Y = V.current, X = Y.formattedValue, B = Y.numAsString;
    (ne !== X || le !== B) && L(j(ne, le), {
      event: void 0,
      source: Gu.props
    });
  }, [ne, le]);
  var ue = x.current ? Zp(x.current) : void 0, ie = typeof window < "u" ? Vw : Bt;
  ie(function() {
    var Y = x.current;
    if (ne !== V.current.formattedValue && Y) {
      var X = w(V.current.formattedValue, ne, ue);
      Y.value = ne, k(Y, X, ne);
    }
  }, [ne]);
  var fe = function(Y, X, B) {
    var se = X.target, me = ce.current ? die(ce.current, se.selectionEnd) : LT(ne, Y), de = Object.assign(Object.assign({}, me), { lastValue: ne }), xe = a(Y, de), Oe = A(xe);
    if (xe = a(Oe, void 0), f && !f(j(Oe, xe))) {
      var Be = X.target, Xe = Zp(Be), Re = w(Y, ne, Xe);
      return Be.value = ne, k(Be, Re, ne), !1;
    }
    return P({
      formattedValue: Oe,
      numAsString: xe,
      inputValue: Y,
      event: X,
      source: B,
      input: X.target
    }), !0;
  }, ye = function(Y, X) {
    X === void 0 && (X = 0);
    var B = Y.selectionStart, se = Y.selectionEnd;
    ce.current = { selectionStart: B, selectionEnd: se + X };
  }, Te = function(Y) {
    var X = Y.target, B = X.value, se = fe(B, Y, Gu.event);
    se && h(Y), ce.current = void 0;
  }, N = function(Y) {
    var X = Y.target, B = Y.key, se = X.selectionStart, me = X.selectionEnd, de = X.value;
    de === void 0 && (de = "");
    var xe;
    B === "ArrowLeft" || B === "Backspace" ? xe = Math.max(se - 1, 0) : B === "ArrowRight" ? xe = Math.min(se + 1, de.length) : B === "Delete" && (xe = se);
    var Oe = 0;
    B === "Delete" && se === me && (Oe = 1);
    var Be = B === "ArrowLeft" || B === "ArrowRight";
    if (xe === void 0 || se !== me && !Be) {
      v(Y), ye(X, Oe);
      return;
    }
    var Xe = xe;
    if (Be) {
      var Re = B === "ArrowLeft" ? "left" : "right";
      Xe = g(de, xe, Re), Xe !== xe && Y.preventDefault();
    } else
      B === "Delete" && !I(de[xe]) ? Xe = g(de, xe, "right") : B === "Backspace" && !I(de[xe]) && (Xe = g(de, xe, "left"));
    Xe !== xe && k(X, Xe, de), v(Y), ye(X, Oe);
  }, F = function(Y) {
    var X = Y.target, B = function() {
      var se = X.selectionStart, me = X.selectionEnd, de = X.value;
      if (de === void 0 && (de = ""), se === me) {
        var xe = g(de, se);
        xe !== se && k(X, xe, de);
      }
    };
    B(), requestAnimationFrame(function() {
      B();
    }), b(Y), ye(X);
  }, G = function(Y) {
    Y.persist && Y.persist();
    var X = Y.target, B = Y.currentTarget;
    x.current = X, E.current.focusTimeout = setTimeout(function() {
      var se = X.selectionStart, me = X.selectionEnd, de = X.value;
      de === void 0 && (de = "");
      var xe = g(de, se);
      xe !== se && !(se === 0 && me === de.length) && k(X, xe, de), y(Object.assign(Object.assign({}, Y), { currentTarget: B }));
    }, 0);
  }, ee = function(Y) {
    x.current = null, clearTimeout(E.current.focusTimeout), clearTimeout(E.current.setCaretTimeout), S(Y);
  }, Z = d && pie() ? "numeric" : void 0, q = Object.assign({ inputMode: Z }, D, {
    type: t,
    value: ne,
    onChange: Te,
    onKeyDown: N,
    onMouseUp: F,
    onFocus: G,
    onBlur: ee
  });
  if (r === "text")
    return i ? Fr.createElement(Fr.Fragment, null, i(ne, D) || null) : Fr.createElement("span", Object.assign({}, D, { ref: s }), ne);
  if (n) {
    var he = n;
    return Fr.createElement(he, Object.assign({}, q, { ref: s }));
  }
  return Fr.createElement("input", Object.assign({}, q, { ref: s }));
}
function Bw(e, t) {
  var r = t.decimalScale, n = t.fixedDecimalScale, i = t.prefix;
  i === void 0 && (i = "");
  var s = t.suffix;
  s === void 0 && (s = "");
  var o = t.allowNegative, a = t.thousandsGroupStyle;
  if (a === void 0 && (a = "thousand"), e === "" || e === "-")
    return e;
  var c = kh(t), u = c.thousandSeparator, l = c.decimalSeparator, f = r !== 0 && e.indexOf(".") !== -1 || r && n, h = oy(e, o), v = h.beforeDecimal, b = h.afterDecimal, y = h.addNegation;
  return r !== void 0 && (b = $T(b, r, !!n)), u && (v = uie(v, u, a)), i && (v = i + v), s && (b = b + s), y && (v = "-" + v), e = v + (f && l || "") + b, e;
}
function kh(e) {
  var t = e.decimalSeparator;
  t === void 0 && (t = ".");
  var r = e.thousandSeparator, n = e.allowedDecimalSeparators;
  return r === !0 && (r = ","), n || (n = [t, "."]), {
    decimalSeparator: t,
    thousandSeparator: r,
    allowedDecimalSeparators: n
  };
}
function xie(e, t) {
  e === void 0 && (e = "");
  var r = new RegExp("(-)"), n = new RegExp("(-)(.)*(-)"), i = r.test(e), s = n.test(e);
  return e = e.replace(/-/g, ""), i && !s && t && (e = "-" + e), e;
}
function Sie(e, t) {
  return new RegExp("(^-)|[0-9]|" + NT(e), t ? "g" : void 0);
}
function Eie(e, t, r) {
  return e === "" ? !0 : !(t != null && t.match(/\d/)) && !(r != null && r.match(/\d/)) && typeof e == "string" && !isNaN(Number(e));
}
function Tie(e, t, r) {
  var n;
  t === void 0 && (t = mie(e));
  var i = r.allowNegative, s = r.prefix;
  s === void 0 && (s = "");
  var o = r.suffix;
  o === void 0 && (o = "");
  var a = r.decimalScale, c = t.from, u = t.to, l = u.start, f = u.end, h = kh(r), v = h.allowedDecimalSeparators, b = h.decimalSeparator, y = e[f] === b;
  if (Ku(e) && (e === s || e === o) && t.lastValue === "")
    return e;
  if (f - l === 1 && v.indexOf(e[l]) !== -1) {
    var S = a === 0 ? "" : b;
    e = e.substring(0, l) + S + e.substring(l + 1, e.length);
  }
  var C = function(x, E, A) {
    var j = !1, k = !1;
    s.startsWith("-") ? j = !1 : x.startsWith("--") ? (j = !1, k = !0) : o.startsWith("-") && x.length === o.length ? j = !1 : x[0] === "-" && (j = !0);
    var g = j ? 1 : 0;
    return k && (g = 2), g && (x = x.substring(g), E -= g, A -= g), { value: x, start: E, end: A, hasNegation: j };
  }, O = C(e, l, f), I = O.hasNegation;
  n = O, e = n.value, l = n.start, f = n.end;
  var U = C(t.lastValue, c.start, c.end), D = U.start, H = U.end, z = U.value, ne = e.substring(l, f);
  e.length && z.length && (D > z.length - o.length || H < s.length) && !(ne && o.startsWith(ne)) && (e = z);
  var le = 0;
  e.startsWith(s) ? le += s.length : l < s.length && (le = l), e = e.substring(le), f -= le;
  var te = e.length, ce = e.length - o.length;
  e.endsWith(o) ? te = ce : (f > ce || f > e.length - o.length) && (te = f), e = e.substring(0, te), e = xie(I ? "-" + e : e, i), e = (e.match(Sie(b, !0)) || []).join("");
  var V = e.indexOf(b);
  e = e.replace(new RegExp(NT(b), "g"), function(x, E) {
    return E === V ? "." : "";
  });
  var L = oy(e, i), p = L.beforeDecimal, d = L.afterDecimal, m = L.addNegation;
  return u.end - u.start < c.end - c.start && p === "" && y && !parseFloat(d) && (e = m ? "-" : ""), e;
}
function Cie(e, t) {
  var r = t.prefix;
  r === void 0 && (r = "");
  var n = t.suffix;
  n === void 0 && (n = "");
  var i = Array.from({ length: e.length + 1 }).map(function() {
    return !0;
  }), s = e[0] === "-";
  i.fill(!1, 0, r.length + (s ? 1 : 0));
  var o = e.length;
  return i.fill(!1, o - n.length + 1, o + 1), i;
}
function Aie(e) {
  var t = kh(e), r = t.thousandSeparator, n = t.decimalSeparator, i = e.prefix;
  i === void 0 && (i = "");
  var s = e.allowNegative;
  if (s === void 0 && (s = !0), r === n)
    throw new Error(`
        Decimal separator can't be same as thousand separator.
        thousandSeparator: ` + r + ` (thousandSeparator = {true} is same as thousandSeparator = ",")
        decimalSeparator: ` + n + ` (default value for decimalSeparator is .)
     `);
  return i.startsWith("-") && s && (console.error(`
      Prefix can't start with '-' when allowNegative is true.
      prefix: ` + i + `
      allowNegative: ` + s + `
    `), s = !1), Object.assign(Object.assign({}, e), { allowNegative: s });
}
function Mie(e) {
  e = Aie(e), e.decimalSeparator, e.allowedDecimalSeparators, e.thousandsGroupStyle;
  var t = e.suffix, r = e.allowNegative, n = e.allowLeadingZeros, i = e.onKeyDown;
  i === void 0 && (i = xo);
  var s = e.onBlur;
  s === void 0 && (s = xo);
  var o = e.thousandSeparator, a = e.decimalScale, c = e.fixedDecimalScale, u = e.prefix;
  u === void 0 && (u = "");
  var l = e.defaultValue, f = e.value, h = e.valueIsNumericString, v = e.onValueChange, b = RT(e, ["decimalSeparator", "allowedDecimalSeparators", "thousandsGroupStyle", "suffix", "allowNegative", "allowLeadingZeros", "onKeyDown", "onBlur", "thousandSeparator", "decimalScale", "fixedDecimalScale", "prefix", "defaultValue", "value", "valueIsNumericString", "onValueChange"]), y = kh(e), S = y.decimalSeparator, C = y.allowedDecimalSeparators, O = function(m) {
    return Bw(m, e);
  }, I = function(m, x) {
    return Tie(m, x, e);
  }, U = hc(f) ? l : f, D = h ?? Eie(U, u, t);
  hc(f) ? hc(l) || (D = D || typeof l == "number") : D = D || typeof f == "number";
  var H = function(m) {
    return PT(m) ? m : (typeof m == "number" && (m = DT(m)), D && typeof a == "number" ? Dw(m, a, !!c) : m);
  }, z = BT(H(f), H(l), !!D, O, I, v), ne = z[0], le = ne.numAsString, te = ne.formattedValue, ce = z[1], V = function(m) {
    var x = m.target, E = m.key, A = x.selectionStart, j = x.selectionEnd, k = x.value;
    if (k === void 0 && (k = ""), (E === "Backspace" || E === "Delete") && j < u.length) {
      m.preventDefault();
      return;
    }
    if (A !== j) {
      i(m);
      return;
    }
    E === "Backspace" && k[0] === "-" && A === u.length + 1 && r && na(x, 1), a && c && (E === "Backspace" && k[A - 1] === S ? (na(x, A - 1), m.preventDefault()) : E === "Delete" && k[A] === S && m.preventDefault()), C != null && C.includes(E) && k[A] === S && na(x, A + 1);
    var g = o === !0 ? "," : o;
    E === "Backspace" && k[A - 1] === g && na(x, A - 1), E === "Delete" && k[A] === g && na(x, A + 1), i(m);
  }, L = function(m) {
    var x = le;
    if (x.match(/\d/g) || (x = ""), n || (x = fie(x)), c && a && (x = Dw(x, a, c)), x !== le) {
      var E = Bw(x, e);
      ce({
        formattedValue: E,
        value: x,
        floatValue: parseFloat(x)
      }, {
        event: m,
        source: Gu.event
      });
    }
    s(m);
  }, p = function(m) {
    return m === S ? !0 : Ku(m);
  }, d = function(m) {
    var x = m.currentValue, E = m.lastValue, A = m.formattedValue, j = m.currentValueIndex, k = m.formattedValueIndex, g = x[j], w = A[k], P = LT(E, x), ue = P.to, ie = function(fe) {
      return I(fe).indexOf(".") + u.length;
    };
    return f === 0 && c && a && x[ue.start] === S && ie(x) < j && ie(A) > k ? !1 : j >= ue.start && j < ue.end && C && C.includes(g) && w === S ? !0 : g === w;
  };
  return Object.assign(Object.assign({}, b), {
    value: te,
    valueIsNumericString: !1,
    isValidInputCharacter: p,
    isCharacterSame: d,
    onValueChange: ce,
    format: O,
    removeFormatting: I,
    getCaretBoundary: function(m) {
      return Cie(m, e);
    },
    onKeyDown: V,
    onBlur: L
  });
}
function Oie(e) {
  var t = Mie(e);
  return Fr.createElement(_ie, Object.assign({}, t));
}
function Iie(e) {
  const {
    className: t,
    value: r,
    decimals: n,
    placeholder: i,
    style: s,
    onChange: o,
    maxValue: a,
    minValue: c = 0,
    inputAllowed: u = !0,
    prefix: l,
    ...f
  } = e, h = (v) => {
    var S;
    const b = ((S = v == null ? void 0 : v.target) == null ? void 0 : S.value) || "";
    let y = b;
    if (b.startsWith("0") && b !== "0" && !b.startsWith("0.") && (y = b.replace(/^0+/, "")), y) {
      if (y.startsWith(".")) {
        o(y.slice(1, y.length));
        return;
      }
      let C = String(y).replace(/,/g, "");
      if (C.startsWith("-")) {
        o("");
        return;
      }
      l && (C = C.replace(l, "")), a !== void 0 && Ue(C).gt(a) ? C = a.toString() : c !== void 0 && Ue(C).lt(c) && (C = c.toString()), o(String(C));
    } else
      o("");
  };
  return /* @__PURE__ */ _.jsx(
    Oie,
    {
      className: t,
      value: r,
      disabled: !u,
      placeholder: i,
      decimalScale: n,
      prefix: l,
      allowLeadingZeros: !0,
      thousandSeparator: ",",
      isAllowed: (v) => !v.value.startsWith("-"),
      onChange: h,
      ...f,
      style: {
        ...s,
        cursor: u ? "pointer" : "not-allowed",
        fontFamily: "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji",
        fontFeatureSettings: "tnum",
        fontVariant: "tabular-nums"
      }
    }
  );
}
function kie(e) {
  const { token: t, handleTokenSelectClick: r } = e;
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "token-select-block",
      onClick: () => {
        r && r();
      },
      children: [
        /* @__PURE__ */ _.jsx("div", { className: "token-img-box", children: /* @__PURE__ */ _.jsx(Gr, { src: t == null ? void 0 : t.logo_url, token: t, showWarnSize: "16px" }) }, t == null ? void 0 : t.coin_type),
        /* @__PURE__ */ _.jsx("div", { className: "name", children: /* @__PURE__ */ _.jsxs("h4", { className: "truncate-text", children: [
          " ",
          (t == null ? void 0 : t.symbol) || "Select"
        ] }) }),
        /* @__PURE__ */ _.jsx("svg", { className: "cs-icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-arrow" }) })
      ]
    }
  );
}
function Uw({
  label: e,
  amount: t,
  amountValue: r,
  balance: n,
  onInputChange: i,
  handleTokenSelectClick: s,
  token: o,
  loading: a = !1,
  showMax: c = !0,
  showHalf: u = !0,
  inputAllowed: l = !0,
  marginTop: f
}) {
  const [h, v] = Mt(!1), { currentAccount: b } = Tn(), y = () => {
    const C = Ue((n == null ? void 0 : n.totalBalanceFormat) || "0").div(2), O = jn(
      C.toString(),
      o == null ? void 0 : o.decimals,
      !0
    ).toString();
    t && Ue(O).eq(t) || i(O);
  }, S = () => {
    const C = Ue((n == null ? void 0 : n.totalBalanceFormat) || 0), O = jr((o == null ? void 0 : o.coin_type) || "").full_address === Id, I = 0.05;
    let U = C;
    O && Ue(C).gt(I) && (U = U.sub(I)), !(t && Ue(U).eq(t)) && Ue(U).gte(0) && i(U.toString());
  };
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: h ? "active trade-input-box" : "trade-input-box",
      style: {
        backgroundColor: l ? "var(--cs-input-bg-normal)" : "var(--cs-input-disabled-bg)",
        marginTop: f
      },
      children: [
        /* @__PURE__ */ _.jsxs("div", { className: "title", children: [
          " ",
          e,
          " "
        ] }),
        /* @__PURE__ */ _.jsxs("div", { className: "token-input", children: [
          a ? /* @__PURE__ */ _.jsxs("div", { style: { flex: 1 }, children: [
            " ",
            /* @__PURE__ */ _.jsx(
              Ra,
              {
                className: "custom-skeleton",
                style: { width: "150px", height: "28px", flex: 1 }
              }
            ),
            " "
          ] }) : /* @__PURE__ */ _.jsx(
            Iie,
            {
              inputAllowed: l,
              value: t,
              decimals: (o == null ? void 0 : o.decimals) || 9,
              placeholder: "0.0",
              className: "input",
              onChange: i,
              onFocus: () => v(!0),
              onBlur: () => v(!1)
            }
          ),
          /* @__PURE__ */ _.jsx(
            kie,
            {
              token: o,
              handleTokenSelectClick: s
            }
          )
        ] }),
        /* @__PURE__ */ _.jsxs("div", { className: "info-box", children: [
          !a && r && Ue(r).gt(0) ? /* @__PURE__ */ _.jsx("div", { className: "input-rate", style: { marginTop: "8px" }, children: U5(r, 2) }) : /* @__PURE__ */ _.jsx("div", {}),
          b && o && /* @__PURE__ */ _.jsxs(
            "div",
            {
              style: { display: "flex", flexDirection: "row", marginTop: "8px" },
              children: [
                /* @__PURE__ */ _.jsxs("div", { className: "token-balance", children: [
                  /* @__PURE__ */ _.jsx("svg", { className: "icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-wallet" }) }),
                  /* @__PURE__ */ _.jsx("span", { children: (n == null ? void 0 : n.displayBalance) || 0 })
                ] }),
                /* @__PURE__ */ _.jsxs("div", { className: "btn-box", children: [
                  u && /* @__PURE__ */ _.jsx("button", { className: "cs-outline-btn", onClick: y, children: "HALF" }),
                  c && /* @__PURE__ */ _.jsx("button", { className: "cs-outline-btn", onClick: S, children: "MAX" })
                ] })
              ]
            }
          )
        ] })
      ]
    }
  );
}
function jie({
  refreshCount: e,
  customWallet: t,
  initProps: r
}) {
  const { currentAccount: n, onWalletModal: i } = Tn(), { getOwnerCoinBalances: s } = $u(), {
    fromCoin: o,
    toCoin: a,
    fromAmount: c,
    toAmount: u,
    findRouterLoading: l,
    byAmountIn: f,
    routerData: h,
    isOpenSecondary: v,
    setIsOpenSecondary: b,
    isOpenTokensDialog: y,
    setIsOpenTokensDialog: S
  } = En(), {
    handleAmountChange: C,
    handleSelectToken: O,
    fromBalanceInfo: I,
    toBalanceInfo: U,
    fromAmountValue: D,
    toAmountValue: H,
    doSwapAction: z,
    reCalculateRouteData: ne,
    refreshMarketPrice: le,
    scamsText: te
  } = HJ(), { slippage: ce } = Sn(), { allProviders: V } = X9(h), { isCustomMode: L, customWarnTokenList: p } = bJ(
    o == null ? void 0 : o.coin_type,
    a == null ? void 0 : a.coin_type
  ), { amountLimit: d } = H9(ce, h), [m, x] = Mt(!1), { btnText: E, btnDisabled: A } = GJ(
    I == null ? void 0 : I.totalBalanceFormat
  ), [j, k] = Mt(!1), [g, w] = Mt(!1);
  Bt(() => {
    v ? e >= 5 && P() : e >= 20 && P();
  }, [e]);
  const P = () => {
    ne(), n && s(), le();
  }, ue = () => ({ ...h }), ie = async () => {
    a && O(a, !0);
  };
  return /* @__PURE__ */ _.jsxs("div", { className: "swap-trade-box", children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "trade-form",
        style: {
          flexDirection: "column"
        },
        children: [
          /* @__PURE__ */ _.jsx(
            Uw,
            {
              loading: !f && l,
              balance: I,
              amountValue: D,
              handleTokenSelectClick: () => {
                k(!0), S(!0);
              },
              onInputChange: (fe) => {
                C(fe, !0);
              },
              amount: c,
              token: o
            }
          ),
          /* @__PURE__ */ _.jsx(
            "div",
            {
              onClick: ie,
              className: "swap-icon",
              onMouseEnter: () => x(!0),
              onMouseLeave: () => x(!1),
              style: {
                cursor: "pointer"
              },
              children: /* @__PURE__ */ _.jsx(
                "svg",
                {
                  className: "cs-icon",
                  "aria-hidden": "true",
                  style: {
                    transform: m ? "rotate(90deg)" : "none",
                    width: m ? "16px" : "14px",
                    height: m ? "16px" : "14px"
                  },
                  children: /* @__PURE__ */ _.jsx("use", { xlinkHref: m ? "#icon-swap" : "#icon-trade" })
                }
              )
            }
          ),
          /* @__PURE__ */ _.jsx(
            Uw,
            {
              marginTop: "-20px",
              loading: f && l,
              balance: U,
              showHalf: !1,
              showMax: !1,
              amountValue: H,
              handleTokenSelectClick: () => {
                k(!1), S(!0);
              },
              onInputChange: (fe) => {
                C(fe, !1);
              },
              inputAllowed: !1,
              amount: u,
              token: a
            }
          )
        ]
      }
    ),
    te && /* @__PURE__ */ _.jsx(nZ, { scamsText: te }),
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "swap-bottom-block",
        style: {
          border: A ? "0px solid var(--cs-border)" : "1px solid var(--cs-border)"
        },
        children: [
          /* @__PURE__ */ _.jsx(
            "button",
            {
              className: "cs-solid-btn swap-btn",
              style: { marginTop: "0px" },
              disabled: A || l,
              onClick: () => {
                n ? L && p.length > 0 ? w(!0) : b(!0) : t != null && t.connect ? t.connect() : i(!0);
              },
              children: l ? /* @__PURE__ */ _.jsx(
                "div",
                {
                  style: {
                    width: "100%",
                    display: "flex",
                    justifyContent: "center"
                  },
                  children: /* @__PURE__ */ _.jsx(g1, {})
                }
              ) : E
            }
          ),
          c && u && Ue(c).gt(0) && Ue(u).gt(0) && /* @__PURE__ */ _.jsxs("div", { className: "content", children: [
            /* @__PURE__ */ _.jsxs("div", { className: "price-related-info", children: [
              h && !(h != null && h.errorCode) && /* @__PURE__ */ _.jsx(
                Y1,
                {
                  baseToken: o,
                  quoteToken: a,
                  baseAmount: h.fromAmountUi || "",
                  quoteAmount: h.toAmountUi || "",
                  loading: l
                }
              ),
              /* @__PURE__ */ _.jsx(
                Z9,
                {
                  isLoading: l,
                  routerData: h
                }
              )
            ] }),
            /* @__PURE__ */ _.jsx(
              Q9,
              {
                isLoading: l,
                amountLimit: d
              }
            ),
            /* @__PURE__ */ _.jsx(
              Ine,
              {
                hasSubMenu: !0,
                allProviders: V,
                isLoading: l,
                data: h
              }
            ),
            !!(r != null && r.overlayFeeRate) && !!(r != null && r.overlayFeeReceiver) && /* @__PURE__ */ _.jsx(
              tZ,
              {
                value: r == null ? void 0 : r.overlayFeeRate,
                isLoading: l
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ _.jsx(eZ, { themeType: r == null ? void 0 : r.themeType }),
    v && /* @__PURE__ */ _.jsx(
      bne,
      {
        data: ue(),
        toBack: () => b(!1),
        onSubmitClick: async (fe) => {
          try {
            await z(fe, r == null ? void 0 : r.partner);
          } finally {
            b(!1);
          }
        }
      }
    ),
    y && /* @__PURE__ */ _.jsx(
      nie,
      {
        currToken: j ? o : a,
        backClick: () => S(!1),
        onSelectToken: (fe) => {
          O(fe, j), S(!1);
        }
      }
    ),
    g && p.length > 0 && /* @__PURE__ */ _.jsx(
      sie,
      {
        onClose: () => {
          w(!1);
        },
        tokenList: p,
        onSureClick: () => {
          w(!1), b(!0);
        }
      }
    )
  ] });
}
const Rie = (e, t) => {
  const r = { ...e };
  return r.primary_10 = gn(e.primary, 0.1), r.primary_20 = gn(e.primary, 0.2), r.primary_50 = gn(e.primary, 0.5), r.primary_80 = gn(e.primary, 0.8), r.btn_disabled_bg = gn(e.primary, 0.2), r["btn-hover-bg"] = gn(e.primary, 0.8), r.success_10 = gn(e.success, 0.1), r.warning_10 = gn(e.warning, 0.1), r.error_10 = gn(e.error, 0.1), t === "Light" ? (r.bg_secondary = "#72C1F7", r.bg_secondary_common = gn(
    e.primary,
    0.1
  ), r.input_bg_normal = gn(e.primary, 0.1), r.border = "rgba(0,0,0,0.1)", r.icon_fill = gn(e.text_secondary, 1), r.text_placeholder = "rgba(0,0,0,0.5)", r.btn_disabled_text = gn(
    e.text_primary,
    0.5
  ), r.router_percent_bg = "#F1F9FE") : (r.bg_secondary = "#000", r.bg_secondary_common = "rgba(0, 0, 0,0.2)", r.input_bg_normal = "rgba(0, 0, 0,0.3)", r.border = "rgba(255,255,255,0.1)", r.icon_fill = gn(e.text_secondary, 1), r.text_placeholder = "rgba(255,255,255,0.5)", r.btn_disabled_text = gn(
    e.text_primary,
    0.5
  ), r.router_percent_bg = "#192128"), r;
}, gn = (e, t) => {
  const r = e.replace("#", ""), n = parseInt(r.substring(0, 2), 16), i = parseInt(r.substring(2, 4), 16), s = parseInt(r.substring(4, 6), 16);
  return `rgba(${n}, ${i}, ${s}, ${t})`;
}, Pie = (e, t) => {
  let r = ":root {";
  const n = Rie(e, t);
  return Object.entries(n).forEach(([i, s]) => {
    s && (r += `--cs-${i.split("_").join("-")}: ${s};`);
  }), r += "}", r;
}, Fw = (e) => {
  const t = document.createElement("style");
  t.id = "dynamic-theme", t.textContent = e;
  const r = document.getElementById("dynamic-theme");
  r && r.remove(), document.head.appendChild(t);
}, Nie = ({ theme: e, children: t, themeType: r }) => (Bt(() => {
  if (!e || !r)
    return;
  const n = Pie(e, r);
  if ("adoptedStyleSheets" in document) {
    const i = new CSSStyleSheet();
    try {
      return i.replaceSync(n), document.adoptedStyleSheets = [...document.adoptedStyleSheets, i], () => {
        document.adoptedStyleSheets = document.adoptedStyleSheets.filter(
          (s) => s !== i
        );
      };
    } catch (s) {
      console.warn("CSSStyleSheet error:", s), Fw(n);
    }
  } else
    Fw(n);
}, [e, r]), /* @__PURE__ */ _.jsx(_.Fragment, { children: t }));
function $ie({
  initProps: e = {},
  customWallet: t
}) {
  iJ(e);
  const { ToastContainer: r } = Nc(), { fetchRouterConfig: n } = XX(), { getTrustTokens: i } = $c(), { transactionData: s, setTransactionData: o } = H1(), { isOpenSecondary: a, fromCoin: c, toAmount: u, toCoin: l, fromAmount: f } = En(), [h, v] = Mt(0), b = Ar(h);
  nJ(e), Bt(() => {
    i(), n();
  }, []), Bt(() => {
    b.current = 0;
  }, [c == null ? void 0 : c.coin_type, l == null ? void 0 : l.coin_type, f, u]), JX({
    interval: 1e3,
    callback: () => {
      b.current = b.current + 1, a ? b.current >= 5 && y() : b.current >= 20 && y();
    }
  });
  const y = () => {
    b.current = 20, v(20), setTimeout(() => {
      b.current = 0, v(0);
    }, 20);
  };
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsxs("div", { className: "cs-swap-container", id: "cs-swap-widget", children: [
    /* @__PURE__ */ _.jsx(
      HX,
      {
        independentWallet: !!(e != null && e.independentWallet),
        customWallet: t,
        logo: e == null ? void 0 : e.logo
      }
    ),
    /* @__PURE__ */ _.jsx(
      kX,
      {
        handleRefresh: y,
        themeType: e == null ? void 0 : e.themeType
      }
    ),
    /* @__PURE__ */ _.jsx(
      jie,
      {
        refreshCount: h,
        customWallet: t,
        initProps: e
      }
    ),
    s && /* @__PURE__ */ _.jsx(
      GX,
      {
        transactionData: s,
        onClose: () => {
          o(void 0);
        }
      }
    ),
    /* @__PURE__ */ _.jsx(r, {})
  ] }) });
}
function ay({
  initProps: e = {},
  customWallet: t
}) {
  var o;
  eJ();
  const { getOwnerCoinBalances: r } = $u(), n = wd(), { saveCurrentAccount: i } = Tn(), { mutate: s } = rC();
  return Bt(() => {
    i(n || void 0), r(n == null ? void 0 : n.address);
  }, [n]), Bt(() => {
    var a;
    t && ((a = t == null ? void 0 : t.currentAccount) == null ? void 0 : a.address) !== (n == null ? void 0 : n.address) && s(
      { wallet: t == null ? void 0 : t.currentWallet },
      {
        onSuccess: () => {
        }
      }
    );
  }, [(o = t == null ? void 0 : t.currentAccount) == null ? void 0 : o.address, n == null ? void 0 : n.address]), /* @__PURE__ */ _.jsx(Nie, { theme: e.theme, themeType: e.themeType, children: /* @__PURE__ */ _.jsx($ie, { initProps: e, customWallet: t }) });
}
function Die({
  initProps: e,
  customWallet: t
}) {
  const [r, n] = Mt(!0);
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: r ? "export-modal-container" : "export-modal-container none",
      children: [
        r && /* @__PURE__ */ _.jsx("div", { className: "swap-modal-box", children: /* @__PURE__ */ _.jsx(ay, { initProps: e, customWallet: t }) }),
        /* @__PURE__ */ _.jsx("div", { className: "swap-modal-mask", onClick: () => n(!1) })
      ]
    }
  );
}
function Lie({
  size: e,
  direction: t,
  initProps: r,
  customWallet: n
  // isOpen,
  // onToggle,
}) {
  const [i, s] = Mt(!1), o = () => {
    s(!i);
  };
  return /* @__PURE__ */ _.jsxs("div", { className: "widget-btn-box", children: [
    /* @__PURE__ */ _.jsx("div", { className: `img-btn ${e} ${t}`, onClick: o, children: i ? /* @__PURE__ */ _.jsx("svg", { className: "icon", "aria-hidden": "true", children: /* @__PURE__ */ _.jsx("use", { xlinkHref: "#icon-unfold" }) }) : /* @__PURE__ */ _.jsx("img", { src: Lt("/images/img-logo@2x.png") }) }),
    i && /* @__PURE__ */ _.jsx("div", { className: `widget-modal ${t} ${e}`, children: /* @__PURE__ */ _.jsx(ay, { initProps: r, customWallet: n }) })
  ] });
}
function Bie({
  initProps: e = {},
  customWallet: t
}) {
  const { displayMode: r, widgetBtnDirection: n, widgetBtnSize: i } = e;
  return /* @__PURE__ */ _.jsxs(fh, { appearance: "dark", children: [
    r === "Integrated" && /* @__PURE__ */ _.jsx(ay, { initProps: e, customWallet: t }),
    r === "Widget" && /* @__PURE__ */ _.jsx(
      Lie,
      {
        initProps: e,
        customWallet: t,
        direction: n || "right-bottom",
        size: i || "Default"
      }
    ),
    (!r || r === "Modal") && /* @__PURE__ */ _.jsx(Die, { initProps: e, customWallet: t })
  ] });
}
const rse = Bie;
export {
  rse as CetusSwap
};
