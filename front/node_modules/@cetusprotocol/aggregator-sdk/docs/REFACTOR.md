aggregator V3 SDK 对接新版本合约: #架构
sui move 合约加 ts sdk

# 主要合约构造逻辑改变:

1.  在一笔交易中需要首先调用 aggregator_v3 router new_swap_context,构造一个交易上下文，该上下文主要用于存储所有 coin balance，以及设置 overlay_fee 和 overlay_fee_recipient（合约中的 fee 和 fee_recipient）.
2.  对于以中间代币为 input coin（from 是 A，target 是 B，其他任何代币都是中间代币）的单个 path（指在一个池子中），都必须判断这个路径是不是这个中间代币，并且是最后一次 在这个完整的路径中作为 input coin 出现了，如果是的话，将 amount in 改成一个 MAX_AMOUNT_IN（u64 最大值）。
3.  将 amount in 改成一个 MAX_AMOUNT_IN 的原因是合约在执行 swaptx 的时候，所有的 swap 方法会先执行 take_balance，当 amount_in 大于 swap context 中中间代币的余额时，就会将所有的余额都转出来用于交易，如果 amount_in 小于 swap context 中的中间代币的余额时，只会用多少取多少。为了保证最终 swap context 中不会再存在中间代币，所以必须要有第 2 步的操作。
4.  aggregator clientv3 在初始化的时候设置对应的 overlay fee rate， overlay fee receiver，用于在创建 swap context 的时候设置，合约的 FEE_DENOMINATOR 为 1000000, 所以当 sdk 输入的 fee 放入 movecall 中需要乘 1000000， sdk 中设置的 MAX_FEE_RATE 为 0.1，不得超过，超过需要报错。
5.  原有的每个 movecall 的 published_at 是使用默认+find_router 返回的 packages map 的方式，新版本的每个 dex 的 swap movecall published_at 现在都记录在 path 中，直接从 path 中取。aggregator router 中的 movecall(如 swap context 的 new 与 confirm)需要从 packages 中实时获取最新的，如果没有再使用默认的。
6.  find router 返回的结果需要重构，需要合并一个 router data 中所有相同的池子的 swap，将其 amount in 合并，最终将二维的 path 转换成一个一维的 path， 举个例子:  
     6.1. P1(X,A) -> P2(A,Y)  
     6.2. P3(X,B) -> P4(B, A) -> P2(A,Y)
    6.3. P5(X,C) -> P6(C, A) -> P2(A,Y)

        SWAP SORT
        6.1.   P1(X,A)
        6.2.   P3(X,B) -> P4(B, A)
        6.3.   P5(X,C) -> P6(C, A)
        6.4.   P2(A,Y) 此时P2的amount in应该为三条路径的总和

    这里的原则就是这个池子的 amount in 必须已经交易完了才能进行这个池子的交易，否则会缺失 amount in coin。

7.  对于每个 dex 都需要添加 find router 已经 swap（router swap + fast router swap）的单元测试。
