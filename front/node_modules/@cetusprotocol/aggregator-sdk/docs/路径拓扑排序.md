# 拓扑排序解决路由合并问题

## 问题描述

在多路径路由系统中，需要将多条路由合并为一个全局序列，同时保持原有的顺序约束关系：

> 对于不同 multi path 中的相同的池子，需要保证合并之后，所有原先在一条 multi hop 中的位于该 pool 前面的 pool，都还需要在这个 pool 前面

## 问题建模

### 输入示例

```
Route1: [A, B, C, D]
Route2: [X, B, Y, D, Z]
Route3: [M, C, N]
```

### 约束关系提取

从路由中提取顺序约束：

- Route1: A→B, B→C, C→D
- Route2: X→B, B→Y, Y→D, D→Z
- Route3: M→C, C→N

### 依赖图构建

```
A ─→ B ─→ C ─→ D ─→ Z
     ↑     ↑     ↑
     X     M     Y
           │     ↑
           └─→ N B
```

## 拓扑排序算法

### Kahn 算法实现

```rust
use std::collections::{HashMap, HashSet, VecDeque};

fn merge_routes_topological(routes: Vec<Vec<Pool>>) -> Vec<Pool> {
    let mut graph: HashMap<Pool, HashSet<Pool>> = HashMap::new();
    let mut in_degree: HashMap<Pool, usize> = HashMap::new();

    // 1. 构建有向图
    for route in routes {
        for window in route.windows(2) {
            let from = &window[0];
            let to = &window[1];

            graph.entry(from.clone()).or_default().insert(to.clone());
            *in_degree.entry(to.clone()).or_default() += 1;
            in_degree.entry(from.clone()).or_default();
        }
    }

    // 2. 找入度为0的顶点
    let mut queue: VecDeque<Pool> = in_degree.iter()
        .filter(|(_, &degree)| degree == 0)
        .map(|(pool, _)| pool.clone())
        .collect();

    let mut result = vec![];

    // 3. 拓扑排序主循环
    while let Some(pool) = queue.pop_front() {
        result.push(pool.clone());

        if let Some(neighbors) = graph.get(&pool) {
            for neighbor in neighbors {
                if let Some(degree) = in_degree.get_mut(neighbor) {
                    *degree -= 1;
                    if *degree == 0 {
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }
    }

    result
}
```

### 算法步骤

1. **构建有向图**：根据路由中相邻池子的顺序关系建立边
2. **计算入度**：统计每个池子有多少前驱
3. **初始化队列**：将入度为 0 的池子加入队列
4. **循环处理**：
   - 从队列取出一个池子加入结果
   - 移除该池子的所有出边
   - 更新邻接池子的入度
   - 将新的入度为 0 的池子加入队列

## 算法验证

### 执行过程示例

```
初始入度: A:0, X:0, M:0, B:2, Y:1, C:2, N:1, D:2, Z:1

步骤1: 处理A,X,M (入度为0)
结果: [A, X, M]
更新后: B:0, C:1, Y:1, N:1, D:2, Z:1

步骤2: 处理B
结果: [A, X, M, B]
更新后: C:0, Y:0, N:1, D:2, Z:1

步骤3: 处理C,Y
结果: [A, X, M, B, C, Y]
更新后: N:0, D:0, Z:1

步骤4: 处理N,D
结果: [A, X, M, B, C, Y, N, D]
更新后: Z:0

步骤5: 处理Z
最终结果: [A, X, M, B, C, Y, N, D, Z]
```

### 约束验证

检查最终序列是否满足原始路由的约束：

- **Route1 [A,B,C,D]**: A<B<C<D ✓
- **Route2 [X,B,Y,D,Z]**: X<B<Y<D<Z ✓
- **Route3 [M,C,N]**: M<C<N ✓

## 为什么选择拓扑排序

### 问题特征匹配

1. **有向无环图（DAG）**

   - 路由是有向的（前后顺序明确）
   - 无环的（同一路径不会回到起点）

2. **线性排序需求**

   - 需要将所有池子排成单一序列
   - 满足所有前后约束关系

3. **约束保持**
   - 如果 A 在某路径中位于 B 前面，合并后 A 仍需在 B 前面
   - 传递性约束自动满足

### 算法优势

- **正确性保证**：数学上证明能保持所有约束
- **效率高**：时间复杂度 O(V+E)，空间复杂度 O(V+E)
- **环检测**：自动检测冲突的约束关系
- **通用性**：适用于各种规模的路由合并

## 与原始方案对比

### 原始伪代码问题

```rust
// 原始方案的问题
for route in routes {
    for pool in route {
        if res_pools.contains(pool) {
            // 问题1: 只考虑局部约束，忽略全局依赖
            // 问题2: 插入位置计算错误
            // 问题3: 无法处理复杂的多重依赖
        }
    }
}
```

### 拓扑排序优势

- **全局视角**：考虑所有约束关系
- **约束传递**：自动处理间接依赖
- **多重依赖**：正确处理一个池子的多个前驱
- **冲突检测**：能发现不可满足的约束

## 使用建议

### 适用场景

- 任务调度系统
- 编译依赖管理
- 课程安排
- 工作流排序
- 路由路径合并

### 注意事项

- 确保输入图无环
- 结果可能不唯一（可通过优先级调整）
- 大规模数据建议优化内存使用

## 总结

拓扑排序是解决路由合并问题的最佳方案，它能够：

1. **保证正确性**：数学证明的约束保持
2. **处理复杂性**：自动处理多重依赖和传递关系
3. **高效执行**：线性时间复杂度
4. **易于维护**：代码清晰，逻辑简单

通过将路由合并问题转换为拓扑排序，我们获得了一个既正确又高效的解决方案。
