import * as _mysten_sui_client from '@mysten/sui/client';
import { SuiClient, DevInspectResults, SuiMoveObject } from '@mysten/sui/client';
import { Transaction, TransactionObjectArgument, TransactionArgument } from '@mysten/sui/transactions';
import BN from 'bn.js';
import Decimal from 'decimal.js';
import { SuiPriceServiceConnection, SuiPythClient } from '@pythnetwork/pyth-sui-js';
import { Signer } from '@mysten/sui/cryptography';

interface FindRouterParams {
    from: string;
    target: string;
    amount: BN;
    byAmountIn: boolean;
    depth?: number;
    splitAlgorithm?: string;
    splitFactor?: number;
    splitCount?: number;
    providers?: string[];
    liquidityChanges?: PreSwapLpChangeParams[];
}
interface PreSwapLpChangeParams {
    poolID: string;
    ticklower: number;
    tickUpper: number;
    deltaLiquidity: number;
}
type ExtendedDetails = {
    aftermath_pool_flatness?: number;
    aftermath_lp_supply_type?: string;
    turbos_fee_type?: string;
    afterSqrtPrice?: string;
    deepbookv3DeepFee?: number;
    scallopScoinTreasury?: string;
    scallop_scoin_treasury?: string;
    haedal_pmm_base_price_seed?: string;
    haedal_pmm_quote_price_seed?: string;
    haedalhmmv2_base_price_seed?: string;
    steamm_bank_a?: string;
    steamm_bank_b?: string;
    steamm_lending_market?: string;
    steamm_lending_market_type?: string;
    steamm_btoken_a_type?: string;
    steamm_btoken_b_type?: string;
    steamm_lp_token_type?: string;
    steamm_oracle_registry_id?: string;
    steamm_oracle_pyth_price_seed_a?: string;
    steamm_oracle_pyth_price_seed_b?: string;
    steamm_oracle_index_a?: number;
    steamm_oracle_index_b?: number;
    metastable_price_seed?: string;
    metastable_eth_price_seed?: string;
    metastable_whitelisted_app_id?: string;
    metastable_create_cap_pkg_id?: string;
    metastable_create_cap_module?: string;
    metastable_create_cap_all_type_params?: boolean;
    metastable_registry_id?: string;
    obric_coin_a_price_seed?: string;
    obric_coin_b_price_seed?: string;
    obric_coin_a_price_id?: string;
    obric_coin_b_price_id?: string;
    sevenk_coin_a_price_seed?: string;
    sevenk_coin_b_price_seed?: string;
    sevenk_oracle_config_a?: string;
    sevenk_oracle_config_b?: string;
    sevenk_lp_cap_type?: string;
};
type Path = {
    id: string;
    direction: boolean;
    provider: string;
    from: string;
    target: string;
    feeRate: number;
    amountIn: string;
    amountOut: string;
    version?: string;
    publishedAt?: string;
    extendedDetails?: ExtendedDetails;
};
type Router = {
    path: Path[];
    amountIn: BN;
    amountOut: BN;
    initialPrice: Decimal;
};
type RouterError = {
    code: number;
    msg: string;
};
type RouterData = {
    quoteID?: string;
    amountIn: BN;
    amountOut: BN;
    byAmountIn: boolean;
    routes: Router[];
    insufficientLiquidity: boolean;
    deviationRatio?: number;
    packages?: Map<string, string>;
    totalDeepFee?: number;
    error?: RouterError;
    overlayFee?: number;
};
type RouterDataV3 = {
    quoteID?: string;
    amountIn: BN;
    amountOut: BN;
    byAmountIn: boolean;
    paths: Path[];
    insufficientLiquidity: boolean;
    deviationRatio: number;
    packages?: Map<string, string>;
    totalDeepFee?: number;
    error?: RouterError;
    overlayFee?: number;
};
type FlattenedPath = {
    path: Path;
    isLastUseOfIntermediateToken: boolean;
};
type ProcessedRouterData = {
    quoteID: string;
    amountIn: BN;
    amountOut: BN;
    byAmountIn: boolean;
    flattenedPaths: FlattenedPath[];
    fromCoinType: string;
    targetCoinType: string;
    packages?: Map<string, string>;
    totalDeepFee?: number;
    error?: RouterError;
    overlayFee?: number;
};
type AggregatorResponse = {
    code: number;
    msg: string;
    data: RouterData;
};
type DeepbookV3Config = {
    id: string;
    is_alternative_payment: boolean;
    alternative_payment_amount: number;
    trade_cap: string;
    balance_manager: string;
    deep_fee_vault: number;
    whitelist: number;
    package_version: 0;
    last_updated_time: number;
    whitelist_pools: string[];
};
type DeepbookV3ConfigResponse = {
    code: number;
    msg: string;
    data: DeepbookV3Config;
};
type PathV2 = {
    id: string;
    a2b: boolean;
    provider: string;
    from: string;
    target: string;
    feeRate: number;
    amountIn: number;
    amountOut: number;
    extendedDetails?: ExtendedDetails;
    version?: string;
};
type RouterV2 = {
    path: PathV2[];
    amountIn: BN;
    amountOut: BN;
    initialPrice: Decimal;
};
type RouterDataV2 = {
    amountIn: BN;
    amountOut: BN;
    routes: RouterV2[];
    insufficientLiquidity: boolean;
};

type Package = {
    packageName: string;
    packageId: string;
    publishedAt: string;
};
declare enum Env {
    Mainnet = 0,
    Testnet = 1
}
declare class AggregatorConfig {
    private endpoint;
    private fullNodeUrl;
    private signer;
    private env;
    constructor(endpoint: string, fullNodeUrl: string, signer: string, env: Env);
    getAggregatorUrl(): string;
    getFullNodeUrl(): string;
    getWallet(): string;
    getENV(): Env;
}

declare function getRouterResult(endpoint: string, apiKey: string, params: FindRouterParams, overlayFee: number, overlayFeeReceiver: string): Promise<RouterDataV3 | null>;
declare function getDeepbookV3Config(endpoint: string): Promise<DeepbookV3ConfigResponse | null>;
declare function processFlattenRoutes(routerData: RouterDataV3): ProcessedRouterData;

interface Extends {
    deepbookv3DeepFee?: TransactionObjectArgument;
    pythPriceIDs?: Map<string, string>;
}
interface DexRouter {
    swap(txb: Transaction, flattenedPath: FlattenedPath, swapContext: TransactionObjectArgument, _extends?: Extends): void;
}

declare const CETUS = "CETUS";
declare const DEEPBOOKV2 = "DEEPBOOK";
declare const KRIYA = "KRIYA";
declare const FLOWXV2 = "FLOWX";
declare const FLOWXV3 = "FLOWXV3";
declare const KRIYAV3 = "KRIYAV3";
declare const TURBOS = "TURBOS";
declare const AFTERMATH = "AFTERMATH";
declare const HAEDAL = "HAEDAL";
declare const VOLO = "VOLO";
declare const AFSUI = "AFSUI";
declare const BLUEMOVE = "BLUEMOVE";
declare const DEEPBOOKV3 = "DEEPBOOKV3";
declare const SCALLOP = "SCALLOP";
declare const SUILEND = "SUILEND";
declare const BLUEFIN = "BLUEFIN";
declare const HAEDALPMM = "HAEDALPMM";
declare const ALPHAFI = "ALPHAFI";
declare const SPRINGSUI = "SPRINGSUI";
declare const STEAMM = "STEAMM";
declare const METASTABLE = "METASTABLE";
declare const OBRIC = "OBRIC";
declare const HAWAL = "HAWAL";
declare const STEAMM_OMM = "STEAMM_OMM";
declare const MOMENTUM = "MOMENTUM";
declare const STEAMM_OMM_V2 = "STEAMM_OMM_V2";
declare const MAGMA = "MAGMA";
declare const SEVENK = "SEVENK";
declare const HAEDALHMMV2 = "HAEDALHMMV2";
declare const FULLSAIL = "FULLSAIL";
declare const DEFAULT_ENDPOINT = "https://api-sui.cetus.zone/router_v3";
declare const ALL_DEXES: string[];
type BuildRouterSwapParamsV3 = {
    router: RouterDataV3;
    inputCoin: TransactionObjectArgument;
    slippage: number;
    txb: Transaction;
    partner?: string;
    deepbookv3DeepFee?: TransactionObjectArgument;
    fixable?: boolean;
};
type BuildFastRouterSwapParamsV3 = {
    router: RouterDataV3;
    slippage: number;
    txb: Transaction;
    partner?: string;
    refreshAllCoins?: boolean;
    payDeepFeeAmount?: number;
};
interface SwapInPoolsParams {
    from: string;
    target: string;
    amount: BN;
    byAmountIn: boolean;
    pools: string[];
}
interface SwapInPoolsResultV3 {
    isExceed: boolean;
    routeData?: RouterDataV3;
}
declare function getAllProviders(): string[];
/**
 * Get all providers excluding the specified ones
 * @param excludeProviders Array of provider names to exclude
 * @returns Filtered provider list
 */
declare function getProvidersExcluding(excludeProviders: string[]): string[];
/**
 * Get only the specified providers
 * @param includeProviders Array of provider names to include
 * @returns Filtered provider list
 */
declare function getProvidersIncluding(includeProviders: string[]): string[];
type AggregatorClientParams = {
    endpoint?: string;
    signer?: string;
    client?: SuiClient;
    env?: Env;
    pythUrls?: string[];
    apiKey?: string;
    partner?: string;
    overlayFeeRate?: number;
    overlayFeeReceiver?: string;
};
declare class AggregatorClient {
    endpoint: string;
    signer: string;
    client: SuiClient;
    env: Env;
    apiKey: string;
    protected pythConnections: SuiPriceServiceConnection[];
    protected pythClient: SuiPythClient;
    protected overlayFeeRate: number;
    protected overlayFeeReceiver: string;
    protected partner?: string;
    private static readonly CONFIG;
    constructor(params: AggregatorClientParams);
    newPythClients(pythUrls: string[]): SuiPriceServiceConnection[];
    deepbookv3DeepFeeType(): string;
    getDeepbookV3Config(): Promise<DeepbookV3ConfigResponse | null>;
    getOneCoinUsedToMerge(coinType: string): Promise<string | null>;
    findRouters(params: FindRouterParams): Promise<RouterDataV3 | null>;
    executeFlexibleInputSwap(txb: Transaction, inputCoin: TransactionObjectArgument, routerData: RouterDataV3, expectedAmountOut: string, amountLimit: string, pythPriceIDs: Map<string, string>, partner?: string, deepbookv3DeepFee?: TransactionObjectArgument, packages?: Map<string, string>): Promise<void>;
    newDexRouterV3(provider: string, pythPriceIDs: Map<string, string>, partner?: string): DexRouter;
    expectInputSwapV3(txb: Transaction, inputCoin: TransactionObjectArgument, routerData: RouterDataV3, expectAmountOut: string, amountOutLimit: string, pythPriceIDs: Map<string, string>, partner?: string): TransactionObjectArgument;
    expectOutputSwapV3(txb: Transaction, inputCoin: TransactionObjectArgument, routerData: RouterDataV3, amountOut: string, _amountLimit: string, // it will set when build inputcoin
    partner?: string): TransactionObjectArgument;
    routerSwap(params: BuildRouterSwapParamsV3): Promise<TransactionObjectArgument>;
    fastRouterSwap(params: BuildFastRouterSwapParamsV3): Promise<void>;
    fixableRouterSwapV3(params: BuildRouterSwapParamsV3): Promise<TransactionObjectArgument>;
    swapInPools(params: SwapInPoolsParams): Promise<SwapInPoolsResultV3>;
    updatePythPriceIDs(priceIDs: string[], txb: Transaction): Promise<Map<string, string>>;
    devInspectTransactionBlock(txb: Transaction): Promise<_mysten_sui_client.DevInspectResults>;
    sendTransaction(txb: Transaction, signer: Signer): Promise<_mysten_sui_client.SuiTransactionBlockResponse>;
}

/**
 * Generate a downgraded UUID6 format identifier
 * This creates a time-based identifier with reduced entropy for better compatibility
 * @returns A downgrade_uuid6 string in format: downgrade_xxxxxxxx-xxxx-6xxx-xxxx-xxxxxxxxxxxx
 */
declare function generateDowngradeUuid6(): string;
/**
 * Generate a simplified downgrade UUID6 with timestamp-based components
 * @returns A simplified downgrade_uuid6 string
 */
declare function generateSimpleDowngradeUuid6(): string;
/**
 * Validate if a string is a valid downgrade_uuid6 format
 * @param uuid The string to validate
 * @returns true if valid downgrade_uuid6 format
 */
declare function isValidDowngradeUuid6(uuid: string): boolean;
/**
 * Extract timestamp from downgrade_uuid6 if possible
 * @param uuid The downgrade_uuid6 string
 * @returns timestamp in milliseconds or null if cannot extract
 */
declare function extractTimestampFromDowngradeUuid6(uuid: string): number | null;

declare function processEndpoint(endpoint: string): string;

type GetOrCreateAccountCapResult = {
    accountCap: TransactionObjectArgument;
    isCreate: boolean;
};
declare function getOrCreateAccountCap(txb: Transaction, client: SuiClient, owner: string): Promise<GetOrCreateAccountCapResult>;

/**
 * Represents a SUI address, which is a string.
 */
type SuiAddress = string;
/**
 * Represents a SUI object identifier, which is a string.
 */
type SuiObjectIdType = string;
/**
 * Represents a BigNumber, which can be a Decimal.Value, number, or string.
 */
type BigNumber = Decimal.Value | number | string;
/**
 * Represents a SUI resource, which can be of any type.
 */
type SuiResource = any;
/**
 * Represents a Non-Fungible Token (NFT) with associated metadata.
 */
type NFT = {
    /**
     * The address or identifier of the creator of the NFT.
     */
    creator: string;
    /**
     * A description providing additional information about the NFT.
     */
    description: string;
    /**
     * The URL to the image representing the NFT visually.
     */
    image_url: string;
    /**
     * A link associated with the NFT, providing more details or interactions.
     */
    link: string;
    /**
     * The name or title of the NFT.
     */
    name: string;
    /**
     * The URL to the project or collection associated with the NFT.
     */
    project_url: string;
};
/**
 * Represents a SUI struct tag.
 */
type SuiStructTag = {
    /**
     * The full address of the struct.
     */
    full_address: string;
    /**
     * The source address of the struct.
     */
    source_address: string;
    /**
     * The address of the struct.
     */
    address: SuiAddress;
    /**
     * The module to which the struct belongs.
     */
    module: string;
    /**
     * The name of the struct.
     */
    name: string;
    /**
     * An array of type arguments (SUI addresses) for the struct.
     */
    type_arguments: SuiAddress[];
};
/**
 * Represents basic SUI data types.
 */
type SuiBasicTypes = "address" | "bool" | "u8" | "u16" | "u32" | "u64" | "u128" | "u256";
/**
 * Represents a SUI transaction argument, which can be of various types.
 */
type SuiTxArg = TransactionArgument | string | number | bigint | boolean;
/**
 * Represents input types for SUI data.
 */
type SuiInputTypes = "object" | SuiBasicTypes;
/**
 * Gets the default SUI input type based on the provided value.
 * @param value - The value to determine the default input type for.
 * @returns The default SUI input type.
 * @throws Error if the type of the value is unknown.
 */
declare const getDefaultSuiInputType: (value: any) => SuiInputTypes;
/**
 * Represents a coin asset with address, object ID, and balance information.
 */
type CoinAsset = {
    /**
     * The address type of the coin asset.
     */
    coinAddress: SuiAddress;
    /**
     * The object identifier of the coin asset.
     */
    coinObjectId: SuiObjectIdType;
    /**
     * The balance amount of the coin asset.
     */
    balance: bigint;
};

declare function completionCoin(s: string): string;
declare function mintZeroCoin(txb: Transaction, coinType: string): TransactionObjectArgument;
declare function compareCoins(coinA: string, coinB: string): boolean;
declare function parseTurbosPoolFeeType(typeData: string): string | null;
declare function parseAftermathFeeType(typeData: string): string | undefined;
type BuildCoinResult = {
    targetCoin: TransactionObjectArgument;
    isMintZeroCoin: boolean;
    targetCoinAmount: number;
};
declare function buildInputCoin(txb: Transaction, allCoins: CoinAsset[], amount: bigint, coinType: string): BuildCoinResult;

declare function getAggregatorV2PublishedAt(publishedAt: string, packages?: Map<string, string>): string;
declare function getAggregatorV2ExtendPublishedAt(publishedAt: string, packages?: Map<string, string>): string;
declare function getAggregatorV2Extend2PublishedAt(publishedAt: string, packages?: Map<string, string>): string;

declare function isSortedSymbols(symbolX: string, symbolY: string): boolean;
declare function composeType(address: string, generics: SuiAddress[]): SuiAddress;
declare function composeType(address: string, struct: string, generics?: SuiAddress[]): SuiAddress;
declare function composeType(address: string, module: string, struct: string, generics?: SuiAddress[]): SuiAddress;
declare function extractAddressFromType(type: string): string;
declare function extractStructTagFromType(type: string): SuiStructTag;
declare function normalizeCoinType(coinType: string): string;
declare function fixSuiObjectId(value: string): string;
/**
 * Recursively traverses the given data object and patches any string values that represent Sui object IDs.
 *
 * @param {any} data - The data object to be patched.
 */
declare function patchFixSuiObjectId(data: any): void;
declare function createTarget(packageName: string, moduleName: string, functionName: string): `${string}::${string}::${string}`;

interface Dex {
    swap(client: AggregatorClient, ptb: Transaction, path: Path, inputCoin: TransactionObjectArgument, packages?: Map<string, string>, deepbookv3DeepFee?: TransactionObjectArgument): Promise<TransactionObjectArgument>;
}

interface GasMetrics {
    computationCost: string;
    storageCost: string;
    storageRebate: string;
    nonRefundableStorageFee: string;
    totalGasCost: string;
    gasUsed: string;
    gasPrice: string;
    success: boolean;
    error?: string;
}
interface SwapGasAnalysis {
    gasMetrics: GasMetrics;
    amountIn: BN;
    amountOut: BN;
    priceImpact: number;
    gasEfficiency: number;
    provider: string;
    route: string[];
    timestamp: number;
    isEstimated?: boolean;
    originalPathCount?: number;
    mergedPathCount?: number;
}
interface ComparisonResult {
    v2: SwapGasAnalysis[];
    v3: SwapGasAnalysis[];
    summary: {
        v2AverageGas: string;
        v3AverageGas: string;
        gasSavingsPercent: number;
        v2SuccessRate: number;
        v3SuccessRate: number;
        totalTests: number;
    };
}
/**
 * Extract gas metrics from DevInspectResults
 */
declare function extractGasMetrics(result: DevInspectResults): GasMetrics;
/**
 * Calculate gas efficiency (amount out per gas unit)
 */
declare function calculateGasEfficiency(amountOut: BN, totalGasCost: string): number;
/**
 * Calculate price impact percentage
 */
declare function calculatePriceImpact(amountIn: BN, amountOut: BN, expectedRate?: number): number;
/**
 * Compare gas metrics between two analyses
 */
declare function compareGasMetrics(v2Analysis: SwapGasAnalysis[], v3Analysis: SwapGasAnalysis[]): ComparisonResult;
/**
 * Format gas metrics for human readable output
 */
declare function formatGasMetrics(metrics: GasMetrics, isEstimated?: boolean): string;
/**
 * Export results to JSON format
 */
declare function exportToJSON(comparison: ComparisonResult): string;
/**
 * Export results to CSV format
 */
declare function exportToCSV(comparison: ComparisonResult): string;

declare const dealWithFastRouterSwapParamsForMsafe: (data: any) => any;
declare const restituteMsafeFastRouterSwapParams: (data: any) => any;

declare function printTransaction(tx: Transaction, isPrint?: boolean): Promise<void>;
declare function checkInvalidSuiAddress(address: string): boolean;

declare const ZERO: BN;
declare const ONE: BN;
declare const TWO: BN;
declare const U128: BN;
declare const U64_MAX_BN: BN;
declare const U64_MAX = "18446744073709551615";
declare const TEN_POW_NINE = 1000000000;
declare const AGGREGATOR = "aggregator";
declare const CETUS_DEX = "CETUS";
declare const DEEPBOOK_DEX = "DEEPBOOK";
declare const KRIYA_DEX = "KRIYA";
declare const FLOWX_AMM = "FLOWX";
declare const TURBOS_DEX = "TURBOS";
declare const AFTERMATH_AMM = "AFTERMATH";
declare const INTEGRATE = "integrate";
declare const CETUS_MODULE = "cetus";
declare const DEEPBOOK_MODULE = "deepbook";
declare const KRIYA_MODULE = "kriya";
declare const UTILS_MODULE = "utils";
declare const POOL_MODULT = "pool";
declare const PAY_MODULE = "pay";
declare const FLOWX_AMM_MODULE = "flowx_amm";
declare const TURBOS_MODULE = "turbos";
declare const AFTERMATH_MODULE = "aftermath";
declare const DEEPBOOK_CUSTODIAN_V2_MODULE = "custodian_v2";
declare const DEEPBOOK_CLOB_V2_MODULE = "clob_v2";
declare const FlashSwapFunc = "flash_swap";
declare const FlashSwapWithPartnerFunc = "flash_swap_with_partner";
declare const RepayFalshSwapFunc = "repay_flash_swap";
declare const RepayFlashSwapWithPartnerFunc = "repay_flash_swap_with_partner";
declare const FlashSwapA2BFunc = "flash_swap_a2b";
declare const FlashSwapB2AFunc = "flash_swap_b2a";
declare const FlashSwapWithPartnerA2BFunc = "flash_swap_with_partner_a2b";
declare const FlashSwapWithPartnerB2AFunc = "flash_swap_with_partner_b2a";
declare const REPAY_FLASH_SWAP_A2B_FUNC = "repay_flash_swap_a2b";
declare const REPAY_FLASH_SWAP_B2A_FUNC = "repay_flash_swap_b2a";
declare const REPAY_FLASH_SWAP_WITH_PARTNER_A2B_FUNC = "repay_flash_swap_with_partner_a2b";
declare const REPAY_FLASH_SWAP_WITH_PARTNER_B2A_FUNC = "repay_flash_swap_with_partner_b2a";
declare const SWAP_A2B_FUNC = "swap_a2b";
declare const SWAP_B2A_FUNC = "swap_b2a";
declare const TRANSFER_OR_DESTORY_COIN_FUNC = "transfer_or_destroy_coin";
declare const CHECK_COINS_THRESHOLD_FUNC = "check_coins_threshold";
declare const JOIN_FUNC = "join_vec";
declare const TRANSFER_ACCOUNT_CAP = "transfer_account_cap";
declare const CLOCK_ADDRESS = "0x0000000000000000000000000000000000000000000000000000000000000006";
declare const CoinInfoAddress = "0x1::coin::CoinInfo";
declare const CoinStoreAddress = "0x1::coin::CoinStore";
declare const SuiZeroCoinFn = "0x2::coin::zero";
declare const DEEPBOOK_PACKAGE_ID = "0x000000000000000000000000000000000000000000000000000000000000dee9";
declare const DEEPBOOK_PUBLISHED_AT = "0x000000000000000000000000000000000000000000000000000000000000dee9";
declare const CETUS_PUBLISHED_AT = "0x70968826ad1b4ba895753f634b0aea68d0672908ca1075a2abdf0fc9e0b2fc6a";
declare const CETUS_V3_PUBLISHED_AT = "0xd7b0cfc33a3b46c0ae0e2584c44028385da11724d4c94ec5b21a78117c5c1ab9";
declare const MAINNET_CETUS_GLOBAL_CONFIG_ID = "0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f";
declare const TESTNET_CETUS_GLOBAL_CONFIG_ID = "0x6f4149091a5aea0e818e7243a13adcfb403842d670b9a2089de058512620687a";
declare const MAINNET_FLOWX_AMM_CONTAINER_ID = "0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511";
declare const TESTNET_FLOWX_AMM_CONTAINER_ID = "";
declare const TURBOS_VERSIONED = "0xf1cf0e81048df168ebeb1b8030fad24b3e0b53ae827c25053fff0779c1445b6f";
declare const MAINNET_AFTERMATH_REGISTRY_ID = "0xfcc774493db2c45c79f688f88d28023a3e7d98e4ee9f48bbf5c7990f651577ae";
declare const TESTNET_AFTERMATH_REGISTRY_ID = "";
declare const MAINNET_AFTERMATH_PROTOCOL_FEE_VAULT_ID = "0xf194d9b1bcad972e45a7dd67dd49b3ee1e3357a00a50850c52cd51bb450e13b4";
declare const TESTNET_AFTERMATH_PROTOCOL_FEE_VAULT_ID = "";
declare const MAINNET_AFTERMATH_TREASURY_ID = "0x28e499dff5e864a2eafe476269a4f5035f1c16f338da7be18b103499abf271ce";
declare const TESTNET_AFTERMATH_TREASURY_ID = "";
declare const MAINNET_AFTERMATH_INSURANCE_FUND_ID = "0xf0c40d67b078000e18032334c3325c47b9ec9f3d9ae4128be820d54663d14e3b";
declare const TESTNET_AFTERMATH_INSURANCE_FUND_ID = "";
declare const MAINNET_AFTERMATH_REFERRAL_VAULT_ID = "0x35d35b0e5b177593d8c3a801462485572fc30861e6ce96a55af6dc4730709278";
declare const TESTNET_AFTERMATH_REFERRAL_VAULT_ID = "";
declare const PACKAGE_NAMES: {
    readonly AGGREGATOR_V3: "aggregator_v3";
};
declare const DEFAULT_AGG_V3_ENDPOINT = "https://api-sui.cetus.zone/router_v3";
declare const DEFAULT_AGG_V2_ENDPOINT = "https://api-sui.cetus.zone/router_v2";
declare const PYTH_CONFIG: {
    readonly Testnet: {
        readonly wormholeStateId: "0x31358d198147da50db32eda2562951d53973a0c0ad5ed738e9b17d88b213d790";
        readonly pythStateId: "0x243759059f4c3111179da5878c12f68d612c21a8d54d85edc86164bb18be1c7c";
    };
    readonly Mainnet: {
        readonly wormholeStateId: "0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c";
        readonly pythStateId: "0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8";
    };
};
declare const PUBLISHED_ADDRESSES: {
    readonly V2: {
        readonly Mainnet: "0x8ae871505a80d8bf6bf9c05906cda6edfeea460c85bebe2e26a4313f5e67874a";
        readonly Testnet: "0x52eae33adeb44de55cfb3f281d4cc9e02d976181c0952f5323648b5717b33934";
    };
    readonly V2_EXTEND: {
        readonly Mainnet: "0x8a2f7a5b20665eeccc79de3aa37c3b6c473eca233ada1e1cd4678ec07d4d4073";
        readonly Testnet: "0xabb6a81c8a216828e317719e06125de5bb2cb0fe8f9916ff8c023ca5be224c78";
    };
    readonly V2_EXTEND2: {
        readonly Mainnet: "0x5cb7499fc49c2642310e24a4ecffdbee00133f97e80e2b45bca90c64d55de880";
        readonly Testnet: "0x0";
    };
};
declare const DEEPBOOK_V3_DEEP_FEE_TYPES: {
    readonly Mainnet: "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP";
    readonly Testnet: "0x36dbef866a1d62bf7328989a10fb2f07d769f4ee587c0de4a0a256e57e0a58a8::deep::DEEP";
};
declare const CLIENT_CONFIG: {
    readonly DEFAULT_PYTH_URL: "https://hermes.pyth.network";
    readonly PYTH_TIMEOUT: 3000;
    readonly MAX_OVERLAY_FEE_RATE: 0.1;
    readonly MAX_OVERLAY_FEE_RATE_NUMERATOR: 100000;
    readonly FEE_RATE_MULTIPLIER: 1000000;
    readonly DEFAULT_OVERLAY_FEE_RECEIVER: "0x0";
    readonly ERRORS: {
        readonly SIGNER_REQUIRED: "Signer is required, but not provided.";
        readonly INVALID_OVERLAY_FEE_RATE: "Overlay fee rate must be between 0 and 0.1";
        readonly INVALID_SLIPPAGE: "Invalid slippage value. Must be between 0 and 1 (e.g., 0.01 represents 1% slippage)";
        readonly NO_ROUTER_FOUND: "No router found";
        readonly EMPTY_PATH: "Empty path";
        readonly UNSUPPORTED_DEX: "Unsupported dex";
        readonly PYTH_UNAVAILABLE: "All Pyth price nodes are unavailable. Cannot fetch price data. Please switch to or add new available Pyth nodes";
        readonly QUOTE_ID_REQUIRED: "Quote ID is required";
        readonly AGGREGATOR_V3_PACKAGE_REQUIRED: "Aggregator V3 package is required";
        readonly PACKAGES_REQUIRED: "Packages are required";
        readonly OVERLAY_FEE_RECEIVER_REQUIRED: "Overlay fee rate is set, but overlay fee receiver is not set";
    };
};
declare const AGGREGATOR_V3_CONFIG: {
    readonly FEE_DENOMINATOR: 1000000;
    readonly MAX_FEE_RATE: 100000;
    readonly MAX_AMOUNT_IN: "18446744073709551615";
    readonly DEFAULT_PUBLISHED_AT: {
        readonly Mainnet: "0x33ec64e9bb369bf045ddc198c81adbf2acab424da37465d95296ee02045d2b17";
        readonly Testnet: "0x0";
    };
};

declare enum TypesErrorCode {
    InvalidType = "InvalidType"
}
declare enum ConfigErrorCode {
    MissAggregatorPackage = "MissAggregatorPackage",
    MissGlobalConfig = "MissGlobalConfig",
    InvalidWallet = "InvalidWallet",
    SimulateError = "SimulateError"
}
declare enum TransactionErrorCode {
    InsufficientBalance = "InsufficientBalance",
    SimulateEventError = "simulateEventError",
    CannotGetDecimals = "CannotGetDecimals",
    MissCoinA = "MissCoinA",
    MissCoinB = "MissCoinB",
    MissTurbosFeeType = "MissTurbosFeeType",
    MissAftermathLpSupplyType = "MissAftermathLpSupplyType"
}
declare enum AggregatorServerErrorCode {
    NumberTooLarge = 1000,
    RateLimitExceeded = 1001,
    InsufficientLiquidity = 1002,
    HoneyPot = 1003
}
type AggregatorErrorCode = TypesErrorCode;
declare function getAggregatorServerErrorMessage(code: AggregatorServerErrorCode): string;
/**
 * AggregatorError is a custom error class that extends the built-in Error class. It is used to represent errors that occur during aggregation operations.
 * The key functionality of this code includes:
 * - Defining the AggregatorError class that represents an error during aggregation. It includes a message property and an optional errorCode property.
 * - Providing a static method isAggregatorErrorCode() that checks if a given error instance is an instance of AggregatorError and has a specific error code.
 */
declare class AggregatorError extends Error {
    message: string;
    errorCode?: AggregatorErrorCode | string;
    constructor(message: string, errorCode?: AggregatorErrorCode | string);
    static isAggregatorErrorCode(e: any, code: AggregatorErrorCode): boolean;
}

type BuildRouterSwapParams = {
    routers: Router[];
    byAmountIn: boolean;
    inputCoin: TransactionObjectArgument;
    slippage: number;
    txb: Transaction;
    partner?: string;
    deepbookv3DeepFee?: TransactionObjectArgument;
};
type BuildFastRouterSwapParams = {
    routers: Router[];
    byAmountIn: boolean;
    slippage: number;
    txb: Transaction;
    partner?: string;
    refreshAllCoins?: boolean;
    payDeepFeeAmount?: number;
};
type BuildRouterSwapParamsV2 = {
    routers: RouterData;
    inputCoin: TransactionObjectArgument;
    slippage: number;
    txb: Transaction;
    partner?: string;
    deepbookv3DeepFee?: TransactionObjectArgument;
};
type BuildFastRouterSwapParamsV2 = {
    routers: RouterData;
    slippage: number;
    txb: Transaction;
    partner?: string;
    refreshAllCoins?: boolean;
    payDeepFeeAmount?: number;
};
interface PythConfig {
    wormholeStateId: string;
    pythStateId: string;
}

declare const DEFAULT_GAS_BUDGET_FOR_SPLIT = 1000;
declare const DEFAULT_GAS_BUDGET_FOR_MERGE = 500;
declare const DEFAULT_GAS_BUDGET_FOR_TRANSFER = 100;
declare const DEFAULT_GAS_BUDGET_FOR_TRANSFER_SUI = 100;
declare const DEFAULT_GAS_BUDGET_FOR_STAKE = 1000;
declare const GAS_TYPE_ARG = "0x2::sui::SUI";
declare const GAS_TYPE_ARG_LONG = "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI";
declare const GAS_SYMBOL = "SUI";
declare const DEFAULT_NFT_TRANSFER_GAS_FEE = 450;
declare const SUI_SYSTEM_STATE_OBJECT_ID = "0x0000000000000000000000000000000000000005";
/**
 * This class provides helper methods for working with coins.
 */
declare class CoinUtils {
    /**
     * Get the coin type argument from a SuiMoveObject.
     *
     * @param obj The SuiMoveObject to get the coin type argument from.
     * @returns The coin type argument, or null if it is not found.
     */
    static getCoinTypeArg(obj: SuiMoveObject): string | null;
    /**
     * Get whether a SuiMoveObject is a SUI coin.
     *
     * @param obj The SuiMoveObject to check.
     * @returns Whether the SuiMoveObject is a SUI coin.
     */
    static isSUI(obj: SuiMoveObject): boolean;
    /**
     * Get the coin symbol from a coin type argument.
     *
     * @param coinTypeArg The coin type argument to get the symbol from.
     * @returns The coin symbol.
     */
    static getCoinSymbol(coinTypeArg: string): string;
    /**
     * Get the balance of a SuiMoveObject.
     *
     * @param obj The SuiMoveObject to get the balance from.
     * @returns The balance of the SuiMoveObject.
     */
    static getBalance(obj: SuiMoveObject): bigint;
    /**
     * Get the total balance of a list of CoinAsset objects for a given coin address.
     *
     * @param objs The list of CoinAsset objects to get the total balance for.
     * @param coinAddress The coin address to get the total balance for.
     * @returns The total balance of the CoinAsset objects for the given coin address.
     */
    static totalBalance(objs: CoinAsset[], coinAddress: SuiAddress): bigint;
    /**
     * Get the ID of a SuiMoveObject.
     *
     * @param obj The SuiMoveObject to get the ID from.
     * @returns The ID of the SuiMoveObject.
     */
    static getID(obj: SuiMoveObject): string;
    /**
     * Get the coin type from a coin type argument.
     *
     * @param coinTypeArg The coin type argument to get the coin type from.
     * @returns The coin type.
     */
    static getCoinTypeFromArg(coinTypeArg: string): string;
    /**
     * Get the CoinAsset objects for a given coin type.
     *
     * @param coinType The coin type to get the CoinAsset objects for.
     * @param allSuiObjects The list of all SuiMoveObjects.
     * @returns The CoinAsset objects for the given coin type.
     */
    static getCoinAssets(coinType: string, allSuiObjects: CoinAsset[]): CoinAsset[];
    /**
     * Get whether a coin address is a SUI coin.
     *
     * @param coinAddress The coin address to check.
     * @returns Whether the coin address is a SUI coin.
     */
    static isSuiCoin(coinAddress: SuiAddress): boolean;
    /**
     * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
     *
     * @param coins The list of CoinAsset objects to select from.
     * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
     * @param exclude A list of CoinAsset objects to exclude from the selection.
     * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
     */
    static selectCoinObjectIdGreaterThanOrEqual(coins: CoinAsset[], amount: bigint, exclude?: string[]): {
        objectArray: string[];
        remainCoins: CoinAsset[];
        amountArray: string[];
    };
    /**
     * Select the CoinAsset objects from a list of CoinAsset objects that have a balance greater than or equal to a given amount.
     *
     * @param coins The list of CoinAsset objects to select from.
     * @param amount The amount to select CoinAsset objects with a balance greater than or equal to.
     * @param exclude A list of CoinAsset objects to exclude from the selection.
     * @returns The CoinAsset objects that have a balance greater than or equal to the given amount.
     */
    static selectCoinAssetGreaterThanOrEqual(coins: CoinAsset[], amount: bigint, exclude?: string[]): {
        selectedCoins: CoinAsset[];
        remainingCoins: CoinAsset[];
    };
    /**
     * Sort the CoinAsset objects by their balance.
     *
     * @param coins The CoinAsset objects to sort.
     * @returns The sorted CoinAsset objects.
     */
    static sortByBalance(coins: CoinAsset[]): CoinAsset[];
    static sortByBalanceDes(coins: CoinAsset[]): CoinAsset[];
    /**
     * Calculate the total balance of a list of CoinAsset objects.
     *
     * @param coins The list of CoinAsset objects to calculate the total balance for.
     * @returns The total balance of the CoinAsset objects.
     */
    static calculateTotalBalance(coins: CoinAsset[]): bigint;
}

export { AFSUI, AFTERMATH, AFTERMATH_AMM, AFTERMATH_MODULE, AGGREGATOR, AGGREGATOR_V3_CONFIG, ALL_DEXES, ALPHAFI, AggregatorClient, type AggregatorClientParams, AggregatorConfig, AggregatorError, type AggregatorErrorCode, type AggregatorResponse, AggregatorServerErrorCode, BLUEFIN, BLUEMOVE, type BigNumber, type BuildCoinResult, type BuildFastRouterSwapParams, type BuildFastRouterSwapParamsV2, type BuildFastRouterSwapParamsV3, type BuildRouterSwapParams, type BuildRouterSwapParamsV2, type BuildRouterSwapParamsV3, CETUS, CETUS_DEX, CETUS_MODULE, CETUS_PUBLISHED_AT, CETUS_V3_PUBLISHED_AT, CHECK_COINS_THRESHOLD_FUNC, CLIENT_CONFIG, CLOCK_ADDRESS, type CoinAsset, CoinInfoAddress, CoinStoreAddress, CoinUtils, type ComparisonResult, ConfigErrorCode, DEEPBOOKV2, DEEPBOOKV3, DEEPBOOK_CLOB_V2_MODULE, DEEPBOOK_CUSTODIAN_V2_MODULE, DEEPBOOK_DEX, DEEPBOOK_MODULE, DEEPBOOK_PACKAGE_ID, DEEPBOOK_PUBLISHED_AT, DEEPBOOK_V3_DEEP_FEE_TYPES, DEFAULT_AGG_V2_ENDPOINT, DEFAULT_AGG_V3_ENDPOINT, DEFAULT_ENDPOINT, DEFAULT_GAS_BUDGET_FOR_MERGE, DEFAULT_GAS_BUDGET_FOR_SPLIT, DEFAULT_GAS_BUDGET_FOR_STAKE, DEFAULT_GAS_BUDGET_FOR_TRANSFER, DEFAULT_GAS_BUDGET_FOR_TRANSFER_SUI, DEFAULT_NFT_TRANSFER_GAS_FEE, type DeepbookV3Config, type DeepbookV3ConfigResponse, type Dex, Env, type ExtendedDetails, FLOWXV2, FLOWXV3, FLOWX_AMM, FLOWX_AMM_MODULE, FULLSAIL, type FindRouterParams, FlashSwapA2BFunc, FlashSwapB2AFunc, FlashSwapFunc, FlashSwapWithPartnerA2BFunc, FlashSwapWithPartnerB2AFunc, FlashSwapWithPartnerFunc, type FlattenedPath, GAS_SYMBOL, GAS_TYPE_ARG, GAS_TYPE_ARG_LONG, type GasMetrics, type GetOrCreateAccountCapResult, HAEDAL, HAEDALHMMV2, HAEDALPMM, HAWAL, INTEGRATE, JOIN_FUNC, KRIYA, KRIYAV3, KRIYA_DEX, KRIYA_MODULE, MAGMA, MAINNET_AFTERMATH_INSURANCE_FUND_ID, MAINNET_AFTERMATH_PROTOCOL_FEE_VAULT_ID, MAINNET_AFTERMATH_REFERRAL_VAULT_ID, MAINNET_AFTERMATH_REGISTRY_ID, MAINNET_AFTERMATH_TREASURY_ID, MAINNET_CETUS_GLOBAL_CONFIG_ID, MAINNET_FLOWX_AMM_CONTAINER_ID, METASTABLE, MOMENTUM, type NFT, OBRIC, ONE, PACKAGE_NAMES, PAY_MODULE, POOL_MODULT, PUBLISHED_ADDRESSES, PYTH_CONFIG, type Package, type Path, type PathV2, type PreSwapLpChangeParams, type ProcessedRouterData, type PythConfig, REPAY_FLASH_SWAP_A2B_FUNC, REPAY_FLASH_SWAP_B2A_FUNC, REPAY_FLASH_SWAP_WITH_PARTNER_A2B_FUNC, REPAY_FLASH_SWAP_WITH_PARTNER_B2A_FUNC, RepayFalshSwapFunc, RepayFlashSwapWithPartnerFunc, type Router, type RouterData, type RouterDataV2, type RouterDataV3, type RouterError, type RouterV2, SCALLOP, SEVENK, SPRINGSUI, STEAMM, STEAMM_OMM, STEAMM_OMM_V2, SUILEND, SUI_SYSTEM_STATE_OBJECT_ID, SWAP_A2B_FUNC, SWAP_B2A_FUNC, type SuiAddress, type SuiBasicTypes, type SuiInputTypes, type SuiObjectIdType, type SuiResource, type SuiStructTag, type SuiTxArg, SuiZeroCoinFn, type SwapGasAnalysis, type SwapInPoolsParams, type SwapInPoolsResultV3, TEN_POW_NINE, TESTNET_AFTERMATH_INSURANCE_FUND_ID, TESTNET_AFTERMATH_PROTOCOL_FEE_VAULT_ID, TESTNET_AFTERMATH_REFERRAL_VAULT_ID, TESTNET_AFTERMATH_REGISTRY_ID, TESTNET_AFTERMATH_TREASURY_ID, TESTNET_CETUS_GLOBAL_CONFIG_ID, TESTNET_FLOWX_AMM_CONTAINER_ID, TRANSFER_ACCOUNT_CAP, TRANSFER_OR_DESTORY_COIN_FUNC, TURBOS, TURBOS_DEX, TURBOS_MODULE, TURBOS_VERSIONED, TWO, TransactionErrorCode, TypesErrorCode, U128, U64_MAX, U64_MAX_BN, UTILS_MODULE, VOLO, ZERO, buildInputCoin, calculateGasEfficiency, calculatePriceImpact, checkInvalidSuiAddress, compareCoins, compareGasMetrics, completionCoin, composeType, createTarget, dealWithFastRouterSwapParamsForMsafe, exportToCSV, exportToJSON, extractAddressFromType, extractGasMetrics, extractStructTagFromType, extractTimestampFromDowngradeUuid6, fixSuiObjectId, formatGasMetrics, generateDowngradeUuid6, generateSimpleDowngradeUuid6, getAggregatorServerErrorMessage, getAggregatorV2Extend2PublishedAt, getAggregatorV2ExtendPublishedAt, getAggregatorV2PublishedAt, getAllProviders, getDeepbookV3Config, getDefaultSuiInputType, getOrCreateAccountCap, getProvidersExcluding, getProvidersIncluding, getRouterResult, isSortedSymbols, isValidDowngradeUuid6, mintZeroCoin, normalizeCoinType, parseAftermathFeeType, parseTurbosPoolFeeType, patchFixSuiObjectId, printTransaction, processEndpoint, processFlattenRoutes, restituteMsafeFastRouterSwapParams };
